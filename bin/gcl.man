%
% FILE: gclman.tex -- source for GCL manual
%
% %W% %G%
%

%\documentclass{book}
%\usepackage{widetext,multicolumn,chicagob}

\documentstyle[widetext,multicol,chicagob]{book}
%\columnsep .31in
%\columnseprule .02in
\renewcommand{\baselinestretch}{.9}
\newcommand{\bd}{\begin{description}}
\newcommand{\ed}{\end{description}}
\input{psfig}
\newcommand{\tindex}[1]{{\tt #1}\index{{\tt #1}}}
\newcommand{\bindex}[1]{{\bf #1}\index{#1}}
\newcommand{\rindex}[1]{{#1}\index{#1}}
\makeindex

% stuff for lex 
% to put dictionary style headers in function ref sections

\newcommand{\lex}[1]{\mark{#1}\index{{\tt #1}}}

\makeatletter
\def\ps@lexicon{\def\@oddhead{\slshape\mysectionname\hfil 
{\Large\verb+\botmark+}\quad\thepage}
\def\@evenhead{\thepage\quad{\Large\verb+\firstmark+}\hfil \slshape\mysectionname}}
\makeatother

\newcommand{\mysectionname}{\thesection\,\, BUILT-IN FUNCTIONS}

% end stuff for lex


\begin{document}


\title{GAMBIT COMMAND LANGUAGE\thanks{This is part of the Gambit
Project, which was funded in part by National Science Foundation
grants SBR-9308637 to the California Institute of Technology and
SBR-9308862 to the University of Minnesota.}}

\author{Richard D. McKelvey\\California Institute of
Technology
\and
Andrew McLennan\\University of
Minnesota
\and 
Theodore Turocy\\Northwestern University
\and
Gary Wu\\California Institute of Technology
}

\date{Version 0.95\\ \today\\ \jobname.tex}

\maketitle

\tableofcontents

\chapter*{Preface}
\addcontentsline{toc}{chapter}{Preface}
\pagestyle{myheadings}
\markboth{Preface}{Preface}
\chapter{Function Reference, Alphabetical}
\pagestyle{lexicon}

\section{Built-In Functions}

\begin{itemize}


%--A--


\item\lex{ActionProb}
\protect \large \begin{verbatim}
ActionProb[profile->BEHAV, action->ACTION] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the probability that \verb+action+ is chosen at its
information set when all players are following \verb+profile+.
If \verb+action+ is a chance action, the probability of chance selecting
the action is returned.  If the probability is not specified by the 
profile, the null value is returned.  It is an error if \verb+profile+
and \verb+action+ are not from the same extensive form game.

\item [See also:] \verb+ActionProbs+, \verb+SetActionProbs+.
\ed

\item\lex{ActionProbs}
\protect \large \begin{verbatim}
ActionProbs[profile->BEHAV] =: LIST(LIST(LIST(NUMBER))) 
\end{verbatim}\normalsize

\bd 
Returns a nested list of probabilities for each action under
\verb+profile+.  The \verb+(i,j,k)+th entry is the probability of
player \verb+i+, information set \verb+j+, action \verb+k+. 

\item [See also:] \verb+ActionProb+, \verb+SetActionProbs+.
\ed

\item\lex{ActionValue}
\protect \large \begin{verbatim}
ActionValue[profile->BEHAV, action->ACTION] =: NUMBER 
\end{verbatim}\normalsize

\bd 
Returns the expected payoff to a player (who is in control of the
information set including \verb+action+) of choosing \verb+action+ when
all players are following \verb+profile+.  If the value is not
well-defined, the null value is returned.  It is an error if
\verb+profile+ and \verb+action+ are not from the same extensive form
game, or if \verb+action+ is an action at an information set owned by
the chance player.

\item [See also:] \verb+ActionValues+, \verb+Belief+,
\verb+InfosetProb+, \verb+NodeValue+, \verb+RealizProb+.  
\ed

\item\lex{ActionValues}
\protect \large \begin{verbatim}
ActionValues[profile->BEHAV] =: LIST(LIST(LIST(NUMBER))) 
\end{verbatim}\normalsize

\bd 
Returns a list of expected payoffs of each action (to the player who
chooses that action).  The \verb+(i,j,k)+th entry is the expected
payoff to player \verb+i+ at information set \verb+j+, of action \verb+k+. 

\item [See also:] \verb+ActionValue+, \verb+Belief+,
\verb+InfosetProb+, \verb+NodeValue+, \verb+RealizProb+.  
\ed

\item\lex{Actions}
\protect \large \begin{verbatim} 
Actions[infoset->INFOSET*, support->EFSUPPORT] =: LIST(ACTION) 
\end{verbatim}\normalsize

\bd
Returns the list of actions available at \verb+infoset+ in
\verb+support+.  If \verb+infoset+ is the null information set, the
empty list of actions is returned.  It is an error if \verb+infoset+
and \verb+support+ are not from the same extensive form game.

\item [See also:] \verb+DeleteAction+, \verb+InsertAction+.
\ed

\item\lex{AddAction}
\protect \large \begin{verbatim} 
AddAction[support->EFSUPPORT, action->ACTION] =: EFSUPPORT 
\end{verbatim}\normalsize

\bd 
Adds \verb+action+ to the \verb+support+.  If the action is already in
the support, no change is made.  A copy of the modified support is
returned.  It is an error if \verb+support+ and \verb+action+ are not from the
same extensive form game.

\item [See also:] \verb+RemoveAction+, \verb+Support+.
\ed

\item\lex{AddMove}
\protect \large \begin{verbatim} 
AddMove[infoset->INFOSET, node->NODE] =: NODE 
\end{verbatim}\normalsize

\bd
Places a terminal \verb+node+ into the information set
\verb+infoset+.  The result is \verb+node+ becomes a decision node,
with number of branches equal to the number of actions in \verb+infoset+.
New child nodes are created as successor nodes to the actions in the
information set.  The child which succeeds the first action is returned.
It is an error if \verb+node+ and \verb+infoset+ are not from the same
extensive form game, or if \verb+node+ is not a terminal node.

\item [See also:] \verb+InsertMove+, \verb+DeleteMove+,
\verb+NewInfoset+.  
\ed

\item\lex{AddStrategy}
\protect \large \begin{verbatim}
AddStrategy[support->NFSUPPORT, strategy->STRATEGY] =: NFSUPPORT 
\end{verbatim}\normalsize

\bd
Adds \verb+strategy+ to the \verb+support+.  If the strategy is already
in the support, no change is made.  A copy of the modified support is
returned.  It is an error if \verb+support+ and \verb+strategy+ are not
from the same normal form game.

\item [See also:] \verb+RemoveStrategy+, \verb+Support+.
\ed

\item\lex{AgentForm}
\protect \large \begin{verbatim}
AgentForm[efg->EFG, {time<->0}] =: NFG 
\end{verbatim}\normalsize

\bd
Creates and returns the agent normal form representation of \verb+efg+.
The optional parameter \verb+time+, if specified, returns the amount
of time consumed by the conversion.

\item [See also:] \verb+Nfg+.
\ed

\item\lex{And} 
\protect \large \begin{verbatim}
And[x->BOOLEAN, y->BOOLEAN] =: BOOLEAN 
\end{verbatim} \normalsize

\bd
Computes the logical conjunction of \verb+x+ and \verb+y+.
\item [Short forms:] \verb+x && y+, \verb+x AND y+.
\item [See also:] \verb+Not+, \verb+Or+.
\ed



\item\lex{ArgMax} 
\protect \large \begin{verbatim}
ArgMax[x->LIST(INTEGER)] =: INTEGER 
ArgMax[x->LIST(NUMBER)] =: INTEGER 
\end{verbatim} \normalsize

\bd 
Returns the index of the first element of the list \verb+x+ which
attains the maximum value of any elements in the list.  
\ed

\item\lex{Assign} 
\protect \large \begin{verbatim}
Assign[name->TEXT, value<->T*] =: T
\end{verbatim} \normalsize

{\it for all types} {\tt T} 
\bd 
Creates a new variable \verb+name+, with return value of \verb+value+.
Returns the value assigned.  If \verb+name+ is already a defined
variable in the current scope, then if it is of type \verb+T+, it is
modified to have return value of \verb+value+.  If it is of a
different data type, an error results.
 
\item [Short form:] \verb+x := value+
\item [Note:] For the short form, quotes around \verb+name+ are not
required, and the function is not listable.
\item [See also:] \verb+Clear+, \verb+UnAssign+.
\ed

%--B--


\item\lex{Behav}
\protect \large \begin{verbatim}
Behav[mixed->MIXED] =: BEHAV 
\end{verbatim}\normalsize

\bd
Converts \verb+profile+ to the equivalent behavior strategy profile on the
associated extensive form game using Kuhn's Theorem.  It is an error
if there is no extensive form game associated with the normal form game
of \verb+profile+.
\item [See also:] \verb+Mixed+.
\ed

\item\lex{Behav}
\protect \large \begin{verbatim}
Behav[support->EFSUPPORT] =: BEHAV 
\end{verbatim}\normalsize

\bd
Returns a behavior strategy profile over \verb+support+ with equal
probabilities for all actions in the same information set. 
\item [See also:] \verb+Centroid+, \verb+Mixed+.
\ed

\item\lex{Belief}
\protect \large \begin{verbatim}
Belief[profile->BEHAV, node->NODE] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the probability of being at \verb+node+, conditional on the
player who chooses at \verb+node+ knowing she is in \verb+node+'s
information set, assuming all players follow \verb+profile+.  The null
value is returned if the belief value is not well-defined, or if
\verb+node+ is terminal.  It is an error if \verb+profile+ and \verb+node+
are not from the same extensive form game.
\item [See also:] \verb+ActionValue+, \verb+InfosetProb+, \verb+NodeValue+,
\verb+RealizProb+, verb+Beliefs+
\ed

\item\lex{Beliefs}
\protect \large \begin{verbatim}
Beliefs[profile->BEHAV] =: LIST(NUMBER) 
\end{verbatim}\normalsize

\bd 
Returns a nested list of
beliefs of being at each node of each information set under
\verb+profile+. The \verb+(i,j,k)+th element of the list corresponds
to player \verb+i+, information set \verb+j+, and member node
\verb+k+. The null value is returned for nodes where beliefs are
undefined.

\item [See also:] \verb+ActionValue+, \verb+InfosetProb+, \verb+NodeValue+,
\verb+RealizProb+, verb+Belief+
\ed



%--C--


\item\lex{Chance}
\protect \large \begin{verbatim}
Chance[efg->EFG] =: EFPLAYER 
\end{verbatim}\normalsize

\bd
Returns the chance, or nature, player defined on \verb+efg+.
Each extensive form has exactly one
chance player predefined, and it is not possible to define any additional
chance players.
\ed

\item\lex{ChanceProb}
\protect \large \begin{verbatim}
ChanceProb[action->ACTION] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the probability of \verb+action+ being chosen at its information
set by the chance player.  It is an error if \verb+action+ is not an action
which is chosen by the chance player.
\item [See also:] \verb+SetChanceProbs+.
\ed

\item\lex{Children}
\protect \large \begin{verbatim} 
Children[node->NODE] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd
Returns the list of children of \verb+node+.
\item [See also:] \verb+Parent+.
\ed

\item\lex{Clear}
\protect \large \begin{verbatim}
Clear[] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Unassigns all variables defined in the current scope.  Returns \verb+True+.
\item [See also:] \verb+Assign+, \verb+UnAssign+.
\ed

\item\lex{CompressEfg}
\protect \large \begin{verbatim}
CompressEfg[support->EFSUPPORT] =: EFG 
\end{verbatim}\normalsize

\bd
Creates a copy of the extensive form game on which \verb+support+ is
defined, where all actions not present in \verb+support+ have been
removed.
\ed

\item\lex{CompressNfg}
\protect \large \begin{verbatim}
CompressNfg[support->NFSUPPORT] =: NFG 
\end{verbatim}\normalsize

\bd
Creates a copy of the normal form game on which \verb+support+ is
defined, where all strategies not present in \verb+support+ have been
removed.
\ed

\item\lex{Concat}
\protect \large \begin{verbatim}
Concat[x->NLIST(ANYTYPE), y->NLIST(ANYTYPE)] =: LIST(ANYTYPE) 
\end{verbatim}\normalsize

\bd
Returns the concatenation of the lists \verb+x+ and \verb+y+.
\item
[Short form:] \verb%x & y%
\ed

\item\lex{Concat}
\protect \large \begin{verbatim}
Concat[x->TEXT, y->TEXT] =: TEXT 
\end{verbatim} \normalsize

\bd
Returns the concatenation of \verb+x+ and \verb+y+.
\item [Short form:] \verb%x & y%
\ed

\item\lex{Contains}
\protect \large \begin{verbatim}
Contains[list->NLIST(ANYTYPE), x->ANYTYPE] =: BOOLEAN 
Contains[list->NLIST(ANYTYPE), x->LIST(ANYTYPE)] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when the value \verb+x+ is contained in \verb+list+.
\item [See also:] \verb+NthElement+.
\ed

\item\lex{CopyTree}
\protect \large \begin{verbatim}
CopyTree[from->NODE, to->NODE] =: NODE 
\end{verbatim}\normalsize

\bd
Copies the subtree rooted at \verb+from+ to the terminal
node \verb+to+ in the same extensive form game.  The nodes in the
copied subtree belong to the same information sets as their counterparts in
the original subtree.  Returns the node \verb+to+.  It is an error if
\verb+from+ and \verb+to+ are not from the same extensive form game,
or if \verb+to+ is not a terminal node.  The function has no effect if
the copying operation would violate the currently marked subgame
structure.

\item
[See also:] \verb+MoveTree+.
\ed

%--D--

\item\lex{Date}
\protect \large \begin{verbatim}
Date[] =: TEXT 
\end{verbatim}\normalsize

\bd
Returns the current date and time. 
\ed

\item\lex{DeleteAction}
\protect \large \begin{verbatim}
DeleteAction[action->ACTION] =: INFOSET 
\end{verbatim}\normalsize

\bd
Deletes \verb+action+ from its information set. 
As a consequence, the corresponding subtrees associated
with the action from each member of the information set are deleted.
Returns the information set to which \verb+action+ belonged.  It is an
error if \verb+action+ is the only action at its information set.
\item [See also:] \verb+Actions+, \verb+InsertAction+.
\ed

\item\lex{DeleteEmptyInfoset}
\protect \large \begin{verbatim}
DeleteEmptyInfoset[infoset->INFOSET] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Deletes \verb+infoset+ from its extensive form game.  An information set
may be deleted only when it has no members; otherwise, this function has
no effect.  Returns \verb+True+ when the information set was successfully
deleted.
\item [See also:] \verb+Members+, \verb+NewInfoset+.
\ed

\item\lex{DeleteFunction}
\protect \large \begin{verbatim}
*DeleteFunction[function-name[argument-list]]
\end{verbatim}\normalsize

\bd
Removes the function with the given signature
from the list of user-defined functions.
\item [Note:] Special function. Not listable; cannot be called inside
a user defined function; not documented in \verb+Help+ or \verb+Manual+.  
\item [See also:] \verb+NewFunction+.
\ed

\item\lex{DeleteMove}
\protect \large \begin{verbatim}
DeleteMove[node->NODE, keep->NODE] =: NODE 
\end{verbatim}\normalsize

\bd
Deletes \verb+node+ from its extensive form game.  The
subtree rooted in node \verb+keep+, which must be a child of
\verb+node+, is kept, and \verb+keep+ takes the place of \verb+node+ in
the tree.  All other subtrees descending from \verb+node+ are deleted.
The kept node \verb+keep+ is returned.  It is an error if \verb+keep+
is not a child of \verb+node+, or if \verb+keep+ and \verb+node+ are not
from the same extensive form game.
\item [See also:] \verb+DeleteTree+, \verb+InsertMove+, \verb+AddMove+.
\ed

\item\lex{DeleteOutcome}
\protect \large \begin{verbatim}
DeleteOutcome[outcome->EFOUTCOME] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd
Removes \verb+outcome+ from its extensive
form game.  All nodes with the specified outcome attached are reset to
having no outcome attached.  Returns the list of nodes to which
the outcome was attached.
\item [See also:] \verb+NewOutcome+.
\ed

\item\lex{DeleteOutcome}
\protect \large \begin{verbatim}
DeleteOutcome[outcome->NFOUTCOME] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Removes \verb+outcome+ from its normal form game.  Return \verb+True+.
\item [See also:] \verb+NewOutcome+.
\ed


\item\lex{DeleteTree}
\protect \large \begin{verbatim}
DeleteTree[node->NODE] =: NODE 
\end{verbatim}\normalsize

\bd
Deletes the subtree rooted at \verb+node+.  The
node then becomes a terminal node, which is returned.
\item [See also:] \verb+DeleteMove+.
\ed

\item\lex{Divide} 
\protect \large \begin{verbatim}
Divide[x->NUMBER, y->NUMBER] =: NUMBER 
\end{verbatim} \normalsize

\bd
Returns the quotient $x / y$. 
\item [Short form:] \verb+x / y+
\item [See also:] \verb+IntegerDivide+.
\ed

\item\lex{Divide}
\protect \large \begin{verbatim}
Divide[x->INTEGER, y->INTEGER] =: NUMBER 
\end{verbatim}\normalsize

\bd
Divides \verb+y+ into \verb+x+ by forming the equivalent rational number.
\item [Short form:] \verb+x / y+
\item [See also:] \verb+IntegerDivide+.
\ed

\item\lex{Dot}
\protect \large \begin{verbatim}
Dot[x->LIST(INTEGER), y->LIST(INTEGER)] =: INTEGER 
Dot[x->LIST(NUMBER), y->LIST(NUMBER)] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the dot product of \verb+x+ and \verb+y+, where the lists are
treated as vectors.
It is an error to attempt to multiply two lists of different
lengths.
\item [Short form:] \verb%x . y%
\ed

%--E--

\item\lex{ElapsedTime}
\protect \large \begin{verbatim}
ElapsedTime[] =: NUMBER 
\end{verbatim}\normalsize

\bd
If the system stopwatch is currently running, returns the
time elapsed since the stopwatch was started.  If the system stopwatch
is not running, returns the time elapsed during the last period during which
the stopwatch was running.
\item
[See also:] \verb+IsWatchRunning+, \verb+StartWatch+, \verb+StopWatch+.
\ed

\item\lex{ElimDom}
\protect \large \begin{verbatim}
ElimDom[support->NFSUPPORT, {strong->False}, 
        {mixed->False}, {time<->0.000000}, 
        {traceFile<->(Output)}, {traceLevel->0}] =: NFSUPPORT 
ElimDom[support->EFSUPPORT, {strong->False}, 
        {mixed->False}, {time<->0.000000}, 
        {traceFile<->(Output)}, {traceLevel->0}] =: EFSUPPORT 
\end{verbatim}\normalsize

\bd
Finds dominated strategies, or actions, as appropriate, in a 
\verb+support+.  The returned support contains only the undominated
strategies or actions; if this support is identical to the input support,
no strategies or actions were found to be dominated.  The following
optional parameters may be specified to modify the behavior of
the elimination:

\bd
\item [strong:] By default, all weakly dominated strategies or actions
are eliminated.  If this is specified \verb+True+, elimination is based
on strict dominance.
\item [mixed:] By default, elimination is done in pure strategies or
actions.  If this is specified \verb+True+, elimination is done by
examining mixtures over other strategies or actions.
\item [time:] Returns the time consumed by the elimination process.
\item [traceFile:] A file containing a log of more detailed information
on the elimination process.  By default, no logging is done.
\item [traceLevel:] An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no output
at all.
\ed
\ed

\item\lex{EnumMixedSolve}
\protect \large \begin{verbatim}
EnumMixedSolve[support->NFSUPPORT, {stopAfter->0}, 
               {precision->Machine}, {nPivots<->0}, 
               {time<->0.000000}, {traceFile<->(Output)}, 
               {traceLevel->0}] =: LIST(MIXED) 
EnumMixedSolve[support->EFSUPPORT, {asNfg->False}, 
               {stopAfter->0}, {precision->Machine}, 
               {nPivots<->0}, {time<->0.000000}, 
               {traceFile<->(Output)}, {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd
Returns the extreme points of the set of all Nash equilibria (pure or
mixed) for a two person game using \verb+support+.

The following optional parameters may be used to modify the behavior
of the algorithm:
\bd
\item
[asNfg:] By default, this is \verb+False+.  If it is specified to be
\verb+True+, the extensive form game is solved by recursively converting
its marked subgames into normal form, solving, and reconstructing the
solution as a behavior profile.  {\it Note that currently this algorithm
is only supported on the normal form, so this parameter
must always be specified and {\tt True}.} 
\item
[stopAfter:] By default, all equilibria are found.  This parameter may
be used to specify a maximum number of equilibria to be found.
\item
[precision:] Determines the precision of the computation. Default is
machine precision (floating point). 
\item
[nPivots:] Returns the number of pivots done by the
algorithm.
\item
[time:] Returns the time elapsed during the execution
of the algorithm.
\item
[traceFile:] A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no output
at all.
\ed
\item [See also:] \verb+EnumPureSolve+.
\ed

\item\lex{EnumPureSolve}
\protect \large \begin{verbatim}
EnumPureSolve[support->NFSUPPORT, {stopAfter->0}, 
              {precision->Machine}, {time<->0.000000}, 
              {traceFile<->(Output)}, {traceLevel->0}] =: LIST(MIXED) 
EnumPureSolve[support->EFSUPPORT, {asNfg->False}, 
              {stopAfter->0}, {precision->Machine}, 
              {time<->0.000000}, {traceFile<->(Output)}, 
              {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd
Returns all pure strategy Nash equilibria of a game using the given
\verb+support+.  The behavior
of the algorithm may be modified by the following optional parameters:
\bd
\item
[asNfg:] By default, this is \verb+False+.  If it is specified to be
\verb+True+, the extensive form game is solved by recursively converting
its marked subgames into normal form, solving, and reconstructing the
solution as a behavior profile.
\item
[stopAfter:] By default, all equilibria are found.  This parameter may
be used to specify a maximum number of equilibria to be found.
\item
[precision:] Determines the precision of the computation. Default is
machine precision (floating point). 
\item
[time:] Returns the time elapsed during the execution
of the algorithm.
\item
[traceFile:] A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An integer specifying the level of detail in logging.  Higher
integers correspond to more detail; zero corresponds to no output at all.
\ed
\item
[See also:] \verb+EnumMixedSolve+.
\ed

\item\lex{Equal}
\protect \large \begin{verbatim}
Equal[x->T*, y->T*] =: BOOLEAN
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns \verb+True+ when \verb+x+ and \verb+y+ are equal.  For games,
\verb+x+ and \verb+y+ are considered equal when they refer to the same
game (but not if they refer to two different games with exactly the
same structure, payoffs, and so forth).  A null value is considered equal
to the null value, but is not equal to any non-null value.
\item
[Short form:] \verb+x = y+.
\item
[See also:] \verb+NotEqual+.
\ed

\item\lex{ExePath}
\protect \large \begin{verbatim}
ExePath[{file->True}, {path->True}] =: TEXT 
\end{verbatim} \normalsize

\bd
Returns the path of the GCL executable. 
\bd
\item [file:] Returns the file name.  Default is True.  
\item [path:] Returns the path.  Default is True. 
\ed
\item [See also:] \verb+GetPath+.
\ed

\item\lex{Exp}
\protect \large \begin{verbatim}
Exp[x->NUMBER] =: NUMBER 
\end{verbatim} \normalsize

\bd
Returns the value of the function ${\rm e}^{x}$.
\item [See also:] \verb+Log+, \verb+Power+.
\ed


%--F--

\item\lex{Filter}
\protect \large \begin{verbatim}
Filter[x->NLIST(ANYTYPE*), y->NLIST(BOOLEAN)] =: LIST(ANYTYPE) 
\end{verbatim} \normalsize

\bd
Returns a list with the same dimension structure as \verb+list+, with the
elements for which the corresponding elements of \verb+by+ are \verb+False+
removed.  It is an error if \verb+x+ and \verb+y+ do not have the same
dimensionality.
\item [See also:] \verb+Sort+.
\ed

\item\lex{Flatten}
\protect \large \begin{verbatim}
Flatten[x->NLIST(ANYTYPE*), {levels->0}] =: LIST(ANYTYPE) 
\end{verbatim} \normalsize

\bd
Returns a list with the same elements as \verb+x+, with the nesting
structure flattened.  By default, all levels are flattened, returning
a one-dimensional list; the optional parameter \verb+levels+ may be
used to limit the flattening to the topmost \verb+levels+.
\ed

\item\lex{For}
\protect \large \begin{verbatim}
*For[statement-list, boolean-expression, 
    statement-list, statement-list]
\end{verbatim}\normalsize

\bd
Defines a piece of code to be executed repeatedly.  See the section
on control structures for complete information.
\item [Note:] Special function.  Not listable; arguments are not GCl
data types; not documented in \verb+Help+ or \verb+Manual+.  
\item
[See also:] \verb+While+.
\ed

\item\lex{Format}
\protect \large \begin{verbatim}
Format[x->INTEGER, {width<->0}] =: INTEGER 
\end{verbatim} \normalsize

\bd 
Sets the formatting style for output of INTEGER data types on
output streams.
\bd
\item [width:] The width for a numeric field.  If the width of the
data is greater than \verb+width+, the width is overridden.  (The
default is 0.)
\ed
\item [See also:] \verb+Write+, \verb+ListFormat+.
\ed


\item\lex{Format}
\protect \large \begin{verbatim}
Format[x->NUMBER, {width<->0}, {precis<->6}, {expmode<->False}] =: NUMBER 
\end{verbatim} \normalsize

\bd
Sets the formatting style for output of NUMBER data types on output streams.
\bd
\item [width:] The width for a numeric field.  If the width of the
data is greater than \verb+width+, the width is overridden.  (The
default is 0.)
\item [precis:] The number of decimal places shown for floating point
numbers.
\item [expmode:] If \verb+True+, floating point numbers are printed in
exponential format.
\ed
\item [See also:] \verb+Write+, \verb+ListFormat+.
\ed

\item\lex{Format}
\protect \large \begin{verbatim}
Format[x->TEXT, {quote<->False}] =: TEXT 
\end{verbatim} \normalsize

\bd
Sets the formatting style for output of text on output streams.
\bd
\item [quote:] Whether opening and closing quotation marks are
written.  The default is True.  
\ed
\item [See also:] \verb+Write+, \verb+ListFormat+.
\ed


\item\lex{Format}
\protect \large \begin{verbatim}
Format[x->MIXED BEHAV, {info<->1}] =: MIXED BEHAV 
\end{verbatim} \normalsize

\bd
Sets the formatting style for output of solution types on output streams.
\bd
\item [info:] The amount of information to be displayed.  A value of 1
displays just the strategy or action probabilities.  A value of 2
displays all of the information about the solution. 
\ed
\item [See also:] \verb+Write+, \verb+ListFormat+.
\ed


%--G--

\item\lex{Game}
\protect \large \begin{verbatim}
Game[player->NFPLAYER] =: NFG 
Game[strategy->STRATEGY] =: NFG 
Game[outcome->NFOUTCOME] =: NFG 
Game[player->EFPLAYER] =: EFG 
Game[node->NODE] =: EFG 
Game[outcome->EFOUTCOME] =: EFG 
Game[infoset->INFOSET] =: EFG 
Game[profile->MIXED] =: NFG 
Game[profile->BEHAV] =: EFG 
Game[support->NFSUPPORT] =: NFG 
Game[support->EFSUPPORT] =: EFG 
\end{verbatim} \normalsize

\bd
Returns the game on which the parameter is defined.
\ed

\item\lex{GetEnv}
\protect \large \begin{verbatim}
GetEnv[name->TEXT] =: TEXT 
\end{verbatim} \normalsize

\bd
Returns the string associated with environment variable \verb+name+.
\item [See also:] \verb+SetEnv+, \verb+UnSetEnv+.
\ed


\item\lex{GetFormat}
\protect \large \begin{verbatim}
GetFormat[x->INTEGER, {width<->0}] =: INTEGER 
\end{verbatim} \normalsize

\bd 
Gets the current formatting style for output of INTEGER data types on
output streams.
\bd
\item [width:] The width for a numeric field.  
\ed
\item [See also:] \verb+Format+.
\ed


\item\lex{GetFormat}
\protect \large \begin{verbatim}
GetFormat[x->NUMBER, {width<->0}, {precis<->6}, {expmode<->False}] =: NUMBER 
\end{verbatim} \normalsize

\bd Gets the current formatting style for output of NUMBER data types
on output streams.  
\bd
\item [width:] The width for a numeric field.  
\item [precis:] The number of decimal places shown for floating point
numbers.
\item [expmode:] Whether floating point numbers are printed in
exponential format.
\ed
\item [See also:] \verb+Format+.
\ed

\item\lex{GetFormat}
\protect \large \begin{verbatim}
GetFormat[x->TEXT, {quote<->False}] =: TEXT 
\end{verbatim} \normalsize

\bd
Gets the current formatting style for output of text on output streams.
\bd
\item [quote:] Whether opening and closing quotation marks are
written. 
\ed
\item [See also:] \verb+Format+.
\ed


\item\lex{GetFormat}
\protect \large \begin{verbatim}
GetFormat[x->MIXED BEHAV, {info<->1}] =: MIXED BEHAV 
\end{verbatim} \normalsize

\bd Gets the current formatting style for output of solution types on
output streams.  
\bd
\item [info:] The amount of information to be displayed.  
\ed
\item [See also:] \verb+Format+.
\ed

\item\lex{GetListFormat}
\protect \large \begin{verbatim}
GetListFormat[{braces<->True}, {commas<->True}, {lf<->1}, {indent<->2}] =: BOOLEAN 
\end{verbatim} \normalsize

\bd
Gets the current formatting style for output of lists on output streams.
\bd
\item [braces:] If \verb+True+, lists are delimited by braces.
\item [commas:] If \verb+True+, elements are delimited by commas.
\item [lf:] Number of levels of list that are displayed with a line feed.
\item [indent:] Number of spaces to indent each level of a list.
\ed
\item [See also:] \verb+Write+, \verb+Format+.
\ed


\item\lex{GetPath}
\protect \large \begin{verbatim}
GetPath[{file->True}, {path->True}] =: TEXT 
\end{verbatim} \normalsize

\bd
Returns the path to the file in which the command is included.  Can be
used to identify Include[] files. 
\bd
\item [file:] Returns the file name.  Default is True.  
\item [path:] Returns the path.  Default is true. 
\ed
\item [See also:] \verb+ExePath+, \verb+Include+.
\ed

\item\lex{GobitGridSolve}
\protect \large \begin{verbatim}
GobitGridSolve[support->NFSUPPORT, {pxifile->}, 
               {minLam->0.001000}, {maxLam->500.000000}, 
               {delLam->0.020000}, {powLam->1}, 
               {delp1->0.100000}, {tol1->0.100000}, 
               {delp2->0.010000}, {tol2->0.010000}, 
               {nEvals<->0}, {time<->0.000000}, 
               {traceFile<->(Output)}, 
               {traceLevel->0}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd
Computes the complete logistic quantal response correspondence for
a (small) two-person normal form game on the \verb+support+, for values of
$\lambda$ between $\underline{\lambda}$ and $\bar{\lambda}.$ Returns
the list of mixed profiles computed, one profile for each value of
$\lambda_t$ from lowest to highest.

The operation of the algorithm may be modified by specifying optional
parameters.  See \verb+GobitSolve+ for a description of parameters
not listed here:
\bd
\item
[delp1:] Grid size for course search over probability space.  Default
is $0.1$ .
\item
[tol1:] The tolerance on the objective function for course search.
Values of $p$ for which the objective function is less this value are
searched further on a finer grid.  The default is $0.1$.
\item
[delp2:] Grid size for fine search over probability space.  Default is
$0.01$ .
\item
[tol2:] The tolerance on the objective function for fine search.
Values of $p$ for which the objective function is less this value are
kept.  The default is $0.01$.  
\ed
\item [See also:] \verb+GobitSolve+.
\ed

\item\lex{GobitLambda}
\protect \large \begin{verbatim}
GobitLambda[profile->MIXED] =: NUMBER 
GobitLambda[profile->BEHAV] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the value of \verb+lambda+ for mixed or behavior profiles
computed by \verb+GobitSolve+ or \verb+GobitGridSolve+.  Profiles not
created by one of these algorithms have a null lambda value.
\item
[See also:] \verb+GobitGridSolve+, \verb+GobitSolve+, \verb+GobitValue+.
\ed

\item\lex{GobitSolve}
\protect \large \begin{verbatim}
GobitSolve[start->MIXED BEHAV, {pxifile->}, {minLam->0.001000}, 
           {maxLam->500.000000}, {delLam->0.020000}, {powLam->1}, 
           {fullGraph->False}, {maxitsN->20}, {tolN->0.000000}, 
           {maxits1->100}, {tol1->0.000000}, {time<->0}, 
           {nEvals<->0}, {nIters<->0}, {traceFile<->(Output)}, 
           {traceLevel->0}] =: LIST(MIXED BEHAV) 
\end{verbatim}\normalsize

\bd 
Computes a branch of the logistic quantal response equilibrium
correspondence for a game. \verb+start+ is
used as the starting point for the computation of $\lambda_{0}$, and
the support over which \verb+start+ is defined is the support over
which the correspondence is computed.

The behavior of the algorithm may be modified by specifying some of the
following optional parameters:
\bd
\item
[pxifile:] Generate output to this file for later retrieval and viewing by
the PXI program.  By default no output file is generated.
\item
[minLam:] Sets $\underline{\lambda}$, the minimum value of $\lambda$.  The 
default value is $\underline{\lambda}=0.001$.
\item
[maxLam:] Sets $\overline{\lambda}$, the maximum value of $\lambda$.  The
default value is $\overline{\lambda}=500.0$.
\item
[delLam:] Sets the constant $\delta$ used in incrementing $\lambda$.  The
default value is $\delta=0.02$.
\item
[powLam:] Sets the exponent $a$ used in incrementing $\lambda$.  The default
value is $a=1$, producing geometric incrementing.  Setting $a=0$ corresponds
to linear incrementing.
\item
[fullGraph:] If \verb+True+, the list of behavior strategy profiles
returned contains the full sequence of profiles computed from each successive
value of $\lambda$.  The default value is \verb+False+, in which case only
the profile for the last value of $\lambda$ computed is returned.
\item
[maxitsN:] Sets the maximum number of iterations for the $n$-dimensional
optimization routine.  The default value is $200$.
\item
[tolN:] Sets the tolerance for the $n$-dimensional optimization routine.
The default is 1.0e-10.
\item
[maxits1:] Sets the maximum number of iterations for the one-dimensional
optimization routine.  The default is $100$.
\item
[tol1:] Sets the tolerance for the one-dimensional optimization routine.
The default is 2.0e-10.
\item
[time:] Returns the amount of time consumed by the
algorithm.
\item
[nEvals:] Returns the number of function evaluations
performed by the algorithm.
\item
[nIters:] Returns the number of iterations performed
by the algorithm.
\item
[traceFile:] A file containing a log of more detailed information on
the execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to
no output at all.
\ed

\item
[Note:] The extensive form version disregards any marked
subgames.
\item [See also:] \verb+GobitGridSolve+.
\ed

\item\lex{GobitValue}
\protect \large \begin{verbatim}
GobitValue[profile->MIXED] =: NUMBER 
GobitValue[profile->BEHAV] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the value of the Gobit objective function for mixed or behavior
profiles computed by \verb+GobitSolve+ or \verb+GobitGridSolve+.  The Gobit
value for profiles not created by these algorithms is null.
\item
[See also:] \verb+GobitGridSolve+, \verb+GobitLambda+, \verb+GobitSolve+.
\ed

\item\lex{Greater}
\protect \large \begin{verbatim}
Greater[x->INTEGER, y->INTEGER] =: BOOLEAN 
Greater[x->NUMBER, y->NUMBER] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when \verb+x+ is (strictly) greater than \verb+y+.
\item
[Short form:] \verb+x > y+
\item
[See also:] \verb+GreaterEqual+, \verb+Less+, \verb+LessEqual+.
\ed

\item\lex{Greater}
\protect \large \begin{verbatim}
Greater[x->TEXT, y->TEXT] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when the string \verb+x+ is lexicographically (strictly)
greater than the string \verb+y+, using the native character set of the 
achine.
\item
[Short form:] \verb+x > y+
\item
[See also:] \verb+GreaterEqual+, \verb+Less+, \verb+LessEqual+.
\ed

\item\lex{GreaterEqual}
\protect \large \begin{verbatim}
GreaterEqual[x->INTEGER, y->INTEGER] =: BOOLEAN 
GreaterEqual[x->NUMBER, y->NUMBER] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when \verb+x+ is at least as large as \verb+y+.
\item
[Short form:] \verb+x >= y+
\item
[See also:] \verb+Greater+, \verb+Less+, \verb+LessEqual+.
\ed

\item\lex{GreaterEqual}
\protect \large \begin{verbatim}
GreaterEqual[x->TEXT, y->TEXT] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when the string \verb+x+ is lexicographically greater than
or equal to the string \verb+y+, using the native character set of the
machine.
\item
[Short form:] \verb+x >= y+
\item
[See also:] {\tt Greater}, {\tt Less}, {\tt LessEqual}.
\ed

%--H--


\item\lex{Help}
\protect \large \begin{verbatim}
Help[x->TEXT, {udf->True}, {bif->True}] =: LIST(TEXT) 
\end{verbatim}\normalsize

\bd 
Returns a list of all function names or function prototypes matching
\verb+x+.  If \verb+x+ is an exact match to a function name, a list of
corresponding function prototypes is returned.  \verb+x+ can also
contain the regular-expression style wildcards \verb+*+ and \verb+?+.
In this case, if there is not an exact match, a list of function names
matching \verb+x+ is returned.  The parameter \verb+udf+ determines if
user defined functions are listed, and \verb+bif+ determines if built
in functions are listed.  Both of these parameters are \verb+True+ by
default.
\item
[See also:] \verb+HelpVars+, \verb+Manual+.
\ed

\item\lex{HelpVars}
\protect \large \begin{verbatim}
HelpVars[x->TEXT] =: LIST(TEXT) 
\end{verbatim}\normalsize

\bd 
Returns a list of all variables matching \verb+x+.  \verb+x+ can
contain regular-expression style wildcards \verb+*+ and \verb+?+. 
In this case,
if there is not an exact match, a list of variables matching \verb+x+
is returned.
\item [See also:] \verb+Help+.
\ed

%--I--

\item\lex{If} 
\protect \large \begin{verbatim}
*If[boolean-expression, statement-list]
*If[boolean-expression, statement-list, statement-list]
\end{verbatim} \normalsize
  
\bd
Defines a block of statements to be executed under certain conditions.
See the section on control structures for complete information. 
\item [Note:] Special function.  Not listable; arguments are not GCl
data types; not documented in \verb+Help+ or \verb+Manual+.  
\ed


\item\lex{Include}
\protect \large \begin{verbatim}
*Include[file->TEXT]
\end{verbatim}\normalsize

\bd
Includes the commands in the specified file as commands
in the running GCL program.  The program treats the command as if it
were replaced by the contents of the file.  \verb+Include+ may only be used
at the top level, that is, it cannot be used inside of \verb+NewFunction+
or flow control structures.
\item [Note:] Special function:  Not listable; cannot be called in a
user defined function; not documented in \verb+Help+ or \verb+Manual+. 
\ed


\item\lex{Index}
\protect \large \begin{verbatim}
Index[list->NLIST(ANYTYPE), x->ANYTYPE] =: LIST(INTEGER) 
Index[list->NLIST(ANYTYPE), x->LIST(ANYTYPE)] =: LIST(INTEGER) 
\end{verbatim} \normalsize

\bd
Returns the list of indices in \verb+list+ where \verb+x+ appears.
\ed

\item\lex{Infoset}
\protect \large \begin{verbatim}
Infoset[action->ACTION*] =: INFOSET 
\end{verbatim} \normalsize

\bd
Returns the information set to which \verb+action+ belongs.  The null
action is assumed to belong to the null information set.
\item [See also:] \verb+Actions+.
\ed

\item\lex{Infoset}
\protect \large \begin{verbatim}
Infoset[node->NODE*] =: INFOSET 
\end{verbatim}\normalsize

\bd
Returns the information set to which \verb+node+
belongs.  All nonterminal nodes belong to an information set. 
Terminal nodes, and the null node, belong to the null information set.
\item [See also:] \verb+Members+.
\ed

\item\lex{InfosetProb}
\protect \large \begin{verbatim}
InfosetProb[profile->BEHAV, infoset->INFOSET*] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the probability of reaching \verb+infoset+ when all players
follow \verb+profile+.  The probability of reaching the null information
set is defined to be null.  It is an error if \verb+profile+ and
\verb+infoset+ are not defined on the same extensive form game.
\item
[See also:] \verb+ActionValue+, \verb+Belief+, \verb+NodeValue+,
\verb+RealizProb+.
\ed

\item\lex{InfosetProbs}
\protect \large \begin{verbatim}
InfosetProbs[profile->BEHAV] =: LIST(LIST(NUMBER)) 
\end{verbatim}\normalsize

\bd
Returns the probability of reaching \verb+infoset+ when all players
follow \verb+profile+.  The probability of reaching the null information
set is defined to be null.  It is an error if \verb+profile+ and
\verb+infoset+ are not defined on the same extensive form game.
\item
[See also:] \verb+ActionValue+, \verb+Belief+, \verb+NodeValue+,
\verb+RealizProb+.
\ed

\item\lex{Infosets}
\protect \large \begin{verbatim}
Infosets[player->EFPLAYER] =: LIST(INFOSET) 
\end{verbatim}\normalsize

\bd
Returns the list of information sets at which 
\verb+player+ has the decision.
\item [See also:] \verb+Player+.
\ed

\item\lex{Input}
\protect \large \begin{verbatim}
Input[file->TEXT] =: INPUT 
\end{verbatim}\normalsize

\bd
Opens a new input stream for reading from the file \verb+text+.  An
error occurs if the file is not able to be opened.
\item
[See also:]  \verb+Output+, \verb+Read+.
\ed

%\item\lex{Insert}
%\protect \large \begin{verbatim}
%Insert[list<->NLIST(T*), x->T*, {n->INTEGER}] =: LIST(T)
%Insert[list<->NLIST(T*), x->NLIST(T*), {n->INTEGER}] =: LIST(T) 
%\end{verbatim}\normalsize

%{\it for all types} {\tt T}
%\bd
%Inserts the element \verb+x+ into \verb+list+.  If \verb+n+ is
%unspecified, \verb+x+ is appended to \verb+list+; otherwise, \verb+x+
%is inserted as the \verb+n+th element.  It is an error if \verb+n+ is
%nonpositive, or if \verb+n+ is greater than the length of \verb+list+.
%\item [See also:] \verb+Remove+.
%\ed

\item\lex{InsertAction}
\protect \large \begin{verbatim}
InsertAction[infoset->INFOSET, at->ACTION] =: ACTION 
InsertAction[infoset->INFOSET] =: ACTION 
\end{verbatim}\normalsize

\bd
Inserts a new action into \verb+infoset+ before the action \verb+at+.  
If \verb+at+ is not specified, the new action is appended to \verb+infoset+'s
actions.
The corresponding new branch is created for
each node belonging to \verb+infoset+.  Returns the newly created action.
\item
[See also:] \verb+Actions+, \verb+DeleteAction+.
\ed

\item\lex{InsertMove}
\protect \large \begin{verbatim}
InsertMove[infoset->INFOSET, node->NODE] =: NODE 
\end{verbatim}\normalsize

\bd
Inserts a new node in the tree at the location of \verb+node+.  The
new node is made a member of \verb+infoset+, and the
corresponding number of branches are created from the new node.  \verb+node+
becomes the first child of the new node.  Returns the new node.
\item [See also:] \verb+AddMove+, \verb+DeleteMove+, \verb+NewInfoset+.
\ed

\item\lex{Integer}
\protect \large \begin{verbatim}
Integer[x->NUMBER] =: INTEGER 
Integer[x->INTEGER] =: INTEGER 
\end{verbatim} \normalsize

\bd
Converts \verb+x+ into a value of type \verb+INTEGER+.
\item [See also:] \verb+Number+.
\ed

\item\lex{IntegerDivide} 
\protect \large \begin{verbatim}
IntegerDivide[x->INTEGER, y->INTEGER] =: INTEGER 
\end{verbatim} \normalsize

\bd
Returns the quotient $x / y$, rounded to the next integer
towards zero.  It is an error to attempt to divide by zero.
\item [Short form:] \verb%x DIV y%
\item [See also:] \verb+Divide+, \verb+Modulus+.
\ed


\item\lex{IsConstSum}
\protect \large \begin{verbatim}
IsConstSum[nfg->NFG] =: BOOLEAN 
IsConstSum[efg->EFG] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when the game \verb+efg+ or \verb+nfg+ is constant sum.
\ed

\item\lex{IsFloat}
\protect \large \begin{verbatim}
IsFloat[x->NUMBER] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when the internal representation of \verb+x+ is a
floating point number 
\item
[See also:] \verb+Float+.
\ed

\item\lex{IsKnownNash}
\protect \large \begin{verbatim}
IsKnownNash[profile->BEHAV] =: BOOLEAN 
IsKnownNash[profile->MIXED] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when \verb+profile+
is known by Gambit to be a Nash equilibrium of the
corresponding game.  If \verb+profile+ is complete (probabilities sum to
one for every player, and every information set), then there is a
definitive test for Nash equilibrium.  However if the profile is
incomplete (i. e., it does not specify actions at off the equilibrium
path information sets), then it is possible that a profile (or set
of all completions of the profile) may be Nash, but \verb+IsKnownNash+
returns \verb+False+, because it is not known by Gambit to be Nash.
If the answer is not known to Gambit, then \verb+IsKnownNotNash+ will also
return \verb+False+.
\item [See also:] \verb+IsKnownNotNash+, \verb+IsKnownStrictNash+.
\ed

\item\lex{IsKnownNotNash}
\protect \large \begin{verbatim}
IsKnownNotNash[profile->BEHAV] =: BOOLEAN 
IsKnownNotNash[profile->MIXED] =: BOOLEAN 
\end{verbatim}\normalsize

\bd 
Returns \verb+True+ if the \verb+Profile+
is known by Gambit not to be a Nash equilibrium of the
corresponding game.  
\item
[See also:] \verb+IsKnownNash+.
\ed

\item\lex{IsKnownNotPerfect}
\protect \large \begin{verbatim}
IsKnownNotPerfect[profile->MIXED] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ if \verb+profile+
is known by Gambit not to be a perfect Nash equilibrium.
\item [See also:] \verb+IsKnownPerfect+.
\ed

\item\lex{IsKnownNotSequential}
\protect \large \begin{verbatim}
IsKnownNotSequential[profile->BEHAV] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ if \verb+profile+
is known by Gambit not to be a sequential Nash
equilibrium.
\item [See also:] \verb+IsKnownSequential+.
\ed

\item\lex{IsKnownNotSubgamePerfect}
\protect \large \begin{verbatim}
IsKnownNotSubgamePerfect[profile->BEHAV] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ if \verb+profile+
is known by Gambit not to be a subgame perfect Nash equilibrium.
\item [See also:] \verb+IsKnownSubgamePerfect+.
\ed

\item\lex{IsKnownPerfect}
\protect \large \begin{verbatim}
IsKnownPerfect[profile->MIXED] =: BOOLEAN 
\end{verbatim}\normalsize

\bd 
Returns \verb+True+ if \verb+profile+
is known by Gambit to be a perfect Nash equilibrium, and \verb+False+
otherwise.  There is currently no definitive test in Gambit for
whether an arbitrary profile is perfect, so it is possible for a
perfect equilibrium to return \verb+False+.  However some of the
algorithms (notably \verb+LcpSolve+) will only return perfect
equilibria, which are marked as such.  
\item [See also:] \verb+IsKnownNotPerfect+.
\ed

\item\lex{IsKnownSequential}
\protect \large \begin{verbatim}
IsKnownSequential[profile->BEHAV] =: BOOLEAN 
\end{verbatim}\normalsize

\bd 
Returns \verb+True+ if \verb+profile+
is known by Gambit to be an approximation to a
sequential Nash equilibrium, and \verb+False+ otherwise.  There is
currently no definitive test in Gambit for whether an arbitrary
profile is sequential.  However any Nash equilibrium of an extensive
form game which is computed via the \verb+LiapSolve+ or
\verb+GobitSolve+ algorithms is sequential.
\item [See also:] \verb+IsKnownNotSequential+.
\ed

%\item\lex{IsKnownStrictNash}
%\protect \large \begin{verbatim}
%IsKnownStrictNash[profile->BEHAV(T)] =: BOOLEAN
%IsKnownStrictNash[profile->MIXED(T)] =: BOOLEAN
%\end{verbatim}\normalsize

%{\it for} {\tt T = FLOAT, RATIONAL}
%\bd
%Returns \verb+True+ if \verb+profile+ is known by Gambit to be a strict
%Nash equilibrium of the corresponding game.  If \verb+profile+ is
%complete, there is a definitive test for strict Nash equilibrium.
%However, if the profile is incomplete,then it is possible that a profile
%(or the set of all completions of the profile) may be strict Nash, but
%\verb+IsKnownStrictNash+ returns \verb+False+.  If the answer is not
%known to Gambit, then \verb+IsKnownNotStrictNash+ also returns \verb+False+.
%\item [See also:] \verb+IsKnownNash+, \verb+IsKnownNotStrictNash+.
%\ed

\item\lex{IsKnownSubgamePerfect}
\protect \large \begin{verbatim}
IsKnownSubgamePerfect[profile->BEHAV] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ if \verb+profile+
is known by Gambit to be a subgame perfect Nash
equilibrium.  There is currently no
definitive test in Gambit for whether an arbitrary profile is subgame
perfect.  However, any Nash equilibrium of an extensive form game which
is computed when all subgames are marked will only return a subgame
perfect equilibrium.  
\item [See also:] \verb+IsKnownNotSubgamePerfect+.
\ed

\item\lex{IsList}
\protect \large \begin{verbatim}
IsList[x->ANYTYPE] =: BOOLEAN 
IsList[list->NLIST(ANYTYPE)] =: BOOLEAN 
\end{verbatim}\normalsize

\bd 
Returns \verb+True+ when \verb+x+ is a list or a nested list.
\item
[See also:] \verb+List+.
\ed

\item\lex{IsNull}
\protect \large \begin{verbatim}
IsNull[x->ANYTYPE*] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ if x is a NULL object of type \verb+T+.  
\ed

\item\lex{IsPerfectRecall}
\protect \large \begin{verbatim}
IsPerfectRecall[efg->EFG] =: BOOLEAN 
\end{verbatim}\normalsize

\bd 
Returns \verb+True+ if \verb+efg+ is a game of perfect recall.
\ed


\item\lex{IsPredecessor}
\protect \large \begin{verbatim}
IsPredecessor[node->NODE, of->NODE] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when \verb+node+ is a predecessor
in the tree of the node \verb+of+.  A node is considered its own predecessor.
\item [See also:] \verb+IsSuccessor+.
\ed

%\item\lex{IsRoot}
%\protect \large \begin{verbatim}
%#IsRoot[node->NODE] =: BOOLEAN
%\end{verbatim}\normalsize

%\bd
%Returns \verb+True+ when \verb+node+ is the root node of its
%extensive form.
%\item [See also:] \verb+Parent+.
%\ed

\item\lex{IsSuccessor}
\protect \large \begin{verbatim}
IsSuccessor[node->NODE, from->NODE] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when \verb+node+ is a successor
in the tree of the node \verb+from+.  A node is considered its own successor.
\item [See also:] \verb+IsPredecessor+.
\ed

\item\lex{IsWatchRunning}
\protect \large \begin{verbatim}
IsWatchRunning[] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when the system stopwatch is currently running.
\item
[See also:] \verb+ElapsedTime+, \verb+StartWatch+, \verb+StopWatch+.
\ed


%--J--

%--K--

%--L--

\item\lex{LcpSolve}
\protect \large \begin{verbatim}
LcpSolve[support->NFSUPPORT, {stopAfter->0}, {precision->Machine}, 
         {nPivots<->0}, {time<->0}, {traceFile<->(Output)}, 
         {traceLevel->0}] =: LIST(MIXED) 
LcpSolve[support->EFSUPPORT, {asNfg->False}, {stopAfter->0}, 
         {precision->Machine}, {nPivots<->0}, {time<->0.000000}, 
         {traceFile<->(Output)}, {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd
Solves the game as a linear complementarity problem, using the
Lemke-Howson algorithm for normal form games, and the
Koller-Megiddo-Stengel sequence form for extensive form games.  


The behavior of the algorithm may be modified by the following
optional parameters:
\bd
\item
[asNfg:] By default, extensive forms are solved by the sequence form.
By setting this parameter to \verb+True+, each marked subgame of the extensive
form is converted to its corresponding reduced normal form, solved
via Lemke-Howson, and the mixed strategy solutions converted back into
behavior profiles.
\item
[stopAfter:] Specifies the maximum number of equilibria to find.  If
not specified, the default value is zero, which means that all
equilibria reachable by the algorithm are to be found.
\item
[precision:] Determines the precision of the computation. Default is
machine precision (floating point). 
\item
[nPivots:] Returns the total number of pivots. 
\item
[time:] Returns the elapsed time for the operation.
\item
[traceFile:] A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no
logging at all.
\ed
\item [See also:] \verb+LpSolve+.
\ed

\item\lex{Length}
\protect \large \begin{verbatim}
Length[list->LIST(ANYTYPE*)] =: INTEGER 
\end{verbatim}\normalsize

\bd
Returns the number of elements in \verb+list+.
\item
[See also:] {\tt NthElement}, \verb+NumElements+.
\ed

\item\lex{Less}
\protect \large \begin{verbatim}
Less[x->INTEGER, y->INTEGER] =: BOOLEAN 
Less[x->NUMBER, y->NUMBER] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when \verb+x+ is (strictly) less than \verb+y+.
\item [Short form:] \verb+x < y+
\item [See also:] \verb+Greater+, \verb+GreaterEqual+, \verb+LessEqual+.
\ed

\item\lex{Less}
\protect \large \begin{verbatim}
Less[x->TEXT, y->TEXT] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when the string \verb+x+ is lexicographically (strictly)
less than
the string \verb+y+, using the native character set of the machine.
\item [Short form:] \verb+x < y+
\item [See also:] \verb+Greater+, \verb+GreaterEqual+, \verb+LessEqual+.
\ed

\item\lex{LessEqual}
\protect \large \begin{verbatim}
LessEqual[x->INTEGER, y->INTEGER] =: BOOLEAN 
LessEqual[x->NUMBER, y->NUMBER] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when \verb+x+ is no more than \verb+y+.
\item [Short form:] \verb+x <= y+
\item [See also:] \verb+Greater+, \verb+GreaterEqual+, \verb+Less+.
\ed

\item\lex{LessEqual}
\protect \large \begin{verbatim}
LessEqual[x->TEXT, y->TEXT] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when the string \verb+x+ is lexicographically less than
or equal to the string \verb+y+, using the native character set of the machine.
\item [Short form:] \verb+x <= y+
\item [See also:] \verb+Greater+, \verb+GreaterEqual+, \verb+Less+.
\ed

\item\lex{LiapSolve}
\protect \large \begin{verbatim}
LiapSolve[start->BEHAV, {asNfg->False}, {stopAfter->1}, 
          {nTries->10}, {maxitsN->20}, {tolN->0.000000}, 
          {maxits1->100}, {tol1->0.000000}, {time<->0}, 
          {nEvals<->0}, {traceFile<->(Output)}, 
          {traceLevel->0}] =: LIST(BEHAV) 
LiapSolve[start->MIXED, {stopAfter->1}, {nTries->10}, 
          {maxitsN->20}, {tolN->0.000000}, {maxits1->100}, 
          {tol1->0.000000}, {time<->0}, {nEvals<->0}, 
          {traceFile<->(Output)}, {traceLevel->0}] =: LIST(MIXED) 
\end{verbatim}\normalsize


\bd 
Searches for a Nash equilibrium by minimizing a Lyapunov function
which is zero exactly at Nash equilibria.  The algorithm starts from
the initial starting point determined by the parameter \verb+start+.
The algorithm is not guaranteed to find a Nash equilibrium from any
fixed starting point.  The algorithm thus incorporates the capability
of restarting.  If a Nash equilibrium is not found, it will keep
searching from new randomly chosen starting points until a Nash
equilibrium has been found or the maximum number of tries (parameter
\verb+nTries+) is exceeded, whichever comes first.  The list of
solutions found is returned.

The behavior of the algorithm may be modified by specifying the following
optional parameters:
\bd
\item
[asNfg:] By default, extensive forms are solved in the extensive form.
By setting this parameter to \verb+True+, each marked subgame of the
extensive form is converted to its corresponding reduced normal form game,
solved, and the overall behavior profile reconstructed from these
solutions.
\item
[nTries:] Sets the maximum number of attempts at finding an
equilibrium. Default is 10.
\item
[stopAfter:] Sets the number of equilibria to find.  Default is 1.
\item
[maxitsN:] Sets the maximum number of iterations in the
$n$-dimensional optimization.  Default is 10.
\item
[tolN:] Sets the tolerance for the $n$-dimensional optimization
routine.  Default is 1.0e-10.
\item
[maxits1:] Sets the maximum number of iterations in the
one-dimensional line search.  Default is 100.
\item
[tol1:] Sets the tolerance for the one-dimensional line search.
Default is 2.0e-10.
\item
[time:] Returns the elapsed time for the operation.
\item
[nEvals:] Returns the number of function evaluations for the operation.
\item
[traceFile:] A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no output
at all.
\ed
\ed

\item\lex{LiapValue}
\protect \large \begin{verbatim}
LiapValue[profile->BEHAV] =: NUMBER 
LiapValue[profile->MIXED] =: NUMBER 
\end{verbatim} \normalsize

\bd 
Returns the Lyapunov function value for \verb+profile+.
This value is zero exactly when the
profile is a Nash equilibrium.
\ed

\item\lex{List}
\protect \large \begin{verbatim}
List[x->T, {length->INTEGER}] =: LIST(T)
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Creates a new list of \verb+length+ elements, each equal to \verb+x+.
If \verb+length+ is unspecified, it defaults to 1.
\ed

\item\lex{List}
\protect \large \begin{verbatim}
List[x->INTEGER, {length->1}, {delta->0}] =: LIST(INTEGER) 
List[x->NUMBER, {length->1}, {delta->0}] =: LIST(NUMBER) 
\end{verbatim}\normalsize

\bd
Creates an initialized list of \verb+length+ elements, whose $i^{th}$
entry is \verb%x + (i * delta)%.  If \verb+length+ is unspecified,
it defaults to 1; if \verb+delta+ is unspecified, it defaults to 0.
\ed

\item\lex{ListFormat}
\protect \large \begin{verbatim}
ListFormat[{braces<->True}, {commas<->True}, {lf<->1}, {indent<->2}] =: BOOLEAN
\end{verbatim} \normalsize

\bd
Sets the formatting style for output of lists on output streams.
\bd
\item [braces:] If \verb+True+, lists are delimited by braces.
\item [commas:] If \verb+True+, elements are delimited by commas.
\item [lf:] Number of levels of list that are displayed with a line feed.
\item [indent:] Number of spaces to indent each level of a list.
\ed
\item [See also:] \verb+Write+, \verb+Format+.
\ed

\item\lex{LoadEfg}
\protect \large \begin{verbatim}
LoadEfg[file->TEXT] =: EFG 
\end{verbatim}\normalsize

\bd
Loads an extensive form game from an external savefile.
It is an error if the file cannot be opened, or if the file does
not contain a valid extensive form savefile.
\item [See also:] \verb+SaveEfg+.
\ed

\item\lex{LoadGlobalVar}
\protect \large \begin{verbatim}
LoadGlobalVar[name->TEXT, var->ANYTYPE] =: ANYTYPE
\end{verbatim}\normalsize

\bd
Loads a variable from memory that was previously saved with 
\verb+SaveGlobalVar+. 
\item [See also:] \verb+SaveGlobalVar+.
\ed

\item\lex{LoadLocalVar}
\protect \large \begin{verbatim}
LoadLocalVar[name->TEXT, var->ANYTYPE] =: ANYTYPE
\end{verbatim}\normalsize

\bd
Loads a variable from memory that was previously saved with 
\verb+SaveLocalVar+. 
\item [See also:] \verb+SaveLocalVar+.
\ed

\item\lex{LoadNfg}
\protect \large \begin{verbatim}
LoadNfg[file->TEXT] =: NFG 
\end{verbatim}\normalsize

\bd
Loads a normal form game from an external savefile.
It is an error if the file cannot be opened, or if the file does not 
contain a valid normal form savefile.
\item [See also:] \verb+SaveNfg+.
\ed

\item\lex{Log}
\protect \large \begin{verbatim}
Log[x->NUMBER] =: NUMBER 
\end{verbatim} \normalsize

\bd
Computes the natural logarithm of \verb+x+.  It is an error if
\verb+x+ is nonpositive.
\item [See also:] \verb+Exp+, \verb+Power+.
\ed

\item\lex{LpSolve}
\protect \large \begin{verbatim}
LpSolve[support->NFSUPPORT, {stopAfter->1}, 
        {precision->Machine}, {nPivots<->0}, 
        {time<->0.000000}, {traceFile<->(Output)}, 
        {traceLevel->0}] =: LIST(MIXED) 
LpSolve[support->EFSUPPORT, {asNfg->False}, 
        {stopAfter->1}, {precision->Machine}, 
        {nPivots<->0}, {time<->0.000000}, 
        {traceFile<->(Output)}, {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd
Solves a two-person, constant-sum game for a Nash equilibrium as a linear
program.  For extensive form games, the Koller-Megiddo-Stengel
sequence form is used; games not of perfect recall return the empty
list of solutions.

The behavior of the algorithm may be modified by the following optional
parameters:
\bd
\item
[asNfg:] By default, extensive forms are solved by the sequence form.
By setting this parameter to \verb+True+, each marked subgame of the
extensive form is converted to its corresponding reduced normal form,
solved as a linear program, and the mixed strategy solutions converted back
into behavior profiles.
\item
[stopAfter:] Maximum number of equilibria to find.  
\item
[precision:] Determines the precision of the computation. Default is
machine precision (floating point). 
\item
[nPivots:] Returns the total number of pivots.
\item
[time:] Returns the elapsed time for the operation.
\item
[traceFile:] A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no
output at all.
\ed
\item [See also:] \verb+LcpSolve+.
\ed

%--M--

\item\lex{Manual}
\protect \large \begin{verbatim}
Manual[x->TEXT, {y->(Output)}] =: BOOLEAN 
\end{verbatim} \normalsize

\bd 
Prints the manual entry for the function \verb+x+.  If there is no
entry for \verb+x+, the empty string is returned. The parameter
\verb+y+, which is the null output by default, can be used to print
the manual entry to an output stream.
\item [See also:] \verb+Help+, \verb+HelpVars+.
\ed

\item\lex{MarkSubgame}
\protect \large \begin{verbatim}
MarkSubgame[node->NODE] =: BOOLEAN 
\end{verbatim} \normalsize

\bd
Mark \verb+node+ as being the root of a subgame for use in later computation.
Only nodes which are roots of subgames may be marked.  Returns \verb+True+
if \verb+node+ was marked as a subgame (i.e., if it is the root of a subgame).
\item [See also:] \verb+MarkedSubgame+, \verb+Subgames+,
\verb+UnmarkSubgame+.
\ed


%\item\lex{MarkSubgames}
%\protect \large \begin{verbatim}
%#MarkSubgames[efg->EFG(T)] =: LIST(NODE)
%\end{verbatim} \normalsize

%{\it for} {\tt T = FLOAT, RATIONAL} 

%\bd 
%Marks all the nodes in \verb+efg+ which are roots of subgames.  The
%subgame marking is used in solution computation. Returns a list of the
%marked nodes. 
%\item [See also:] \verb+MarkSubgame+, \verb+Subgames+, \verb+UnmarkSubgame+.
%\ed

\item\lex{MarkedSubgame}
\protect \large \begin{verbatim}
MarkedSubgame[node->NODE] =: BOOLEAN 
\end{verbatim} \normalsize

\bd
Returns \verb+True+ if \verb+node+ is currently marked as a subgame. 
\item [See also:] \verb+MarkSubgame+, \verb+Subgames+, \verb+UnmarkSubgame+.
\ed

%\item\lex{MarkedSubgames}
%\protect \large \begin{verbatim}
%#MarkedSubgames[efg->EFG(T)] =: LIST(NODE)
%\end{verbatim} \normalsize

%{\it for} {\tt T = FLOAT, RATIONAL}
%\bd
%Returns the list of nodes currently marked as roots of subgames in
%\verb+efg+.  
%\item [See also:] \verb+MarkSubgame+, \verb+Subgames+, \verb+UnmarkSubgame+.
%\ed

\item\lex{Members}
\protect \large \begin{verbatim}
Members[infoset->INFOSET*] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd
Returns the list of nodes which are members of \verb+infoset+.  If
\verb+infoset+ is null, the empty list is returned.
\item [See also:] \verb+Infoset+.
\ed

\item\lex{MergeInfosets}
\protect \large \begin{verbatim}
MergeInfosets[infoset1->INFOSET,
              infoset2->INFOSET] =: INFOSET
\end{verbatim}\normalsize

\bd
Moves all the nodes from \verb+infoset2+ into \verb+infoset1+.
It is an error if the number of actions is not the same at the
two information sets, or if the information sets are not from the
same extensive form game.  \verb+infoset1+ is returned.
\item [See also:] \verb+MoveToInfoset+.
\ed

\item 
\protect \large \begin{verbatim}
Minus[x->INTEGER, y->INTEGER] =: INTEGER 
Minus[x->NUMBER, y->NUMBER] =: NUMBER 
Minus[x->MIXED, y->MIXED] =: MIXED 
Minus[x->BEHAV, y->BEHAV] =: BEHAV 
\end{verbatim} \normalsize

\bd
Returns the difference $x - y$.
\item [Short form:] \verb+x - y+
\item [See also:] \verb+Divide+, \verb+Plus+, \verb+Times+.
\ed

\item\lex{Mixed}
\protect \large \begin{verbatim}
Mixed[support->NFSUPPORT] =: MIXED 
\end{verbatim}\normalsize

\bd
Returns a mixed strategy profile over \verb+support+ with equal
probabilites for each strategy in the support.  
\item [See also:] \verb+Behav+, \verb+Centroid+.
\ed

%\item\lex{Mixed}
%\protect \large \begin{verbatim}
%Mixed[profile->BEHAV(T)] =: MIXED(T)
%\end{verbatim}\normalsize

%{\it for} {\tt T = FLOAT, RATIONAL}
%\bd
%Converts \verb+profile+ to the equivalent mixed strategy profile on the
%associated normal form game.  It is an error if there is no associated
%normal form game.
%\item [See also:] \verb+Behav+.
%\ed

\item\lex{Modulus}
\protect \large \begin{verbatim}
Modulus[x->INTEGER, y->INTEGER] =: INTEGER 
\end{verbatim}\normalsize

\bd
Computes the remainder from dividing \verb+y+ into \verb+x+.  It is an
error if \verb+y+ is zero.
\item [Short form:] \verb+x MOD y+
\item [See also:] \verb+IntegerDivide+.
\ed


\item\lex{MoveToInfoset}
\protect \large \begin{verbatim}
MoveToInfoset[node->NODE, infoset->INFOSET] =: NODE 
\end{verbatim}\normalsize

\bd
Removes \verb+node+ from its current information set, and makes it a
member of \verb+infoset+. It is an error if the number of actions at
\verb+node+ is not the same as the number of actions in
\verb+infoset+, or if \verb+node+ and \verb+infoset+ are from
different extensive form games.   
\item [See also:] \verb+MergeInfosets+.
\ed


\item\lex{MoveTree}
\protect \large \begin{verbatim}
MoveTree[from->NODE, to->NODE] =: NODE 
\end{verbatim}\normalsize

\bd
Moves the subtree rooted at \verb+from+ to
the terminal node \verb+to+.  \verb+from+ becomes a terminal node.
Returns \verb+to+.  It is an error if \verb+to+ is not a terminal
node, or if \verb+from+ and \verb+to+ are not from the same extensive
form game.
\item [See also:] \verb+CopyTree+.
\ed

%--N--

\item\lex{Name}
\protect \large \begin{verbatim}
Name[x->T] =: TEXT
\end{verbatim}\normalsize

{\it for} {\tt T = ACTION*, EFG*, EFOUTCOME*, EFPLAYER*, INFOSET*,
NFG*, NFOUTCOME*, NFPLAYER*, NODE*, STRATEGY*} 
\bd
Returns the name of \verb+x+.  The name of a null object is defined
to be the empty string.
\item
[See also:] \verb+SetName+.
\ed

\item\lex{Negate} 
\protect \large \begin{verbatim}
Negate[x->INTEGER] =: INTEGER 
Negate[x->NUMBER] =: NUMBER 
\end{verbatim} \normalsize

\bd
Returns $-x$.
\item
[Short form:] \verb+-x+
\ed

\item\lex{NewEfg}
\protect \large \begin{verbatim} 
NewEfg[{players->{}}] =: EFG 
\end{verbatim}\normalsize

\bd
Creates a new extensive form game.  The default extensive form
game has no players (other than the chance player) defined on it; the
optional parameter \verb+players+ specifies a list of players to be
created and the names to be assigned to them.  Returns the newly created game.
\ed

\item\lex{NewFunction}   
\protect \large \begin{verbatim}
*NewFunction[name[argument-list], body]
\end{verbatim}\normalsize

\bd
Creates a new function.  The function may be called exactly
as if it were a predefined function of the command language.  See the
section on user-defined functions for more detailed information.
\item [Note:]  Special function.  Not listable, cannot be called in a
user defined function; not documented in \verb+Help+ or \verb+Manual+.  
\item [See also:] \verb+DeleteFunction+.
\ed

\item\lex{NewInfoset}
\protect \large \begin{verbatim} 
NewInfoset[player->EFPLAYER, actions->INTEGER] =: INFOSET 
\end{verbatim}\normalsize

\bd
Creates a new information set belonging to \verb+player+, with
\verb+actions+ actions.  It is an error if \verb+actions+ is not
positive.  The newly created information set is returned.
\item [See also:] \verb+DeleteEmptyInfoset+.
\ed

\item\lex{NewNfg}
\protect \large \begin{verbatim}
NewNfg[dim->LIST(INTEGER)] =: NFG 
\end{verbatim}\normalsize

\bd 
Creates a new normal form game with dimensionality \verb+dim+.  No
initialization of the payoffs of the game is done.  Returns the newly
created game.  
\ed

%\item\lex{NewNfg}
%\protect \large \begin{verbatim}
%NewNfg[payoffs->NLIST(T)] =: NFG(T) 
%\end{verbatim}\normalsize

%{\it for} {\tt T = FLOAT, RATIONAL} 
%\bd 
%Creates an \verb+n+ person normal form game from a \verb&n+1&
%dimensional nested list of payoffs.  It is an error if the array of payoffs
%is not rectangular.  Returns the newly created game.
%\item [See also:] \verb+ListForm+
%\ed

\item\lex{NewOutcome}
\protect \large \begin{verbatim} 
NewOutcome[efg->EFG] =: EFOUTCOME 
\end{verbatim}\normalsize


\bd 
Defines a new outcome in the extensive form game \verb+efg+.  The new
outcome specifies payoffs of zero for all players.  Returns the newly
created outcome.
\item [See also:] \verb+DeleteOutcome+, \verb+SetOutcome+.
\ed


\item\lex{NewOutcome}
\protect \large \begin{verbatim} 
NewOutcome[nfg->NFG] =: NFOUTCOME 
\end{verbatim}\normalsize

\bd 
Defines a new outcome in the normal form game \verb+nfg+.  The new
outcome specifies payoffs of zero for all players.  Returns the newly
created outcome.
\item [See also:] \verb+DeleteOutcome+, \verb+Outcomes+,
\verb+SetOutcome+.
\ed


\item\lex{NewPlayer}
\protect \large \begin{verbatim}
NewPlayer[efg->EFG] =: EFPLAYER 
\end{verbatim}\normalsize

\bd 
Defines a new player in the extensive form game \verb+efg+.  Returns
the newly created player.  
\ed

\item\lex{NextSibling}
\protect \large \begin{verbatim}
NextSibling[node->NODE] =: NODE 
\end{verbatim}\normalsize

\bd
Returns the next sibling of \verb+node+.  If \verb+node+ has no next
sibling, the null node is returned.
\item [See also:] \verb+PriorSibling+.
\ed

\item\lex{Nfg}
\protect \large \begin{verbatim}
Nfg[efg->EFG, {time<->0}] =: NFG 
\end{verbatim}\normalsize

\bd
Creates and returns the (structural) reduced normal form game equivalent
to the extensive form game \verb+efg+.  The optional parameter \verb+time+,
if specified, contains upon completion the amount of time consumed by
the transformation.
\item [See also:] \verb+AgentForm+.
\ed

\item\lex{Nodes}
\protect \large \begin{verbatim}
Nodes[efg->EFG] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd
Returns a list of nodes of the extensive form game \verb+efg+.  The
list is in {\it indexed traversal} order.  This is the order that is
imposed by a lexicographic ordering of the nodes when each node is
identified by the sequence of branch numbers taken to reach it.  
\ed

\item\lex{NodeValue}
\protect \large \begin{verbatim}
NodeValue[profile->BEHAV, player->EFPLAYER, node->NODE] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the expected payoff to \verb+player+ at \verb+node+, given
that all players are following \verb+profile+.
\item [See also:] \verb+ActionValue+, \verb+Belief+, \verb+InfosetProb+,
\verb+RealizProb+.
\ed

\item\lex{NodeValues}
\protect \large \begin{verbatim}
NodeValues[profile->BEHAV, player->EFPLAYER] =: LIST(NUMBER) 
\end{verbatim}\normalsize

\bd 
Returns the expected payoff to \verb+player+ at all nodes in the
game, given that all players are following \verb+profile+.  The nodes
are in indexed traversal order.
\item [See also:] \verb+NodeValue+.  
\ed

\item\lex{Not}
\protect \large \begin{verbatim}
Not[x->BOOLEAN] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns the boolean inverse of \verb+x+.
\item [Short forms:] \verb+NOT x+, \verb+!x+.
\item [See also:] \verb+And+, \verb+Or+.
\ed

\item\lex{NotEqual}
\protect \large \begin{verbatim}
NotEqual[x->T, y->T] =: BOOLEAN
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns \verb+True+ when the values of \verb+x+ and \verb+y+ are
not equal.
\item [Short form:] \verb+x != y+.
\item [See also:] \verb+Equal+.
\ed

\item\lex{BthChar}
\protect \large \begin{verbatim}
NthChar[text->TEXT, n->INTEGER] =: TEXT 
\end{verbatim}\normalsize

\bd
Returns a text string of length 1 containing the \verb+n+th
character from \verb+text+.  By convention, the first character
in a string is indexed by 1.  It is an error if \verb+n+ is nonpositive,
or if \verb+n+ is greater than the length of \verb+text+.
\item [Short forms:] \verb+text[[n]]+, \verb+text#n+.
\item [See also:] \verb+NumChars+.
\ed

\item\lex{NthChild}
\protect \large \begin{verbatim} 
NthChild[node->NODE, n->INTEGER] =: NODE 
\end{verbatim}\normalsize

\bd
Returns the \verb+n+th child of \verb+node+.
By convention, the first child of a node is indexed by 1.
It is an error if \verb+n+ is nonpositive, or if \verb+n+ is greater
than the number of children of \verb+node+.
\item [Short form:] \verb+node#n+.
\item [See also:] \verb+Children+.
\ed

\item\lex{NthElement}
\protect \large \begin{verbatim}
NthElement[list<->NLIST(ANYTYPE*), n->INTEGER] =: ANYTYPE 
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns the \verb+n+th element of \verb+list+.
By convention, the first element of a list is indexed by 1.
It is an error if \verb+n+ is nonpositive, or if \verb+n+ is greater
than the number of elements in \verb+list+.
\item [Short form:] \verb+list[[n]]+, \verb+list_n+.
\item [See also:] \verb+Length+.
\ed

\item\lex{Null}
\protect \large \begin{verbatim}
Null[x->ANYTYPE] =: ANYTYPE* 
\end{verbatim}\normalsize

\bd
Returns a null object of type \verb+T+.  
\ed

\item\lex{Number}
\protect \large \begin{verbatim}
Number[x->INTEGER] =: NUMBER 
Number[x->NUMBER] =: NUMBER 
\end{verbatim} \normalsize

\bd
Converts \verb+x+ into a value of type \verb+NUMBER+.
\item [See also:] \verb+Float+, \verb+Number+.
\ed

\item\lex{NumChars}
\protect \large \begin{verbatim}
NumChars[text->TEXT] =: INTEGER 
\end{verbatim}\normalsize

\bd
Returns the number of characters in \verb+text+.
\item [See also:] \verb+NthChar+.
\ed

\item\lex{NumElements}
\protect \large \begin{verbatim}
NumElements[list->LIST(ANYTYPE*)] =: INTEGER 
\end{verbatim}\normalsize

\bd
Returns the number of elements in \verb+list+.  The difference between
this function and \verb+Length+ is that this function is not listable,
while \verb+Length+ is.  
\item
[See also:] \verb+NthChar+, \verb+Length+.
\item
[Note:] This function is not listable. 
\ed




%--O--

\item\lex{Or} 
\protect \large \begin{verbatim}
Or[x->BOOLEAN, y->BOOLEAN] =: BOOLEAN 
\end{verbatim} \normalsize
  
\bd
Returns the disjunction of \verb+x+ and \verb+y+.
\item
[Short form:] \verb+x || y+, \verb+x OR y+.
\item [See also:] \verb+And+, \verb+Or+.
\ed

\item\lex{Outcome}
\protect \large \begin{verbatim}
Outcome[node->NODE*] =: EFOUTCOME 
\end{verbatim}\normalsize

\bd
Returns the outcome attached to \verb+node+.  If no outcome is attached
to \verb+node+, or if \verb+node+ is null, the null outcome is returned.
\item [See also:] \verb+SetOutcome+.
\ed

\item\lex{Outcome}
\protect \large \begin{verbatim}
Outcome[profile->LIST(STRATEGY)] =: NFOUTCOME 
\end{verbatim}\normalsize

\bd
Returns the outcome associated with the contingency specified by
\verb+profile+.
\item [See also:] \verb+SetOutcome+.
\ed

\item\lex{Outcomes}
\protect \large \begin{verbatim}
Outcomes[efg->EFG] =: LIST(EFOUTCOME) 
\end{verbatim}\normalsize

\bd
Returns the list of outcomes defined on \verb+efg+.
\item [See also:] \verb+DeleteOutcome+, \verb+NewOutcome+.
\ed

\item\lex{Outcomes}
\protect \large \begin{verbatim}
Outcomes[nfg->NFG] =: LIST(NFOUTCOME) 
\end{verbatim}\normalsize

\bd
Returns the list of outcomes defined on \verb+nfg+.
\item [See also:] \verb+DeleteOutcome+, \verb+NewOutcome+.
\ed

\item\lex{Output}
\protect \large \begin{verbatim}
Output[file->TEXT, {append->False}] =: OUTPUT 
\end{verbatim}\normalsize

\bd
Opens a new output stream for writing to \verb+file+.  By default,
an existing file is overwritten; specifying \verb+append+ to be \verb+True+
opens the file in append mode.  An error occurs if \verb+file+ is not
able to be opened.
\item [See also:] \verb+Input+, \verb+ListFormat+, \verb+Format+,
\verb+Write+.
\ed

%--P--

\item\lex{Parent}
\protect \large \begin{verbatim}
Parent[node->NODE*] =: NODE 
\end{verbatim}\normalsize

\bd
Returns the parent of \verb+node+.  If \verb+node+ is the root node,
or if \verb+node+ is null, the null node is returned.
\item [See also:] \verb+Children+.
\ed

\item\lex{Parentheses}
\protect \large \begin{verbatim}
Parentheses[x->ANYTYPE] =: ANYTYPE 
\end{verbatim}\normalsize

\bd
Returns the value passed in \verb+x+.  This is used to control
the order of evaluation of expressions.
\item [Short form:] \verb+(x)+
\ed

\item\lex{Payoff}
\protect \large \begin{verbatim}
Payoff[outcome->EFOUTCOME, player->EFPLAYER] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the payoff to \verb+player+ at \verb+outcome+.  It is an error if
\verb+player+ and \verb+outcome+ are not from the same extensive form game.
\item [See also:] \verb+SetPayoff+.
\ed

\item\lex{Payoff}
\protect \large \begin{verbatim}
Payoff[outcome->NFOUTCOME*, player->NFPLAYER] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the payoff to \verb+player+ at \verb+outcome+.  It is an error if
\verb+player+ and \verb+outcome+ are not from the same game.
\item [See also:] \verb+SetPayoff+.
\ed

\item\lex{Payoff}
\protect \large \begin{verbatim}
Payoff[profile->BEHAV, player->EFPLAYER] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the payoff to \verb+player+ in an extensive form game if all
players follow \verb+profile+.  It is an error if \verb+profile+
and \verb+player+ are not from the same extensive form game.
\ed

\item\lex{Payoff}
\protect \large \begin{verbatim}
Payoff[profile->MIXED, player->NFPLAYER] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the payoff to \verb+player+ in a normal form game if all players
follow \verb+profile+.  It is an error if \verb+profile+ and \verb+player+
are not from the same normal form game.
\ed

\item\lex{Platform}
\protect \large \begin{verbatim}
Platform[] =: TEXT 
\end{verbatim} \normalsize

\bd 
Returns a string identifying the platform that the GCL is
currently running on.  Can be used in user defined functions to define
system dependent variables, such as pathnames and command lines for
shell commands.  
\item [See also:] \verb+Shell+.
\ed

\item\lex{Player}
\protect \large \begin{verbatim}
Player[infoset->INFOSET*] =: EFPLAYER 
\end{verbatim}\normalsize

\bd
Returns the player who makes the decision at \verb+infoset+.
If \verb+infoset+ is null, the null player is returned.
\item [See also:] \verb+Infosets+.
\ed

\item\lex{Player}
\protect \large \begin{verbatim}
Player[strategy->STRATEGY*] =: NFPLAYER 
\end{verbatim}\normalsize

\bd
Returns the player to whom the \verb+strategy+ belongs.
If \verb+strategy+ is null, the null player is returned.
\item [See also:] \verb+Strategies+.
\ed

\item\lex{Players}
\protect \large \begin{verbatim}
Players[efg->EFG] =: LIST(EFPLAYER) 
\end{verbatim} \normalsize

\bd
Returns the list of players defined on \verb+efg+.
\ed

\item\lex{Players}
\protect \large \begin{verbatim}
Players[nfg->NFG] =: LIST(NFPLAYER) 
\end{verbatim} \normalsize

\bd
Returns the list of players defined on \verb+nfg+.
\ed

\item\lex{Plus} 
\protect \large \begin{verbatim}
Plus[x->T, y->T] =: T
\end{verbatim} \normalsize

{\it for} {\tt T = NUMBER, INTEGER, MIXED, BEHAV}
\bd
Returns the sum of \verb+x+ and \verb+y+.
\item [Short form:] \verb%x + y%
\item [See also:] \verb+Divide+, \verb+Minus+, \verb+Times+.
\ed

\item\lex{Power}
\protect \large \begin{verbatim}
Power[x->NUMBER, y->NUMBER] =: NUMBER 
\end{verbatim} \normalsize

\bd
Computes the value $x^{y}$.
\item [Short form:] \verb%x ^ y%.
\item [See also:] \verb+Exp+, \verb+Log+.
\ed

\item\lex{Print}
\protect \large \begin{verbatim}
Print[x->ANYTYPE*] =: ANYTYPE 
Print[x->NLIST(ANYTYPE*)] =: NLIST(ANYTYPE) 
\end{verbatim} \normalsize

\bd
Prints \verb+x+ at the console.  When relevant, the output is
formatted according to the current settings determined by the
\verb+Format+ commands.  Returns \verb+x+.  
\item [Short form:] \verb+<< x+.
\item [See also:] \verb+SetVerbose+, \verb+Write+, \verb+ListFormat+, 
\verb+Format+.  
\ed

\item\lex{PriorAction}
\protect \large \begin{verbatim}
PriorAction[node->NODE] =: ACTION 
\end{verbatim} \normalsize

\bd
Returns the action corresponding to the branch leading to \verb+node+.
If \verb+node+ is the root node, its prior action is the null action.
\ed

\item\lex{PriorSibling}
\protect \large \begin{verbatim}
PriorSibling[node->NODE] =: NODE 
\end{verbatim}\normalsize

\bd
Returns the prior sibling of \verb+node+.  If \verb+node+ has
no prior sibling, the null node is returned.
\item [See also:] \verb+NextSibling+.
\ed


%--Q--


\item\lex{Quit}
\protect \large \begin{verbatim}
*Quit
\end{verbatim}\normalsize

\bd
Exits the command language.  
\item [notes:] Special function:  Typed without \verb+[ ]+, not
listable; not documented in \verb+Help+ or \verb+Manual+.  
\ed

%--R--

\item\lex{Randomize}
\protect \large \begin{verbatim}
Randomize[x->INTEGER, {seed->0}] =: INTEGER 
\end{verbatim}\normalsize

\bd 
Returns a random number of type \verb+INTEGER+.  The return value
is uniform between 1 and \verb+MAXINT=214748367+.  
\ed

\item\lex{Read}
\protect \large \begin{verbatim}
Read[input<->INPUT, x<->T] =: INPUT 
\end{verbatim}\normalsize

{\it for} {\tt T = BOOLEAN, INTEGER, NUMBER, TEXT, LIST}
\bd
Reads data of type \verb+T+ from the input stream and assigns it to
\verb+x+.  If \verb+x+ is undefined, an error is generated.  If
\verb+x+ is defined to be a variable of one of the allowable types
\verb+T+ listed above, then the \verb+Read+ function will expect to find the
corresponding data type in the input stream, and a file read error
will be generated if the exposed data is of the wrong data type.  If
\verb+x+ is previously defined to be a \verb+LIST+, then \verb+Read[in,x]+
will successively read elements into each element of the list.  If the
wrong data type is found for any element of the list, a file read
error will be returned.

The ``exposed data'' in the input stream consists of the following: If
first character is a double quote (\verb+"+), then the exposed data
consists of all characters up until the next double quote.  If the
first character is a \verb+{+, then the exposed data consists of all
the characters up until the next matching \verb+}+.  Otherwise, the
exposed data consists of all characters until the next whitespace.
\item [Short form:] \verb+input >> x+
\item [See also:] \verb+Input+, \verb+Write+.
\ed

\item\lex{RealizProbs}
\protect \large \begin{verbatim}
RealizProb[profile->BEHAV, node->NODE] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the realization probability for \verb+node+ given that all players
are following \verb+profile+.  It is an error if \verb+profile+ and
\verb+node+ are not from the same extensive form game.
\item [See also:] \verb+ActionValue+, \verb+Belief+, \verb+InfosetProb+,
\verb+NodeValue+.
\ed

\item\lex{RealizProbs}
\protect \large \begin{verbatim}
RealizProbs[profile->BEHAV] =: LIST(NUMBER) 
\end{verbatim}\normalsize

\bd

Returns a list of the realization probabilities generated by
\verb+profile+ for all nodes in the game tree.  The nodes are in the
same order as returned by \verb+Nodes+.
\item [See also:] \verb+Nodes+, \verb+RealizProb+, 
\ed

\item\lex{Regret}
\protect \large \begin{verbatim}
Regret[profile->BEHAV, action->ACTION] =: NUMBER 
\end{verbatim} \normalsize

\bd
Returns the gain to a player for deviating to \verb+action+, assuming
all players are following \verb+profile+.  The strategy profile is
a Nash equilibrium if and only if the regrets of all actions are zero.
\ed

\item\lex{Regret}
\protect \large \begin{verbatim}
Regret[profile->MIXED, strategy->STRATEGY] =: NUMBER 
\end{verbatim} \normalsize

\bd
Returns the gain to a player for deviating to \verb+strategy+, assuming
all players are following \verb+profile+.  The strategy profile is
a Nash equilibrium if and only if the regrets of all strategies are
identically zero.
\ed

\item\lex{Regrets}
\protect \large \begin{verbatim}
Regrets[profile->BEHAV] =: LIST(LIST(LIST(NUMBER))) 
\end{verbatim} \normalsize

\bd
Returns a nested list of the regrets generated for each action by
\verb+profile+.  The \verb+(i,j,k)+th entry is the regret for player
\verb+i+, infoset \verb+j+, action \verb+k+.
\ed

\item\lex{Regrets}
\protect \large \begin{verbatim}
Regrets[profile->MIXED] =: LIST(LIST(NUMBER)) 
\end{verbatim} \normalsize

\bd
Returns a nested list of the regrets generated for each strategy by
\verb+profile+.  The \verb+(i,j)+th entry is the regret for player
\verb+i+, strategy \verb+j+.
\ed

\item\lex{Remove}
\protect \large \begin{verbatim}
Remove[list->NLIST(ANYTYPE), n->INTEGER] =: LIST(ANYTYPE) 
\end{verbatim}\normalsize

\bd
Removes the \verb+n+th element from \verb+list+.  A copy of the list
with the element removed is returned.  It is an error if \verb+n+
is nonpositive, or if \verb+n+ is greater than the length of \verb+list+.
\item [See also:] \verb+Insert+.
\ed

\item\lex{RemoveAction}
\protect \large \begin{verbatim}
RemoveAction[support->EFSUPPORT, action->ACTION] =: EFSUPPORT 
\end{verbatim}\normalsize

\bd
Removes \verb+action+ from \verb+support+.  If \verb+action+ is
not in \verb+support+, there is no effect.  A copy of the modified
support is returned.  It is an error if \verb+support+ and \verb+action+
are not from the same extensive form game, or if removing \verb+action+
would result in the support containing no actions at an information set.
\item [See also:] \verb+AddAction+, \verb+Support+.
\ed

\item\lex{RemoveStrategy}
\protect \large \begin{verbatim}
RemoveStrategy[support->NFSUPPORT, strategy->STRATEGY] =: NFSUPPORT 
\end{verbatim}\normalsize

\bd
Removes \verb+strategy+ from \verb+support+.  If \verb+strategy+ is not in
the support, there is no effect.  A copy of the modified support is
returned.  It is an error if \verb+support+ and \verb+strategy+ are
not from the same normal form game, or if removing \verb+strategy+
would result in the support containing no strategies for a player.
\item [See also:] \verb+AddStrategy+, \verb+Support+.
\ed

\item\lex{Reveal}
\protect \large \begin{verbatim}
Reveal[infoset->INFOSET, who->LIST(EFPLAYER)] =: INFOSET 
\end{verbatim}\normalsize

\bd
Reveals the list of actions at \verb+infoset+ to the players in \verb+who+,
refining their information partitions at
all information sets in the extensive form game accordingly.  
\ed

\item\lex{RootNode}
\protect \large \begin{verbatim}
RootNode[efg->EFG] =: NODE 
\end{verbatim}\normalsize

\bd
Returns the root node of \verb+efg+.
\ed

%--S--

\item\lex{SaveEfg}
\protect \large \begin{verbatim}
SaveEfg[efg->EFG, file->TEXT] =: EFG 
\end{verbatim}\normalsize

\bd
Writes \verb+efg+ to an external savefile \verb+file+.  It is an error
if \verb+file+ cannot be opened for writing.  Returns \verb+efg+.
\item [See also:] \verb+LoadEfg+.
\ed

\item\lex{SaveGlobalVar}
\protect \large \begin{verbatim}
SaveGlobalVar[name->TEXT, var->ANYTYPE] =: ANYTYPE
\end{verbatim}\normalsize

\bd
Saves the variable \verb+var+ in memory.  The name \verb+name+ is a
text string to identify it so it can later be retrieved with
\verb+LoadGlobalVar+.  Variables saved with this function can be
retreived outside of the function in which they are saved.  So this
function can be used to create variables that are shared in common by
user defined functions.   
\item [See also:] \verb+LoadGlobalVar+, \verb+SaveLocalVar+.
\ed

\item\lex{SaveLocalVar}
\protect \large \begin{verbatim}
SaveLocalVar[name->TEXT, var->ANYTYPE] =: ANYTYPE
\end{verbatim}\normalsize

\bd
Saves the variable \verb+var+ in memory.  The name \verb+name+ is a
text string to identify it so it can later be retrieved with
\verb+LoadLocalVar+.  Variables saved with this function can only be
retrieved in the scope in which they are saved.  So this function can
be used to create ``static'' variables within a user defined function.   
\item [See also:] \verb+LoadLocalVar+, \verb+SaveGlobalVar+.
\ed

\item\lex{SaveNfg}
\protect \large \begin{verbatim}
SaveNfg[nfg->NFG, file->TEXT] =: NFG 
\end{verbatim}\normalsize

\bd
Writes \verb+nfg+ to an external savefile \verb+file+.  It is an
error if \verb+file+ cannot be opened for writing.  Returns \verb+nfg+.
\item [See also:] \verb+LoadNfg+.
\ed

\item\lex{SetActionProbs}
\protect \large \begin{verbatim} 
SetActionProbs[profile<->BEHAV, infoset->INFOSET, 
               value->LIST(NUMBER)] =: BEHAV 
\end{verbatim}\normalsize

\bd
Sets the components of \verb+profile+ for
information set \verb+infoset+ to be equal to \verb+values+.
Returns \verb+profile+.  It is an error if \verb+profile+ and \verb+infoset+
are not from the same extensive form game, or if the length of
\verb+value+ is not the same as the number of actions in \verb+profile+'s
support at \verb+infoset+.
\item [See also:] \verb+ActionProb+.
\ed

\item\lex{SetChanceProbs}
\protect \large \begin{verbatim} 
SetChanceProbs[infoset->INFOSET, 
               probs->LIST(NUMBER)] =: INFOSET 
\end{verbatim}\normalsize

\bd
Sets the action probabilities for 
\verb+infoset+ to the values given in \verb+probs+.  Returns \verb+infoset+. 
An error occurs if \verb+infoset+ does not belong to the chance player.
\item [See also:] \verb+ChanceProb+.
\ed

\item\lex{SetEnv}
\protect \large \begin{verbatim}
SetEnv[name->TEXT, value->TEXT] =: BOOLEAN 
\end{verbatim} \normalsize

\bd
Sets the environment variable \verb+name+.
\item [See also:] \verb+GetEnv+, \verb+UnSetEnv+.
\ed

\item\lex{SetName}
\protect \large \begin{verbatim}
SetName[x->T, name->TEXT] =: T
\end{verbatim}\normalsize

{\it for} {\tt T = ACTION, EFG, EFPLAYER, INFOSET, NFG, NFOUTCOME, 
NFPLAYER, NODE, EFOUTCOME, STRATEGY}
\bd
Sets the name of \verb+x+ to \verb+name+.  Returns \verb+x+.
\item [See also:] \verb+Name+.
\ed

\item\lex{SetOutcome}
\protect \large \begin{verbatim} 
SetOutcome[node->NODE, outcome->EFOUTCOME*] =: EFOUTCOME 
\end{verbatim}\normalsize

\bd
Attaches \verb+outcome+ to \verb+node+.  Returns the outcome attached.
Note that nonterminal nodes may have outcomes attached; the interpretation
is that nonterminal outcomes represent incremental payoffs.  
It is an error if \verb+node+ and \verb+outcome+ are not from the same
extensive form game.
\item [See also:] \verb+Outcome+.
\ed

\item\lex{SetOutcome}
\protect \large \begin{verbatim} 
SetOutcome[profile->LIST(STRATEGY), outcome->NFOUTCOME] =: NFOUTCOME 
\end{verbatim}\normalsize

\bd 
Attaches \verb+outcome+ to the cell in the normal form game
determined by the pure strategy profile defined by \verb+profile+.
Returns the outcome attached.  It is an error if \verb+profile+ and
\verb+outcome+ are not from the same normal form game. Also,
\verb+profile+ must be a list of strategies consisting of one strategy
for each player in the game.  
\item [See also:] \verb+Outcome+.
\ed

\item\lex{SetPayoff}
\protect \large \begin{verbatim}
SetPayoff[outcome->EFOUTCOME, player->EFPLAYER, payoff->NUMBER] =: EFOUTCOME 
\end{verbatim}\normalsize

\bd
Sets the payoff of \verb+outcome+ for \verb+player+ to \verb+payoff+.
It is an error if \verb+outcome+ and \verb+player+ are not from the
same extensive form game.  Returns \verb+outcome+.
\item [See also:] \verb+Payoff+.
\ed

\item\lex{SetPayoff}
\protect \large \begin{verbatim}
SetPayoff[outcome->NFOUTCOME, player->NFPLAYER, 
          payoff->NUMBER] =: NFOUTCOME 
\end{verbatim}\normalsize

\bd
Sets the payoff of \verb+outcome+ for \verb+player+ to \verb+payoff+.
It is an error if \verb+outcome+ and \verb+player+ are not from \verb+nfg+.
Returns \verb+outcome+.
\item [See also:] \verb+Payoff+.
\ed

\item\lex{SetStrategyProbs} 
\protect \large \begin{verbatim}
SetStrategyProbs[profile<->MIXED, player->NFPLAYER, 
                 value->LIST(NUMBER)] =: MIXED 
\end{verbatim} \normalsize

\bd
Sets the components of \verb+profile+ for \verb+player+ to be equal
to \verb+value+.  It is an error if \verb+profile+ and \verb+player+
are not from the same normal form game, or if the length of \verb+value+
is not the same as the number of strategies for \verb+player+ in the
support of \verb+profile+.  Returns \verb+profile+.
\item [See also:] \verb+StrategyProb+.
\ed

\item\lex{Shell}
\protect \large \begin{verbatim}
Shell[{command->}, {spawn->True}] =: INTEGER 
\end{verbatim} \normalsize

\bd
Runs a child process.  
\bd
\item [command:] A text string to be executed by the shell.  
\item [spawn:] Specifies whether to run in the foreground or
background.  Default is to run in the background.  
\ed
\item [See also:] \verb+Platform+.
\ed

\item\lex{SimpDivSolve}
\protect \large \begin{verbatim}
SimpDivSolve[support->NFSUPPORT, {stopAfter->1}, 
             {nRestarts->1}, {leashLength->0}, 
             {precision->Machine}, {nEvals<->0}, 
             {time<->0.000000}, {traceFile<->(Output)}, 
             {traceLevel->0}] =: LIST(MIXED) 
SimpDivSolve[support->EFSUPPORT, {asNfg->False}, 
             {stopAfter->1}, {nRestarts->1}, {leashLength->0}, 
             {precision->Machine}, {nEvals<->0}, 
             {time<->0.000000}, {traceFile<->(Output)}, 
             {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd
Computes a Nash equilibrium for a game using a simplicial subdivision
algorithm. 

The behavior of the algorithm may be modified by several optional
parameters:

\bd
\item
[asNfg:] By default, this is \verb+False+.  If it is specified to be
\verb+True+, the extensive form game is solved by recursively converting
its marked subgames into normal form, solving, and reconstructing the
solution as a behavior profile.  {\it Note that currently simplicial
subdivision is only supported on the normal form, so this parameter
must always be specified and {\tt True}.}
\item
[stopAfter:] Maximum number of equilibria to find. Default is 1.  
\item
[precision:] Determines the precision of the computation. Default is
machine precision (floating point). 
\item 
[nRestarts:] Number of restarts.  At each restart the mesh of the
triangulation is halved.  So this parameter determines the final mesh
by the formula $\frac{1}{2}^{ndivs}$.
\item
[leashLength:] Sets the leash length. Default is 0, which results in no
constraint, or no leash.  Note that if this parameter is set to a value
different from 0, the algorithm is no longer guaranteed to converge.
\item
[time:] Returns the elapsed time for the algorithm.
\item
[traceFile:] A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to
no output at all.
\ed
\ed

\item\lex{Sort}
\protect \large \begin{verbatim}
Sort[x->LIST(T)] =: LIST(T)
\end{verbatim} \normalsize

{\it for} {\tt T = INTEGER, NUMBER, TEXT}
\bd
Returns a list consisting of the elements of \verb+x+ sorted in
increasing order.
\ed

\item\lex{Sort}
\protect \large \begin{verbatim}
Sort[x->LIST(T), by->LIST(X)] =: LIST(T)
\end{verbatim} \normalsize

{\it for all types} {\tt T}, {\it for} {\tt X = INTEGER, NUMBER,
TEXT}
\bd
Returns a list consisting of the elements of \verb+list+, sorted
according to the ordering of the elements of \verb+by+.  It is an
error if \verb+list+ and \verb+by+ do not have the same dimensionality.
\ed

\item\lex{StartWatch}
\protect \large \begin{verbatim}
StartWatch[] =: NUMBER 
\end{verbatim}\normalsize

\bd
Starts the system stopwatch.  This function has no
effect if the stopwatch is already running.
Returns the amount of time since the stopwatch was started.
\item [See also:] \verb+ElapsedTime+, \verb+IsWatchRunning+, \verb+StopWatch+.
\ed

\item\lex{StopWatch}
\protect \large \begin{verbatim}
StopWatch[] =: NUMBER 
\end{verbatim}\normalsize

\bd
Stops the system stopwatch.  If the stopwatch was not
running, this function has no effect.  Returns the amount of time
on the stopwatch.
\item [See also:] \verb+ElapsedTime+, \verb+IsWatchRunning+,
\verb+StartWatch+.
\ed

\item\lex{Strategies}
\protect \large \begin{verbatim}
Strategies[player->NFPLAYER, support->NFSUPPORT] =: LIST(STRATEGY) 
\end{verbatim}\normalsize

\bd
Returns the list of strategies from which  \verb+player+ may choose
in \verb+support+.
\item [See also:] \verb+Player+. 
\ed

\item\lex{StrategyProb}
\protect \large \begin{verbatim}
StrategyProb[profile->MIXED, strategy->STRATEGY] =: NUMBER 
\end{verbatim} \normalsize

\bd
Returns the probability that \verb+strategy+ is chosen when all
players are following \verb+profile+.  It is an error if \verb+profile+
and \verb+strategy+ are not from the same normal form game.
\item [See also:] \verb+SetStrategyProbs+.
\ed

\item\lex{StrategyProbs}
\protect \large \begin{verbatim}
StrategyProbs[profile->MIXED] =: LIST(LIST(NUMBER)) 
\end{verbatim} \normalsize

\bd
Returns a nested list of the probabilities for each strategy under
\verb+profile+.  The \verb+(i,j)+th entry is the probability of player
\verb+i= adopting strategy \verb+j+.
\item [See also:] \verb+StrategyProb+, \verb+SetStrategyProbs+.
\ed

\item\lex{StrategyValue}
\protect \large \begin{verbatim}
StrategyValue[profile->MIXED, strategy->STRATEGY] =: NUMBER 
\end{verbatim}\normalsize

\bd 
Returns the expected payoff to a player (who is in control of the
strategy set including \verb+strategy+) of choosing \verb+strategy+ when
all players are following \verb+profile+.  It is an error if
\verb+profile+ and \verb+strategy+ are not from the same normal form
game.

\item [See also:] \verb+StrategyProb+. 
\ed

\item\lex{Subgames}
\protect \large \begin{verbatim}
Subgames[efg->EFG] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd
Returns the list of nodes which are roots of subgames in \verb+efg+.
The ordering of the list is such that
all children of a node are listed before the node.
\item [See also:] \verb+MarkSubgame+, \verb+MarkedSubgames+, 
\verb+UnmarkSubgame+.
\ed

\item\lex{Support}
\protect \large \begin{verbatim}
Support[efg->EFG] =: EFSUPPORT 
\end{verbatim}\normalsize

\bd
Returns the support of \verb+efg+.  The support contains all actions at every
information set for all players.
\item [See also:] \verb+AddAction+, \verb+RemoveAction+.
\ed

\item\lex{Support}
\protect \large \begin{verbatim}
Support[nfg->NFG] =: NFSUPPORT 
\end{verbatim}\normalsize

\bd
Returns the support of \verb+nfg+.  The support contains all strategies
for all players.
\item [See also:] \verb+AddStrategy+, \verb+RemoveStrategy+.
\ed

\item\lex{Support}
\protect \large \begin{verbatim}
Support[profile->BEHAV] =: EFSUPPORT 
Support[profile->MIXED] =: NFSUPPORT 
\end{verbatim}\normalsize

\bd
Returns the support on which \verb+profile+ is defined.
\item [See also:] \verb+Behav+, \verb+Mixed+.
\ed

%--T--

\item\lex{Text}
\protect \large \begin{verbatim}
Text[x->INTEGER] =: TEXT 
Text[x->NUMBER] =: TEXT 
Text[x->TEXT] =: TEXT 
\end{verbatim} \normalsize

\bd
Converts \verb+x+ into a text string.
\ed

\item\lex{Times} 
\protect \large \begin{verbatim}
Times[x->INTEGER, y->INTEGER] =: INTEGER 
Times[x->NUMBER, y->NUMBER] =: NUMBER 
\end{verbatim} \normalsize

\bd
Computes the product of \verb+x+ and \verb+y+.
\item [Short form:] \verb+x * y+.
\item [See also:] \verb+Divide+, \verb+Minus+, \verb+Plus+.
\ed

\item\lex{Times}
\protect \large \begin{verbatim}
Times[x->NUMBER, y->MIXED] =: MIXED 
Times[x->NUMBER, y->BEHAV] =: BEHAV 
\end{verbatim} \normalsize

\bd
Computes the product of \verb+x+ and \verb+y+.
\item [Short form:] \verb+x * y+.
\item [See also:] \verb+Minus+, \verb+Plus+.
\ed

\item\lex{Transpose}
\protect \large \begin{verbatim} 
Transpose[x->LIST(LIST(ANYTYPE))] =: LIST(LIST(ANYTYPE)) 
\end{verbatim}\normalsize

\bd
Returns the transpose of a rectangular matrix.  It is an error if \verb+list+
is not rectangular.
\ed


%--U--

\item\lex{Unassign}
\protect \large \begin{verbatim}
UnAssign[name->TEXT] =: BOOLEAN
\end{verbatim}\normalsize

\bd
Undefines the variable with name \verb+name+.  Returns 
\verb+True+ if the variable was defined, and \verb+False+ if the
variable was not defined, at the time of the call.
\item [Short form:] \verb+x :=
\item [Note:] For the short form, quotes around \verb+name+ are not
required, and the function is not listable.
\item [See also:] \verb+Assign+, \verb+Clear+.
\ed

\item\lex{UnmarkSubgame}
\protect \large \begin{verbatim}
UnmarkSubgame[node->NODE] =: NODE 
\end{verbatim}\normalsize

\bd
Unmark \verb+node+ as being the root of a subgame for use in later
computation.  If \verb+node+ is not marked as a subgame root, or if
\verb+node+ is the root node, this function has no effect.  Returns
the \verb+node+.
\item [See also:] \verb+MarkSubgame+, \verb+MarkedSubgames+,
\verb+Subgames+.
\ed

%\item\lex{UnmarkSubgames}
%\protect \large \begin{verbatim}
%#UnmarkSubgames[efg<->EFG] =: LIST(NODE) 
%\end{verbatim}\normalsize

%\bd 
%Unmarks all non trivial subgames in \verb+efg+.  Returns a list of
%roots of currently marked subgames, which will be a singleton list
%containing the root node of \verb+efg+ if the function is successful.
%\item [See also:] \verb+MarkSubgame+, \verb+MarkedSubgames+,
%\verb+Subgames+.
%\ed

\item\lex{UnSetEnv}
\protect \large \begin{verbatim}
UnSetEnv[name->TEXT] =: BOOLEAN 
\end{verbatim} \normalsize

\bd
Un sets the environment variable \verb+name+.
\item [See also:] \verb+SetEnv+, \verb+GetEnv+.
\ed

%--V--

\item\lex{Version}
\protect \large \begin{verbatim}
Version[] =: NUMBER 
\end{verbatim} \normalsize

\bd
Returns the version number of the command language.
\ed

%--W--

\item\lex{While} 
\protect \large \begin{verbatim}
*While[boolean-expression, statement-list]
\end{verbatim} \normalsize
  
\bd
Defines a block of statements to be executed repeatedly.
See the section on control structures for complete information.
\item [Note:] Special function.  Not listable; arguments are not GCl
data types; not documented in \verb+Help+ or \verb+Manual+.  
\item
[See also:] \verb+For+.
\ed

\item\lex{Write}
\protect \large \begin{verbatim}
Write[output<->OUTPUT, x->T] =: OUTPUT  
\end{verbatim}\normalsize

{\it for} {\tt T = BEHAV, BOOLEAN, EFG, EFSUPPORT, INTEGER,
NFG, NFSUPPORT, MIXED, NUMBER, STRATEGY, TEXT, LIST}
\bd
Does a formatted write of \verb+x+ to \verb+output+.
\item [Short form:] \verb+output << x+
\item [See also:] \verb+Output+, \verb+Read+, \verb+ListFormat+,
\verb+Format+.
\ed

%--X--

%--Y--

%--Z--

\end{itemize}

\section{Standard User Defined Functions}
\renewcommand{\mysectionname}{\thesection\,\, USER DEFINED FUNCTIONS}

The functions listed in this section are user defined functions that
are provided in the file \verb+stdudfs.gcl+.  For each function, the
function prototype is followed first by a brief description of what
the function does, and then by the body of the function.  

\begin{itemize}

%--A--

\item\lex{ActionNumber}
\protect \large \begin{verbatim}
ActionNumber[a->ACTION] =: INTEGER 
\end{verbatim}\normalsize

\bd 
Returns the action number of \verb+a+.
\begin{verbatim}
Index[Actions[Infoset[a]],a]_1
\end{verbatim} 
\ed

\item\lex{Actions}
\protect \large \begin{verbatim}
Actions[infoset->INFOSET] =: LIST(ACTION) 
\end{verbatim}\normalsize

\bd 
Returns a list of all actions in \verb+infoset+.

\begin{verbatim}
Actions[infoset,Support[Game[infoset]]]
\end{verbatim} 
\ed

\item\lex{Actions}
\protect \large \begin{verbatim}
Actions[efg->EFG] =: LIST(LIST(LIST(ACTION))) 
\end{verbatim}\normalsize

\bd 
Returns a nested list of actions in the game, whose  \verb+(i,j,k)+
entry is action \verb+k+ in information set \verb+j+ of player \verb+i+.

\begin{verbatim}
Actions[Infosets[Players[efg]]]
\end{verbatim} 
\ed

\item\lex{Actions}
\protect \large \begin{verbatim}
Actions[s->EFSUPPORT] =: LIST(LIST(LIST(ACTION))) 
\end{verbatim}\normalsize

\bd 

A nested list of actions for the support \verb+s+ in the extensive
form game.

\begin{verbatim}
Actions[Infosets[Game[s]],s]
\end{verbatim} 
\ed

\item\lex{AddMove}
\protect \large \begin{verbatim}
AddMove[i->INFOSET, a->ACTION] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd 
Adds a move determined by infoset \verb+i+ to all nodes with prior
action \verb+a+.  
\begin{verbatim}
AddMove[i,Filter[n:=Nodes[Game[i]],PriorAction[n]=a]]
\end{verbatim} 
\ed

\item\lex{AllActions}
\protect \large \begin{verbatim}
AllActions[efg->EFG] =: LIST(LIST(LIST(ACTION))) 
\end{verbatim}\normalsize

\bd 
Gives a nested list of all actions in the game, including those of
the chance player.  
\begin{verbatim}
Actions[AllInfosets[efg]]
\end{verbatim} 
\ed

\item\lex{AllInfosets}
\protect \large \begin{verbatim}
AllInfosets[efg->EFG] =: LIST(LIST(INFOSET)) 
\end{verbatim}\normalsize

\bd 
Gives a nested list of all actions in the game, including those for
chance. 
\begin{verbatim}
Infosets[{Chance[efg]}&Players[efg]]
\end{verbatim} 
\ed

\item\lex{AllNash}
\protect \large \begin{verbatim}
AllNash[e->EFG, {stopAfter->0}, {nTries->0}, 
        {precision->Machine}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
Searches for all Nash equilibria of the extensive form game
\verb+e+.  Returns a list containing the equilibria found.

\begin{verbatim}
ms:=MarkedSubgames[e];UnmarkSubgames[e];
s:=ElimAllDom[Nfg[e],strong->True];
If[NumPlayers[e] = 2, 
  m:=EnumMixedSolve[s,0,precision],
  << InfiniteLoopWarning[stopAfter,nTries];
  m:=LiapSolve[Centroid[s],stopAfter,nTries]
];
MarkSubgames[ms];Behav[m]
\end{verbatim} 
\ed

\item\lex{AllNash}
\protect \large \begin{verbatim}
AllNash[n->NFG, {stopAfter->0}, {nTries->0}, 
        {precision->Machine}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
Searches for all Nash equilibria of the normal form game
\verb+n+.  Returns a list containing the equilibria found.

\begin{verbatim}
s:=ElimAllDom[n,strong->True];
If[NumPlayers[n] = 2, 
  EnumMixedSolve[s,0,precision],
  << InfiniteLoopWarning[stopAfter,nTries];
  LiapSolve[Centroid[s],stopAfter,nTries]
]
\end{verbatim} 
\ed

\item\lex{AllMembers}
\protect \large \begin{verbatim}
AllMembers[efg->EFG] =: LIST(LIST(LIST(NODE))) 
\end{verbatim}\normalsize

\bd 
Returns a list of all member nodes of information sets, including
those of the chance player.
\begin{verbatim}
Members[AllInfosets[efg]]
\end{verbatim} 
\ed

\item\lex{AllPerfect}
\protect \large \begin{verbatim}
AllPerfect[n->NFG, {stopAfter->0}, {nTries->0}, 
           {precision->Machine}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
Searches for all Perfect Nash equilibria of the normal form game
\verb+n+.  Returns a list containing the equilibria found.

\begin{verbatim}
s:=ElimAllDom[n,strong->True];
If[NumPlayers[n] = 2, 
  << " Warning: may not find all";
  LcpSolve[s,0,precision],
  << " Not implemented for n-person games";
  List[Centroid[Support[n]],0]
]
\end{verbatim} 
\ed

\item\lex{AllSequential}
\protect \large \begin{verbatim}
AllSequential[e->EFG, {stopAfter->0}, {nTries->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
Searches for all sequential Nash equilibria of the extensive form
game \verb+e+.  Returns a list containing the equilibria found.

\begin{verbatim}
ms:=MarkedSubgames[e];UnmarkSubgames[e];
<< InfiniteLoopWarning[stopAfter,nTries];
b:=LiapSolve[e,stopAfter->stopAfter,nTries->nTries];
MarkSubgames[ms];b
\end{verbatim} 
\ed

\item\lex{AllSubgamePerfect}
\protect \large \begin{verbatim}
AllSubgamePerfect[e->EFG, {stopAfter->0}, {nTries->0}, 
                  {precision->Machine}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
Searches for all subgame perfect Nash equilibria of the extensive
form game \verb+e+.  Returns a list containing the equilibria found.

\begin{verbatim}
ms:=MarkedSubgames[e];MarkSubgames[e];
If[NumPlayers[e] = 2, 
  b:=EnumMixedSolve[e,True,0,precision],
  << InfiniteLoopWarning[stopAfter,nTries];
  b:=LiapSolve[e,asNfg->True,stopAfter->stopAfter,nTries->nTries]
];
MarkSubgames[ms];b
\end{verbatim} 
\ed

\item\lex{Ancestors}
\protect \large \begin{verbatim}
Ancestors[n->NODE] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd 
Returns a nested list of the nodes in the tree following a given one.  
\begin{verbatim}
If[IsRoot[n],{n},Flatten[{Ancestors[Parent[n]]}&{n}]]
\end{verbatim} 
\ed


%--B--

\item\lex{Behav}
\protect \large \begin{verbatim}
Behav[efg->EFG, list->LIST(LIST(LIST(NUMBER)))] =: BEHAV 
\end{verbatim}\normalsize

\bd 
Converts a nested list of numbers into a Behavior strategy
profile for the game \verb+efg+.
\begin{verbatim}
Behav[Support[efg],list]
\end{verbatim} 
\ed

%--C--

\item\lex{CartesianProd}
\protect \large \begin{verbatim}
CartesianProd[l->LIST(LIST(ANYTYPE))] =: LIST(LIST(ANYTYPE)) 
\end{verbatim}\normalsize

\bd 
Constructs the cartesian product of a set of sets.  
\begin{verbatim}
If[NumElements[l]=1,
  Prepend[l_1,{}],
  r:={};i:=1;
  l1:=l_1;
  l2:=CartesianProd[Remove[l,1]];
  While[i<=Length[l1], r:=r&{Prepend[l1_i,l2]};i:=i+1];
  r
]
\end{verbatim} 
\ed
	

\item\lex{Centroid}
\protect \large \begin{verbatim}
Centroid[efg->EFG] =: BEHAV 
\end{verbatim}\normalsize

\bd 
Returns the centroid of an extensive form game.  
\begin{verbatim}
Behav[Support[efg]]
\end{verbatim} 
\ed

\item\lex{Centroid}
\protect \large \begin{verbatim}
Centroid[nfg->NFG] =: MIXED 
\end{verbatim}\normalsize

\bd 
Returns the centroid of a normal form game.  
\begin{verbatim}
Mixed[Support[nfg]]
\end{verbatim} 
\ed

\item\lex{Centroid}
\protect \large \begin{verbatim}
Centroid[s->EFSUPPORT] =: BEHAV 
\end{verbatim}\normalsize

\bd 
Returns the centroid of the support \verb+s+ of an extensive form game.  
\begin{verbatim}
Behav[s]
\end{verbatim} 
\ed

\item\lex{Centroid}
\protect \large \begin{verbatim}
Centroid[s->NFSUPPORT] =: MIXED 
\end{verbatim}\normalsize

\bd 
Returns the centroid of the support \verb+n+ of a normal form game.  
\begin{verbatim}
Mixed[s]
\end{verbatim} 
\ed

\item\lex{Concat}
\protect \large \begin{verbatim}
Concat[list->LIST(TEXT)]=:TEXT
\end{verbatim}\normalsize

\bd 
Concatenates all of the elements of \verb+list+
\begin{verbatim}
If[Length[list]=1,list_1,list_1&Concat[Remove[list,1]]];
\end{verbatim} 
\ed


%--D--

\item\lex{DeleteEmptyInfosets}
\protect \large \begin{verbatim}
DeleteEmptyInfosets[efg->EFG] =: LIST(BOOLEAN) 
\end{verbatim}\normalsize

\bd 
Deletes all empty information sets in a game.  
\begin{verbatim}
DeleteEmptyInfoset[Filter[i:=Infosets[efg],NumMembers[i]=0]]
\end{verbatim} 
\ed

\item\lex{Descendants}
\protect \large \begin{verbatim}
Descendants[n->NODE] =: NLIST(NODE) 
\end{verbatim}\normalsize

\bd 
Gives a nested list of the nodes following \verb+n+.
\begin{verbatim}
{n}&Descendants[Children[n]]
\end{verbatim} 
\item[Note:] The above version is very slow on large games.
\ed

\item\lex{Dimensions}
\protect \large \begin{verbatim}
Dimensions[x->NLIST(ANYTYPE)] =: LIST(INTEGER) 
\end{verbatim}\normalsize

\bd 
Gives the dimensions of a nested rectangular list. 
\begin{verbatim}
//*  Note:  x is assumed rectangular
l:=Length[x];
If[IsList[l],{NumElements[x]}&Dimensions[x_1],{l}]
\end{verbatim} 
\ed


\item\lex{Display}
\protect \large \begin{verbatim}
Display[e->EFG] =: INTEGER 
\end{verbatim}\normalsize

\bd 
Runs a child process to display the game \verb+e+ in the Gambit GUI. 
\begin{verbatim}
SaveEfg[e,"junk.efg"];
Shell[GambitExe[]&" junk.efg"]
\end{verbatim} 
\ed

\item\lex{Display}
\protect \large \begin{verbatim}
Display[n->NFG] =: INTEGER 
\end{verbatim}\normalsize

\bd 
Runs a child process to display the game \verb+n+ in the Gambit GUI. 
\begin{verbatim}
SaveNfg[n,"junk.nfg"];
Shell[GambitExe[]&" junk.nfg"]
\end{verbatim} 
\ed

%--E--

\item\lex{ElimAllDom}
\protect \large \begin{verbatim}
ElimAllDom[nfg->NFG, {strong->False}, {mixed->False}, 
           {time<->0.000000}, {traceFile<->(Output)}, 
           {traceLevel->0}] =: NFSUPPORT 
\end{verbatim}\normalsize

\bd 
Successively eliminates dominated strategies in \verb+nfg+.  See
\verb+ElimDom+ for description of parameters.  
\begin{verbatim}
s:=Support[nfg];
While[s!=(ss:=ElimDom[s,strong,mixed,time,traceFile,traceLevel]),
  s:=ss
];
s;
\end{verbatim} 
\ed

\item\lex{ElimAllDom}
\protect \large \begin{verbatim}
ElimAllDom[efg->EFG, {strong->False}, {mixed->False}, 
           {time<->0.000000}, {traceFile<->(Output)}, 
           {traceLevel->0}] =: EFSUPPORT 
\end{verbatim}\normalsize

\bd 
Successively eliminates dominated strategies in \verb+nfg+. See
\verb+ElimDom+ for description of parameters.  
\begin{verbatim}
s:=Support[efg];
While[s!=(ss:=ElimDom[s,strong,mixed,time,traceFile,traceLevel]),
  s:=ss
];
s;
\end{verbatim} 
\ed

\item\lex{ElimDom}
\protect \large \begin{verbatim}
ElimDom[nfg->NFG, {strong->False}, {mixed->False}, 
        {time<->0.000000}, {traceFile<->(Output)}, 
        {traceLevel->0}] =: NFSUPPORT 
\end{verbatim}\normalsize

\bd 
A version of \verb+ElimDom+ that takes a normal form game instead
of a support.  See the built-in function, \verb+ElimDom+ for a
description of the parameters.
\begin{verbatim}
ElimDom[Support[nfg],strong,mixed,time,traceFile,traceLevel]
\end{verbatim} 
\ed

\item\lex{ElimDom}
\protect \large \begin{verbatim}
ElimDom[efg->EFG, {strong->False}, {mixed->False}, 
        {time<->0.000000}, {traceFile<->(Output)}, 
        {traceLevel->0}] =: EFSUPPORT 
\end{verbatim}\normalsize

\bd 
A version of \verb+ElimDom+ that takes an extensive form game instead
of a support.  See the built-in function, \verb+ElimDom+ for a
description of the parameters.
\begin{verbatim}
ElimDom[Support[efg],strong,mixed,time,traceFile,traceLevel]
\end{verbatim} 
\ed

\item\lex{EnumMixedSolve}
\protect \large \begin{verbatim}
EnumMixedSolve[nfg->NFG, {stopAfter->0}, {precision->Machine}, 
               {nPivots<->0}, {time<->0.000000}, 
               {traceFile<->(Output)}, 
               {traceLevel->0}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
A version of \verb+EnumMixedSolve+ that takes a normal form game instead
of a support.  See the built-in function, \verb+EnumMixedSolve+ for a
description of the parameters.
\begin{verbatim}
EnumMixedSolve[Support[nfg], stopAfter, precision, nPivots, time, 
  traceFile, traceLevel]
\end{verbatim} 
\ed

\item\lex{EnumMixedSolve}
\protect \large \begin{verbatim}
EnumMixedSolve[efg->EFG, {asNfg->False}, {stopAfter->0}, 
               {precision->Machine}, {nPivots<->0}, 
               {time<->0.000000}, {traceFile<->(Output)}, 
               {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
A version of \verb+EnumMixedSolve+ that takes an extensive form game instead
of a support.  See the built-in function, \verb+EnumMixedSolve+ for a
description of the parameters.
\begin{verbatim}
EnumMixedSolve[Support[efg], asNfg,stopAfter, precision, nPivots, time,
  traceFile, traceLevel]
\end{verbatim} 
\ed

\item\lex{EnumPureSolve}
\protect \large \begin{verbatim}
EnumPureSolve[nfg->NFG, {stopAfter->0}, {precision->Machine}, 
              {time<->0.000000}, {traceFile<->(Output)}, 
              {traceLevel->0}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
A version of \verb+EnumPureSolve+ that takes a normal form game instead
of a support.  See the built-in function, \verb+EnumPureSolve+ for a
description of the parameters.
\begin{verbatim}
EnumPureSolve[Support[nfg], stopAfter, precision, time, traceFile,
  traceLevel]
\end{verbatim} 
\ed

\item\lex{EnumPureSolve}
\protect \large \begin{verbatim}
EnumPureSolve[efg->EFG, {stopAfter->0}, {precision->Machine}, 
              {time<->0.000000}, {traceFile<->(Output)}, 
              {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
A version of \verb+EnumMixedSolve+ that takes an extensive form
game instead of a support.  See the built-in function,
\verb+EnumMixedSolve+ for a description of the parameters.
\begin{verbatim}
EnumPureSolve[Support[efg], False, stopAfter, precision, time, 
  traceFile, traceLevel]
\end{verbatim} 
\ed

%--F--

\item\lex{Float}
\protect \large \begin{verbatim}
Float[x->NUMBER] =: NUMBER 
\end{verbatim}\normalsize

\bd 
Converts the internal representation of \verb+x+ to Floating point.  
\begin{verbatim}
0.0+x
\end{verbatim} 
\ed

\item\lex{Float}
\protect \large \begin{verbatim}
Float[x->INTEGER] =: NUMBER 
\end{verbatim}\normalsize

\bd 
Converts \verb+x+ to \verb+NUMBER+ with internal representation of
x to Floating point.
\begin{verbatim}
Float[Number[x]]
\end{verbatim} 
\ed

\item\lex{Float}
\protect \large \begin{verbatim}
Float[x->BEHAV] =: BEHAV 
Float[x->MIXED] =: MIXED 
\end{verbatim}\normalsize

\bd 
Converts the internal representation of x to Floating point.  
\begin{verbatim}
1.0*x
\end{verbatim} 
\ed

\item\lex{Float}
\protect \large \begin{verbatim}
Float[x->EFOUTCOME] =: EFOUTCOME 
Float[x->NFOUTCOME] =: NFOUTCOME 
\end{verbatim}\normalsize

\bd 
Converts the internal representation of x to Floating point.  
\begin{verbatim}
SetPayoffs[x,Float[Payoffs[x]]];
\end{verbatim} 
\ed

%--G--

\item\lex{GambitExe}
\protect \large \begin{verbatim}
GambitExe[] =: TEXT 
\end{verbatim}\normalsize

\bd 
Returns the path to the directory containing the Gambit GUI executable
file, assuming a standard installation.  
\begin{verbatim}
p:=Platform[];
If[p="DOS/Windows",f:="gambit32"];
If[p="HP UX" || p="HPPA",f:="gui_motif_hp"];
If[p="SPARC" || p="SUN",f:="gui_motif_sun4"];
If[p="SVR4",f:="gui_motif_solaris"];
If[p="AIX32" || p="AIX",f:="gui_motif_rs6000"];
If[(h:=GetEnv["GAMBIT_HOME"])="",p:=ExePath[file->False]&f,p:=h&f];
p
\end{verbatim} 
\ed

\item\lex{GetIntegerFormat}
\protect \large \begin{verbatim}
GetIntegerFormat[{width<->0}] =: BOOLEAN 
\end{verbatim} \normalsize

\bd 
Gets the current values of the formatting parameters for numeric
data types.  See \verb+Format+ for definitions of the
parameters.  
\begin{verbatim}
GetFormat[1,width];
True
\end{verbatim} 
\ed

\item\lex{GetNumericFormat}
\protect \large \begin{verbatim}
GetNumericFormat[{width<->0}, {precis<->6}, 
                 {expmode<->False}] =: BOOLEAN 
\end{verbatim} \normalsize

\bd 
Gets the current values of the formatting parameters for numeric
data types.  See \verb+Format+ for definitions of the
parameters.  
\begin{verbatim}
GetFormat[1.0,width,precis,expmode];
True
\end{verbatim} 
\ed

\item\lex{GetSolutionFormat}
\protect \large \begin{verbatim}
GetSolutionFormat[{info<->1}] =: BOOLEAN 
\end{verbatim} \normalsize

\bd
Gets the current values of the formatting parameters for Mixed and
Behavior strategy solution data types.  See \verb+Format+ for
definitions of the parameters.  
\begin{verbatim}
GetFormat[Centroid[NewEfg[]],info];
True
\end{verbatim} 
\ed

\item\lex{GetTextFormat}
\protect \large \begin{verbatim}
GetTextFormat[{quote<->True}] =: BOOLEAN 
\end{verbatim} \normalsize

\bd
Gets the current values of the formatting parameters for text strings.  See
\verb+Format+ for definitions of the parameters. 
\begin{verbatim}
GetFormat["",quote];
True
\end{verbatim} 
\ed

\item\lex{GobitSolve}
\protect \large \begin{verbatim}
GobitSolve[efg->EFG, {pxifile->}, {minLam->0.001000}, 
           {maxLam->500.000000}, {delLam->0.020000}, {powLam->1}, 
           {fullGraph->False}, {maxitsN->20}, {tolN->0.000000}, 
           {maxits1->100}, {tol1->0.000000}, {time<->0.000000}, 
           {nEvals<->0}, {nIters<->0}, {traceFile<->(Output)}, 
           {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
A version of \verb+GobitSolve+ that takes an extensive form
game instead of a support.  See the built-in function,
\verb+GobitSolve+ for a description of the parameters.
\begin{verbatim}
GobitSolve[Centroid[Support[efg]],pxifile,minLam,maxLam,delLam,powLam, 
  fullGraph,maxitsN,tolN,maxits1,tol1,time,nEvals,nIters,traceFile,
  traceLevel]
\end{verbatim} 
\ed

\item\lex{GobitSolve}
\protect \large \begin{verbatim}
GobitSolve[nfg->NFG, {pxifile->}, {minLam->0.001000}, 
           {maxLam->500.000000}, {delLam->0.020000}, {powLam->1}, 
           {fullGraph->False}, {maxitsN->20}, {tolN->0.000000}, 
           {maxits1->100}, {tol1->0.000000}, {time<->0.000000}, 
           {nEvals<->0}, {nIters<->0}, {traceFile<->(Output)}, 
           {traceLevel->0}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
A version of \verb+GobitSolve+ that takes a normal form
game instead of a support.  See the built-in function,
\verb+GobitSolve+ for a description of the parameters.
\begin{verbatim}
GobitSolve[Centroid[Support[nfg]],pxifile,minLam,maxLam,delLam,powLam,
  fullGraph,maxitsN,tolN,maxits1,tol1,time,nEvals,nIters,traceFile,
  traceLevel]
\end{verbatim} 
\ed

%--H--

\item\lex{History}
\protect \large \begin{verbatim}
History[n->NODE] =: LIST(ACTION) 
\end{verbatim}\normalsize

\bd 
Returns a list containing the sequence of actions connecting the root
node to \verb+n+
\begin{verbatim}
If[IsRoot[n],{},Flatten[{History[Parent[n]]}&{PriorAction[n]}]]
\end{verbatim} 
\ed

%--I--

\item\lex{InfiniteLoopWarning}
\protect \large \begin{verbatim}
InfiniteLoopWarning[stopAfter->INTEGER, nTries->INTEGER] =: TEXT 
\end{verbatim}\normalsize

\bd 
Generates a warning at the console when a solution algorithm may enter
an infinite loop.  Used by the standard solution algorithms
\verb+AllNash+, \verb+AllSubgamePerfect+, etc.  

\begin{verbatim}
If[nTries=0,
  If[stopAfter=0,
  " Warning: Entering infinite loop.  Use Ctl-C to exit.",  
  " Warning: Entering possible infinite loop.  Use Ctl-C to exit."],
" Warning: May not find all"]
\end{verbatim} 
\ed

\item\lex{Infosets}
\protect \large \begin{verbatim}
Infosets[efg->EFG] =: LIST(LIST(INFOSET)) 
\end{verbatim}\normalsize

\bd 
A nested list of information sets in the game. The \verb+(i,j)+th
element is player \verb+i+s \verb+j+th information set.  
\begin{verbatim}
Infosets[Players[efg]]
\end{verbatim} 
\ed

\item\lex{IsRoot}
\protect \large \begin{verbatim}
IsRoot[n->NODE] =: BOOLEAN 
\end{verbatim}\normalsize

\bd 
Returns \verb+True+ if \verb+n+ is the root node of the game, else
false.  
\begin{verbatim}
IsNull[Parent[n]]
\end{verbatim} 
\ed

%--J--

%--K--

%--L--

\item\lex{LcpSolve}
\protect \large \begin{verbatim}
LcpSolve[nfg->NFG, {stopAfter->0}, {precision->Machine}, 
         {nPivots<->0}, {time<->0.000000}, {traceFile<->(Output)}, 
         {traceLevel->0}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
A version of \verb+LcpSolve+ that takes a normal form
game instead of a support.  See the built-in function,
\verb+LcpSolve+ for a description of the parameters.
\begin{verbatim}
LcpSolve[Support[nfg], stopAfter, precision, nPivots,
  time, traceFile, traceLevel]
\end{verbatim} 
\ed

\item\lex{LcpSolve}
\protect \large \begin{verbatim}
LcpSolve[efg->EFG, {asNfg->False}, {stopAfter->0}, 
        {precision->Machine}, {nPivots<->0}, {time<->0.000000}, 
        {traceFile<->(Output)}, {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
A version of \verb+LcpSolve+ that takes an extensive form
game instead of a support.  See the built-in function,
\verb+LcpSolve+ for a description of the parameters.
\begin{verbatim}
LcpSolve[Support[efg], asNfg, stopAfter, precision, nPivots,
  time, traceFile, traceLevel]
\end{verbatim} 
\ed

\item\lex{LiapSolve}
\protect \large \begin{verbatim}
LiapSolve[nfg->NFG, {stopAfter->1}, {nTries->10}, {maxitsN->20}, 
          {tolN->0.000000}, {maxits1->100}, {tol1->0.000000}, 
          {time<->0.000000}, {nEvals<->0}, {traceFile<->(Output)}, 
          {traceLevel->0}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
A version of \verb+LiapSolve+ that takes a normal form
game instead of a support.  See the built-in function,
\verb+LiapSolve+ for a description of the parameters.
\begin{verbatim}
LiapSolve[Centroid[Support[nfg]], stopAfter, nTries,
  maxitsN, tolN, maxits1, tol1, time, nEvals, traceFile,
  traceLevel]
\end{verbatim} 
\ed

\item\lex{LiapSolve}
\protect \large \begin{verbatim}
LiapSolve[efg->EFG, {asNfg->False}, {stopAfter->1}, {nTries->10}, 
          {maxitsN->20}, {tolN->0.000000}, {maxits1->100}, 
          {tol1->0.000000}, {time<->0.000000}, {nEvals<->0}, 
          {traceFile<->(Output)}, {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
A version of \verb+LiapSolve+ that takes an extensive form
game instead of a support.  See the built-in function,
\verb+LiapSolve+ for a description of the parameters.
\begin{verbatim}
LiapSolve[Centroid[Support[efg]], asNfg, stopAfter, nTries,
  maxitsN, tolN, maxits1, tol1, time, nEvals, traceFile,
  traceLevel]
\end{verbatim} 
\ed

\item\lex{ListForm}
\protect \large \begin{verbatim}
ListForm[behav->BEHAV] =: LIST(LIST(LIST(NUMBER))) 
\end{verbatim}\normalsize

\bd 
This function is provided for backwards compatibility only.  It
provides the same output as \verb+ActionProbs+.
\begin{verbatim}
ActionProb[behav,Actions[Game[behav]]]
\end{verbatim} 
\ed

\item\lex{ListForm}
\protect \large \begin{verbatim}
ListForm[mixed->MIXED] =: LIST(LIST(NUMBER)) 
\end{verbatim}\normalsize

\bd 
This function is provided for backwards compatibility only.  It
provides the same output as \verb+StrategyProbs+.
\begin{verbatim}
StrategyProb[mixed,Strategies[Game[mixed]]]
\end{verbatim} 
\ed

\item\lex{LpSolve}
\protect \large \begin{verbatim}
LpSolve[nfg->NFG, {stopAfter->1}, {precision->Machine}, 
        {nPivots<->0}, {time<->0.000000}, {traceFile<->(Output)}, 
        {traceLevel->0}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
A version of \verb+LpSolve+ that takes a normal form
game instead of a support.  See the built-in function,
\verb+LpSolve+ for a description of the parameters.
\begin{verbatim}
LpSolve[Support[nfg], stopAfter, precision, nPivots, time, traceFile, 
  traceLevel]
\end{verbatim} 
\ed

\item\lex{LpSolve}
\protect \large \begin{verbatim}
LpSolve[efg->EFG, {asNfg->False}, {stopAfter->1},
        {precision->Machine}, {nPivots<->0}, {time<->0.000000}, 
        {traceFile<->(Output)}, {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
A version of \verb+LpSolve+ that takes an extensive form
game instead of a support.  See the built-in function,
\verb+LpSolve+ for a description of the parameters.
\begin{verbatim}
LpSolve[Support[efg], asNfg, stopAfter, precision, nPivots, time, 
  traceFile, traceLevel]
\end{verbatim} 
\ed

%--M--

\item\lex{MarkedSubgames}
\protect \large \begin{verbatim}
MarkedSubgames[efg->EFG] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd 
Returns a list of the root nodes of all currently marked subgames.  
\begin{verbatim}
Filter[n:=Nodes[efg],MarkedSubgame[n]]
\end{verbatim} 
\ed

\item\lex{MarkSubgames}
\protect \large \begin{verbatim}
MarkSubgames[efg->EFG] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd 
Marks all legal subgames in \verb+efg+.  Returns a list of root nodes
of the marked subgames.  
\begin{verbatim}
MarkSubgame[s:=Subgames[efg]];
MarkedSubgames[efg]
\end{verbatim} 
\ed


\item\lex{MarkSubgames}
\protect \large \begin{verbatim}
MarkSubgames[n->LIST(NODE)] =: LIST(BOOLEAN) 
\end{verbatim}\normalsize

\bd 
Marks the subgames whose roots are in \verb+n+, leaving all other
subgames unmarked.  Returns a list of \verb+BOOLEAN+, indicating if
the corresponding node was successfully marked (i. e., was a valid
subgame root).
\begin{verbatim}
UnmarkSubgames[Game[n_1]];MarkSubgame[n]
\end{verbatim} 
\ed

\item\lex{Max}
\protect \large \begin{verbatim}
Max[x->LIST(NUMBER)] =: NUMBER 
Max[x->LIST(INTEGER)] =: INTEGER 
\end{verbatim}\normalsize

\bd 
Returns the maximum value in the list \verb+x+.  
\begin{verbatim}
i:=1;r:=x_1;
While[i<NumElements[x],i:=i+1;If[x_i>r,r:=x_i]];
r
\end{verbatim} 
\ed


\item\lex{MaxInt}
\protect \large \begin{verbatim}
MaxInt[] =: INTEGER 
\end{verbatim}\normalsize

\bd 
Returns the maximum integer:
\begin{verbatim}
2147483647
\end{verbatim} 
\ed


\item\lex{Members}
\protect \large \begin{verbatim}
Members[efg->EFG] =: LIST(LIST(LIST(NODE))) 
\end{verbatim}\normalsize

\bd 
Returns a nested list of member nodes of information sets.  The
\verb+(i,j,k)+th element corresponds to player \verb+i+, information
set \verb+j+, action \verb+k+.  
\begin{verbatim}
Members[Infosets[Players[efg]]]
\end{verbatim} 
\ed

\item\lex{Min}
\protect \large \begin{verbatim}
Min[x->LIST(NUMBER)] =: NUMBER 
Min[x->LIST(INTEGER)] =: INTEGER 
\end{verbatim}\normalsize

\bd 
Returns the minimum value in the list \verb+x+.  
\begin{verbatim}
-Max[-x]
\end{verbatim} 
\ed

\item\lex{Mixed}
\protect \large \begin{verbatim}
Mixed[nfg->NFG, list->LIST(LIST(NUMBER))] =: MIXED 
\end{verbatim}\normalsize

\bd 
Converts a nested list of numerical values into a mixed strategy.  The
\verb+(i,j)+th element of \verb+list+ becomes the probability
player \verb+i+ assigns to strategy \verb+j+. 
\begin{verbatim}
SetProbs[Mixed[Support[nfg]],list]
\end{verbatim} 
\ed

\item\lex{Mixed}
\protect \large \begin{verbatim}
Mixed[list->LIST(STRATEGY)] =: MIXED 
\end{verbatim}\normalsize

\bd 
Constructs a mixed strategy profile representing the pure strategy
profile given by \verb+list+. It is an error if \verb+list+ does not
contain one strategy for each player.
\begin{verbatim}
n:=Game[list_1];
s:=Strategies[n];
m:=Centroid[n];
v:=ListForm[m];
For[i:=1,i<=NumElements[v],i:=i+1,
  For[j:=1,j<=NumElements[v_i],j:=j+1,
    v_i_j:=0/1;
  ];
  v_i_(Index[s_i,list_i]_1) := 1/1
];
SetProbs[m,v];   
\end{verbatim} 
\ed


%--N--

\item\lex{NewInfoset}
\protect \large \begin{verbatim}
NewInfoset[player->EFPLAYER, actions->LIST(TEXT), 
  {name->}] =: INFOSET 
\end{verbatim}\normalsize

\bd 
A version of \verb+NewInfoset+ that assigns \verb+name+ to be the name
of the information set, and \verb+actions_j+ to be the name of action
\verb+j+.  The number of actions created for the new information set
is determined implicitly by the length of the list \verb+actions+.  
\begin{verbatim}
i:=SetName[NewInfoset[player,Length[actions]],name];
SetName[Actions[i,Support[Game[player]]],actions];
i
\end{verbatim} 
\ed

\item\lex{NewNfg}
\protect \large \begin{verbatim}
NewNfg[dim->LIST(INTEGER), outcomes->BOOLEAN] =: NFG }
\end{verbatim}\normalsize

\bd 

Creates an new normal form game with \verb+Length[dim]+ players, and
\verb+dim_i+ strategies for player \verb+i+.  A new outcome is
attached to each cell of the normal form game.  Returns the newly
created game.

\begin{verbatim}
n:=NewNfg[dim];
If[outcomes=True,
  NewOutcome[CartesianProd[Strategies[n]]]
];
n;
\end{verbatim} 
\ed

\item\lex{NewOutcome}
\protect \large \begin{verbatim}
NewOutcome[efg->EFG, name->TEXT] =: EFOUTCOME 
\end{verbatim}\normalsize

\bd 
A version of \verb+NewOutcome+ that assigns \verb+name+ to be the name
of the outcome created.  
\begin{verbatim}
SetName[NewOutcome[efg],name]
\end{verbatim} 
\ed

\item\lex{NewOutcome}
\protect \large \begin{verbatim}
NewOutcome[profile->LIST(STRATEGY)] =: NFOUTCOME 
\end{verbatim}\normalsize

\bd 
Creates a new outcome for the normal form game, attaching it to
the pure profile \verb+profile+.  \verb+profile+ must be a list of
strategies, whose \verb+i+th entry is a strategy for player \verb+i+. 


\begin{verbatim}
name:=Concat[Name[profile]];
SetName[SetOutcome[profile,NewOutcome[Game[profile_1]]],name];
\end{verbatim} 
\ed

\item\lex{NewOutcome}
\protect \large \begin{verbatim}
NewOutcome[profile->LIST(STRATEGY), payoff->LIST(NUMBER)] =: NFOUTCOME 
\end{verbatim}\normalsize
 
\bd 
Creates a new outcome for the normal form game, attaching it to
the pure profile \verb+profile+, and sets the payoffs to be the vector
\verb+payoff+.  \verb+profile+ must be a list of strategies, whose
\verb+i+th entry is a strategy for player \verb+i+, and \verb+payoff+
is a list whose \verb+i+th entry is a payoff for player \verb+i+.

\begin{verbatim}
SetPayoffs[NewOutcome[profile], payoff];
\end{verbatim} 
\ed


\item\lex{NewPlayer}
\protect \large \begin{verbatim}
NewPlayer[efg->EFG, name->TEXT] =: EFPLAYER 
\end{verbatim}\normalsize

\bd 
A version of \verb+NewPlayer+ that assigns \verb+name+ to be the name
of the extensive form player created.  
\begin{verbatim}
SetName[NewPlayer[efg],name]
\end{verbatim} 
\ed

\item\lex{NewPlayer}
\protect \large \begin{verbatim}
NewPlayer[nfg->NFG, name->TEXT] =: NFPLAYER 
\end{verbatim}\normalsize

\bd 
A version of \verb+NewPlayer+ that assigns \verb+name+ to be the name
of the normal form player created.  
\begin{verbatim}
SetName[NewPlayer[nfg],name]
\end{verbatim} 
\ed

\item\lex{Nfg}
\protect \large \begin{verbatim}
Nfg[x->NLIST(NUMBER)] =: NFG 
\end{verbatim}\normalsize

\bd 

Creates an \verb+n+ person normal form game from a \verb&n+1&
dimensional nested list \verb+x+ of payoffs.  It is an error if the
array of payoffs is not rectangular.  Entry
\verb+x_(k_1)_(k_2)_..._(k_n)_j+ is the payoff to player \verb+j+ from
the strategy profile where player \verb+i+ adopts strategy \verb+k_i+.
Returns the newly created game.

\begin{verbatim}
d:=Dimensions[x];
n:=NewNfg[Remove[d,Length[d]]];
s:=CartesianProd[Strategies[n]];
SetPayoffs[s,x];
n
\end{verbatim} 
\ed

\item\lex{NodeTree}
\protect \large \begin{verbatim}
NodeTree[efg->EFG] =: NLIST(NODE) 
\end{verbatim}\normalsize

\bd 
Returns a nested list of nodes in the game tree of \verb+efg+.  
\begin{verbatim}
Descendants[RootNode[efg]]
\end{verbatim} 
\ed

\item\lex{NodeValues}
\protect \large \begin{verbatim}
NodeValues[behav->BEHAV, node->NODE] =: LIST(NUMBER) 
\end{verbatim}\normalsize

\bd 
Returns a list whose \verb+i+th entry is the value to player \verb+i+
of being at \verb+node+ under \verb+behav+.
\begin{verbatim}
NodeValue[behav,Players[Game[behav]],node]
\end{verbatim} 
\ed

\item\lex{NonterminalNodes}
\protect \large \begin{verbatim}
NonterminalNodes[efg->EFG] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd 
A list of nonterminal nodes of \verb+efg+.
\begin{verbatim}
Filter[d:=Nodes[efg],NumChildren[d]>0]
\end{verbatim} 
\ed

\item\lex{NumActions}
\protect \large \begin{verbatim}
NumActions[infoset->INFOSET, support->EFSUPPORT] =: INTEGER 
\end{verbatim}\normalsize

\bd 
The number of actions in \verb+infoset+.
\begin{verbatim}
Length[Actions[infoset,support]] 
\end{verbatim} 
\ed

\item\lex{NumActions}
\protect \large \begin{verbatim}
NumActions[infoset->INFOSET] =: INTEGER 
\end{verbatim}\normalsize

\bd \begin{verbatim}
Length[Actions[infoset,Support[Game[infoset]]]] 
\end{verbatim} 
\ed

\item\lex{NumChildren}
\protect \large \begin{verbatim}
NumChildren[n->NODE] =: INTEGER 
\end{verbatim}\normalsize

\bd 
The number of child nodes of \verb+n+.
\begin{verbatim}
Length[Children[n]]
\end{verbatim} 
\ed

\item\lex{NumMembers}
\protect \large \begin{verbatim}
NumMembers[i->INFOSET] =: INTEGER 
\end{verbatim}\normalsize

\bd 
The number of member nodes in the information set \verb+i+.
\begin{verbatim}
Length[Members[i]]
\end{verbatim} 
\ed

\item\lex{NumPlayers}
\protect \large \begin{verbatim}
NumPlayers[efg->EFG] =: INTEGER 
\end{verbatim}\normalsize

\bd 
The number of players in the extensive form game \verb+efg+.
\begin{verbatim}
Length[Players[efg]]
\end{verbatim} 
\ed

\item\lex{NumPlayers}
\protect \large \begin{verbatim}
NumPlayers[nfg->NFG] =: INTEGER 
\end{verbatim}\normalsize

\bd 
The number of players in the normal form game \verb+nfg+.
\begin{verbatim}
Length[Players[nfg]]
\end{verbatim} 
\ed

\item\lex{NumStrats}
\protect \large \begin{verbatim}
NumStrats[player->NFPLAYER, support->NFSUPPORT] =: INTEGER 
\end{verbatim}\normalsize

\bd 
The number of strategies in \verb+support+ for player \verb+player+.
\begin{verbatim}
Length[Strategies[player,support]] 
\end{verbatim} 
\ed

%--O--

\item\lex{OneNash}
\protect \large \begin{verbatim}
OneNash[e->EFG, {precision->Machine}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
Finds one Nash equilibrium of the extensive form game \verb+e+.
Returns a singleton list containing the equilibrium found.

\begin{verbatim}
ms:=MarkedSubgames[e];MarkSubgames[e];
If[NumPlayers[e] = 2 && IsPerfectRecall[e],
  If[IsConstSum[e],
    b:=LpSolve[e,False,1,precision],
    b:=LcpSolve[e,False,1,precision]
  ],
  b:=SimpDivSolve[e,asNfg->True,stopAfter->1,nRestarts->16,
    precision->precision]
];
MarkSubgames[ms];b
\end{verbatim} 
\ed

\item\lex{OneNash}
\protect \large \begin{verbatim}
OneNash[n->NFG, {precision->Machine}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
Finds one Nash equilibrium of the normal form game \verb+n+.
Returns a singleton list containing the equilibrium found.

\begin{verbatim}
s:=ElimAllDom[n];
If[NumPlayers[n] = 2,
  If[IsConstSum[n],LpSolve[s,1,precision],LcpSolve[s,1,precision]],
  SimpDivSolve[s,stopAfter->1,nRestarts->16,precision->precision]
]
\end{verbatim} 
\ed

\item\lex{OnePerfect}
\protect \large \begin{verbatim}
OnePerfect[n->NFG, {precision->Machine}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
Finds one Perfect Nash equilibrium of the normal form game
\verb+n+.  Returns a singleton list containing the equilibrium found.

\begin{verbatim}
s:=ElimAllDom[n,strong->True];
If[NumPlayers[n] = 2, 
  LcpSolve[s,1,precision],
  << " Not implemented for n-person games";
  List[Centroid[Support[n]],0] // return empty set of mixed
]
\end{verbatim} 
\ed

\item\lex{OneSequential}
\protect \large \begin{verbatim}
OneSequential[e->EFG] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
Finds one sequential Nash equilibrium of the extensive form game
\verb+e+.  Returns a singleton list containing the equilibrium found.

\begin{verbatim}
ms:=MarkedSubgames[e];UnmarkSubgames[e];
b:=GobitSolve[e,fullGraph->False];
If[!IsKnownSequential[b_1],
  << " Warning: Algorithm did not converge, returning last value"
];
MarkSubgames[ms];b
\end{verbatim} 
\ed

\item\lex{OneSubgamePerfect}
\protect \large \begin{verbatim}
OneSubgamePerfect[e->EFG, {precision->Machine}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
Finds one subgame perfect Nash equilibrium of the extensive form
game \verb+e+.  Returns a singleton list containing the equilibrium
found.

\begin{verbatim}
ms:=MarkedSubgames[e];MarkSubgames[e];
If[NumPlayers[e] = 2 && IsPerfectRecall[e],
  If[IsConstSum[e],
    b:=LpSolve[e,False,1,precision],
    b:=LcpSolve[e,False,1,precision]
  ],
  b:=SimpDivSolve[e,asNfg->True,stopAfter->1,nRestarts->16,
    precision->precision]
];
MarkSubgames[ms];b
\end{verbatim} 
\ed

\item\lex{OutcomeForm}
\protect \large \begin{verbatim}
OutcomeForm[n->NFG(NUMBER)]=:NLIST(NFOUTCOME)
\end{verbatim}\normalsize

\bd 
Gives the game form of \verb+n+ in the form of a nested list, with
entires as the corresponding outcomes for each pure profile. 

\begin{verbatim}
Outcome[CartesianProd[Strategies[n]]]
\end{verbatim} 
\ed

%--P--

\item\lex{Payoffs}
\protect \large \begin{verbatim}
Payoffs[outcome->EFOUTCOME] =: LIST(NUMBER) 
Payoffs[outcome->NFOUTCOME] =: LIST(NUMBER) 
\end{verbatim}\normalsize

\bd 
Returns a list whose \verb+i+th entry is the payoff to player \verb+i+
at \verb+outcome+.
\begin{verbatim}
Payoff[outcome,Players[Game[outcome]]]
outcome
\end{verbatim} 
\ed

\item\lex{Payoffs}
\protect \large \begin{verbatim}
Payoffs[profile->BEHAV] =: LIST(NUMBER) 
Payoffs[profile->MIXED] =: LIST(NUMBER) 
\end{verbatim}\normalsize

\bd 
Returns a list whose \verb+i+th entry is the payoff to player \verb+i+
in the extensive or normal form game under \verb+profile+.
\begin{verbatim}
Payoff[profile,Players[Game[profile]]]
\end{verbatim} 
\ed

\item\lex{Payoffs}
\protect \large \begin{verbatim}
Payoffs[profile->LIST(STRATEGY)] =: ANYTYPE 
\end{verbatim}\normalsize

\bd 
Returns a list whose \verb+i+th entry is the payoff to player \verb+i+
in the normal form game under the pure strategy represented by \verb+profile+.
It is an error if \verb+profile+ does not contain a list of
strategies, one for each player, in order.  
\begin{verbatim}
Payoff[Outcome[profile],Players[Game[profile_1]]]
\end{verbatim} 
\ed


\item\lex{Payoffs}
\protect \large \begin{verbatim}
Payoffs[n->NFG] =: NLIST(NUMBER) 
\end{verbatim}\normalsize

\bd 
Returns a nested list of payoffs in the normal form game, verb+n+.
The \verb+(k_1,k_2, ... , k_n, j)+ entry of the list is the payoff to
player \verb+j+ from the strategy profile where player \verb+i+ adopts
strategy \verb+k_i+.
\begin{verbatim}
Payoffs[CartesianProd[Strategies[n]]]
\end{verbatim} 
\ed
  

\item\lex{PlayerNumber}
\protect \large \begin{verbatim}
PlayerNumber[p->EFPLAYER] =: INTEGER 
PlayerNumber[p->NFPLAYER] =: INTEGER 
\end{verbatim}\normalsize

\bd 
The player number of player \verb+p+.
\begin{verbatim}
Index[Players[Game[p]],p]_1
\end{verbatim} 
\ed

\item\lex{Power}
\protect \large \begin{verbatim}
Power[x->INTEGER,y->INTEGER]=:INTEGER
\end{verbatim}\normalsize

\bd 
\verb+x+ to the power \verb+y+.
\begin{verbatim}
Integer[Power[Number[x],Number[y]]]
\end{verbatim} 
\ed

\item\lex{Power}
\protect \large \begin{verbatim}
Power[x->INTEGER,y->NUMBER]=:NUMBER
\end{verbatim}\normalsize

\bd 
\verb+x+ to the power \verb+y+.
\begin{verbatim}
Power[Number[x],y]
\end{verbatim} 
\ed

\item\lex{Power}
\protect \large \begin{verbatim}
Power[x->NUMBER,y->INTEGER]=:NUMBER
\end{verbatim}\normalsize

\bd 
\verb+x+ to the power \verb+y+.
\begin{verbatim}
Power[x,Number[y]]
\end{verbatim} 
\ed

\item\lex{Prepend}
\protect \large \begin{verbatim}
Prepend[x->ANYTYPE, l->LIST(ANYTYPE)] =: LIST(ANYTYPE) 
\end{verbatim}\normalsize

\bd 
Inserts \verb+x+ as the first element of the list \verb+l+.  
\begin{verbatim}
{x}&l
\end{verbatim} 
\ed

\item\lex{Profiles}
\protect \large \begin{verbatim}
Profiles[s->NFSUPPORT] =: NLIST(STRATEGY) 
\end{verbatim}\normalsize

\bd 
Returns a nested list of all the pure strategy profiles for the support
\verb+s+.  Each profile is a list of strategies, one for each player.  
\begin{verbatim}
CartesianProd[Strategies[s]]
\end{verbatim} 
\ed


\item\lex{Profiles}
\protect \large \begin{verbatim}
Profiles[nfg->NFG] =: NLIST(STRATEGY) 
\end{verbatim}\normalsize

\bd 
Returns a nested list of all the pure strategy profiles for the normal
form game \verb+n+.  Each profile is a list of strategies, one for
each player.
\begin{verbatim}
Profiles[Support[nfg]]
\end{verbatim} 
\ed

%--Q--

%--R--

\item\lex{Randomize}
\protect \large \begin{verbatim}
Randomize[x->EFG, {seed->0}] =: EFG 
Randomize[x->NFG, {seed->0}] =: NFG 
\end{verbatim}\normalsize

\bd 
Assigns a payoff for each outcome for each player in the extensive
or normal form game \verb+x+ randomly chosen from the uniform
distribution between 0 and 1.  The optional parameter \verb+seed+ may
be used to set the seed of the pseudo-random number generator.  The
identical game randomized with the same seed will always produce the
same results.
\begin{verbatim}
o:=Outcomes[x];
pay:=Payoffs[o];
Randomize[pay_1_1,seed];
pay:=Randomize[pay];
SetPayoffs[o,pay];
x;
\end{verbatim} 
\ed

\item\lex{Randomize}
\protect \large \begin{verbatim}
Randomize[x->NUMBER, {seed->0}] =: NUMBER 
\end{verbatim}\normalsize

\bd 
Returns a uniform random number between 0 and 1.  The precision of the
number returned is the same as that of \verb+x+.  The optional
parameter \verb+seed+ may be used to set the seed of the pseudo-random
number generator. 
\begin{verbatim}
num:=Randomize[1,seed]/MaxInt[];
If[IsFloat[x],Float[num],num];
\end{verbatim} 
\ed

\item\lex{Read}
\protect \large \begin{verbatim}
Read[input<->INPUT, x<->MIXED] =: INPUT 
Read[input<->INPUT, x<->BEHAV] =: INPUT 
\end{verbatim}\normalsize

\bd 
Reads data of type \verb+MIXED+ or \verb+BEHAV+ from the input
stream and assigns it to \verb+x+.  If the wrong data type is found
for any element of the list, a file read error will be returned.
\item [Short form:] \verb+input >> x+
\item [See also:] \verb+Read+, \verb+Input+, \verb+Write+.
\begin{verbatim}
v:=ListForm[x];
input >> v;
SetProbs[x,v];
input
\end{verbatim} 
\ed

%--S--

\item\lex{SetIntegerFormat}
\protect \large \begin{verbatim}
SetIntegerFormat[{width->0}] =: BOOLEAN 
\end{verbatim}\normalsize

\bd 
Sets the formatting style for output of integer types on output
streams.  See \verb+Format+ for definitions of the parameters.
\item [See also:] \verb+SetListFormat+, \verb+SetTextFormat+, 
\verb+SetSolutionFormat+, \verb+Write+.
\begin{verbatim}
!IsNull[Format[1,width]]
\end{verbatim} 
\ed

\item\lex{SetListFormat}
\protect \large \begin{verbatim}
SetListFormat[{braces->True}, {commas->True}, 
              {lf->1}, {indent->2}] =: BOOLEAN 
\end{verbatim} \normalsize

\bd
Sets the formatting style for output of lists on output streams. See
\verb+ListFormat+ for definitions of the parameters. 
\item [See also:] \verb+SetNumericFormat+, \verb+SetTextFormat+,
\verb+SetSolutionFormat+, \verb+Write+.
\begin{verbatim}
ListFormat[braces,commas,lf,indent]
\end{verbatim} 
\ed

\item\lex{SetNumericFormat}
\protect \large \begin{verbatim}
SetNumericFormat[{width->0}, {precis->6}, 
                 {expmode->False}] =: BOOLEAN 
\end{verbatim}\normalsize

\bd Sets the formatting style for output of numeric types on output
streams.  See \verb+Format+ for definitions of the parameters.
\item [See also:] \verb+SetListFormat+, \verb+SetTextFormat+, 
\verb+SetSolutionFormat+, \verb+Write+.
\begin{verbatim}
!IsNull[Format[1.0,width,precis,expmode]]
\end{verbatim} 
\ed

\item\lex{SetPayoffs}
\protect \large \begin{verbatim}
SetPayoffs[outcome->EFOUTCOME, payoff->LIST(NUMBER)] =: EFOUTCOME 
SetPayoffs[outcome->NFOUTCOME, payoff->LIST(NUMBER)] =: NFOUTCOME 
\end{verbatim}\normalsize
 
\bd 

Sets the payoffs of \verb+outcome+ to be the vector \verb+payoff+,
where \verb+payoff+ is a list whose \verb+i+th entry is a payoff for
player \verb+i+.
\begin{verbatim}
SetPayoff[outcome,Players[Game[outcome]],payoff];
outcome
\end{verbatim} 
\ed

\item\lex{SetProbs}
\protect \large \begin{verbatim}
SetProbs[profile<->BEHAV, value->LIST(LIST(LIST(NUMBER)))] =: BEHAV 
SetProbs[profile<->MIXED, value->LIST(LIST(NUMBER))] =: MIXED 
\end{verbatim}\normalsize

\bd 
Sets the probabilities in the \verb+profile+ to the values in
\verb+value+.  
\begin{verbatim}
SetStrategyProbs[profile,Players[Game[profile]],value];
profile
\end{verbatim} 
\ed

\item\lex{SetSolutionFormat}
\protect \large \begin{verbatim}
SetSolutionFormat[{info->1}] =: BOOLEAN 
\end{verbatim}\normalsize

\bd Sets the formatting style for output of solution types on output
streams.  See \verb+Format+ for definitions of the parameters.
\item [See also:] \verb+SetListFormat+, \verb+SetTextFormat+, 
\verb+SetNumericFormat+, \verb+Write+.
\begin{verbatim}
!IsNull[Format[Centroid[NewEfg[]],info]]
\end{verbatim} 
\ed

\item\lex{SetTextFormat}
\protect \large \begin{verbatim}
SetTextFormat[{quote->True}] =: BOOLEAN 
\end{verbatim}\normalsize

\bd 
Sets the formatting style for output of text on output streams.
See \verb+Format+ for definitions of the parameters.
\item [See also:] \verb+SetListFormat+, \verb+SetSolutionFormat+, 
\verb+SetNumericFormat+, \verb+Write+.
\begin{verbatim}
!IsNull[Format["",quote]]
\end{verbatim} 
\ed

\item\lex{SimpDivSolve}
\protect \large \begin{verbatim}
SimpDivSolve[nfg->NFG, {stopAfter->1}, {nRestarts->16}, 
             {leashLength->0}, {precision->Machine}, {nEvals<->0}, 
             {time<->0.000000}, {traceFile<->(Output)}, 
             {traceLevel->0}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
A version of \verb+SimpDivSolve+ that takes a normal form
game instead of a support.  See the built-in function,
\verb+SimpDivSolve+ for a description of the parameters.
\begin{verbatim}
SimpDivSolve[Support[nfg], stopAfter, nRestarts, leashLength,
  precision, nEvals, time, traceFile, traceLevel]
\end{verbatim} 
\ed

\item\lex{SimpDivSolve}
\protect \large \begin{verbatim}
SimpDivSolve[efg->EFG, {asNfg->False}, {stopAfter->1}, 
             {nRestarts->16}, {leashLength->0}, {precision->Machine}, 
             {nEvals<->0}, {time<->0.000000}, {traceFile<->(Output)}, 
             {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
A version of \verb+SimpDivSolve+ that takes an extensive form
game instead of a support.  See the built-in function,
\verb+SimpDivSolve+ for a description of the parameters.
\begin{verbatim}
SimpDivSolve[Support[efg], asNfg, stopAfter, nRestarts, leashLength,
  precision, nEvals, time, traceFile, traceLevel]
\end{verbatim} 
\ed

\item\lex{Strategies}
\protect \large \begin{verbatim}
Strategies[player->NFPLAYER] =: LIST(STRATEGY) 
\end{verbatim}\normalsize

\bd 
A list of strategies for \verb+player+ in the normal form game.  
\begin{verbatim}
Strategies[player,Support[Game[player]]]
\end{verbatim} 
\ed

\item\lex{Strategies}
\protect \large \begin{verbatim}
Strategies[s->NFSUPPORT] =: LIST(LIST(STRATEGY)) 
\end{verbatim}\normalsize

\bd 
A list of sets of strategies in the support \verb+s+. The \verb+i+th
element of the list returned is a list of strategies for player
\verb+i+.   
\begin{verbatim}
Strategies[Players[Game[s]],s]
\end{verbatim} 
\ed


\item\lex{Strategies}
\protect \large \begin{verbatim}
Strategies[nfg->NFG] =: LIST(LIST(STRATEGY)) 
\end{verbatim}\normalsize

\bd 
A list of strategy sets in the normal form game \verb+nfg+. The
\verb+(i,j)+th element of the list is player \verb+i+s \verb+j+th
strategy.  
\begin{verbatim}
Strategies[Players[nfg]]
\end{verbatim} 
\ed

\item\lex{StrategyValues}
\protect \large \begin{verbatim}
StrategyValues[profile->MIXED] =: LIST(LIST(NUMBER)) 
\end{verbatim}\normalsize

\bd 
Returns the strategy values of \verb+profile+.  The
\verb+(i,j)'th+ element is the value to player \verb+i+ of adopting
strategy \verb+j+. 
\begin{verbatim}
StrategyValue[profile,Strategies[Game[profile]]];
\end{verbatim} 
\ed

\item\lex{Sum}
\protect \large \begin{verbatim}
Sum[l->LIST(INTEGER)] =: INTEGER 
\end{verbatim}\normalsize

\bd 
The sum of the elements of a list.  
\begin{verbatim}
Dot[l,List[1,Length[l] ]]
\end{verbatim} 
\ed

\item\lex{Sum}
\protect \large \begin{verbatim}
Sum[l->LIST(NUMBER)] =: NUMBER 
\end{verbatim}\normalsize

\bd 
The sum of the elements of a list.  
\begin{verbatim}
Dot[l,List[1/1,Length[l] ]]
\end{verbatim} 
\ed


%--T--

\item\lex{TerminalNodes}
\protect \large \begin{verbatim}
TerminalNodes[efg->EFG] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd 
The terminal nodes of the game tree of the extensive form game \verb+efg+.
\begin{verbatim}
Filter[d:=Nodes[efg],NumChildren[d]=0]
\end{verbatim} 
\ed

%--U--

\item\lex{UnmarkSubgames}
\protect \large \begin{verbatim}
UnmarkSubgames[efg->EFG] =: LIST(NODE)
\end{verbatim}\normalsize

\bd 
Unmarks all subgames in \verb+efg+.
\begin{verbatim}
UnmarkSubgame[Nodes[efg]];
MarkedSubgames[efg]
\end{verbatim} 
\ed

%--V--

%--W--

%--X--

%--Y--

%--Z--

\end{itemize}

\end{document}