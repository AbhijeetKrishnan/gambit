<chapter id="api">
<title>Overview of the Gambit API</title>

<para>
Gambit is written in C++.  This chapter gives an overview of the underlying 
library of classes which represent and manipulate games.
</para>

<para>
This chapter does not go into exhaustive detail about all functions and
classes implemented in libgambit.  Programmers interested in using the
library in their own applications should consult the Doxygen-generated
source documentation available from the Documentation page of the
Gambit website, as well as the sample programs.
</para>

<para>
Gambit also provides an interface to the library for scripting languages
by the use of SWIG (http://www.swig.org).  Currently, only an interface
for Python (http://www.python.org) is available.  The SWIG wrapper should
be easily modifiable to create interfaces for the other languages
SWIG supports.
</para>

<sect1 id="api.concepts">
<title>General concepts and terminology</title>

<para>
The file <literal>libgambit/libgambit.h</literal> includes all the
header files for all classes and functions.
To help play nice with other libraries, all classes and functions
in libgambit are contained in the namespace <literal>Gambit</literal>.
</para>

<para>
The development of much of Gambit occurred during 1994 and 1995.
As this predates the formal standardization of the Standard Template
Library (and, in fact, C++ itself), as well as other standard libraries
for reusable container and similar classes, Gambit has its own implementation
of some of these classes.  This section outlines those facilities.
In the longer term, the goal is to evolve these classes to be more
compatible with STL and/or with another standard library, and to possibly
migrate fully to such a library.
<xref linkend="table.containers"> lists the generic container
classes provided by the library.
</para>

<table id="table.containers">
<title>Container classes in libgambit</title>
<tgroup cols="2">
<colspec colname="Class">
<colspec colname="Description">
<thead>
<row>
<entry>Class</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>Array</entry>
<entry>A basic bounds-checked array</entry>
</row>
<row>
<entry>List</entry>
<entry>A doubly-linked list</entry>
</row>
<row>
<entry>Map</entry>
<entry>A sorted associative container</entry>
</row>
<row>
<entry>Vector</entry>
<entry>A mathematical vector</entry>
</row>
<row>
<entry>PVector</entry>
<entry>A singly-partitioned vector</entry>
</row>
<row>
<entry>DVector</entry>
<entry>A doubly-partitioned vector</entry>
</row>
<row>
<entry>RectArray</entry>
<entry>A basic bounds-checked rectangular array</entry>
</row>
<row>
<entry>Matrix</entry>
<entry>A mathematical matrix</entry>
</row>
<row>
<entry>SquareMatrix</entry>
<entry>A mathematical square matrix</entry>
</row>
</tbody>
</tgroup>
</table>

<para>
The <classname>Array</classname> and <classname>List</classname> classes
are the basic generic one-dimensional containers; they have identical
interfaces, and as such may be used interchangeably.  Thus,
<classname>List</classname> is similar to the STL's <classname>list</classname>.
<classname>Array</classname> is parallel to STL's 
<classname>vector</classname>; note that Gambit reserves 
<classname>Vector</classname> to represent mathematical objects of
that name (i.e., they are <classname>Array</classname>s which have
the standard mathematical operations defined on them).  The third
generic container is <classname>Map</classname>, which is similar to
STL's <classname>map</classname>, which associates a key to a value.
</para>

<note>
<para>
For historical reasons, and in contrast to STL and indexing conventions
in C, C++, Python, and most languages, the <classname>List</classname>
class starts indexing the first element at one, not zero.  The
<classname>Array</classname> class defaults to this behavior, but allows
any index to be used as the first index.  It is planned to migrate the
library to using zero-based indexing; therefore, it is recommended to
write code as generically as possible, especially using the iterator
idioms provided, to make this migration easier. 
</para>
</note>

</sect1>

<sect1 id="api.games">
<title>Games</title>

<para>
All games, whether represented in extensive or strategic form, are
handled by the C++ classes <classname>Game</classname> and
<classname>GameRep</classname>.  The classes which represent games
and parts thereof uses the pointer-to-implementation (pimpl) idiom.
Client code will generally refer to objects of type
<classname>Game</classname>.  This is a smart-pointer class containing
a pointer to the representation class <classname>GameRep</classname>.
</para>

<sect2 id="api.games.lifecycle">
<title>Building, loading, and saving games</title>

<para>
For example, to create a new game with
an extensive (tree) representation in C++, set its title, and print
out that title:

<programlisting>
#include &lt;iostream>
#include "libgambit/libgambit.h"

main()
{
  Gambit::Game myGame = Gambit::NewTree();
  myGame->SetTitle("Hello, World!");
  std::cout << myGame->GetTitle() << std::endl;
}
</programlisting>

Note that the object myGame has pointer semantics.  If it points to
a null or invalid pointer, attempting to dereference it will throw
a C++ exception of class <classname>Gambit::NullException</classname>.
Assignment of one <classname>Game</classname> to another also has
pointer semantics; both objects will refer to the same physical game.
Also, objects of class <classname>Game</classname> handle reference-counting,
which is decremented when the object goes out of scope.  Thus, in the
above example, the game created is automatically deallocated when the
last <classname>Game</classname> referencing it goes away at the end
of main().
</para>

<para>
The parallel code for Python users is

<programlisting>
import gambit

myGame = gambit.NewTree()
myGame.SetTitle("Hello, World!")
print myGame.GetTitle()
</programlisting>
</para>

<para>
Constructing a game in strategic form requires specifying an initial
dimension for the game.  In C++, this is done using an 
<classname>Array</classname> of type <classname>int</classname>. For
a two-player game where the first player has 2 strategies and the second
player 3 strategies, 

<programlisting>
Gambit::Array&lt;int> dim(2);
dim[1] = 2;
dim[2] = 3;
Gambit::Game myGame = Gambit::NewTable(dim);
</programlisting>

In Python, it's a little simpler, since a Python list can be used
directly:

<programlisting>
myGame = gambit.NewTable([2,3])
</programlisting>

</para>

<para>
As just noted, Gambit games can be expressed in either extensive or
strategic representation.  Games in extensive representation can only
be built or modified using functions appropriate to game trees, and
games in strategic representation can only use functions appropriate
to setting the payoffs associated with each strategy vector.
For games in extensive representation, Gambit
can compute the reduced strategic representation.  This is done
by calling <function>BuildComputedValues</function> on the
game object.  The computed reduced strategy sets are cached internally
until any structural changes in the game tree are made, at which point
the cached values are cleared and <function>BuildComputedValues</function>
must be called again to compute the revised reduced strategic
representation.
Note that the size of the reduced strategic representation
of a game may increase very rapidly, so think carefully about building
the reduced strategic representation for games of nontrivial size; 
it is generally recommended to analyze extensive games directly
in the extensive form where possible.
</para>

<para>
After building a game, it is generally recommended to call
<function>Canonicalize</function> on the game.  This function
renumbers the nodes and information sets in the game in a regular way,
such that two identical games will always have their elements numbered
the same way, irrespective of the order of operations used to construct
them.
</para>

<para>
Games can also be read from a file.  A typical C++ usage might be

<programlisting>
Gambit::Game myGame;

try {
  std::ifstream f("mygame.efg");
  myGame = Gambit::ReadGame(f);
}
except (Gambit::InvalidFileException) {
  // report the error condition here
}
</programlisting>

In the Python version, <function>ReadGame</function> takes a 
string with the file contents, not the file object itself, and (currently)
failure results in an <classname>RuntimeError</classname>:

<programlisting>
try:
  myGame = gambit.ReadGame(file("mygame.efg").read())
except RuntimeError:
  # handle here
</programlisting>

<function>ReadGame</function> reads files in the <filename>.efg</filename>
and <filename>.nfg</filename> formats described in <xref linkend="file">.
It does not (yet) handle the XML-based <filename>.gbt</filename> workbook
format recently introduced in the graphical user interface.
However, note that the game structure itself is stored in the
<filename>.gbt</filename> file using these formats, so it can be extracted
with a little preprocessing.
</para>

<para>
Writing games to these file formats is accomplished by the members
<function>WriteEfgFile</function> and <function>WriteNfgFile</function>,
respectively.  This fragment reads in an extensive game, and writes both
a copy of the game in extensive form, as well as its reduced strategic
form, to separate files.

<programlisting>
std::ifstream f1("mygame.efg");
Gambit::Game myGame = Gambit::ReadGame(f1);

std::ofstream f2("mygamecopy.efg");
myGame->WriteEfgFile(f2);

myGame->BuildComputedValues();   /* constructs the reduced strategic form */
std::ofstream f3("mygamecopy.nfg");
myGame->WriteNfgFile(f3);
</programlisting>

Use in Python again varies slightly. In Python, the members
<function>AsEfgFile</function> and <function>AsNfgFile</function>
create a string representation of the game, which can be written to a
file:

<programlisting>
myGame = gambit.ReadGame(file("mygame.efg").read())
file("mygamecopy.efg", "w").write(myGame.AsEfgFile())
file("mygamecopy.nfg", "w").write(myGame.AsNfgFile())
</programlisting>

</para>

</sect2>

<sect2 id="api.games.parts">
<title>Objects representing components of a game</title>

<table id="table.game.objects">
<title>Classes representing parts of games</title>
<tgroup cols="2">
<colspec colname="Class">
<colspec colname="Description">
<thead>
<row>
<entry>Class</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>GamePlayer</entry>
<entry>A player in the game (including the chance player)</entry>
</row>
<row>
<entry>GameOutcome</entry>
<entry>An outcome, assigning payoffs to all players</entry>
</row>
<row>
<entry>GameNode</entry>
<entry>A node in an extensive game</entry>
</row>
<row>
<entry>GameInfoset</entry>
<entry>An information set in an extensive game</entry>
</row>
<row>
<entry>GameStrategy</entry>
<entry>A strategy for a player in a strategic game</entry>
</row>
</tbody>
</tgroup>
</table>

<para>
<xref linkend="table.game.objects"> lists the classes which represent
objects defined within a game. As with <classname>Game</classname>,
each of these classes is a smart-pointer class, which references an
internal representation class ending in <classname>Rep</classname>;
e.g., <classname>GamePlayer</classname> is a smart pointer pointing to
an object of class <classname>GamePlayerRep</classname>.
</para>

<para>
In addition to serving the usual purposes of a smart pointer, these classes
also guard against attempting to access objects within a game which no
longer exist.  Consider this example in Python:

<programlisting>
>>> import gambit
>>> myGame = gambit.NewTree()
>>> outcome = myGame.NewOutcome()
>>> myGame.DeleteOutcome(outcome)
>>> outcome.GetLabel()
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in ?
  File "/usr/lib/python2.4/site-packages/gambit.py", line 1096, in GetLabel
    def GetLabel(*args): return _gambit.GameOutcome_GetLabel(*args)
RuntimeError: operating on null object
</programlisting>

Here, we create a variable <varname>outcome</varname> which refers to
an outcome in the game.  This outcome is subsequently deleted from the
game.  After that point, further attempts to reference the object
<varname>outcome</varname> result in an exception.  The C++ equivalent code
fragment would be

<programlisting>
Gambit::Game myGame = Gambit::NewTree();
Gambit::GameOutcome outcome = myGame->NewOutcome();
myGame->DeleteOutcome(outcome);
std::string label = outcome->GetLabel();
</programlisting>

The last line would raise an exception of type
<classname>Gambit::NullException</classname>.
</para>


</sect2>

</sect1>

<sect1 id="api.supports">
<title>Supports</title>

<para>

</para>
</sect1>

<sect1 id="api.profiles">
<title>Behavior and strategy profiles</title>

<para>

</para>
</sect1>

<sect1 id="api.iterators">
<title>Profile iterators</title>

<para>

</para>
</sect1>

</chapter>

