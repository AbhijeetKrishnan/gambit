<chapter id="api">
<title>Overview of the Gambit API</title>

<para>
Gambit is written in C++.  This chapter gives an overview of the underlying 
library of classes which represent and manipulate games.
</para>

<para>
This chapter does not go into exhaustive detail about all functions and
classes implemented in libgambit.  Programmers interested in using the
library in their own applications should consult the Doxygen-generated
source documentation available from the Documentation page of the
Gambit website, as well as the sample programs.
</para>

<para>
Gambit also provides an interface to the library for scripting languages
by the use of SWIG (http://www.swig.org).  Currently, only an interface
for Python (http://www.python.org) is available.  The SWIG wrapper should
be easily modifiable to create interfaces for the other languages
SWIG supports.
</para>

<sect1 id="api.concepts">
<title>General concepts and terminology</title>

<para>
The file <literal>libgambit/libgambit.h</literal> includes all the
header files for all classes and functions.
To help play nice with other libraries, all classes and functions
in libgambit are contained in the namespace <literal>Gambit</literal>.
</para>

<para>
The development of much of Gambit occurred during 1994 and 1995.
As this predates the formal standardization of the Standard Template
Library (and, in fact, C++ itself), as well as other standard libraries
for reusable container and similar classes, Gambit has its own implementation
of some of these classes.  This section outlines those facilities.
In the longer term, the goal is to evolve these classes to be more
compatible with STL and/or with another standard library, and to possibly
migrate fully to such a library.
<xref linkend="table.containers"> lists the generic container
classes provided by the library.
</para>

<table id="table.containers">
<title>Container classes in libgambit</title>
<tgroup cols="2">
<colspec colname="Class">
<colspec colname="Description">
<thead>
<row>
<entry>Class</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>Array</entry>
<entry>A basic bounds-checked array</entry>
</row>
<row>
<entry>List</entry>
<entry>A doubly-linked list</entry>
</row>
<row>
<entry>Map</entry>
<entry>A sorted associative container</entry>
</row>
<row>
<entry>Vector</entry>
<entry>A mathematical vector</entry>
</row>
<row>
<entry>PVector</entry>
<entry>A singly-partitioned vector</entry>
</row>
<row>
<entry>DVector</entry>
<entry>A doubly-partitioned vector</entry>
</row>
<row>
<entry>RectArray</entry>
<entry>A basic bounds-checked rectangular array</entry>
</row>
<row>
<entry>Matrix</entry>
<entry>A mathematical matrix</entry>
</row>
<row>
<entry>SquareMatrix</entry>
<entry>A mathematical square matrix</entry>
</row>
</tbody>
</tgroup>
</table>

<para>
The <classname>Array</classname> and <classname>List</classname> classes
are the basic generic one-dimensional containers; they have identical
interfaces, and as such may be used interchangeably.  Thus,
<classname>List</classname> is similar to the STL's <classname>list</classname>.
<classname>Array</classname> is parallel to STL's 
<classname>vector</classname>; note that Gambit reserves 
<classname>Vector</classname> to represent mathematical objects of
that name (i.e., they are <classname>Array</classname>s which have
the standard mathematical operations defined on them).  The third
generic container is <classname>Map</classname>, which is similar to
STL's <classname>map</classname>, which associates a key to a value.
</para>

<note>
<para>
For historical reasons, and in contrast to STL and indexing conventions
in C, C++, Python, and most languages, the <classname>List</classname>
class starts indexing the first element at one, not zero.  The
<classname>Array</classname> class defaults to this behavior, but allows
any index to be used as the first index.  It is planned to migrate the
library to using zero-based indexing; therefore, it is recommended to
write code as generically as possible, especially using the iterator
idioms provided, to make this migration easier. 
</para>
</note>

</sect1>

<sect1 id="api.games">
<title>Games</title>

<para>
All games, whether represented in extensive or strategic form, are
handled by the C++ classes <classname>Game</classname> and
<classname>GameRep</classname>.  The classes which represent games
and parts thereof uses the pointer-to-implementation (pimpl) idiom.
Client code will generally refer to objects of type
<classname>Game</classname>.  This is a smart-pointer class containing
a pointer to the representation class <classname>GameRep</classname>.
For example, to create a new game with
an extensive (tree) representation in C++, set its title, and print
out that title:

<programlisting>
#include &lt;iostream>
#include "libgambit/libgambit.h"

main()
{
  Gambit::Game myGame = Gambit::NewTree();
  myGame->SetTitle("Hello, World!");
  std::cout << myGame->GetTitle() << std::endl;
}
</programlisting>

Note that the object myGame has pointer semantics.  If it points to
a null or invalid pointer, attempting to dereference it will throw
a C++ exception of class <classname>Gambit::NullException</classname>.
Assignment of one <classname>Game</classname> to another also has
pointer semantics; both objects will refer to the same physical game.
Also, objects of class <classname>Game</classname> handle reference-counting,
which is decremented when the object goes out of scope.  Thus, in the
above example, the game created is automatically deallocated when the
last <classname>Game</classname> referencing it goes away at the end
of main().
</para>

<para>
The parallel code for Python users is

<programlisting>
import gambit

myGame = gambit.NewTree()
myGame.SetTitle("Hello, World!")
print myGame.GetTitle()
</programlisting>
</para>

<para>
Constructing a game in strategic form requires specifying an initial
dimension for the game.  In C++, this is done using an 
<classname>Array</classname> of type <classname>int</classname>. For
a two-player game where the first player has 2 strategies and the second
player 3 strategies, 

<programlisting>
Gambit::Array&lt;int> dim(2);
dim[1] = 2;
dim[2] = 3;
Gambit::Game myGame = Gambit::NewTable(dim);
</programlisting>

In Python, it's a little simpler, since a Python list can be used
directly:

<programlisting>
myGame = gambit.NewTable([2,3])
</programlisting>

</para>

<para>
As just noted, Gambit games can be expressed in either extensive or
strategic representation.  Games in extensive representation can only
be built or modified using functions appropriate to game trees, and
games in strategic representation can only use functions appropriate
to setting the payoffs associated with each strategy vector.
For games in extensive representation, Gambit
can compute the reduced strategic representation.  This is done
by calling <function>BuildComputedValues</function> on the
game object.  The computed reduced strategy sets are cached internally
until any structural changes in the game tree are made, at which point
the cached values are cleared and <function>BuildComputedValues</function>
must be called again to compute the revised reduced strategic
representation.
Note that the size of the reduced strategic representation
of a game may increase very rapidly, so think carefully about building
the reduced strategic representation for games of nontrivial size; 
it is generally recommended to analyze extensive games directly
in the extensive form where possible.
</para>

<para>
After building a game, it is generally recommended to call
<function>Canonicalize</function> on the game.  This function
renumbers the nodes and information sets in the game in a regular way,
such that two identical games will always have their elements numbered
the same way, irrespective of the order of operations used to construct
them.
</para>

<para>
Games can also be read from a file.  A typical C++ usage might be

<programlisting>
Gambit::Game myGame;

try {
  std::ifstream f("mygame.efg");
  myGame = Gambit::ReadGame(f);
}
except (Gambit::InvalidFileException) {
  // report the error condition here
}
</programlisting>

In the Python version, <function>ReadGame</function> takes a 
string with the file contents, not the file object itself, and (currently)
failure results in an <classname>RuntimeError</classname>:

<programlisting>
try:
  myGame = gambit.ReadGame(file("mygame.efg").read())
except RuntimeError:
  # handle here
</programlisting>

</para>

</sect1>

<sect1 id="api.supports">
<title>Supports</title>

<para>

</para>
</sect1>

<sect1 id="api.profiles">
<title>Behavior and strategy profiles</title>

<para>

</para>
</sect1>

<sect1 id="api.iterators">
<title>Profile iterators</title>

<para>

</para>
</sect1>

</chapter>

