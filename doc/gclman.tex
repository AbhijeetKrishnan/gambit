%
% FILE: gclman.tex -- source for GCL manual
%
% $Id$
%

%\documentclass{book}
%\usepackage{widetext,multicolumn,chicagob}

\documentstyle[widetext,multicol,chicagob]{book}
%\columnsep .31in
%\columnseprule .02in
\renewcommand{\baselinestretch}{.9}
\newcommand{\bd}{\begin{description}}
\newcommand{\ed}{\end{description}}
\input{psfig}
\newcommand{\tindex}[1]{{\tt #1}\index{{\tt #1}}}
\newcommand{\bindex}[1]{{\bf #1}\index{#1}}
\newcommand{\rindex}[1]{{#1}\index{#1}}
\makeindex

% stuff for lex 
% to put dictionary style headers in function ref sections

\newcommand{\lex}[1]{\mark{#1}\index{{\tt #1}}}

\makeatletter
\def\ps@lexicon{\def\@oddhead{\slshape\mysectionname\hfil 
{\Large\verb+\botmark+}\quad\thepage}
\def\@evenhead{\thepage\quad{\Large\verb+\firstmark+}\hfil \slshape\mysectionname}}
\makeatother

\newcommand{\mysectionname}{\thesection\,\, BUILT-IN FUNCTIONS}

% end stuff for lex


\begin{document}


\title{GAMBIT COMMAND LANGUAGE\thanks{This is part of the Gambit
Project, which was funded in part by National Science Foundation
grants SBR-9308637 and SBR-9617854 to the California Institute of
Technology and SBR-9308862 to the University of Minnesota.  We are
also grateful to the Intel Corporation for computer equipment grants
to California Institute of Technology that facilitated this project}}

\author{Richard D. McKelvey\\California Institute of
Technology
\and
Andrew McLennan\\University of
Minnesota
\and 
Theodore Turocy\\Northwestern University
\and
Gary Wu\\California Institute of Technology
}

\date{Version 0.96\\ \today\\ \jobname.tex}

\maketitle

\tableofcontents

\chapter*{Preface}
\addcontentsline{toc}{chapter}{Preface}
\pagestyle{myheadings}
\markboth{Preface}{Preface}

The Gambit Project is a project for the development of computer code
for the solution of extensive and normal form games.  The software
developed under the project is public domain.  The Gambit Project is
funded in part by National Science Foundation grants SBR-9308637 and
SBR-9617854 to the California Institute of Technology and SBR-9308862
to the University of Minnesota.

Numerous students at Caltech and the University of Minnesota have
contributed to the Gambit Command Language and to the Gambit Project
more generally: Among these are Bruce Bell, Anand Chelian, Matthew
Derer, Nelson Escobar, Ben Freeman, Eugene Grayver, Todd Kaplan, Geoff
Matters, Brian Trotter, Michael Vanier, and Rob Weber. We are
particularly grateful to Eugene Grayver for setting up and maintaining
our Web site, and for his extensive work on the related GUI and PXI
programs.  

\chapter{Introduction}
\pagestyle{headings}

This document describes the Gambit Command Language (GCL).  Gambit is
a library of computer program that allows one to build, manipulate,
and solve finite extensive and normal form games. The GCL provides a
method of directing the operation of Gambit that is analagous to that
of a high level general purpose programming language.

The purpose of the GCL is to provide a simple, but powerful and
flexible language by which one can perform complicated or repetitive
operations and procedures on games in extensive or normal form.  The
language has facilities for building and editing an extensive or
normal form game, converting back and forth between the extensive and
normal form representations, and solving the resulting games for
various equilibria of interest.  Standard arithmetic, logic, text and
input-output operations are provided, as well as vectorizable
functions which support many vector and matrix operations.  Flow
control statements allow for repetitive operations (such as
investigating games as one changes various parameters) or conditional
operations.  Thus the GCL is also suitable for certain types of
econometric analysis of games.


\section{\rindex{Installation}}
All of the gambit files can be found at the Gambit World Wide Web site
at

\begin{verbatim}
http://www.hss.caltech.edu/~gambit/Gambit.html
\end{verbatim} 

\noindent Instructions on downoading and installation as well as a
list of platforms supported can be obtained there.  Source code is
also available at the same location. 

After you have installed the GCL, you can start it on unix systems by
typing the name of the GCL executable file (usually \verb+gcl+) at the
command line prompt.  On Windows systems, you can start it by double
clicking on its icon.

When the GCL starts, it first looks for the initialization file
\verb+gclini.gcl+, which is a file containing GCL commands, including
commands to load the standard user defined functions that are
documented in this manual.  If the file cannot be found, a warning
will be issued.  Control is then turned over to you, and you will
receive the GCL prompt

\begin{verbatim}
GCL1:= << 
\end{verbatim}

\noindent The interpreter is ready for your first command.  Note that
your prompt may be different from the above depending on settings in
your \verb+gclini.gcl+ file.  

\subsection{Command line editing}\index{Command line!Editing}

You can edit the command line by using the arrow keys. The left and
right arrow key move the cursor, the back space or delete key can be
used to delete characters, and the typing characters will enter the
characters in insert mode. The up and down arrow keys can be used to
recall previous lines.  

\subsection{Meaning of the prompt}\index{Prompt}
\index{Command line!Prompt}

The GCL prompt is of the form \verb+GCLnn:= <<+.  The prompt is
actually part of the GCL command, and can be deleted or modified by
the command line editor if so desired.  The \verb+<<+ part of the
command is the short form of the \verb+Print+ command, which causes
the evaluation of the command line to be echoed to the
console. Backspacing over this part of the command will supress
output.  The \verb+GCLnn:=+ part of the command saves the evaluation
of the command line to the variable \verb+GCLnn+.  Backspacing over
this will prevent saving of the output into a variable.

\section{\rindex{Technical support} and \rindex{bug reports}}

User feedback is an important part of Gambit's development cycle.  Our
design choices have been motivated in large part by our experiences
and by some of the potential uses of the software we have imagined.
But this is by no means complete, and so we are eager to hear from
you, Gambit's users, to find out what features are particularly
useful, and in what areas future releases might be improved.

The authors may be contacted via email at {\tt
gambit@hss.caltech.edu}.  This address will forward a copy of your
message to the development team.  While a personal reply may not
always be possible, we will read all correspondence and apply as many
suggestions as possible to our future releases.

Although we have made every effort to ensure the reliability and
correctness of the code, it is certain that errors of varying degrees
of severity exist.   If you experience problems with the software,
send us email at {\tt gambit@hss.caltech.edu} describing your problem.

When reporting a bug, it is important to include the following
information:

\begin{itemize}
\item the version number
\item the platform(s) on which the problem occurred
\item as complete a description of the circumstances of the problem as
possible, including a sequence of steps which reproduces the problem
\end{itemize}
 
\noindent 
Without this information, it will be difficult for us to
identify the source of the problem to correct it.

At this time, no formal technical support mechanism exists for Gambit.
As time permits, we will make every effort to answer any and all
questions pertaining to the program an its documentation.

We hope you will find Gambit a useful tool for research and
instruction.

\chapter{Basic concepts}

\section{Design principles}
The design motifs for GCL come from two principal families of
programming languages.  The first is traditional imperative
programming languages such as Pascal, C, and Modula-3.  In particular,
the GCL's concept of types draws heavily from these languages,
although the number of predefined types in GCL is much larger due to
the specialized nature of the language.  The second is more
specialized programming languages such as Mathematica, from which the
GCL's grammar is partially drawn.  Users with experience using any of
these languages should find the GCL easy to learn; however, no
programming experience is necessary to begin using the language
effectively.

The GCL is a language designed primarily for building, solving and
doing econometric analysis of non-cooperative games.  Because the GCL is a
specialized language, it has several features that are designed to
make computing as easy and flexible as possible in this kind of
environment.  Some of the main features of the GCL are:

\begin{itemize}
\item {\bf Specialized built-in data types with implicit typing: }

The GCL has a number of specialized built-in data types to represent
various parts of games. For example for extensive form games, there
are built in data types to represent players, strategies, nodes in an
extensive form game tree, information sets, actions, outcomes,
behavior strategy profiles, and an entire extensive form game.
These data types are used internally by the GCL to organize
computation, and keep track of important features of the objects that
these data types represent.

Despite the large number of specialized data types, the GCL uses {\it
implicit typing}.  Implicit typing means that you never have to
explicitly declare what the data type of a variable is before you use
it.  Variables can thus be easily created in an interactive mode to
refer to any object that is a valid data type, and to save
intermediate steps of computations on these data structures.

\item {\bf Everything is a function: }

Almost every statement in the GCL is built up from function calls.
Briefly, a function in the GCL is a procedure that takes objects of
specified data types, and uses them to construct and return an object
of a (possibly different) specified data type.  The GCL provides a set
of \bindex{Built-In Functions} (BIFs), which are documented in the
function reference section of this manual.  

The GCL provides functions that construct simple objects of any given
data type, and other functions that operate on objects of given data
types to modify them or create a new object that is guaranteed to be a
valid object of the given data type.  A GCL program typically consists
of using output from one function as input to a second, whose output
is then used as input to the next, and so on.  In this way, very
complicated objects, such as extensive form games, can be built, all
the while guaranteeing their internal consistency.  In this fashion,
one can construct any valid extensive form game, and (barring bugs) it
is impossible in the GCL to construct an invalid extensive form game.

In addition to the built-in functions, the GCL also allows you to
construct your own functions, which have exactly the same behavior as
any built-in function (listablity, recursion, optional arguments,
and accessible via online help)

\item {\bf Listability: } 

Many objects of interest in game theory are {\it sets} (the set of
players, of information sets for a player, of actions for an
information set, etc.)  All objects in the GCL (including lists) can
be put in lists.  Further, when a GCL function (with a few exceptions
noted in the Function reference section) is called with a list for
one of its arguments, the function is run ``listably''.  This means
that the function is executed for each element of the list and
generates a list (or nested list) of the corresponding dimension as
output.  This makes it quite easy to generate objects of game
theoretic interest.  It also makes it easy to perform certain
repetitive operations usually performed by flow control statements.
\end{itemize}

\section{\rindex{Data Types}}

The built-in data types for the GCL are give in Table 1.  The Table is
divided into four sections. The data types in the first section are
standard data types that are supported in many languages.  The data
types in the next two sections are more specialized data types that
are used to represent elements of normal and extensive form games,
respectively.  The last section contains only one type, lists, which
play an important role in the GCL. 

The data types ({\tt INTEGER}, 
%{\tt ASSESSMENT}),  
and {\tt EFBASIS} are {\bindex subtypes}
of another, parent type.  They are indicated in the table as the
indented entries following their parent type.  A subtype is a data
type which has all of the properties of its parent type, plus some
additional characteristics.  For example, an integer is a rational
number, with the additional restriction that its denominator is one.

\begin{table}[htp]
\begin{center}
\begin{tabular} {|l||l|} \hline
Type name	& Description \\ \hline
\tindex{BOOLEAN} 	& boolean \\
\tindex{NUMBER} 	& floating-point or rational number \\
\tindex{  INTEGER} 	& \verb+NUMBER+ that is an integer \\ 
\tindex{TEXT}	& string of arbitrary length \\
\tindex{INPUT}	& input stream \\
\tindex{OUTPUT}	& output stream \\ 
\hline
\tindex{NFG}	& normal form game \\
\tindex{NFPLAYER}	& a player in a normal form game \\
\tindex{STRATEGY}	& a strategy in a normal form game \\
\tindex{NFOUTCOME}      & an outcome in a normal form game \\
\tindex{NFSUPPORT}	& a support of strategies in a normal form game \\
\tindex{MIXED}	& a mixed strategy profile for a normal form game \\ 
\hline
\tindex{EFG}	& extensive form game \\
\tindex{EFPLAYER}	& a player in an extensive form game \\
\tindex{NODE}	& a node in an extensive form game \\ 
\tindex{INFOSET}	& an information set in an extensive form game \\
\tindex{ACTION}	& an action at an information set \\
\tindex{EFOUTCOME}	& an outcome in an extensive form game \\
\tindex{EFSUPPORT}	& a support of actions in an extensive form game \\
\tindex{  EFBASIS}	& an \verb+EFSUPPORT+ that is a basis for an assessment \\
\tindex{BEHAV}	& a behavior strategy profile for an extensive form
game \\ 
%\tindex{  ASSESSMENT}	& a \verb+BEHAV+ that is an assessment \\
\hline
\tindex{LIST(T)}	& a list of objects of type T (T is any data type)\\ 
\hline
\multicolumn{2}{c}{\ }\\
\multicolumn{2}{c}{Table 1}\\
\multicolumn{2}{c}{GCL Supported Data Types}\\
\end{tabular}
\end{center}
\end{table}
The remainder of this section details the rules concerning the
standard types \tindex{BOOLEAN}, \tindex{NUMBER},
\tindex{TEXT}, \tindex{INPUT} and \tindex{OUTPUT}, as well as general
rules for typing.  The extensive form and normal form types, and their
related types, are detailed later in special sections.

\subsection{Boolean}
The \tindex{BOOLEAN} type is used to represent the boolean values.
The \tindex{BOOLEAN} type is implemented in tri-state logic,
and has the three values ``true'' and ``false'' and ``unknown''.  The
command language predefines three constants to represent these,
\tindex{True} and \tindex{False}, and \tindex{Unknown}

\subsection{Numeric Data types}

The GCL supports one basic numeric data type, \verb+NUMBER+, with a 
subtype of \verb+INTEGER+.

\begin{itemize}
\item \bindex{Number}

The \tindex{NUMBER} type may contain numbers whose internal
representation is either floating point or rational.  The internal
representation of the number is referred to as the \bindex{precision}
of the number.  Whether the precision of the number is floating point
or rational depends on how the number is initially input.  It can be
input either as a floating point constant, or a rational constant.

Floating point numbers are implemented as the machine's
double-precision floating point type.  Computation with these numbers
is subject to rounding of least significant digits, and hence these
numbers can be imprecise; for example, operations usually associated
with being inverses of each other may not be with floating point
numbers. However, since arithmetic operations on floating point
numbers are typically implemented in hardware, the {\tt Float}
precision is frequently used when speed is important.

Rational numbers are implemented as the ratios of two arbitrary-length
integers. Rational numbers are capable of precisely representing any
rational number, and arithmetic operations on rationals are exact.
However, arithmetic operations on rational numbers are implemented in
software.  Hence, computations with rational numbers can be slow, and
output from them may be unreadably large.

Floating point constants are represented in the GCL by any string of
digits (where a digit is an element of \verb+{0,1,2,3,4,5,6,7,8,9}+)
containing exactly one decimal point (\verb+.+).  Rational constants
are represented in the GCL by andy string of digits containing at most
one division sign (\verb+/+).  Any \verb+NUMBER+ in the GCL is assumed
to be in base ten representation.

\item \bindex{Integer}

The \tindex{INTEGER} type is a subtype of \verb+NUMBER+ consisting of
numbers of rational precision, whose denominator is one.  

\end{itemize}

Since the GCL uses implicit data typing, the data type of a numeric
constant must be identifiable by the way it is written.  Hence, when
you write a numeric constant, keep the following in mind.  Floating
point constants must include exactly one \verb+.+ in them.  Rational
constants must have at most one \verb+/+ in them, and integer
constants must have neither of the above. Thus, to represent the
number \verb+2+ as a floating point \verb+NUMBER+, you would write
\verb+2.+, and to represent it as a rational \verb+NUMBER+, you would
use \verb+2+ or \verb+2/1+, and to represent it as an integer
\verb+NUMBER+, you would use \verb+2+.

\subsection{Text}

The \tindex{TEXT} type is used to store text strings, typically labels
for parts of games.  It is generally encouraged to label various
elements of games in the command language for ease of identification;
however it is not required.  To specify a {\tt TEXT} constant,
surround the text with double-quote characters ({\tt "}).  Constants
may span more than one input line.  Also, line feeds can be explicitly
included in text constants using the \verb+C+-style notation of
\verb+\n+. 

\subsection{Input and Output}

\begin{itemize}
\item\bindex{Input}

The \tindex{INPUT} type is a reference to an input stream, generally a
file on disk.  Its principal use is to read in external data.  The
constant, \tindex{StdIn}, is used to refer to the standard input stream
(generally the console).  New \verb+INPUT+ streams are created with
the function \tindex{Input}, documented in the Function Reference
section.

\item {\bf Output}

The \tindex{OUTPUT} type is a reference to an output stream, generally a
file on disk.  Its principal use is as a logging file for writing
formatted output from an extended command language job.  The
constants \tindex{StdOut} and \tindex{NullOut} refer to the standard
output stream (generally the console) and the null output stream (the
garbage can), respectively.  New \verb+OUTPUT+ streams are created with the 
function \verb+Output+, documented in the Function Reference section.
\end{itemize}

\subsection{Normal form data types}

The data type \tindex{NFG} is used to represent a normal form game.  No
other normal form data type can exist independently of the normal form
game to which it belongs.  The \tindex{NFPLAYER} and \tindex{STRATEGY}
data types are used to represent players and strategies in a normal
form game.  A \tindex{NFOUTCOME} is an outcome for a normal form game,
and an \tindex{NFSUPPORT} represents a support for a normal form
game, which is a collection of sets of admissible strategies, one for
each player.  Finally a \tindex{MIXED} is a mixed strategy profile over
an arbitrary support.

There are no constants of any normal form data type.  Objects that are
of any of the normal form data types must be built up using functions
in the GCL.  Hence, a more detailed discussion of them is deferred
until later.  

\subsection{Extensive form data types}
The data type \tindex{EFG} is used to represent an extensive form
game.  As with normal form games, no other extensive form data type
can exist independently of the extensive form game to which it
belongs.  The \tindex{EFPLAYER} represents a player in an extensive
form game.  The types \tindex{NODE}, \tindex{ACTION},
\tindex{INFOSET}, \tindex{EFOUTCOME} represent the corresponding parts
of the extensive form representation of the game.  A \tindex{BEHAV} is
a behavior strategy profile 
%and a \tindex{ASSESSMENT} is an assessment
for an extensive form game. 
%An \verb+ASSESSMENT+ is a subtype of \verb+BEHAV+, which in addition
%to specifying a behavior strategy, specifies non null beliefs for all
%information sets in the game.  
An \tindex{EFSUPPORT} represents a
support for a behavior strategy in an extensive form game, which is a
collection of sets of admissible actions (at least one for each
information set of each player).  An \verb+EFBASIS+ is a subtype of
\verb+EFSUPPORT+, representing a support for an assessment in an
extensive form game. This is a collection of sets of admissible
actions together with a collection of sets of admissible members of
information sets (at least one member for each information set).

As with normal form games, there are no constants of any extensive form
data type.  Objects that are of any of extensive form data types must
be built up using functions in the GCL.  Hence, a more detailed
discussion of them is deferred until later.

\subsection{\rindex{Lists}}

The \tindex{LIST(T)} data type can be used to represent lists of any
data type \verb+T+ (including \verb+T=LIST(R)+, where \verb+R+ is any
data type).  Lists are represented in GCL statements by including
objects of a given data type in curly braces and separated by commas.
For example, the following is how to represent a list containing the
first five integers:

\begin{verbatim}
{ 1, 2, 3, 4, 5 }
\end{verbatim}

\noindent 
The data type \verb+T+ of a list is determined by the data type of its
first element.  All other elements of the list must be of the same
type as the first element.  The only exception to this rule is that
subsequent elements can be listed to a different depth than the first
element.  For example if \verb+T+ is a basic data type, then then the
second and subsequent elements of a \verb+LIST(T)+ can be of type
\verb+LIST(T)+ or \verb+LIST(LIST(T))+, etc.  Similarly, the second
and subsequent elements of a \verb+LIST(LIST(T))+ can be of type
\verb+T+.  

We refer to the elements at the bottom levels of a nested list as the
\bindex{basic elements} of the list.  Then lists can be of heterogeneous
depth.  However, lists must be of homogeneous type. In other words,
all basic elements of the list must be of the same type.  Hence,

\begin{verbatim}
{ 1, { 2, 3 }, 4 }
\end{verbatim}

\noindent 
is a legal list of type \verb+LIST(NUMBER)+, since all the basic
elements are of type {\tt NUMBER}, and 

\begin{verbatim}
{ { 2.0, 3/2 }, 1, 4 }
\end{verbatim}

\noindent 
is a legal list of type \verb+LIST(LIST(NUMBER))+.  On the other
hand, 

\begin{verbatim}
{ 1, { 2, "3" }, 4 }
\end{verbatim}

\noindent 
is not a legal list, since the second element of the nested list is
not a {\tt NUMBER}.

Lists are distinct in type from each other and from their scalar
equivalents.  That is to say, {\tt LIST(BOOLEAN)} is a distinct data
type from {\tt LIST(NUMBER)}, and is also a distinct data type from
{\tt NUMBER}.
 
\subsection{Conglomerate data types}

In some of the function prototypes in the Function Reference section,
you will notice certain data types which are not listed as supported
data types in the section on GCL data types. These are referred to as
\bindex{Conglomerate data types}. Conglomerate types are not actually
data types, but are names used in GCL function prototypes to represent
subsets of data types.  Following is a list of the conglomerate data
types along with the types they include:

\medskip
\begin{center}
\begin{tabular} {|l|l|}
\hline 
Conglomerate Type & Includes \\
\hline
\tindex{ANYTYPE} & Any type except \verb+LIST+ \\ 
\tindex{NLIST(T)} & Nested \verb+LIST(T)+ of any depth \\ 
& i. e., \verb+LIST(LIST( ... LIST(T) ...))+\\
\verb+T*+ & \verb+T+, or Null value of type \verb+T+ \\ 
\hline
\end{tabular}
\end{center}
\medskip

\noindent
Here \verb+T+ could be any data type except \verb+LIST+


\section{\rindex{Expressions}}
A GCL program consists of a series of expressions.  An expression is
typically a GCL command built up out of function calls. 
Expressions can be
entered interactively, at the command prompt, or can be entered from
files, via the \verb+Include["filename"]+ directive (see the section
on including files).  

Expressions are terminated by an end-of-line character (the carriage
return) at a point where all brackets, braces, and quotes are matched
(cloed).  Expressions can be explicitly continued on additional lines
by using the continuation character, \verb+\+.

Comments can be
included in GCL statements by preceeding the comments with the
characters \verb+//+.  Anything after the \verb+//+ and before a
linefeed is ignored by the GCL interpreter.

Some statements can lead to computations which may take a long time to
complete.  A control-C, typed at the console, is used to halt
execution of the GCL and return to the command prompt.  Note that the
effect of a control-C may not always be immediate, as the control-C is
only polled for at convenient stages during computation.

\section{\rindex{Functions}}

Functions in the GCL are rules for taking objects of specified data
types, and using them to construct and return an object of a (possibly
different) specified data type.  All statements in the GCL are built
up out of function calls.  In this section, we desribe the rules for
using functions in the GCL.

A function call consists of the name of a function followed (if the
function has parameters) by a list of parameters to the function,
enclosed in brackets.  Functions return a value, which may in turn
be used as a parameter to another function call, allowing more complex
computations to be expressed.

Functions in the GCL can be either built-in or user defined.  Also
functions can either require arguments or not.  This leads to four
combinations.  We label these as follows

\medskip
\begin{center}
\begin{tabular} {|l||c|c|} 
\hline
Description & Built-in & Parameters\\ 
\hline
Constant & Yes & No \\ 
Built-In Function (BIF) & Yes & Yes \\ 
Variable & No & No \\ 
User Defined Function (UDF) & No & Yes \\ 
\hline
\end{tabular}
\end{center}

\subsection{\rindex{Constants}}

The simplest type of a function in the GCL is a constant.  A constant
is a built-in function that has no arguments, and returns the same
value whenever it is called.  How to construct constants for the basic
data types is described in the section on data types.  Some examples
of constants follow:

\medskip
\begin{center}
\begin{tabular} {|l|l|} 
\hline
Data Type & Constant \\ 
\hline
\verb+BOOLEAN+  & \tindex{True},  \tindex{False} \\
\verb+NUMBER+ (rational precision) & \verb+1+, \verb+-1234567/563+ \\
\verb+NUMBER+ (float precision)  & \verb+1.+,  \verb+-1.234567+ \\
\verb+TEXT+  & \verb+"Help"+ \\
\verb+OUTPUT+  & \tindex{StdOut}, \tindex{NullOut} \\
\verb+INPUT+  & \tindex{StdIn} \\
\hline
\end{tabular}
\end{center}
\medskip

You typically don't think of a constant as a function, but it is.  It
is a function with no arguments, whose name is the constant itself.
You can ``execute'' a constant by simply typing its name.  When you do
so, it returns a value, corresponding to the object that the constant
represents.  

You are now ready to write your first GCL program:

\begin{verbatim}
GCL1:= << "Help"
"Help"
\end{verbatim}

It is important to note that like all functions in the GCL, constants
have a data type, which is determined by the ``function name''.  If
you try and use a \verb+NUMBER+ constant, say \verb+123+, where a
\verb+TEXT+ or other data type is expected, you will get an error.

\subsection{\rindex{Variables}}

A variable is like a constant in that it has no arguments.  It stores
one object of a particular data type, and returns it when called. The
difference between a constant and a variable is that a variable must
be created before it can be used, and once it is created, it can be
deleted or redefined if you want.  To create a new variable, or to
redefine an existing variable, one can use the built-in function,
\tindex{Assign}, which has the prototype:
\begin{verbatim}
Assign[name->TEXT, value<->T] =: T
\end{verbatim}
\noindent 
for any type \verb+T+.  (How to read a function's prototype is
described in more detail in the section of function calls.  For now,
suffice it to say that \tindex{Assign} takes two parameters, the first of
which is the name of the variable, and the second of which is the
value to be assigned to the variable.)  The variable name can be any
string of alphanumeric characters (\verb+a-z+, \verb+A-Z+, or
\verb+0-9+) beginning with a letter.  So, to create a variable with
name \verb+x+ which returns the \verb+NUMBER+ \verb+1+, we can use
\verb+Assign+ as follows:
\marginpar{Assign BIF is not defined.  Fix this section}

\begin{verbatim}
GCL1:= << Assign["x",1]
1
\end{verbatim}


\noindent 
The \tindex{Assign} function also has an infix operator form, written
{\tt :=}.  In this form, the quotes are not needed around the variable
name, and the function is not ``listable'' (see the section on Lists,
later in this chapter).  So, equivalently, and more compactly,

\begin{verbatim}
GCL1:= << x := 1
1
\end{verbatim}

The {\tt Assign} function can be used to either create a new variable or
modify an existing one.  However, it cannot be used to change the type
of a variable.  Consider the calls

\begin{verbatim}
y:=2
y:=3
y:="3"
\end{verbatim}
\noindent The first call creates a new variable {\tt y} of type {\tt
NUMBER}, with value of \verb+3+.  The second modifies \verb+y+ to
have value \verb+3+.  Since the new assignment does not change the
type of \verb+y+, this command is fine.  The third statement attempts
to change the data type of \verb+y+.  This statement will result in an
error, since {\tt Assign} cannot be used to change the type of a
variable.  To change the data type of a variable, it must first be
deleted, and then reassigned.  

An existing variable may be deleted by the use of the \tindex{UnAssign}
function, with the following prototype:

\begin{verbatim}
UnAssign[name->TEXT] =: BOOLEAN
\end{verbatim}

\noindent After \verb+UnAssign+ is called on a variable, the variable
is no longer defined.  A subsequent call of {\tt Assign} may redefine
the variable to be of any type.  \verb+UnAssign+ has a short form of
\verb+:=+ followed immediately by a linefeed or semicolon.  Hence, if
\verb+y+ is a variable of type \verb+BOOLEAN+ you can change it to
\verb+NUMBER+ with value \verb+3.0+ in two steps as follows:

\begin{verbatim}
y:=
y:= 3.0
\end{verbatim}  

\subsubsection{\rindex{Global and Static Variables}}\index{Variables!Scope}

Variables in the GCL are by default only visible in the the part of
the program in which they are defined.  In otherwords, a variable
defined outside of a function will not be visible inside a GCL
function (unless it is passed by reference), and a variable defined in
a function will not be visible from outside the function.  Secondly,
variables defined inside a function are deallocated when control
leaves the function.  Thus, when a function is called a second time,
variables defined within that function will not ``remember'' the
values they were assigned in the last call to the function.  

To modify the default scope and visibility of variables, the GCL uses
the prefix \verb+$+ in a variable name to represent a ``static''
variable\index{Variables!Static} and the prefix \verb+$$+ to represent
a global variable\index{Variables!Global}.  A static variable
is only visible in the function in which it is defined, but remains
allocated after program control leaves the function, and retains its
last value when the function is called again.  A global variable
remains allocated and visible when control passes to any function.  The
following example illustrates the use of static variables:

\begin{verbatim}
NewFunction[Foo[x->NUMBER]=:NUMBER,If[!IsDefined[$y],$y:=x];$y;];
GCL2:= << Foo[3]
3
GCL3:= << Foo[2]
3
\end{verbatim}

\noindent
and the following illustrates the use of global variables:

\begin{verbatim}
$$x:=5
NewFunction[Foo[],$$x;];
GCL1:= << Foo[]
5
\end{verbatim}


\subsection{\rindex{Built-In Functions}}\index{Functions!Built-In}

Built-in functions in the GCL are just like the mathematical notion of
a function.  They are rules which associate with each point in the  
domain, a point in the range.  In the case of the GCL functions, each
function has a list of arguments.  Each argument must be of a specific
data type.  A point in the domain is specified by specifying a value
of the correct data type for each argument of the function.  

To execute a GCL function you write the function name, followed
(if the function is not a constant) by a comma separated list of the
arguments, enclosed in square brackets.  

All of the built-in functions in the GCL are listed in the Function
Reference section of the manual.  For each function, the \bindex{function
prototype} is listed.  The function prototype is a template that is
used to remind you of the correct syntax for each function.  

A function call consists of the name of a function, and a list of
parameters upon which the function is to operate.  Functions return a
value, which may in turn be used as a parameter to another function
call, allowing more complex computations to be expressed.

A simple example of a function call is

\begin{verbatim}
Plus[x->1, y->2]
\end{verbatim}

This calls the function named \tindex{Plus}, with parameter \verb+x+ set
to the value 1 and \verb+y+ set to the value 2.  Since {\tt Plus} is
the function for addition of two integers, the value returned would
be, as you might expect, 3.

In the addition example above, we called a function which is listed in
the function reference as

\begin{verbatim}
Plus[x->NUMBER, y->NUMBER] =: NUMBER
\end{verbatim}

\noindent This listing of a function is called its {\it prototype}.  
It contains the function's name, its list of parameters, and its return
value.  In this case, the function {\tt Plus} takes two parameters, the
first named \verb+x+ and taking a value of type {\tt NUMBER} and the
second named \verb+y+ and taking a value of type {\tt NUMBER}, and
returns a value of type {\tt NUMBER}.

Because the parameters have explicit names, it is possible to rearrange
the order in which parameters are listed when a function is called.
Thus, we could write out sample call equivalently as

\begin{verbatim}
Plus[y->2, x->1]
\end{verbatim}

\noindent and achieve the same effect.

Explicitly specifying the formal names for parameters all the time
will prove tedious and can hinder readability.  For these reasons, it is
also legal to specify parameters without their associated formal names.
These are called passing {\it anonymous} parameters.  Our addition
example could thus also be written

\begin{verbatim}
Plus[1, 2]
\end{verbatim}

When used without specifying the formal names, however, function
calls are restricted to specifying parameters in exactly the same
order as listed in the function prototype.  In our example, the GCL
interpreter would have no way of distinguishing whether we meant 1 to
be the value of \verb+x+ or the value of \verb+y+, and vice versa.
While in the case of addition we may flip the values of the parameters
without having an effect on the result, in general this is not the
case.

It is permitted to mix the two styles of parameter specification,
subject to the following rules:

\begin{itemize}
\item All anonymous parameters must be specified before any named
parameters
\item No parameters may be omitted in the anonymous parameter list.
If $k$ parameters are specified anonymously, they must match
one-for-one the first $k$ parameters in the function's prototype.
\item Once a named parameter has been specified, all succeeding
parameters must be named, even if the first named parameter appeared
in the same place in the parameter list as it does in the prototype.
\end{itemize}

\noindent Therefore, it would be legal to write

\begin{verbatim}
Plus[1, y->2]
\end{verbatim}

\noindent but

\begin{verbatim}
Plus[x->1, 2]
\end{verbatim}

\noindent is illegal since it violates the third condition.

To be more precise, the function {\tt Plus} comes in several different
variations listed in the function reference:

\begin{verbatim}
Plus[x->NUMBER, y->NUMBER] =: NUMBER
Plus[x->TEXT, y->TEXT] =: TEXT
Plus[x->MIXED, y->MIXED] =: MIXED
Plus[x->BEHAV, y->BEHAV] =: BEHAV 
\end{verbatim}

\noindent This is a good example of function {\it overloading}.  This
means that one function name may have several possible parameter
lists, sometimes called {\it signatures}.  The GCL interpreter is
capable of determining which version of the function to use by
analyzing the names and types of the parameters used.

Since a function may have multiple signatures, it is conceivable that
a function call might be ambiguous, in the sense that its parameters
match more than one signature for that function.  However, no function
call that is complete may be ambiguous from the way that signatures
have been chosen for the predefined functions.  Any function call
flagged by the interpreter as ambiguous must be missing at least one
parameter.

Some functions have parameters which are optional, in the sense that
they need not be specified in order to call the function.  These
parameters are indicated in the function's prototype by being
surrounded by curly braces.  (Note that these braces should not be
included in the function call when specifying an optional parameter.)
If an optional parameter is left unspecified in a function call, a
default value is assumed, as given in the function's documentation.

For a function, all required parameters always precede any optional
parameters.  Optional parameters may also be specified anonymously,
subject to the above rules on parameter specification.

All parameters so far have been passed by {\it value}, that is, a copy
of the value of the parameter is given to the function to which it is
passed.  These parameters may not be modified by the function.  It is
also possible to have parameters to a function passed by {\it
reference}.  This means that the function does not receive a copy of
the value, but rather the memory location of the value itself.  Thus,
the function may modify the value of a parameter passed by reference.

The symbol for passing a parameter by reference, both in a function's
prototype and in a function call, is {\tt <->}.  Constants may not be
passed by reference.  Reference parameters may be specified
anonymously just like a value parameter, subject to the usual rules.
It is a run-time error to attempt to pass a value to a reference
parameter, or vice versa.

In the case where functions have parameters which are subtypes, 
it is preferred to match to the subtype over the parent type.  For example,
suppose the following two signatures have been defined:

\begin{verbatim}
Foo[x->INTEGER] =: INTEGER
Foo[x->NUMBER] =: NUMBER
\end{verbatim}

Then, a call of \verb+Foo[3]+ resolves to the first signature (since the
value passed is an integer), and \verb+Foo[3.5]+ resolves to the second
(since it is a number, but not specifically an integer).

\subsection{\rindex{User defined functions}}\index{Functions!User Defined}

As GCL programs become more and more complex, frequently there are
complicated operations which must be performed repeatedly.  The
command language therefore supports user-defined functions, which
allow for defining sections of code which may be called later.

A new function can be created using the function \tindex{NewFunction}.
For example, one might define a function to compute the absolute value
of an {\tt NUMBER} as such:

\begin{verbatim}
NewFunction[Abs[n->NUMBER],
  If[n > 0, n, If[n < 0, -n, 0]];
];
\end{verbatim}

\noindent After defining the \verb+Abs+ function, it may be called in
exactly the same way a system-supplied predefined function may.  The
return value of the function is the value of the last statement
executed.

Parameter type matching rules apply to user defined functions in
exactly the same way as to predefined functions.  From the function's
point of view, the parameter list is a list of variables on which
assignments are automatically done at the beginning of the function
execution.  So, taking the \verb+Abs+ example above, in executing the
call

\begin{verbatim}
Abs[42]
\end{verbatim}

\noindent an assignment \verb+n := 42+ is implicitly performed before
the body of the function is executed.

It is also possible to pass variables by ``reference'' to a
user-defined function in the same way as a predefined function.  In
this case, the function's ``local'' variable is stored in the same
physical location in the computer, and modifying the value locally
also takes effect on the variable passed to the function.  For
example, it might be useful instead to define \verb+Abs+ as:

\begin{verbatim}
NewFunction[Abs[n<->NUMBER],
		 If[n > 0, n, If[n < 0, n := -n, 0]]]
\end{verbatim}

\noindent in which case the function would still return the absolute
value of \verb+n+, but also modify the variable passed to \verb+n+ to
be the absolute value of the input \verb+n+.  So,

\begin{verbatim}
q := -37;
Abs[q]
\end{verbatim}

\noindent would result in the variable \verb+q+ containing the value
37 at the conclusion of execution.

Each function has its own ``scope'', or set of variables.  Within a
function body, the only variables which are visible are those which
are declared in the parameter list of the function (this is \verb+n+
in the \verb+Abs+ example above), and those which are created during
the function's execution.  That is, no ``global'' or outside variables
may be accessed directly by the function.  For example, if the user
typed in the following:

\begin{verbatim}
i := 4;
NewFunction[FooFunc[x->NUMBER], x * i]
\end{verbatim}

\noindent later execution of the \verb+FooFunc+ would yield an
``undefined variable i'' error message, since \verb+i+ is never
defined within the function.  If instead \verb+FooFunc+ had been
defined as follows:

\begin{verbatim}
NewFunction[FooFunc[x->NUMBER], i := 13, x * i]
\end{verbatim}

\noindent \verb+FooFunc+ would always return 13 times the value of the
parameter \verb+x+, since the value of \verb+i+ inside \verb+FooFunc+
is always 13, regardless of the value of \verb+i+ outside of the
function.

\section{Aliases for function calls}\index{Short forms}

There are several functions which are so commonly used that special
``short forms'' are defined for them.  We already saw one example with
the function \verb+Assign+, which has the short form \verb+:=+.  Most
functions with short forms are the standard arithmetic and logic
operators, for which the usual binary infix or unary prefix notations
are supported.  The example of addition used in a previous section may
more familiarly be written

\begin{verbatim}
1 + 2
\end{verbatim}

\noindent which expression is converted to the ``long form'' function
call by the interpreter.  Note that formal names may not be specified
in a ``short form'' call, and the order of parameters is therefore
significant.

Here is a list of the functions thus abbreviated, and their ``short
form'' equivalents:

\medskip
\begin{multicols}{2}
\begin{verbatim}
And[x,y]            x && y, x AND y 
Assign[x,y]         x := y 
Concat[x,y]         x \ y 
Divide[x,y]         x / y
Dot[x,y]            x . y 
Equal[x,y]          x = y 
Greater[x,y]        x > y 
GreaterEqual[x,y]   x >= y
IntegerDivide[x,y]  x DIV y 
Less[x,y]           x < y 
LessEqual[x,y]      x <= y 
Minus[x,y]          x - y 
Modulus[x,y]        x % y, x MOD y 
Not[x]              NOT x, !x 
NotEqual[x,y]       x != y 
NthChar[text,n]     text[[n]], text_n 
NthChild[node,n]    node#n  
NthElement[list,n]  list[[n]], list_n
Or[x,y]             x || y, x OR y 
Parentheses[x]      (x) 
Plus[x,y]           x + y 
Power[x,y]          x ^ y 
Print[x]            << x
Read[in,x]          in >> x 
Times[x,y]          x * y 
UnAssign[x]         x:=
Write[out,x]        out << x 
\end{verbatim}
\end{multicols}

When functions are written in their canonical forms, no ambiguity
arises in the order of evaluation: In order to evaluate a function,
all arguments must be evaluated first.  Arguments are evaluated from
left-to-right as specified in the function call.  This leads to a
recursive structure of evaluation, which stops only when an argument
being evaluated is a constant function (i. e., a function with no
arguments).

When short form forms are used, then ambiguity can arise in the
intended order of evaluation.  For example, the statement \verb&a + b
* c&, could be meant as \verb+Plus[a,Times[b,c]]+ or as
\verb+Times[Plus[a,b],c]+.  In order to resolve such ambiguities, all
functions that have a short form representation are given an order of
precedence.  When a statement is parsed by the GCL, it is first
scanned from left to right, replacing each short form expression at
the top level of precedence with its canonical form.  Then it is
scanned again replacing each short form expression at the second level
of precedence with its canonical form, and so on, until all short form
expressions have been eliminated.

The order of precedence for built-in functions is as follows:

\begin{center}
\begin{verbatim}
()
:=
>> <<
||
&&
NOT
= != < <= > >=
+ - &
* . / DIV MOD ^
(unary) + -
[[ ]] _ 
\end{verbatim}
\end{center}

Thus, the statement \verb&a + b * c& would become 
\begin{verbatim}
Plus[a,b*c]
Plus[a,Times[b,c]]
\end{verbatim}

\noindent
On the other hand, the statement \verb&( a + b ) * c& would become 
\begin{verbatim}
Parentheses[a+b]*c
Parentheses[Plus[a,b]]*c
Times[Parentheses[Plus[a,b]],c]
\end{verbatim}

\noindent
which, since \tindex{Parentheses} is just the identity mapping, is
equivalent to
\begin{verbatim}
Times[Plus[a,b],c]
\end{verbatim}

\medskip

\section{Getting and suppressing console output}\index{Output!console}
\index{Console output}

The GCL will only print output at the console if you explicity ask for
it with the built-in function \tindex{Print}.  This function has the
prototype \verb+Print[x->T] =: T+ for any data type \verb+T+, and has
the short form \verb+<< x+.  You may have noticed that the GCL prompt
concludes with a \verb+<<+.  In fact, this is not part of the prompt,
but rather is a ``pre-typed'' part of your GCL command.  

Once you have become accustomed to the GCL, you may prefer to supress
output from some or all commands typed at the GCL command line.  This
can be done for individual commands by using the backspace or delete
keys to erase the \verb+<<+  part of the prompt.  The
built-in function \tindex{SetVerbose} controls whether \verb+<<+ is
pretyped at every prompt.  The command \verb+SetVerbose[False]+ will
turn off this feature, so that your prompt will then look as
follows:

\begin{verbatim}
GCL1:= 
\end{verbatim}

Now, the default is that no output is printed.  If you want to have
the output of specific commands printed, then you can start your
command with \verb+<<+.  For example

\begin{verbatim}
GCL1:= 1+1
GCL2:= << 1+1
2
\end{verbatim}

Note that error messages will be reported at the console regardless of
the setting of the verbose mode.


\section{\rindex{Lists}}

\subsection{Building and modifying lists}\index{Lists!building}\index{Lists!modifying}
Lists play a special role in the GCL.  Variables can be created to
contain lists in the same fashion as for any other data type:  

\begin{verbatim}
list:={1,{2,3},4}
\end{verbatim}

The built in function \verb+List[x,n]+\index{List} can be used to
create a list of length \verb+n+ all of whose elements have the value
\verb+x+.  For numeric data types, a third parameter for \verb+List+
allows each successive entry to be incremented.

\begin{verbatim}
GCL1:= << List["Help",3]
{ "Help", "Help", "Help" }
GCL2:= << List[List[0,3],3]
{ { 0, 0, 0 },
  { 0, 0, 0 },
  { 0, 0, 0 } }
GCL3:= << List[0/1, 5, 1/4]
{ 0, 1/4, 1/2, 3/4, 1 }
\end{verbatim}

\noindent
Lists of any data type can be created with \verb+List+.  So if
\verb+n+ is a normal form game, then \verb+List[n,5]+ is a list of $5$
copies of \verb+n+.

The function \verb+NthElement[list,n]+\tindex{NthElement} can be used
to get \verb+n+th element of the list, \verb+list+.  This function has
two short forms, \verb+list[[n]]+ and \verb+list_n+.  Since the
function returns the \verb+n+th element of the list, it can be used
recursively to get the elements of nested lists.  So \verb+list_i_j+
returns the \verb+j+th element of the \verb+i+th element of
\verb+list+.  Also, since \verb+list+ is passed by reference, the
function can be used to modify the corresponding element of a list.
Thus, you can constuct your own $3\times 3$ identity matrix as
follows:

\begin{verbatim}
GCL1:= list:=List[List[0,3],3]
GCL2:= list_1_1:=list_2_2:=list_3_3:=1;
GCL3:= << list
{ { 1, 0, 0 },
  { 0, 1, 0 },
  { 0, 0, 1 } }
\end{verbatim}


\subsection{\rindex{Listability} of functions}\index{Functions!listability}

Almost all of the functions in the GCL are ``listable''.  This means
that if there is a version of the function which takes a type \verb+T+
as the data type for a parameter, then it can be called with
\verb+LIST(T)+ as well.  This results in the function generating a
list of the corresponding length and data type as its output.  For
example, consider a function

\begin{verbatim}
Foo[x->T,y->S] =: R
\end{verbatim}

\noindent
where \verb+T+, \verb+S+, and \verb+R+ represent arbitrary data types.
Then if \verb+a+ is a \verb+LIST(T)+, and \verb+b+ is of type
\verb+S+, then \verb+c := Foo[a,b]+ generates \verb+c+ of type
\verb+LIST(R)+, where the length of \verb+c+ is equal to the length of
\verb+a+, and where \verb+c[[i]] = Foo[a[[i]],b]+.

If \verb+Foo[]+ is called with both \verb+a+ and \verb+b+ being lists
of the correct data type, then the GCL checks whether the length of
\verb+a+ and \verb+b+ is the same.  If not, it generates a
dimensionality error. If they are of the same dimension, then \verb+c
:= Foo[a,b]+ generates \verb+c+ of type \verb+LIST(R)+, where the
length of \verb+c+ is equal to the length of \verb+a+, and where
\verb+c[[i]] = Foo[a[[i]],b[[i]]]+.

Note that the above rules implicitly define versions of \verb+Foo[]+
of the following forms:

\begin{verbatim}
Foo[x->LIST(T),y->S] =: LIST(R)
Foo[x->T,y->LIST(S)] =: LIST(R)
Foo[x->LIST(T),y->LIST(S)] =: LIST(R)
\end{verbatim}

The same rules apply recursively using these function prototypes as
well.  So if \verb+a+ is of type \verb+LIST(LIST(T))+, and \verb+b+ is
of type \verb+S+, the command \verb+c := Foo[a, b]+ results in a
listable call to \verb+Foo[x->LIST(T),y->S]+.  Thus, \verb+c+ is of
type \verb+LIST(LIST(R))+, where \verb+c[[i]] = +
\verb+Foo[a[[i]],b]+.  Hence, \verb+c[[i]][[j]] = +
\verb+Foo[a[[i]][[j]],b]+.

Note that many vector and matrix math operations follow directly as
listable calls to the basic arithmetic functions.  In this example,
listability of \verb+Times+ is used to provide scalar multiplication
of a scalar and a matrix, and listability of \verb+Plus+ is used to
add two conformable matrices:  

\begin{verbatim}
GCL1:= a:={{1,2},{3,4}};
GCL2:= << 2*a
{{2,4},{6,8}}
GCL3:= << a+Transpose[a]
{{2,5},{5,8}}
\end{verbatim}

Here listability of \verb+Power+ is used to create a list of the first
ten perfect squares:

\begin{verbatim}
GCL4:= << List[1,10,1]^2
{ 1, 4, 9, 16, 25, 36, 49, 64, 81, 100 }
\end{verbatim}

While most functions in the GCL are listable, there are some
exceptions.  Built-in functions that are not listable are noted as
such in the Function Reference section of this document.

Listability of functions is a powerful tool of the GCL. Many GCL
programs using flow control statements can be written using listable
function calls instead.  It is encouraged to use listable functions as
much as possible because it typically leads to more concise, easier to
read GCL programs, and in addition the programs typically run
faster than they would if flow control satements were used instead.
This is because listable calls to functions are executed in compiled
code, while flow control statements are executed in interpreted code.

\section{Online documentation}\index{Documentation}

The functions \tindex{Help} and \tindex{Manual} are used to obtain online
documentation of any function in the GCL, including user defined
functions that you created with the \verb+NewFunction+ command. 

If the \verb+Help+ function is called with a string that is an exact
match for a GCL function name, then it returns a list of function
prototypes for that function name (there can be more than one
prototype for a function name since GCL functions can be overloaded.)
For example,

\begin{verbatim}
GCL1:= << Help["help"]
{ Help[x->TEXT, {udf->True}, {bif->True}] =: LIST(TEXT) }
\end{verbatim}

\noindent
returns the function prototype for \verb+Help+: Note that \verb+Help+
has two optional \verb+BOOLEAN+ parameters, \verb+udf+ and \verb+bif+.
By default, both user defined functions and built-in functions are
included in the search.  To exclude one or the other of these, set the
corresponding parameter to \verb+False+.

The required text parameter for \verb+Help+ can also contain the
regular-expression style wildcards \verb+*+ and \verb+?+.  In this
case, if there is not an exact match, a list of function names
matching \verb+x+ is returned.  For example, The command 

\begin{verbatim}
GCL1:= << Help["*efg"]
{ CompressEfg, LoadEfg, NewEfg, SaveEfg }
\end{verbatim}

\noindent
returns a list of all function names ending with ``efg''

Note that the function \verb+Help+ is listable (see section on
listability), so that we can do \verb+Help[Help["*efg"]]+ to get a
list of function prototypes for all functions whose names end with
\verb+efg+.  Similarly, \verb+Help["*"]+ gives a list of all function
names in the GCL, and {\tt Help[Help["*"]]} gives a list of all
function prototypes in the GCL.

If \verb+Manual+ command is used to obtain a more complete description
of a GCL function.  If \verb+Manual+ is called with an argument that
is an exact match for a GCL function name, it returns the manual entry
for that function.  For a built-in function a textual description of
the function and its parameters is returned. 

\chapter{Advanced topics}

\section{\rindex{Including files}}

The function \verb+Include[file->TEXT]+\index{Include} is used to
insert the contents of the file given into the input stream, as if
they had been typed directly by the user.  This can be particularly
useful in conjunction with user defined functions, in that a library
of useful functions can be constructed and included into the program
asily.

The \verb+Include+ directive may only appear at the ``top level'' of
the program.  That is to say, it cannot be used inside a loop,
function declaration, or expression.  However, files may be nested
arbitrarily deep using {\tt Include}, so you can include a file which
in turn includes other files.
  
When a file is included, the GCL looks for a file with that name in
the following locations, in order.  
\begin{enumerate}
\item The current directory.
\item The directory specified by the \verb+HOME+ environment variable, if any.
\item The directory specified by the \verb+GCLLIB+ environment variable, if any.
\item The directory where the executable is located.
\end{enumerate}

This search order applies also to the \verb+gclini.gcl+ file that is
loaded whenever the GCL is started.  Hence, you can keep a standard
version of a file that is frequently included in the same directory as
the GCL executable, and then modify it for use on a particular project
by keeping a modified copy of it in the directory associated with that
project.  

It is good practice to have included files identify themselves when
they are included. This can be done by using the
\verb+GetPath[]+\index{GetPath} function, which returns the full
pathname of the file from which the command is executed.  For example,
if the following line is placed as the first line in an included file
(say with filename \verb+path/myfile.gcl+)

\begin{verbatim}
StdOut << "Include[\""&GetPath[]&"\"]\n"
\end{verbatim}

\noindent
(Note that the standard escape sequences \verb+\"+ and \verb+\n+ are
used within a text string to represent a quotation mark and a carriage
return, respectively.)  Then when the file is included, it will identify
itself by writing the following message to the standard output stream:

\begin{verbatim}
Include["path/myfile.gcl"]
\end{verbatim}


\section{\rindex{Flow control} structures}

The GCL contains three functions which allow flow control within a
program.  These functions are ``special'' in that their parameters are
evaluated in a special way (since their parameters are expressions and
sequences of statements); they also have no ``formal'' names for their
parameters.

\subsection{Conditional execution with \tindex{If}}\index{Flow control!If}

The function \verb+If[]+ allows execution of a sequence of statements
only under certain conditions.  The syntax of the function is

\begin{verbatim}
If[boolean-expression, statement-list {, statement-list}]
\end{verbatim}

\noindent The function is interpreted as follows: If the
\verb+boolean-expression+ evaluates to \verb+True+, then the first
list of statements is executed.  If it evaluates to \verb+False+, and
the second (optional) list of statements is present, that list is
executed; if it is not present, the If[] expression evaluates to \verb+False+.
For example, the statement

\begin{verbatim}
If[i = 2, j := 1, j := 2]
\end{verbatim}

\noindent sets \verb+j+ to \verb+1+ if the value of \verb+i+ is
\verb+2+, and sets \verb+j+ to \verb+2+ if the value of \verb+i+ is
not \verb+2+.  It would also be perfectly legitimate to write

\begin{verbatim}
If[i = 2, j := 1]
\end{verbatim}

\noindent in which case \verb+j+ would be set to \verb+1+ if \verb+i+
is equal to \verb+2+, but if \verb+i+ were not \verb+2+, the expression
evaluates to \verb+False+.

This last example brings up an important note about conditional
execution.  Statements which appear in a branch of an \verb+If+
statement which is not taken are treated as if they did not exist.
So, were this the first mention of \verb+j+ in this scope, the last
example would leave \verb+j+ defined only if \verb+i+ was equal to
\verb+2+.  However, \verb+j+ would {\em not} be defined otherwise.  It
is therefore necessary to be careful in constructing \verb+If+
statements which result in the definition of new variables.

\subsection{Repetitive execution with \tindex{While}}\index{Flow control!While}

Often in writing programs it is necessary to execute a block of
statements repeatedly, usually with different values for variables.
To this end the GCL provides a special function \verb+While+ as a
generalized looping construct.  The syntax of the function is

\begin{verbatim}
While[boolean-expression, statement-list]
\end{verbatim}

The function is interpreted as follows: While
\verb+boolean-expression+ evalutes to \verb+True+, execute the
statements in \verb+statement-list+.  Note that the evaluation of the
boolean takes place at the beginning of the execution of a block, so
it is only important whether the value is \verb+True+ or \verb+False+
at the beginning of the block, and not at some point in the middle.

This simple loop creates a list of the first ten perfect squares: 

\begin{verbatim}
i := 1;
list := { };
While[i <= 10, list := list & { i^2 }; i := i + 1;]
\end{verbatim}

As with \verb+If+, be wary of declaring a variable implicitly inside a
loop.  A variable is declared only when the corresponding statement is
executed; so, if the \verb+boolean-expression+ is \verb+False+ the
first time it is evaluated, the body of the loop never executes, and
no variables which appear in the loop are considered to be defined.

\subsection{Indexed looping with \tindex{For}}\index{Flow control!For}

The function \verb+For+ is a specialized looping construct, useful
mostly in cases where some index variable is used to iterate a list or
some sequence.  The general syntax for \verb+For+ is

\begin{verbatim}
For[statement-list, boolean-expression, statement-list, statement-list]
\end{verbatim}

\noindent The call is interpreted as follows:
\begin{itemize}
\item Execute the statements in the first \verb+statement-list+ (this
is called the {\em initialization}).
\item Evaluate the \verb+boolean-expression+ (called the {\em guard}).
\item If the \verb+boolean-expression+ is \verb+False+, terminate the
loop and continue with the first statement after the loop.  If it is
\verb+True+, execute the third \verb+statement-list+, called the {\em
body} of the loop.
\item Execute the second \verb+statement-list+, called the {\em
increment}, and return to the evaluation of the guard.
\end{itemize}

Returning to the example in the \verb+While+ section, we see another
way of writing the loop to create a list of the first ten squares:

\begin{verbatim}
For[i:=1; list:={}, i<=10, i:=i+1, list:=list&{i^2}]
\end{verbatim}

\noindent The two methods are completely equivalent, but it is often
more convenient to use the structure afforded by the \verb+For+
function.

\section{\rindex{Input} and \rindex{Output}}

Data can be read from an input stream by the \tindex{Read} function.
So if \verb+in+ is an input stream (i. e., of type \verb+INPUT+) then
a successful call of \verb+Read[in,x]+ will read the exposed data (see
function reference for definition of ``exposed data'') from the input
stream, \verb+in+, assign \verb+x+ to have that type and value, and
position the file pointer at the end of the exposed data, to be ready
for the next call of \verb+Read[]+.  \verb+Read[in,x]+ has the short
form \verb+in >> x+.  Since the return value of \verb+Read[in,x]+ is
\verb+in+, these commands can be chained.  In other words,

\begin{verbatim}
in >> x >> y
\end{verbatim}
 
\noindent
is equivalent to 

\begin{verbatim}
Read[in,x]
Read[in,y]
\end{verbatim}

\noindent
In the statement \verb+Read[in,x]+, if \verb+x+ is undefined, then its
data type is determined from the exposed data in the input stream.  On
the other hand if \verb+x+ is previously defined, then the
\verb+Read[]+ function will expect to find the corresponding data type
in the input stream, and a file read error will be generated if the
exposed data is of the wrong data type.  If \verb+x+ is previously
defined to be a \verb+LIST(T)+, then \verb+Read[in,x]+ will
successively read elements into each element of the list.  If the
wrong data type is found for any element of the list, a file read
error will be returned.  Thus, if the file \verb+"file.out"+ contains
the following data

\begin{verbatim}
25 1/3 "This is a text string!" False 3.14159 
{{1, 0},{0, 1}}
1 2 3 4 5
\end{verbatim}

\noindent
then the following GCL code

\begin{verbatim}
in:=Input["file.dat"]
x:=List[0,5]
in >> i >> r >> t >> b >> f >> l >> x
\end{verbatim}

\noindent
opens an input stream, consisting of the file \verb+"file.dat"+, and
then reads data from the input stream into the corresponding
variables.  After the last statement, 
\verb+i+ is an \verb+NUMBER+ with value \verb+25+, 
\verb+r+ is a \verb+NUMBER+ with value \verb+1/3+, 
\verb+t+ is a \verb+TEXT+ with value \verb+"This is a text string!"+, 
\verb+b+ is a \verb+BOOLEAN+ with value \verb+False+, 
\verb+f+ is a \verb+NUMBER+ with value \verb+3.14159+, 
\verb+l+ is a \verb+LIST(LIST(NUMBER))+ with value \verb+{{1,0},{0,1}}+, and 
\verb+x+ is a \verb+LIST(NUMBER)+ with value \verb+{1,2,3,4,5}+.  

Data can be written to an output stream by the use of the
\tindex{Write} function.  Thus, the following commands

\begin{verbatim}
out:=Output["file.out"]
x:=0/1;y:={0.0,0.0}
Write[out,x]
Write[out,y]
\end{verbatim}

\noindent
creates an output stream, \verb+out+, and then writes out a
\verb+NUMBER+, followed by a list of two \verb+NUMBER+s.
\verb+Write[out,x]+ has the short form \verb+out << x+.  Since the
return value of \verb+Write[]+ is \verb+out+, these commands can be
chained.  So the two lines writing out \verb+x+ and \verb+y+ in the
above example could be written instead

\begin{verbatim}
out << x << y
\end{verbatim}

The \tindex{Format} and \tindex{ListFormat} functions can be used to
control the formatting of data written to an output stream.  Note that
the \tindex{Read} and \tindex{Write} functions are not listable.

The \verb+Read[]+ and \verb+Write[]+ functions can only be used with
certain data types (see function documentation).  Reading and writing
of \verb+EFG+ and \verb+NFG+ from external files can be done with the
\tindex{LoadEfg}, \tindex{SaveEfg}, \tindex{LoadNfg} and
\tindex{SaveNfg} functions.

\section{\rindex{Null values}}

Certain function calls in the GCL result in either invalid or
undetermined values for the required data type. Examples would be
asking for the first child node of a terminal node, or the parent of
the root node, or an outcome attached to a node with no outcome.
Similar problems arise in the algorithmic and computational parts of
the code.  Here, for example, algorithms that do not compute
sequential equilibria do not return belief probabilities for unreached
information sets.  Other algorithms may action probabilities for off
the equilibrium path information sets undetermined.  

Under certain situations such as the above, when no valid value is
available for return, instead of returning an error, the GCL will
a Null value for the given type.  Returning a Null value instead of
terminating execuation with an error message is frequently desirable
in a setting where functions are being called listably, as it allows
for computation of elements of the list that have valid entries
without aborting the GCL because some elements have invalid entries.  

The situations in which Null values are returned are described in the
function reference section of the manual.  Most functions in the GCL,
when encountering a Null value as a parameter, will abort with an
error message.  Whether a function will accept Null values as valid
values for an argument is indicated in the function prototype with an
asterisk (\verb+*+) after the relevant parameter.  For example, the
function prototype for \tindex{IsNull} is

\begin{verbatim}
IsNull[x->T*]=:BOOLEAN
  for any data type, T
\end{verbatim}

Here, the \verb+*+ indicates that this function accepts Null values
for its argument.  If a built-in function accepts Null values for an
argument, it is documented in the function reference section what the
behavior of the function is when encountering a Null value.  

Note that user defined functions  will accept Null values for
arguments also, if the relevant parameter is designated with a
\verb+*+, as above. 

\section{\rindex{System information} and commands}\index{System commands}

There are several commands in the GCL that allow you to get
information from or run processes on the host system.  

A series of functions, \tindex{StartWatch}, \tindex{StopWatch},
\tindex{ElapsedTime} provide information on the amount of cpu time
used by the GCL, and can be used to time computation.  

Another series of functions, \tindex{GetEnv}, \tindex{SetEnv},
\tindex{UnSetEnv}, \tindex{Platform}, allow you to set and check
environment variables, or check the operating system that the GCL is
running on.

A third series of functions, \tindex{ExePath}, \tindex{GetPath}, and the
UDF, \tindex{GambitExe}, provide path and filenames to files being used
by or related to the GCL.

Finally, the \tindex{Shell} command allows you to run a child process on
the GCL.  

The above system functions are also used in the user defined function
\tindex{Display}, which allows you to start a child process that brings
up the Gambit GUI to view a graphics display of an extensive or normal
form game. If \verb+game+ is a variable of type \verb+NFG+ or
\verb+EFG+, then the command \verb+Display[game]+ will display the
\verb+game+ in the GUI.\footnote{The user defined functions
\verb+GambitExe+ and \verb+Display+ assume that you used the default
directories and filenames when you installed Gambit.  If you deviated
from the standard installation, you may have to edit these UDFs
before they work correctly.}

\section{\rindex{Orphan variables} and memory management}

In the GCL, you
can create variables to represent objects which may be deleted or
invalidated because of subsequent things you do. For example, suppose
you define a variable to represent an element (node, information set,
outcome, etc) of an extensive form game.  You may subsequently delete
the part of the tree that contains that element.  The object that the
variable originally referred to is no longer valid.  In such a case,
we call the variable an {\bf orphan variable}.

The basic rule in the GCL is that when a variable becomes an orphan,
it is unassigned.  Thus, situations can arise when you have defined a
variable, but when you later try and use that variable, you will find
that it is undefined.  

In the following example, a game is loaded, and the variable \verb+n+
is defined to be the first child of the first child of the root node.
Now the part of the tree after the first branch is deleted, the
variable \verb+n+ is now undefined:

\begin{verbatim}
GCL1:= e:=LoadEfg["poker.efg"]
GCL2:= r:=RootNode[e]
GCL3:= n:=r#1#1
GCL4:= DeleteTree[r#1]
GCL5:= << n
GCL: Parameter 1 undefined in call to Print
\end{verbatim}

\noindent
Since the node is no longer is valid, the variable \verb+n+ which
refers to it must be deleted.  A similar situation occurs here if some
element of a list becomes an orphan:

\begin{verbatim}
GCL1:= e:=LoadEfg["poker.efg"]
GCL2:= t:=TerminalNodes[e]
GCL3:= DeleteTree[RootNode[e]#1]
GCL4:= << t
GCL: Parameter 1 undefined in call to Print
\end{verbatim}

In this case, a variable \verb+t+ is defined to refer to the list of
terminal nodes.  The \tindex{DeleteTree} command deletes some of the
terminal nodes.  Even though some of the nodes in the list \verb+t+
are still valid, the rule currently used by the GCL for orphan
variables is that if any element of a list becomes an orphan, the
entire list is undefined.  

Similar situations arise with mixed and behavior strategies if the
underlying game to which they refer change in a way to invalidate the
solutions.  In the following example, a solution to the game \verb+e+
is saved as a variable \verb+b+ of type \verb+BEHAV+.  

\begin{verbatim}
GCL1:= e:=LoadEfg["poker.efg"]
GCL2:= << b:=EnumMixedSolve[e]_1
(Behav) { { 1.000 0.000 }{ 0.333 0.667 } }{ { 0.667 0.333 } }
GCL3:= DeleteTree[RootNode[e]#1]
GCL4:= << b
GCL: Parameter 1 undefined in call to Print
\end{verbatim}

The game is subsequently edited, making the solution no longer valid
for the changed game.  At this point the solution becomes an orphan,
and the variable that refers to it is unassigned.  

\section{\rindex{Errors}}

Sometimes, programs contain errors.  The interpreter is able to detect
errors which violate rules of the language, and reports information
about the error so the user can correct it.  There are two main
classes of errors which may arise in GCL programs: parse errors and
run time errors.

A parse error occurs when the GCL interpreter cannot determine the
meaning of a statement, because it does not conform to the grammatical
rules of the language.  This most frequently occurs when braces,
brackets, or quotation marks fail to match up or when punctuation is
missing.  When it encounters a parse error, the GCL interpreter will
display an error message giving the filename and line number of the
error and the point at which it determined an error it occurred.

A run time error occurs when a statement which obeys the grammatical
rules of the language violates another rule of the language during its
execution.  Examples of this type of error include attempting to use a
variable name which is not defined, and using a value of one type
where another type was expected.  Also, builtin functions may generate
this type of error on invalid inputs.  A run time error will result in
termination of the GCL at the point where the error occurs, with a
message indicating the type of error encountered.

\chapter{Building and Modifying Games}

The whole point of the GCL is to provide an environment to enable
building and doing computations on games.  This chapter describes how
to build and solve normal and extensive form games in the GCL.  

\section{\rindex{Normal form games}}

A normal form game is a set of $n$ players, each with a strategy
set, together with a function from the cartesian product of strategy
sets to a set of outcomes. Each outcome results in a payoff to each of
the players.  To construct a normal form game, one must therefore
define each of these parts.  A series of GCl functions are available
for building and editing normal form games.  A complete list is given
in the sections on ``Normal Form Manipulation'' in the Categorical
Function Reference section of the manual.  Some of the more important
functions are given in Table 2.  User defined functions are preceded
with a \#, and all other functions are built in functions.  

\begin{table}[htp]
\begin{center}
\begin{tabular} {|l||l|} \hline
Function Name	& Description \\ 
\hline
\verb+  DeleteOutcome[o]+ &Deletes outcome \verb+o+ from its game. \\

\verb+  NewOutcome[n]+ &Returns a new outcome for the game \verb+n+\\ 
\verb+# NewOutcome[n, name]+ &Returns a new oucome named \verb+name+ for game \verb+n+ \\ 
\verb+# NewOutcome[p]+ &Attaches a new outcome with zero payoffs to
the pure profile \verb+p+\\ 

\verb+  Outcome[p]+ &The outcome attached to the pure strategy profile \verb+p+\\ 

\verb+  OutcomeForm[n]+ &The game form for game \verb+n+\\ 

\verb+  Outcomes[n]+ &List of outcomes defined for game \verb+n+\\ 

\verb+  SetOutcome[p, o]+ &Attach outcome \verb+o+ to pure strategy profile \verb+p+\\ 

\verb+  NewNfg[dim]+ &A new normal form with dimensions \verb+dim+\\ 
\verb+# NewNfg[dim, True]+ &A new normal form with dimensions \verb+dim+, outcomes in all cells\\ 

\verb+  Nfg[e]+ &Converts extensive form game \verb+e+ to normal form\\ 
\verb+# Nfg[x]+ &Converts nested list of numbers \verb+x+ to normal form\\ 

\verb+  Payoff[o, pl]+ &Payoff of outcome \verb+o+ to player \verb+pl+\\ 
\verb+  Payoff[m, pl]+ &Payoff of mixed profile \verb+m+ to player \verb+pl+\\ 

\verb+# Payoffs[p]+ &Payoffs of pure strategy \verb+p+\\ 
\verb+# Payoffs[n]+ &Normal form game payoffs of \verb+n+ as a nested list\\ 
\verb+# Payoffs[o]+ &Payoffs of outcome \verb+o+\\ 
\verb+# Payoffs[m]+ &Payoffs of mixed profile \verb+m+ \\ 

\verb+# Strategies[pl]+ &Strategies for player \verb+pl+\\ 
\verb+# Strategies[n]+ &Strategies for game \verb+n+ \\ 

\verb+  SetPayoff[o, pl, pay]+ &Set payoff to player \verb+pl+ in outcome \verb+o+ to \verb+pay+\\ 

\verb+# SetPayoffs[p, pay]+ &Attach new outcome to pure profile \verb+p+ with payoffs \verb+pay+\\ 
\verb+# SetPayoffs[o, pay]+ &Set payoffs of outcome \verb+o+ to vector \verb+pay+.  \\ 
\hline
\multicolumn{2}{c}{\ }\\
\multicolumn{2}{c}{Table 2}\\
\multicolumn{2}{c}{Normal form Building and Editing Functions}\\
\end{tabular}
\end{center}
\end{table}
\medskip


\subsection{Creating a normal form game}\index{Normal forms!creating}

The function \tindex{NewNfg} is used to create a new normal form game.
Thus, the command

\begin{verbatim}
GCL1:= NewNfg[{2,3,2}]
\end{verbatim}

\noindent 
will create a new normal form game with three players, where the first
player has two strategies, the second player has three strategies, and
the third player has two strategies.  Since no outcomes have been
defined, all strategy $n$-tuples of pure strategies result in the
``null'' outcome, which has payoff of zero for all players.  

The game created by \verb+NewNfg+ is not very interesting, because all
payoffs for all strategies are zero.  To make it more interesting,
outcomes must be created and associated with strategy $n$-tuples.  To
create a separate outcome for each pure strategy, one can specify the
second argument in \verb+NewNfg+ to be \verb+TRUE+.  These outcomes
will still have zero payoffs until they are changed. The function
\verb+Randomize+ can be used to randomize the payoffs of each outcome
in the game.  In this way, \verb+NewNfg+ can be used to create
more interesting games by using it as an argument to other functions
that accept Normal form games as arguments.

For example to create a random two person $2\times 2$ normal form
game, with a seed of \verb+34+ for the random number generator, you can
use the function \tindex{Randomize} to randomize the payoffs of the
original game.

\begin{verbatim}
GCL2:= Randomize[NewNfg[{2,2},True],34]
\end{verbatim}  

\noindent
You can look at the payoffs of the game by using the standard UDF,
\tindex{Payoffs}:

\begin{verbatim}
GCL3:= << Payoffs[Randomize[NewNfg[{2,2},True],34]]
{ { { 0.159964, 0.026784 }, { 0.421515, 0.399322 } },
  { { 0.233245, 0.923402 }, { 0.039071, 0.695271 } } }
\end{verbatim}  

\noindent
Here, the payoffs are written in a nested list, where the
\verb+(i,j)+th component is the vector of payoffs when player 1 takes
strategy \verb+i+ and player 2 takes strategy \verb+j+.  The game can
be solved for all mixed Nash equilibrium by

\begin{verbatim}
GCL4:= << AllNash[Randomize[NewNfg[{2,2},True],34]]
{ (Mixed) { 1.000000 0.000000 }{ 0.000000 1.000000 },
  (Mixed) { 0.000000 1.000000 }{ 1.000000 0.000000 },
  (Mixed) { 0.379795 0.620205 }{ 0.839199 0.160801 } }
\end{verbatim}

In all of the above examples, all work is thrown out, and the normal
form game is created anew in each successive command.  You can avoid
such wasteful computation, and minimize the typing you need to do by
saving intermediate results in a variable.  For example, the above
could be done as follows:

\begin{verbatim}
GCL1:= n:=Randomize[NewNfg[{2,2},True],34];
GCL2:= p:=Payoffs[n];
GCL3:= m:=EnumMixedSolve[n];
\end{verbatim}

The first statement creates a variable \verb+n+ to store the normal
form game.  This variable is then used as an argument in the next two
function calls.  The second two statements create variables \verb+p+
and \verb+m+ to store the nested list of payoffs of the game, and the
list of mixed strategy solutions of the game.  Any of these variables
can then be used as input to other function calls, as long as the data
type of the variable is the same as the data type of the 

The above also illustrates another important principle of the GCL.
All of the functions in the GCL (with a few exeptions, noted in the
Function Reference Section) return objects of some specific data type.
Any object returned by a function can be stored in a variable.  While
the GCL supports a large number specialized data types, the data
typing is all implicit.  In other words, you never have to declare
what data type a variable will be before it is used.  A variable takes
on the data type of the object that is first assigned to it.    

\subsection{Setting payoffs and modifying a normal form
game}\index{Normal forms!payoffs}  

The payoffs in a normal form can be set to have specific values using
the \tindex{SetPayoff} command.  The following sequence of statements
illustrates how to build a simple prisoner's dilemma game, by first
creating a normal form game of the correct dimension, and then
modifying the payoffs one by one.  

\begin{verbatim}
GCL1:= n:=NewNfg[{2,2}]
GCL2:= s:=Strategies[n]
GCL3:= NewOutcome[{s_1_1,s_2_1},{9.0,9.0}]
GCL4:= NewOutcome[{s_1_1,s_2_2},{0.0,10.0}]
GCL5:= NewOutcome[{s_1_2,s_2_1},{10.0,0.0}]
GCL6:= NewOutcome[{s_1_2,s_2_2},{1.0,1.0}]
GCL7:= << Payoffs[n]
{ { { 9.000000, 9.000000 }, { 0.000000, 10.000000 } },
  { { 10.000000, 0.000000 }, { 1.000000, 1.000000 } } }
\end{verbatim}

Note that the above can be done equivalently and more simply by using
the standard UDF, \tindex{Nfg} to create the game directly from a payoff
list:

\begin{verbatim}
GCL1:= n:=Nfg[{{{9,9},{0,10}},{{10,0},{1,1}}}]
GCL2:= << Payoffs[n]
{ { { 9.000000, 9.000000 }, { 0.000000, 10.000000 } },
  { { 10.000000, 0.000000 }, { 1.000000, 1.000000 } } }
\end{verbatim}

\noindent
You can name the strategies if you want by using \tindex{Strategies} to
get a list of the strategies in the game, and \tindex{SetName} to name
them.

\begin{verbatim}
GCL3:= s:=Strategies[n]
GCL4:= SetName[s_1,{"Cooperate","Defect"}]
GCL5:= SetName[s_2,{"Cooperate","Defect"}]
GGCL6:= << Name[s]
{ { Cooperate, Defect },
  { Cooperate, Defect } }
\end{verbatim}

We now give a more complicated example, in which one can use
listability of vector and matrix operations to set the payoffs in the
normal form according to a formula.  In this example, we create a
version of the ``stag hunt'' game.

\begin{verbatim}
GCL1:= << strat:=List[1,3,1]
{ 1, 2, 3 }
GCL2:= << stratSets:=List[strat,2]
{ { 1, 2, 3 },
  { 1, 2, 3 } }
GCL3:= << effort:=CartesianProd[stratSets] 
{ { { 1, 1 }, { 1, 2 }, { 1, 3 } },
  { { 2, 1 }, { 2, 2 }, { 2, 3 } },
  { { 3, 1 }, { 3, 2 }, { 3, 3 } } }
GCL4:= << pay:=Min[effort]-.5*effort
{ { { 0.500, 0.500 }, { 0.500, 0.000 }, { 0.500, -0.500 } },
  { { 0.000, 0.500 }, { 1.000, 1.000 }, { 1.000, 0.500 } },
  { { -0.500, 0.500 }, { 0.500, 1.000 }, { 1.500, 1.500 } } }
GCL5:= << n:=Nfg[pay]
(Nfg) ""
\end{verbatim}

First, the set of effort levels for a player (consisting of the list
of integers from one to 3) is constructed and stored in the variable
\verb+strat+.  (While this variable is called \verb+strat+ its data
type is \verb+LIST(INTEGER)+, not \verb+STRATEGY+.)  Second, the set
of strategy sets for both players is assembled in \verb+stratSets+.
Third, the set of pure strategy profiles is assembled by taking the
cartesian product of the strategy sets, and converted to \verb+NUMBER+
to give a vector of efforts for each pure strategy profile.  The
result is stored in the variable \verb+effort+.  Fourth, the vector of
payoffs for each pure strategy profile is computed by taking, for
vector of payoffs, the minimum effort across players, and subtracting
the cost of effort for each player.  Finally, a game is constructed
with these payoffs, by using the function \verb+Nfg+.  If you now ask
to see the payoffs for the game via \verb+Payoffs[nfg]+ you will see
an array just like \verb+pay+.

The fourth step in the above calculation illustrates a subtle but
important point about listable functions.  The function \tindex{Min}
requires an argument of type \verb+LIST(NUMBER)+ and returns type
\verb+NUMBER+.  It is being called with an argument of type
\verb+LIST(LIST(LIST(NUMBER)))+, and dimensionality $3\times 3\times
2$, .  Hence, the function will be run as a listable function on the
innermost vectors in the nested list, generating a result of type
\verb+LIST(LIST(NUMBER))+, and dimensionality $3\times 3$, each entry
of which contains the minimum of the vector in that cell.  Thus:

\begin{verbatim}
GCL6:= << Min[effort]
{ { 1, 1, 1 },
  { 1, 2, 2 },
  { 1, 2, 3 } }
\end{verbatim}

\noindent
To subtract the component \verb+.5*effort+ from this, the function
\verb+Minus+ requires data of type \verb+NUMBER+ for both arguments.
It is being run with the first argument of type
\verb+LIST(LIST(NUMBER))+, and dimension $3\times 3$, and the second of
type \verb+LIST(LIST(LIST(NUMBER)))+, and dimension $3\times 3\times
2$.  The first two levels of the list for both arguments match
in dimensionality.  Then it encounters a \verb+NUMBER+ in the first
argument, and a \verb+LIST(NUMBER)+ of dimension $2$ on the second.
Hence, \verb+Minus+ runs listably on its second argument, yielding a
\verb+LIST(NUMBER)+ of dimension $2$ for each entry in the $3\times 3$
nested list of \verb+Min[effort]+. 

The functions used in the above construction will accept nested lists
of any level.  Hence, the above can be extended into a user defined
function which allows one to build a stag hunt game for an arbitrary
number of players and strategies:

\begin{verbatim}
NewFunction[StagHuntNfg[n->INTEGER,maxeff->INTEGER,cost->NUMBER]=:NFG,
  strats:=List[1,maxeff,1];
  effort:=CartesianProd[List[strats,n]];
  Nfg[Min[effort]-cost*effort];
];
\end{verbatim}

\noindent
The statements in this user defined function are analagous to the
steps in the two person example above.  Once the above function has
been defined, then you can then use it as follows:

\begin{verbatim}
n:=StagHuntNfg[4,2,.5];
\end{verbatim}

\noindent
to create a four person stag hunt game where each player has two
strategy choices (effort levels) and the cost of effort is \verb+.5+.

Once a normal form game has been defined, there are a number of
solution algorithms that can be applied to solve the game.  How to
solve normal form games is discussed in the next chapter.  Until you
get to that point, you might want to save your work:

\subsection{Saving and loading normal forms}\index{Normal
forms!saving}\index{Normal forms!loading}

Once a normal form game has been constructed, it can be saved in a
similar way to an extensive form game.  The command 

\begin{verbatim}
SaveNfg[n, "filename.nfg" ]
\end{verbatim}

\noindent
will save the normal form game \verb+n+ to the file
\verb+filename.nfg+.  It is recommended that the filename extension
\verb+.nfg+ be used when saving normal form games, as the Gambit
Graphics user interface recognizes this extension as containing normal
form games.  Once a normal form game has been saved to an external
file, it can be loaded by the command \tindex{LoadNfg}, as follows:

\begin{verbatim}
n := LoadNfg["filename.nfg" ]
\end{verbatim}



\section{\rindex{Extensive forms}}

\subsection{Creating a new extensive form}\index{Extensive forms!creating}

The function \tindex{NewEfg} can be used to create a new extensive form
game.  In order to do anything with it, a variable should be created
to be the new extensive form game.  Thus, the command

\begin{verbatim}
e := NewEfg[]
\end{verbatim}

\noindent will create a new extensive form game stored in \verb+e+.
The game is a trivial game with only one node, a \verb+root node+, and
one player, \verb+chance+.  You can create a game whose data is which
has two players, named \verb+Fred+ and \verb+Alice+ by specifying


\begin{verbatim}
e := NewEfg[{"Fred", "Alice"} ]
\end{verbatim}

For an arbitrary extensive form game, a number of commands are
available to get information about the game.  A complete list is given
in the section on ``Getting Information'' in the Categorical Function
Reference section of this manual.  Some of the more important
functions are given in Table 3.  

\begin{table}[htp]
\begin{center}
\begin{tabular} {|l||l|} \hline
Function Name	& Description \\ 
\hline
\verb+# Actions[i]+ & Actions at information set \verb+i+ \\
\verb+# Actions[e]+ & Actions in the game \verb+e+ \\
\verb+  Chance[e]+ & Chance player of \verb+e+ \\
\verb+  Children[n]+ & Child nodes of node \verb+n+ \\
\verb+# History[n]+ & History of actions preceeding node \verb+n+ \\
\verb+  Infoset[n]+ & Information set that node \verb+n+ belongs to\\
\verb+  Infoset[a]+ & Information set that action \verb+a+ belongs to\\
\verb+  Infosets[e]+ & Information sets in the game \verb+e+\\
\verb+  Members[i]+ & Member nodes of information set \verb+i+\\
\verb+  Nodes[e]+ & Nodes in the game tree of the game \verb+e+\\
\verb+# NonterminalNodes[e]+ & Nonterminal nodes of game \verb+e+\\
\verb+  NthChild[n,j]+ & The \verb+j+th child of node \verb+n+ \\
\verb+  Outcome[n]+ & Outcome attached to node \verb+n+ \\
\verb+  Outcomes[e]+ & Outcomes for the game \verb+e+ \\
\verb+  Parent[n]+ & Parent node of node \verb+n+ \\
\verb+  Payoff[o,p]+ & Payoff  of outcome \verb+o+ for player \verb+p+ \\
\verb+# Payoffs[o]+ & Payoff vector of outcome \verb+o+ \\
\verb+  Player[i]+ & Player of information set \verb+i+ \\
\verb+  Players[e]+ & Players of the game \verb+e+ \\
\verb+  PriorAction[n]+ & Action preceeding node \verb+n+ \\
\verb+  RootNode[e]+ & Root node of \verb+e+ \\
\verb+# TerminalNodes[e]+ & Terminal nodes of game \verb+e+\\
\hline
\multicolumn{2}{c}{\ }\\
\multicolumn{2}{c}{Table 3}\\
\multicolumn{2}{c}{Extensive form information functions}\\
\end{tabular}
\end{center}
\end{table}
\medskip

The \verb+NthChild[n,j]+\tindex{NthChild} function has a short form of
\verb+n#j+.  So the second child of the third child of the root node
of \verb+e+ can be accessed (if it exists) by the command
\verb+RootNode[e]#3#2+.

\subsection{Modifying an extensive form}\index{Extensive forms!modifying}

A series of extensive form game editing functions are available for
modifying an extensive form game. A complete list is given in the
section on ``Extensive form manipulation'' in the Categorical Function
Reference section of this manual.  The more important functions for
building a game are given in Table 4.

\begin{table}[htp]
\begin{center}
\begin{tabular} {|l||l|} \hline
Function Name	& Description \\ 
\hline
\verb+  AddMove[i,n]+ &Adds a move from infoset \verb+i+ to node \verb+n+ \\
\verb+# AddMove[i,a]+ &Adds a move from infoset \verb+i+ to action \verb+a+ \\
\verb+  CopyTree[n1,n2]+ &Copies tree rooted at node \verb+n1+ to node \verb+n2+ \\
\verb+  InsertAction[i]+ &Inserts an action into information set \verb+i+ \\
\verb+  InsertMove[i,n]+ &Inserts a move from infoset \verb+i+ at node \verb+n+\\
\verb+  MergeInfosets[i1,i2]+ &Moves nodes from infoset \verb+i1+ into \verb+i2+\\
\verb+  MoveToInfosets[n,i]+ &Moves node \verb+n+ into infoset \verb+i+\\
\verb+  NewInfoset[p,j]+ &Creates a new infoset for player \verb+p+ with \verb+j+ actions\\
\verb+  NewInfoset[p,list]+ &Creates a new infoset for \verb+p+ with action names as in \verb+list+\\
\verb+# NewOutcome[e,t]+ &Creates a new outcome for the game \verb+e+
with name \verb+t+\\
\verb+# NewPlayer[e,t]+ &Creates a new player for the game \verb+e+
with name \verb+t+\\
\verb+  Randomize[e,j]+ &Randomizes the payoffs in \verb+e+ with seed \verb+j+\\
\verb+  Reveal[i,list]+ &Reveals infoset \verb+i+ to players in \verb+list+\\
\verb+  SetChanceProbs[i,list]+ &Sets chance probs in infoset \verb+i+ to values in \verb+list+\\
\verb+  SetOutcome[n,o]+ &Attaches outcome \verb+o+ to node \verb+n+ \\
\verb+  SetPayoff[o,p,v]+ &Sets payoff of outcome \verb+o+ for player \verb+o+ to value \verb+v+\\
\verb+  SetPayoffs[o,list]+ &Sets payoff of outcome \verb+o+ to values in \verb+list+\\
\hline
\multicolumn{2}{c}{\ }\\
\multicolumn{2}{c}{Table 4}\\
\multicolumn{2}{c}{Extensive form building functions}\\
\end{tabular}
\end{center}
\end{table}
\medskip

The functions in Table 4 can be used to build up any valid extensive
form game from a trivial game.  The basic procedure by which a more
complex game is constructed from a simple game is:

\begin{itemize}
\item
Create a new game, and create all players.  
\item
Iteratively add moves to the game.  This involves two steps
\begin{itemize}
\item
Construct a ``template'' for a move by creating an information set for
a player with the desired choices (actions).  

\item
Add the move to the game for the appropriate histories of actions.  
\end{itemize}
\item
Reveal information about the moves to players that observe them.  

\item
Compute payoffs and attach outcomes to the game.  
\end{itemize}

The next to last step (revealing information) may require considerable
care for games with complex information structures.  It is usually
easiest to wait to do this step until the entire game tree is built,
since currently, the GCL does not maintain a game of perfect recall as
you add new moves.  Hence, if you reveal a move of player 1 to player
2, and then add new moves to the game for the player 2, the move that
was revealed to player 2 will not be ``remembered'' by player 2 at the
new moves.

The following sequence of commands builds the game tree for a simple
poker game as described in \cite{Mye:91}, and whose game tree is given
in Figure~\ref{fig:poker}.  

\begin{figure}[htp]
\label{fig:poker}
\psfig{figure=poker.ps,height=2in}
\vspace{.25in}
\begin{verbatim} 
                         Game Description:

Fred (Player 1) and Alice (Player 2) each ante $1.00 into the pot.
Fred draws a card from a deck; Fred observes the card; Alice does not. 
Fred moves:
  If Fred Folds, 
    Fred wins the pot if his card is Red (net gain of $1.00 to Fred).
    Fred loses the pot if his card is Black (net loss of $1.00 to Fred).
  If Fred Raises, then Fred throws a dollar in the pot, and Alice moves:
    If Alice Passes, then Fred wins the pot (net gain of $1.00 to Fred)
    If Alice Meets, she throws a dollar in the pot; Fred must show the card: 
      If the card is Red Fred wins the pot (net gain of $2.00 to Fred).
      If the card is Black Alice wins the pot (net loss of $2.00 to Fred)
\end{verbatim}
\caption{A simple poker game}
\end{figure}
\medskip

To construct this game, first we create a new game, and the players.
We create the players separately, using \tindex{NewPlayer} so that we
have variables to refer to them later:

\begin{verbatim}
e := NewEfg[];
fred := NewPlayer[ e, "Fred"];
alice := NewPlayer[e,"Alice"];
\end{verbatim}

Now, we iteratively add moves to the game, by creating an information
set with a template for the move, and then adding that move to the
game at the appropriate histories: 

\begin{verbatim}
deal := NewInfoset[ Chance[e], {"Red", "Black"}];
AddMove[deal,RootNode[e]];
fredmove := NewInfoset[ fred , {"Raise", "Fold"} ];
AddMove[ fredmove, TerminalNodes[e]];
alicemove := NewInfoset[ alice , {"Meet", "Pass"} ];
fredraised:=Filter[t:=TerminalNodes[e],Name[PriorAction[t]]="Raise"]
AddMove[alicemove,fredraised];
\end{verbatim}

In the above, the first move, \verb+deal+, is a chance move. It is
added at the root node of the game.  The second move is called
\verb+fredmove+, and is added at the terminal nodes of the tree, since
Fred gets to take this move for any draw of the card.  Since there are
two terminal nodes the call to \tindex{AddMove}  here is a listable call,
and adds the move to both terminal nodes of the tree.  The third move
is called \verb+alicemove+.  Alice only gets to move if Fred chooses
to raise.  So the step computing \verb+fredraised+ identifies all of
the terminal nodes whose prior action was named \verb+"Raise"+.  The
move \verb+alicemove+ is added at all of these nodes, via a listable
call to \verb+AddMove+.  At this point, if you execute the command

\begin{verbatim}
Display[e]
\end{verbatim}

\noindent
you can bring up the Gambit GUI to view a graphics display of the game
in it's current state. You will see that the game tree looks like that
in Figure~\ref{fig:poker}, except there are no payoffs yet, and Fred
only has one information set.  This is because you did not yet account
for the fact that the deal is revealed to Fred.  You can reveal the
deal to Fred (but not to Alice) via

\begin{verbatim}
Reveal[deal,{fred}];
\end{verbatim}

\noindent
and if you now display the game, then except for the fact that no
payoffs have yet been defined, the game tree should look like that in
Figure~\ref{fig:poker}.  Note that an alternate way to get the
information structure correct is to create separate information sets
for Fred's moves from the outset.  So, the commands 

\begin{verbatim}
fredmove := NewInfoset[ fred , {"Raise", "Fold"} ];
AddMove[ fredmove, TerminalNodes[e]];
\end{verbatim}

\noindent
in the above example, could be replaced with:

\begin{verbatim}
fredred := NewInfoset[ fred , {"Raise", "Fold"} ];
fredblack := NewInfoset[ fred , {"Raise", "Fold"} ];
AddMove[ fredred, RootNode[e]#1];
AddMove[ fredblack, RootNode[e]#2];
\end{verbatim}

\noindent
(Here, the short form \verb+n#j+ for
\verb+NthChild[n,j]+\tindex{NthChild} is used to refer to the
\verb+j+th child of node \verb+n+).  A move from the information set
\verb+fredred+ is added to the first child of the root node (which is
the action for chance in which the red card is selected) and a move
from the second information set \verb+fredblack+ is added to the
second child of the root node.  Now, since two separate information
sets for Fred are created from the outset, there is no need to reveal
the deal to Fred.  As with life in general, in the GCL there is
usually more than one way to skin a cat.

To complete construction of this game, we must now add payoffs. This
can be done with the following sequence of commands. 

\begin{verbatim}
ante := 1.00;
raise := 1.00;
win := SetPayoffs[NewOutcome[e, "Win"],{ante,-ante}];
winbig := SetPayoffs[NewOutcome[e, "Win Big"],{ante+raise,-ante-raise}];
lose := SetPayoffs[NewOutcome[e, "Lose"],{-ante,ante}];
losebig := SetPayoffs[NewOutcome[e, "Lose Big"],{-ante-raise,ante+raise}];
SetOutcome[TerminalNodes[e],{winbig,win,win,losebig,win,lose}]
\end{verbatim}

This example has shown how to construct a simple game without any
recursive structure.  This game would be easier to create in the
Gambit GUI.  The usefulness of the GCL in constructing games comes
when the game is larger, or has some repetitive structure to it.  In
Appendix A, part 1, we give an example showing how to construct a multi stage
holdout game using user defined functions. 

\subsection{Saving and loading extensive forms}\index{Extensive forms!loading}\index{Extensive forms!saving}

Once an extensive form game has been constructed, it can be saved by
the command 

\begin{verbatim}
SaveEfg[e, "filename.efg" ]
\end{verbatim}

\noindent where \verb+e+ is the extensive form game, and
\verb+filename.efg+ is the filename of the file to be created.  It is
recommended that the filename extension \verb+.efg+ be used when
saving extensive form games, as the Gambit graphics user interface
recognizes this extension as containing extensive form games.  Once an
extensive form game has been saved to an external file, it can be
loaded by the command \tindex{LoadEfg}, as follows:

\begin{verbatim}
e := LoadEfg["filename.efg" ]
\end{verbatim}

\section{Creating a normal form from an extensive form}\index{Normal
forms!creating!from extensive form}

A normal form game can also be created from an extensive form game.
If \verb+e+ is an extensive form game, then the command 

\begin{verbatim}
n := Nfg[e]
\end{verbatim}

\noindent
will create a normal form game \verb+n+ which is the reduced normal
form game associated with the extensive form game \verb+e+.  

Strategies in the reduced normal form are given default names
consisting of a series of digits, where the \verb+j+th digit in the
strategy name corresponds to the branch number taken at the player's
\verb+j+th information set.  To illustrate, here we create the reduced
normal form of the game of poker encountered earlier.  

\begin{verbatim}
GCL1:= e:=LoadEfg["poker.efg"]
GCL2:= << Name[Actions[e]]
{ { { Raise, Fold }, { Raise, Fold } },
  { { Meet, Pass } } }
GCL3:= n:=Nfg[e];
GCL4:= << Name[Strategies[n]]
{ { 11, 12, 21, 22 },
  { 1, 2 } }
\end{verbatim}

In the normal form game, player 1 has four strategies.  Player 1's
second strategy has name \verb+12+.  This indicates that the player
took strategy 1 (Raise) in the first information set, and action 2
(Fold) in the second information set.  

When a normal form game \verb+n+ is created from an extensive form
game, the GCL will ``remember'' the extensive form game that \verb+n+
is associated with, as long as neither the extensive or normal form
game is edited.  Any mixed strategy solutions computed on the normal
form game \verb+n+ can be converted back to a behavior strategy of the
game \verb+e+ by using the command \tindex{Behav}.  Thus

\begin{verbatim}
n := Nfg[e];
m := EnumMixedSolve[n];
b := Behav[m]
\end{verbatim}

\noindent
will convert the game \verb+e+ to reduced normal form, solve it using
the \tindex{EnumMixedSolve} algorithm, and then convert all mixed profiles found back
to behavior profiles, and display the list, \verb+b+ of behavior
profiles found. The avove can also be done in one command without saving
intermediate steps as follows:  
  
\begin{verbatim}
b := Behav[EnumMixedSolve[Nfg[e]]]
\end{verbatim}

\chapter{Solving Games}\index{Solving games}

Every finite game has at least one \rindex{Nash
equilibrium}\index{equilibrium!Nash} in either pure or mixed
strategies (\cite{Nash:1950}).  Various refinements of Nash
equilibrium are frequently used to select reasonable equilibria in
games with multiple equilibria.  The most commonly studied refinements
are ``perfect'' and ``proper'' equilibria for normal form games, and
``subgame perfect'' and ``sequential'' equilibria for extensive form
games.  

The best way to compute an equilibrium depends on many factors, the
most important of which are the number of players, the number of
equilibrium you want to find, and what kind of refinement you are
looking for.  For a detailed discussion of these issues, see
\cite{McKMcL:1996}.  In general, it is easier to solve two person
games than n-person games, it is easier to find one equilibrium than
to find all, and it is easier to find a Nash equilibrium than a
refinement.

The computational complexity of solving for equilibria of games also
typically at least exponential in the number of strategies or actions.
Consequently, you will find it quite easy to build games in Gambit
which cannot be solved (in any reasonable amount of time) by Gambit.

When solving games of any reasonable size, it is therefore good to try
and simplify things as much as possible before launching into a
solution algorithm.  One way of simplifying a game is by reducing the
size of the strategy set by elimination of dominated strategies.  For
extensive form games, a second way of simplifying the problem is by
taking account of the subgame structure of the game, and then
recursively solve the game from the end.

\section{\rindex{Supports} and dominance elimination}\index{Dominance elimination}

The GCL data types \verb+NFSUPPORT+ and \verb+EFSUPPORT+ can be used
to represent a \bindex{support} in a normal or extensive form game.  A
support for a normal form game is a selection of non-empty subsets of
strategies for all players in the game.  A support for an extensive
form game is a selection of non-empty subsets of actions for all
information sets in the game.

The main use of supports is to represent the sets of strategies that
remain after dominated strategies have been eliminated from the game.
All of the built-in functions for solution algorithms in the GCL take
an \tindex{NFSUPPORT} or \tindex{EFSUPPORT} as their first parameter,
hence can be run on any support of the game.

The command \verb+Support[g]+\tindex{Support} returns the full support
of the normal or extensive form game \verb+g+.  The full support is
the support in which no strategies (or actions) have been eliminated.
The function \tindex{ElimDom} can be used to find the dominated
strategies or strategies in a support of a game.  \tindex{ElimDom}
returns a support containing the undominated strategies for each
player (or actions for each information set, in the case of extensive
for games).  By default weak domination is used, and only domination
by pure strategies is considered. By setting one or both of the
optional parameters \verb+strong+ and \verb+mixed+ to true, strong
domination can be used, and domination by mixed strateies can be
considered\footnote{Elimination by mixed strategies is only
implemented for normal form games in this version.}  The following
sequence of commands shows the computation of the full supports and
the support resulting from weak dominance elimination in the extensive
and reduced normal form of the poker example of the previous chapter.

\begin{verbatim}
GCL1:= e:=LoadEfg["poker.efg"]
GCL2:= efsupp:=ElimDom[e]
GCL3:= << Name[Actions[e]]
{ { { Raise, Fold }, { Raise, Fold } },
  { { Meet, Pass } } }
GCL4:= << Name[Actions[efsupp]]
{ { { Raise }, { Raise, Fold } },
  { { Meet, Pass } } }
GCL5:= n:=Nfg[e];
GCL6:= nfsupp:=ElimDom[n];
GCL7:= << Name[Strategies[n]]
{ { 11, 12, 21, 22 },
  { 1, 2 } }
GCL8:= << Name[Strategies[nfsupp]]
{ { 11, 12 },
  { 1, 2 } }
\end{verbatim}

In the above example, for the extensive form game, the action with
name "Fold" is dominated, and eliminated by \verb+ElimDom+.
Correspondingly, in the reduced normal form game, the strategies in
which the first player takes the second action at the first
information set is eliminated.  

A user defined function \tindex{ElimAllDom} can be used to iteratively
eliminate dominated strategies in a game, until no further dominance
elimination is possible.  This function returns the final support.  So
the commands

\begin{verbatim}
n:=LoadNfg["mygame.nfg"];
s:=ElimAllDom[n,strong->True,mixed->True];
\end{verbatim}

\noindent
will find the set of all strategies that remain after iterative
elimination by mixed strategies of strongly dominated strategies in
the game \verb+n+.

While the main use of supports is to represent strategies that
remain after dominance elimination, you can also construct your own
support for a game using the commands \tindex{RemoveStrategy} and
\tindex{AddStrategy}.

\section{\rindex{Subgames}}

For extensive form games, Gambit recognizes and supports the notion of
a {\bf subgame}.  If \verb+efg+ is an extensive form game, the
command \verb+Subgames[efg]+ returns a list of nodes
representing the roots of valid subgames.

You can control the way the extensive form solution algorithms deal
with subgames by ``marking'' or ``unmarking'' subgames.  All of the
extensive form solution algorithms recursively solve the extensive
form game by subgames, but only for subgames that are marked.  Terminal
marked subgames are solved first, and then for any solution of the
subgame, the parent game is pruned, plugging in the continuation value
generated by the terminal subgame.  The marked subgames that are now
terminal are then recursively solved in a similar manner, and so on,
until the game starting at the root node is reached.  Be warned that
if there are multiple equilibria to each subgame, the size of the set
of solutions to the full game that are generated by this procedure can
be exponential with the number of subgames.

When you first construct a game, the only subgame that is marked is
the root node of the tree.  This node always represents a valid
subgame, and it is not possible to unmark the root node.  If
\verb+node+ is the root of a valid non-trivial subgame, then the
built-in functions \tindex{MarkSubgame} and \tindex{UnmarkSubgame} can be
used to mark and unmark the specific subgames starting at that node.
\tindex{MarkedSubgame} can be used to check if the subgame is marked.
The user defined functions \tindex{MarkSubgames} and
\tindex{UnmarkSubgames} can be used to mark and unmark all valid
subgames in the game.  \tindex{MarkedSubgames} returns a lsit of root
nodes of all currently marked subgames.

The technique of marking subgames can be used to control whether a
solution algorithm that finds Nash equilibria returns any Nash
equilibrium or only subgame perfect Nash equilibria of the game.  If
no subgames are marked, the algorithm will return Nash equilibria
which may not be subgame perfect.  If you first mark all subgames,the
algorithm will return subgame perfect equilibria.

\section{Mixed and Behavior strategy profiles}
\index{Profiles!mixed}\index{Profiles!behav}

The data types \tindex{MIXED} and \tindex{BEHAV} are used to represent
mixed and behavior strategy profiles for normal and extensive form
games, respectively.  Mixed and behavior strategy profiles can be
defined on any support of the game.  A mixed strategy profile is a
specification of a numeric value (usually interpreted as a
probability) for each strategy in the support.  Similarly, a behavior
strategy profile is a specification of a numeric value (usually
interpreted as a probability) for each action in the support.

The simplest way of generating a mixed profile for a game is to use
the built-in function \tindex{Centroid}, which generates a mixed or
behavior strategy profile in which every player adopts each of their
strategies (or each action in an information set) with equal
probability.  For example, if \verb+g+ is a variable representing an
extensive or normal form game, and \verb+s+ is a support for the game
\verb+g+, then the commands \verb+Centroid[g]+ or \verb+Centroid[s]+
generate mixed strategy profiles for the normal form game \verb+nfg+,
and for the support, \verb+s+, respectively.  You can use the built-in
function \tindex{SetStrategyProbs} or \tindex{SetActionProbs} to change
the strategy probabilites for a mixed profile.  You can also use the
standard user defined functions \tindex{Mixed} or \tindex{Behav} to
generate a mixed profile from a nested list of numeric data, as long
as the nested list is of the correct dimensions.

Basic arithmetic operations are defined on mixed and behavior profiles
as well.  So you can take linear combinations of mixed profiles to
create new mixed profiles, as illustrated in this example:

\begin{verbatim}  
GCL1:= n:=Nfg[{{{3,1},{0,0}},{{0,1},{3,0}},{{1,0},{1,3}}}];
GCL2:= << c:=Centroid[n]
(Mixed) { 1/3 1/3 1/3 }{ 1/2 1/2 }
GCL3:= << cc:=Mixed[n,{{1,0,0},{1,0}}]
(Mixed) { 1 0 0 }{ 1 0 }
GCL4:= << m:=1/2*c+1/2*cc
(Mixed) { 2/3 1/6 1/6 }{ 3/4 1/4 }
\end{verbatim}

In most cases, the value assigned to an action or strategy is
interpreted as the probability with which a player adopts the
corresponding action or strategy.  However, the data for \verb+MIXED+
need not be legitimate probabilities.  For example, it would be valid
to create a mixed profile using the command
\verb+Mixed[n,{{1,2,3},{4,5}}]+.  Probabilities are not
required to add up to one, or even to be positive.  This feature is
especially useful in econometric analysis, as the \verb+MIXED+ and
\verb+BEHAV+ data types can be used to represent choice frequencies of
corresponding actions or strategies.  

All of the solution algorithms that operate on games or their supports
return lists of mixed or behavior profiles to representing the
solutions.  Some algorithms compute important additional information
about the profile that may not be recoverable from knowledge of just
the strategy probabilies.  Consequently, the \verb+MIXED+ an
\verb+BEHAV+ data types keep track of who created them, and what
properties are known about them.  A series of functions are available
to query profiles to return this information.  These functions are
listed in section on ``information about solutions'' in the
Categorical Function Reference chapter.  To view all of the
information that is known about a mixed or behavior profile, you can
change the format by which solutions are displayed using the
\tindex{Format} function.

\section{Solution Algorithms}\index{Solving games!Algorithms}

\subsection{\tindex{Enum}}
\index{Algorithms!enumeration!{\tt EnumMixedSolve}}
\index{Algorithms!enumeration!{\tt EnumPureSolve}}

The two \tindex{Enum} functions can be used to enumerate the pure or
mixed Nash equilibria for a normal form game.

The \tindex{EnumPureSolve} function enumerates all pure strategy Nash
equilibria in the support of a normal form game.  This algorithm
simply investigates all pure strategy profiles, checking each for the
Nash equilibrium conditions.  By default, the algorithm finds all pure
strategy Nash equilibrium.  Optionally it can be set to find the first
\verb+k+ Nash equilibria.  This algorithm will work on any normal form
game.

The \tindex{EnumMixedSolve} function enumerates all Nash equilibria (pure
and mixed) for a given support of a two person normal form game.  More
precisely, it finds the set of extreme Nash equilibria, as defined in
\cite[1964]{Man:64}.  For any normal form game, as shown in
Mangasarian, every Nash equilibrium can be expressed as a convex
combination of the extreme Nash equilibria.  For generic games, there
are just a finite number of Nash equilibria, which coincide with the
extreme equilibria.  By default, all extreme equilibria are found.
Optionally, the algorithm can be set to find the first \verb+k+
equilibria.  This algorithm works only on two-person normal form
games.

\subsection{\tindex{Qre}}
\index{Algorithms!logistic quantal response!{\tt QreSolve}}
\index{Algorithms!logistic quantal response!{\tt QreGridSolve}}

The \tindex{QreSolve} function computes a branch of the logistic
quantal response equilibrium correspondence (as described in
\cite{McKPal:95a} for normal form games, and in
\cite{McKPal:95b} for extensive form games.  The branch is
computed for values of $\lambda$ between $\underline{\lambda}$ and
$\bar{\lambda}.$ The algorithm starts at $\lambda_0 =
\underline{\lambda}$ if $\delta>0,$ or $\lambda_0 = \bar{\lambda}$ if
$\delta<0$. It then increments according to the formula
$$
\lambda_{t+1} = \lambda_t +\delta \lambda_t^a,
$$ 
where $\underline\lambda,$ $\bar\lambda,$ $\delta,$ and $a$ are
parameters that can be specified.  In the computation for the first value of
$\lambda_0$, the algorithm begins its search for a solution at a user
specified starting point.  At each
successive value of $\lambda_t,$ the algorithm begins its search at
the point found in step $t - 1.$ 

The {\em principal branch} of the logistic quantal response
equilibrium mapping is the branch that is connected to the centroid of
the game at $\lambda = 0$.  This branch can be computed by setting
$\lambda_0$ sufficiently small.  As discussed in McKelvey and Palfrey,
for generic normal form games, the principal branch of the quantal
response equilibrium correspondence converges to a unique selection
from the set of Nash equilibria as $\lambda$ goes to infinity.
Similarly, for generic extensive form games, the principal branch of
the quantal response mapping converges to a unique selection from the
set of sequential equilibria as $\lambda$ goes to infinity.  Hence, in
extensive form games, this algorithm can be used to compute an
approximation to a sequential equilibrium.

The \tindex{QreGridSolve} function performs a two stage grid search to
compute the {\em complete} logistic quantal response correspondence.
Points are evaluated in terms of the value of an objective function,
that measures the distance between the original point, and the best
response to the best response (under the logistic best response
function.)  Points that are close (within 'tol') to being fixed points
are kept, others are discarded.  A two stage procedure is used, in
which the entire space is searched on a course grid of mesh 'delp1'.
Any points on the course grid for which the value of the objective
function is less than 'tol1' are then searched on a finer grid of mesh
'delp2' around that point.  Points on the finer grid for which the
value of the objective function is below 'tol2' = 'tol' are kept.
This procedure is very computationally intensive, and is only feasible
for small two-person normal form games.

\subsection{Linear Complementarity Program}
\index{Algorithms!linear complementarity!{\tt LcpSolve}}

The \tindex{LcpSolve} function formulates and solves the game as a linear
complementarity problem.  This algorithm works for two person
games in either extensive or normal form.  
 
For a normal form game, the game is solved via the Lemke-Howson
Algorithm.  (See, eg.,
\cite{LemHow:64}) using lexicographic rule for insuring
termination, as developed in \cite{Eav:71}.  This algorithm can also
be used to find the set of {\em accessible} Nash equilibria, by
tracing out the pattern of connectedness of the complemenary basic
feasible solutions, as described in \cite{Sha:74}.  The set of
accessible equilibria is frequently the same as the set of all Nash
equilibria, but this is not always so.

For an extensive form game, this algorithm implements Koller, Megiddo
and von Stengel's {\em sequence form} (\cite{KolMegSte:94}. The
sequence form is a formulation of the set of Nash equilibria as the
solution to a non linear complementarity problem in variables that
correspond to ``sequences'' in the extensive form, which they show can
be solved by Lemke's algorithm for linear complementarity problems.
The method has nice properties in terms of its computational
complexity, as it only grows linearly in the size of the extensive
form game.  

\subsection{Lyapunov Function}
\index{Algorithms!Lyapunov function!{\tt LiapSolve}}

The \tindex{LiapSolve} function finds Nash equilibria via the Lyapunov
function method described in \cite{McK:91}.  This method works on
either the extensive or normal form.  This algorithm casts the problem
as a function minimization problem by use of a Lyapunov function for
Nash equilibria.  This is a continuously differentiable non negative
function whose zeros coincide with the set of Nash equilibria of the
game.  A standard descent algorithm is used to find a constrained
local minimum of the function from any given starting location.  Since
a local minimum need not be a global minimum (with value 0,) the
algorithm is not guaranteed to find a Nash equilibrium from any fixed
starting point.  The algorithm thus incorporates the capability of
restarting.  The algorithm starts from the initial starting point
determined by the parameter 'start'.  If a Nash equilibrium is not
found, it will keep searching from new randomly chosen starting points
until the desired number of Nash equilibria have been found or the
maximum number of tries (\verb+nTries+) is exceeded, whichever
comes first.

\subsection{Linear Program}
\index{Algorithms!linear programming!{\tt LpSolve}}

The \tindex{LpSolve} algorithm finds the minimax solution (a Nash
equilibrium) for a two person constant-sum game in normal form, by
solving it as a linear program.

\subsection{Simpicial Subdivision}
\index{Algorithms!simplicial subdivision!{\tt SimpDivSolve}}

The \tindex{SimpDivSolve} algorithm computes a Nash equilibrium to a
n-person normal form game based on a simplicial subdivision algorithm.
The algorithm implemented is that of \cite{VTH:1987}.  The algorithm
is a simplicial subdivision algorithm which can start at any point in
the simplex.  The algorithm starts with a given grid size, follows a
path of almost completely labeled subsimplexes, and converges to a
completely labeled sub-simplex that approximates the solution.
Additional accuracy is obtained by refining the grid size and
restarting from the previously found point.  The idea is that by
restarting at a close approximation to the solution, each successive
increase in accuracy will yield a short path, and hence be quick.

In its pure form, the algorithm is guaranteed to find at least one
mixed strategy equilibrium to any n-person game.  Experience shows
that the algorithm works well, and is acceptably fast for many
moderate size problems.  But in some examples it can be quite slow.
The reason for this is that sometimes after restarting with a refined
grid size, even though the starting point is a good approximation to
the solution, the algorithm will go to the boundary of the simplex
before converging back to a point that is close to the original
starting point.  When this occurs, each halving of the grid size will
take twice as long to converge as the previous grid size.  If a high
degree of accuracy is required, or if the normal form is large, this
can result in the algorithm taking a long time to converge.

In order to combat the above difficulty, a parameter 'leash' has been
added to the algorithm which places a limit on the distance which the
algorithm can wander from the restart point. (Setting this parameter
to 0 results in no limit, and gives the pure form of the algorithm.)
With this parameter set to a non trivial value, the algorithm is no
longer guaranteed to converge, and setting small values of the
parameter will sometimes yield lack of convergence.  However,
experience shows that values of the parameter on the order of 10
generally do not destroy convergence, and yield much faster
convergence.

\section{Computing Nash equilibria and refinements}\index{Nash equilibrium}
\index{equilibrium!refinements}

As mentioned above, the appropriate algorithm to use to compute a
particular kind of Nash equilibrium depends on a number of different
factors, such as the number of players in the game, how many
equilibria are desired, and whether one wants to find refinements.  In
addition, in some cases it may be advantageous to eliminate dominated
strategies or mark subgames before proceeding.

For each of a number of common equilibrium refinements, the GCL
provides standard user defined functions to compute either one or ``all''
equilibria of the given type.  These user defined functions pick the
appropriate algorithm for the required computation, and select the
type of dominance elimination and subgame marking for the desired
computation.

\subsection{Normal form equilibria}\index{equilibrium!refinements!normal form}

For normal form games, the GCL provides standard user defined
functions for the computation of Nash equilibria\index{Nash
equilibrium} (\tindex{OneNash} and \tindex{AllNash}), and perfect
equilibria (\tindex{OnePerfect}, \tindex{AllPerfect})\footnote{The
functions for computing perfect equilibrium are only implemented for
two person games}.  Table 5 gives the settings that are used for these
UDFs.

\medskip
\begin{center}
\begin{tabular}{|l|l|p{2cm}|l|l|}
\hline
Type & ElimDom & Game Type & Algorithm & Notes \\
\hline
OneNash & Weak & 2-person const sum & Lp & \\ \cline{3-5}
        &      & 2-person general  sum & Lcp& \\ \cline{3-5}
        &      & n person              & SimpDiv & \\
\hline
AllNash & Strong & 2 person       & EnumMixed & \\ \cline{3-5}
        &        & n person       & Liap      & Not guaranteed\\
\hline
\hline
OnePerfect & Strong & 2 person     & Lcp    & \\ \cline{3-5}
           &        & n person     &     &Not implemented  \\
\hline
AllPerfect & Strong & 2 person      & EnumMixed & \\ \cline{3-5}
           &        & n person      &     & Not implemented\\
\hline
\multicolumn{5}{c}{\ }\\
\multicolumn{5}{c}{Table 5}\\
\multicolumn{5}{c}{Standard UDFs for normal form equilibria}\\
\end{tabular}
\end{center}
\medskip

The standard user defined functions for finding ``all'' equilibria
should be used with some care.  These algorithms are sometimes not
guaranteed to find all solutions if they are terminated by the user
(see Table 5).  Rather, these functions for computing ``all''
equilibria will only find all equilibria (for generic games) in a weak
probabilistic sense: Given any number less than one, there is an
amount of time such that if the algorithm is run for at least that amount of
time it will find all solutions with probability higher than the given
number.  However, for an arbitrary game, there is no way of knowing
{\it a priori} how long to run the algorithm in order to achieve the
desired probability.  

For example in $n$ person games, with $n$ greater than two, there are
no algorithms yet implemented in Gambit to find all equilibria in a
finite amount of time.  In these cases, the corresponding user defined
function is designed to enter an infinite loop, continuing to search
for new solutions from new random starting points as long as you are
willing to wait (see documentation in function reference section).
The algorithm can be terminated by a \verb+ctrl-C+ from the console.
These functions (for computing all equilibria) have two optional
arguments, \verb+stopAfter+ to specify the maximum number of
equilibria to find before stopping, and \verb+nTries+ to specify the
maximum number of attempts to find equilibria before stopping. If
either of these parameters is set to a positive value, then the
computation will stop when the parameter reaches the specified value.
So for a three person game \verb+n+, the command
\verb+AllNash[n,2,10]+ will compute a maximum of two Nash equilibria,
taking at most ten tries to do so, whereas the command
\verb+AllNasn[n]+ will enter an infinite loop, continuing to search
for new equilibria until you terminate execution.

\subsection{Extensive form equilibria}
\index{equilibrium!refinements!extensive form}

For extensive form games, the GCL provides standard user defined
functions for the computation of Nash equilibria\index{Nash
equilibrium} (\tindex{OneNash} and \tindex{AllNash}), subgame perfect
equilibria (\tindex{OnePerfect}, \tindex{AllPerfect}), and sequential
equilibria (\tindex{OneSequential},
\tindex{AllSequential})\footnote{The functions for computing perfect
equilibrium are only implemented for two person games}.  Table 6 gives
the settings that are used for these UDFs.  

\medskip
\begin{center}
\begin{tabular}{|l|l|l|p{2cm}|l|l|}
\hline
Type & Subgames & ElimDom & Game Type & Algorithm & Notes\\
\hline
OneNash & Mark & Weak &  2-person const sum & EF/Lp &\\ \cline{4-6}
        &      &      &  2-person general sum & EF/Lcp &\\ \cline{4-6}
        &      &      &  n-person             & NF/SimpDiv &\\
\hline
AllNash &  Unmark & Strong &  2-person       & NF/EnumMixed &\\ \cline{4-6}
        &         &        &  n-person       & NF/Liap &Not guaranteed\\
\hline
\hline
OneSubgamePerfect &  Mark & Weak &  2-person const sum& EF/Lp &\\ \cline{4-6}
                  &       &      &  2-person general sum & EF/Lcp &\\ \cline{4-6}
                  &       &      &  n-person        & NF/SimpDiv &\\
\hline
AllSubgamePerfect &  Mark & Strong &  2-person    & NF/EnumMixed &\\ \cline{4-6}
                  &       &        &  n-person    & NF/Liap &Not guaranteed\\
\hline
\hline
OneSequential &  Unmark & None &  2 or n-person   & EF/Qre &\\ \cline{4-6}
\hline
AllSequential &         &       &  2 or n-person   & EF/Liap &Not guaranteed\\
\hline
\multicolumn{6}{c}{\ }\\
\multicolumn{6}{c}{Table 6}\\
\multicolumn{6}{c}{Standard UDFs for extensive form equilibria}\\
\end{tabular}
\end{center}
\medskip

In Table 6, the column headed ``Subgames'' indicates whether all
subgames are marked or unmarked before solving.  In the column headed
``algorithm'', the prefix \verb+EF+ or \verb+NF+ on the algorithm
indicates whether the game is first converted to normal form before
solving.  For example to find all Nash equilibria of a two person
extensive form game, all subgames are unmarked, the game is converted
to normal form, strongly dominated strategies are iterateively
eliminated, and the resulting game is then solved with the
\verb+EnumMixed+ algorithm.  The resulting set of mixed strategies is
converted back to behavior strategies of the original extensive form
game.  Inspection of the body of the UDF, which is given in the
Function Reference section of the manual (or via the
\verb+Manual["AllNash"]+ command) will reveal the details:

\begin{verbatim}
ms:=MarkedSubgames[e];UnmarkSubgames[e];
s:=ElimAllDom[Nfg[e],strong->True];
If[NumPlayers[e] = 2, 
  m:=EnumMixedSolve[s,0,precision],
  << InfiniteLoopWarning[stopAfter,nTries];
  m:=LiapSolve[Centroid[s],stopAfter,nTries]
];
MarkSubgames[ms];Behav[m]
\end{verbatim} 

Note that some of the settings for the UDFs of Table 6 are chosen for
efficiency in particular problems.  But they may not result in the
fastest solution in all cases.  For example, in the above example, for
$n$-person games, \verb+AllNash+ applies \verb+LiapSolve+ to the normal form.
In many cases, it may be better to apply \verb+LiapSolve+ directly to
the extensive form.  You can easily define a UDFs to suit your own
needs (or redefine the standard UDFs) if you find this to be the case
in the problems you work with.  

As in the normal form case, the functions for computing all equilibria
of extensive form games are sometimes not guaranteed to find all
solutions in finite time (see Table 6).  In these cases, the same
comments that are made in the section on normal form solution
algorithms apply here: The corresponding user defined function is
designed to enter an infinite loop, continuing to search for new
solutions from new random starting points as long as you are willing
to wait (see documentation in function reference section).  The
algorithm can be terminated by a \verb+ctrl-C+ from the console.  As
with the normal form functions, these functions (for computing all
equilibria) have two optional arguments, \verb+stopAfter+ to specify
the maximum number of equilibria to find before stopping, and
\verb+nTries+ to specify the maximum number of attempts to find
equilibria before stopping. If either of these parameters is set to a
positive value, then the computation will stop when the parameter
reaches the specified value.

\section{Solution information}
\index{Solutions!information}

Once a game has been solved, there are a number of functions for
finding out information about the solution.  A full list is given in
the section on Solution information in the function reference section.
Some of the more important functions are given in Table 7. 

\begin{table}[htp]
\begin{center}
\begin{tabular} {|l||l|} \hline
Function Name	& Description \\ 
\hline
\verb+  ActionProb[b,a]+ & Prob of action \verb+a+ for profile \verb+b+\\
\verb+  ActionProbs[b]+ & Nested list of all action probs for \verb+b+ \\ 
\verb+  ActionValue[b,a]+ & Value of action \verb+a+ for profile \verb+b+\\ 
\verb+  ActionValues[b]+ & Nested list of all action values for \verb+b+ \\ 
\verb+  Belief[b,n]+ & Prob of node \verb+n+ conditional on its
infoset under \verb+b+\\ 
\verb+  Beliefs[b]+ & Nested list of all beliefs under \verb+b+\\ 
\verb+  Behav[m]+ & \verb+Behav profile associated with mixed profile \verb+m+\\
\verb+  InfosetProb[b,i]+ & Probability of information set \verb+i+
under \verb+b+\\ 
\verb+  InfosetProbs[b]+ & Nested list of all infoset probabilities
for \verb+b+\\ 
\verb+  IsNash[p]+ &\verb+True+ if \verb+p+ is known to be Nash\\
\verb+  IsPerfect[m]+ &\verb+True+ if \verb+m+ is known to be perfect\\
\verb+  IsSequential[b]+ &\verb+True+ if \verb+b+ is known sequential\\
\verb+  IsSubgamePerfect[b]+ &  \verb+True+ if \verb+b+ is known subgame perfect\\ 
\verb+  NodeValue[b,p,n]+ & Value of \verb+b+ to player \verb+p+ at
node \verb+n+\\ 
\verb+# NodeValues[b,n]+ & List of values of \verb+b+ to all players at node \verb+n+\\
\verb+  NodeValues[b,p]+ & List of values of \verb+b+ to player \verb+p+ at all nodes\\
\verb+  Payoff[p,pl]+ & Payoff of profile \verb+p+ for player \verb+pl+\\
\verb+# Payoffs[p]+ & List of payoffs to all players of profile \verb+p+\\
\verb+  RealizProb[b,n]+ & Probability of reaching node \verb+n+ under \verb+b+\\
\verb+  RealizProbs[b]+ & Realization probabilites of all nodes under \verb+b+\\ 
\verb+  SetActionProbs[b,i.v]+ & Sets action probabilies of \verb+b+ at infoset \verb+i+ to \verb+v+\\
\verb+  SetStrategyProbs[m,p,v]+ & Sets strategy probs of \verb+m+ for
player \verb+p+ to \verb+v+\\
\verb+  StrategyProb[m,s]+ & Probability of strategy \verb+s+ under \verb+m+ \\
\verb+  StrategyProbs[m]+ & Nested list of all strategy probs for \verb+m+\\
\hline
\multicolumn{2}{c}{\ }\\
\multicolumn{2}{c}{Table 7}\\
\multicolumn{2}{c}{Solution information functions}\\
\end{tabular}
\end{center}
\end{table}
\medskip


\chapter{Function Reference, by Category}

This section contains a list of functions organized by
category.  For a description of each function and its arguments,
refer to the following, alphabetically organized, section.  

In the following list, functions preceded by a \verb+#+ are {\it user
defined functions} (UDFs) which are defined in the file
\verb+stdudfs.gcl+.  All the remaining functions are {\it built-in
functions} (BIFs).  Among the built-in functions, a small subset,
those preceeded by a \verb+*+ are ``special'' functions, which do not
necessarily follow all of the rules of GCL functions.  These functions
are also not documented by the GCL \verb+Help+ function.  

In the GCL, we have tried to minimize the number of built-in functions
to include only those that are essential.  The idea is that any other
function can be built up as a user defined function from the built-in
functions.  As part of the GCL distribution, we provide a library of
useful user defined functions in the file \verb+stdudfs.gcl+.  If the
line \verb+Include["stdudfs.gcl"]+ is in the \verb+gclini.gcl+ file,
then this file is loaded when the GCL is started.  The user can also
load their own set of user defined functions by adding a line
\verb+Include["myudfs.gcl"]+

The reason for minimizing the number of built-in funcitons is that it
allows for greater flexibility of use of the GCL, and minimizes
clogging up of the space of functions names.  It is much easier for
users to modify or redefine user defined functions to suit their
particular purpose than to modify built-in functions.  Also, this
approach makes it possible to run a ``stripped down'' version of the
GCL if memory is a premium, by just not including unused user defined
functions.

The cost to the above approach is that user defined functions can take
longer to execute than a corresponding built-in function with the same
functionality.

Much of the development of the GCL is based on our own computational
experience, and tends to be optimized with respect to the kinds of
problems we encounter.  However, it may not be optimized
for the type of problems you find interesting.  If you find that
certain operations in the GCL are unacceptably slow, we would
appreciate getting feedback on this.

\section{General Functionality}

\subsection{Variables and Functions}

\begin{multicols}{3}
\begin{verbatim}
* Assign 
* UnAssign 
* NewFunction
  Clear 
* Include
  Quit
\end{verbatim}
\end{multicols}

\subsection{Flow Control}

\begin{multicols}{3}
\begin{verbatim}
* For
* If
* While
\end{verbatim}
\end{multicols}

\subsection{Help}

\begin{multicols}{3}
\begin{verbatim}
  Help 
  HelpVars 
  IsDefined
  Manual 
  Version 
\end{verbatim}
\end{multicols}


\subsection{Timing}

\begin{multicols}{3}
\begin{verbatim}
  Date 
  IsWatchRunning 
  ElapsedTime 
  StartWatch 
  StopWatch 
\end{verbatim}
\end{multicols}

\subsection{System information and commands}

\begin{multicols}{3}
\begin{verbatim}
  ExePath 
  GetEnv 
  Platform 
  SetEnv 
  Shell 
  UnSetEnv 
# GambitExe 
\end{verbatim}
\end{multicols}

\section{Basic Data Types}

\subsection{Logic}

\begin{multicols}{3}
\begin{verbatim}
  And 
  Not 
  Or 
\end{verbatim}
\end{multicols}

\subsection{Relational operators}

\begin{multicols}{3}
\begin{verbatim}
  Equal 
  Greater 
  GreaterEqual 
  Less 
  LessEqual 
  NotEqual 
\end{verbatim}
\end{multicols}

\subsection{Mathematical operations}

\begin{multicols}{3}
\begin{verbatim}
  Divide 
  Exp 
  Float
  IntegerDivide 
  Inverse
  Log 
# Max
# MaxInt
# Min
  Minus 
  Modulus 
  Negate 
  Parentheses 
  Plus 
  Power 
  Precision
  Randomize 
# Randomize 
  Rational
  Times 
\end{verbatim}
\end{multicols}


\subsection{Strings}

\begin{multicols}{3}
\begin{verbatim}
  Concat
# Concat 
  Greater
  GreaterEqual
  Less
  LessEqual
  NthChar 
  NumChars 
  Text
\end{verbatim}
\end{multicols}

\subsection{Lists}

\begin{multicols}{3}
\begin{verbatim}
  ArgMax 
# CartesianProd
  Concat 
  Contains 
# Dimensions
  Dot 
  Filter 
  Flatten 
  Index
  IsList
  Length 
  List 
# Max
# Min
  NthElement 
  NumElements 
# Prepend
  Remove 
  Sort 
# Sum 
  Transpose 
\end{verbatim}
\end{multicols}

\subsection{Data conversions}

\begin{multicols}{3}
\begin{verbatim}
  Float 
# Float 
  Integer 
# ListForm 
  Null
  Precision
  Rational
# Rational
  Text 
\end{verbatim}
\end{multicols}

\section{Input and Output}

\begin{multicols}{3}
\begin{verbatim}
# Display 
  Format
  GetFormat 
  GetListFormat 
# GetIntegerFormat 
# GetNumericFormat 
# GetSolutionFormat 
# GetTextFormat 
  Input 
  IsEof
  ListFormat
  LoadEfg 
  LoadNfg 
  Output 
  Print
  Read 
# Read 
  SaveEfg 
  SaveNfg 
# SetIntegerFormat 
# SetListFormat 
# SetNumericFormat 
# SetSolutionFormat 
# SetTextFormat 
  Write   
\end{verbatim}
\end{multicols}

\section{Building Games}

\subsection{Extensive form manipulation}

\begin{multicols}{3}
\begin{verbatim}
  AddAction
  AddMove 
# AddMove 
  AddNode
  Basis
  CompressEfg 
  CopyTree 
  DeleteAction 
  DeleteEmptyInfoset 
# DeleteEmptyInfosets 
  DeleteMove 
  DeleteOutcome 
  DeleteTree 
  InsertAction 
  InsertMove 
  MergeInfosets 
  MoveToInfoset 
  MoveTree 
  NewEfg 
  NewInfoset 
# NewInfoset 
  NewOutcome 
# NewOutcome 
  NewPlayer 
# NewPlayer 
# Randomize 
  RemoveAction 
  RemoveNode
  Reveal 
  SetChanceProbs 
  SetComment
  SetName 
  SetOutcome 
  SetPayoff 
# SetPayoffs 
  Support 
\end{verbatim}
\end{multicols}

\subsection{Normal form manipulation}

\begin{multicols}{3}
\begin{verbatim}
  AddStrategy 
  AgentForm 
  CompressNfg
  DeleteOutcome 
# ListForm 
  NewNfg 
# NewNfg 
  NewOutcome
# NewOutcome
  NewPlayer 
# NewPlayer 
  Nfg 
# Nfg
# OutcomeForm
# Randomize 
  RemoveStrategy 
  SetComment
  SetName 
  SetOutcome
  SetPayoff 
# SetPayoffs
  Support 
\end{verbatim}
\end{multicols}

\subsection{Getting Information}

\begin{multicols}{3}
\begin{verbatim}
  ActionNumber 
# ActionNumber 
  Actions 
# Actions 
# AllActions 
# AllInfosets 
# AllMembers 
# Ancestors
# Centroid 
  Chance 
  ChanceProb 
  Children 
  Comment
# Descendants 
  Game 
# History
  Infoset 
  Infosets 
# Infosets 
  IsConsistent
  IsConstSum 
  IsNull 
  IsPerfectRecall 
  IsPredecessor 
# IsRoot 
  IsSuccessor 
  Members 
# Members 
  Mixed
# Mixed
  Name 
  NextSibling 
  NodeNumber
  Nodes 
# NodeTree
# NonterminalNodes 
  NthChild 
# NumActions 
# NumChildren 
# NumMembers 
# NumPlayers 
# NumStrats 
  Outcome 
  Outcomes 
  Parent 
  Payoff 
# Payoffs
  Player 
# PlayerNumber 
  Players 
  PriorAction 
  PriorSibling 
# Profiles
  RootNode 
  Strategies 
# Strategies 
  StrategyNumber
# TerminalNodes 
\end{verbatim}
\end{multicols}

\section{Solving Games}

\subsection{Subgames}

\begin{multicols}{3}
\begin{verbatim}
  MarkedSubgame 
# MarkedSubgames 
# MarkSubgames 
  MarkSubgame 
  Subgames 
# UnmarkSubgames 
  UnmarkSubgame 
\end{verbatim}
\end{multicols}

\subsection{Dominance elimination and supports}

\begin{multicols}{3}
\begin{verbatim}
  Actions
# Actions
  AddAction
  AddStrategy
  Basis
# ElimAllDom 
  ElimDom 
# ElimDom 
# NthElement
  PossibleNashSupports
  RemoveAction
  RemoveStrategy
  Strategies 
# Strategies 
  Support 
\end{verbatim}
\end{multicols}

\subsection{Solution algorithms}

\begin{multicols}{3}
\begin{verbatim}
  EnumMixedSolve 
# EnumMixedSolve 
  EnumPureSolve 
# EnumPureSolve 
  QreGridSolve 
  QreSolve 
# QreSolve 
  LcpSolve 
# LcpSolve 
  LiapSolve 
# LiapSolve 
  LpSolve 
# LpSolve 
  PolEnumSolve
  SimpDivSolve 
# SimpDivSolve 
\end{verbatim}
\end{multicols}

\subsection{Equilibria and refinements}

\begin{multicols}{3}
\begin{verbatim}
# AllNash
# AllPerfect
# AllSequential 
# AllSubgamePerfect
# OneNash
# OnePerfect
# OneSequential
# OneSubgamePerfect
\end{verbatim}
\end{multicols}

\subsection{Solution Information}

\begin{multicols}{3}
\begin{verbatim}
  ActionProb 
  ActionProbs 
  ActionValue 
  ActionValues 
  Behav 
# Behav 
  Belief 
  Beliefs 
  QreLambda 
  QreValue 
  InfosetProb 
  InfosetProbs 
  IsNash 
  IsPerfect 
  IsSequential 
  IsSubgamePerfect 
  LiapValue 
  Mixed
# Mixed
  NodeValue 
  NodeValues 
# NodeValues 
  Payoff 
# Payoffs 
  RealizProb 
  RealizProbs 
  Regret
  Regrets
  SetActionProbs 
  SetStrategyProb 
  SetStrategyProbs 
# SetProbs
  StrategyProb 
  StrategyProbs
  StrategyValue 
# StrategyValues 
\end{verbatim}
\end{multicols}

\chapter{Function Reference, Alphabetical}
\pagestyle{lexicon}

\section{Built-In Functions}

\begin{itemize}


%--A--


\item\lex{ActionNumber}
\protect \large \begin{verbatim}
ActionNumber[action->ACTION, sup->EFSUPPORT] =: INTEGER 
ActionNumber[action->ACTION, basis->EFBASIS] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number
assigned to \verb+action+ in the support \verb+sup+ (or basis
\verb+basis+).  For each information set, actions are numbered from 1
to the number of actions at the information set.  If an action is not
in the corresponding support or basis, it is assigned a number of \verb+0+.  

\item [See also:] \verb+Actions+.
\ed

\item\lex{ActionProb}
\protect \large \begin{verbatim}
ActionProb[profile->BEHAV, action->ACTION] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the probability that \verb+action+ is chosen at its
information set when all players are following \verb+profile+.
If \verb+action+ is a chance action, the probability of chance selecting
the action is returned.  If the probability is not specified by the 
profile, the null value is returned.  It is an error if \verb+profile+
and \verb+action+ are not from the same extensive form game.

\item [See also:] \verb+ActionProbs+, \verb+SetActionProbs+.
\ed

\item\lex{ActionProbs}
\protect \large \begin{verbatim}
ActionProbs[profile->BEHAV] =: LIST(LIST(LIST(NUMBER))) 
\end{verbatim}\normalsize

\bd 
Returns a nested list of probabilities for each action under
\verb+profile+.  The \verb+(i,j,k)+th entry is the probability of
player \verb+i+, information set \verb+j+, action \verb+k+, where the
index numbers correspond to the output of \verb+Players+, \verb+Infosets+,
and \verb+Actions+, respectively. 

\item [See also:] \verb+ActionProb+, \verb+SetActionProbs+.
\ed

\item\lex{ActionValue}
\protect \large \begin{verbatim}
ActionValue[profile->BEHAV, action->ACTION] =: NUMBER 
\end{verbatim}\normalsize

\bd 
Returns the expected payoff to a player (who is in control of the
information set including \verb+action+) of choosing \verb+action+ when
all players are following \verb+profile+.  If the value is not
well-defined, the null value is returned.  It is an error if
\verb+profile+ and \verb+action+ are not from the same extensive form
game, or if \verb+action+ is an action at an information set owned by
the chance player.

\item [See also:] \verb+ActionValues+, \verb+Belief+,
\verb+InfosetProb+, \verb+NodeValue+, \verb+RealizProb+.  
\ed

\item\lex{ActionValues}
\protect \large \begin{verbatim}
ActionValues[profile->BEHAV] =: LIST(LIST(LIST(NUMBER))) 
\end{verbatim}\normalsize

\bd
Returns a list of expected payoffs of each action (to the player
who chooses that action).  The null value is returned for actions for
which this value is not well-defined.  The \verb+(i,j,k)+th entry is
the expected payoff to player \verb+i+ at information set \verb+j+, of
action \verb+k+, where the index numbers correspond to the output of
\verb+Players+, \verb+Infosets+, and \verb+Actions+, respectively.

\item [See also:] \verb+ActionValue+, \verb+Belief+,
\verb+InfosetProb+, \verb+NodeValue+, \verb+RealizProb+.  
\ed

\item\lex{Actions}
\protect \large \begin{verbatim} 
Actions[infoset->INFOSET*, support->EFSUPPORT] =: LIST(ACTION) 
Actions[infoset->INFOSET*, basis->EFBASIS] =: LIST(ACTION) 
\end{verbatim}\normalsize

\bd
Returns the list of actions available at \verb+infoset+ in
\verb+support+ or \verb+EFSUPPORT.  If \verb+infoset+ is the null
information set, the empty list of actions is returned.  It is an
error if \verb+infoset+ and \verb+support+ are not from the same
extensive form game.

\item [See also:] \verb+DeleteAction+, \verb+InsertAction+.
\ed

\item\lex{AddAction}
\protect \large \begin{verbatim} 
AddAction[support->EFSUPPORT, action->ACTION] =: EFSUPPORT 
AddAction[basis->EFBASIS, action->ACTION] =: EFSUPPORT 
\end{verbatim}\normalsize

\bd 
Adds \verb+action+ to the \verb+support+.  If the action is already in
the support, no change is made.  A copy of the modified support is
returned.  It is an error if \verb+support+ and \verb+action+ are not from the
same extensive form game.

\item [See also:] \verb+RemoveAction+, \verb+Support+.
\ed

\item\lex{AddMove}
\protect \large \begin{verbatim} 
AddMove[infoset->INFOSET, node->NODE] =: NODE 
\end{verbatim}\normalsize

\bd
Places a terminal \verb+node+ into the information set
\verb+infoset+.  The result is \verb+node+ becomes a decision node,
with number of branches equal to the number of actions in \verb+infoset+.
New child nodes are created as successor nodes to the actions in the
information set.  The child which succeeds the first action is returned.
It is an error if \verb+node+ and \verb+infoset+ are not from the same
extensive form game, or if \verb+node+ is not a terminal node.

\item [See also:] \verb+InsertMove+, \verb+DeleteMove+,
\verb+NewInfoset+.  
\ed

\item\lex{AddNode}
\protect \large \begin{verbatim}
AddNode[basis->EFBASIS, node->NODE] =: EFBASIS
\end{verbatim}\normalsize

\bd
Describe me!
\ed

\item\lex{AddStrategy}
\protect \large \begin{verbatim}
AddStrategy[support->NFSUPPORT, strategy->STRATEGY] =: NFSUPPORT 
\end{verbatim}\normalsize

\bd
Adds \verb+strategy+ to the \verb+support+.  If the strategy is already
in the support, no change is made.  A copy of the modified support is
returned.  It is an error if \verb+support+ and \verb+strategy+ are not
from the same normal form game.

\item [See also:] \verb+RemoveStrategy+, \verb+Support+.
\ed

\item\lex{AgentForm}
\protect \large \begin{verbatim}
AgentForm[efg->EFG, {time<->0}] =: NFG 
\end{verbatim}\normalsize

\bd
Creates and returns the agent normal form representation of \verb+efg+.
The optional parameter \verb+time+, if specified, returns the amount
of time consumed by the conversion.

\item [See also:] \verb+Nfg+.
\ed

\item\lex{And} 
\protect \large \begin{verbatim}
And[x->BOOLEAN, y->BOOLEAN] =: BOOLEAN 
\end{verbatim} \normalsize

\bd
Computes the logical conjunction of \verb+x+ and \verb+y+, defined by the
truth table:
\begin{center}
\begin{tabular} {|c||c|c|c|} \hline
& \verb+True+ & \verb+False+ & \verb+Unknown+ \\ \hline 
\verb+True+ & \verb+True+ & \verb+False+ & \verb+Unknown+ \\
\verb+False+ & \verb+False+ & \verb+False+ & \verb+False+ \\
\verb+Unknown+ & \verb+Unknown+ & \verb+False+ & \verb+Unknown+ \\ \hline
\end{tabular}
\end{center}

\item [Short forms:] \verb+x && y+, \verb+x AND y+.
\item [See also:] \verb+Not+, \verb+Or+.
\ed



\item\lex{ArgMax} 
\protect \large \begin{verbatim}
ArgMax[x->LIST(NUMBER)] =: INTEGER 
\end{verbatim} \normalsize

\bd 
Returns the index of the first element of the list \verb+x+ which
attains the maximum value of any elements in the list.  
\ed

\item\lex{Assign} 
\protect \large \begin{verbatim}
Assign[name->TEXT, value<->T*] =: T
\end{verbatim} \normalsize

{\it for all types} {\tt T} 
\bd 
Creates a new variable \verb+name+, with return value of \verb+value+.
Returns the value assigned.  If \verb+name+ is already a defined
variable in the current scope, then if it is of type \verb+T+, it is
modified to have return value of \verb+value+.  If it is of a
different data type, an error results.
 
\item [Short form:] \verb+x := value+
\item [Note:] For the short form, quotes around \verb+name+ are not
required, and the function is not listable.
\item [See also:] \verb+Clear+, \verb+UnAssign+.
\ed

%--B--

\item\lex{Basis}
\protect \large \begin{verbatim}
Basis[efg->EFG] =: EFBASIS
\end{verbatim}\normalsize

\bd
Describe me!
\ed

\item\lex{Behav}
\protect \large \begin{verbatim}
Behav[mixed->MIXED] =: BEHAV 
\end{verbatim}\normalsize

\bd
\marginpar{How does this work with imperfect recall?}
Converts \verb+profile+ to the equivalent behavior strategy profile on the
associated extensive form game using Kuhn's Theorem.  It is an error
if there is no extensive form game associated with the normal form game
of \verb+profile+.
\item [See also:] \verb+Mixed+.
\ed

\item\lex{Behav}
\protect \large \begin{verbatim}
Behav[support->EFSUPPORT] =: BEHAV 
\end{verbatim}\normalsize

\bd
Returns a behavior strategy profile with equal
probabilities for all actions in \verb+support+ in the same information set. 
\item [See also:] \verb+Centroid+, \verb+Mixed+.
\ed

\item\lex{Belief}
\protect \large \begin{verbatim}
Belief[profile->BEHAV, node->NODE] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the probability of being at \verb+node+, conditional on the
player who chooses at \verb+node+ knowing she is in \verb+node+'s
information set, assuming all players follow \verb+profile+.  The null
value is returned if the belief value is not well-defined, or if
\verb+node+ is terminal.  It is an error if \verb+profile+ and \verb+node+
are not from the same extensive form game.
\item [See also:] \verb+ActionValue+, \verb+Beliefs+, \verb+InfosetProb+,
\verb+NodeValue+, \verb+RealizProb+.
\ed

\item\lex{Beliefs}
\protect \large \begin{verbatim}
Beliefs[profile->BEHAV] =: LIST(NUMBER) 
\end{verbatim}\normalsize

\bd 
Returns a nested list of
beliefs of being at each node of each information set under
\verb+profile+. The \verb+(i,j,k)+th element of the list corresponds
to player \verb+i+, information set \verb+j+, and member node
\verb+k+. The null value is returned for nodes where beliefs are
undefined.

\item [See also:] \verb+ActionValue+, \verb+Belief+, \verb+InfosetProb+,
\verb+NodeValue+, \verb+RealizProb+.
\ed



%--C--


\item\lex{Chance}
\protect \large \begin{verbatim}
Chance[efg->EFG] =: EFPLAYER 
\end{verbatim}\normalsize

\bd
Returns the chance, or nature, player defined on \verb+efg+.
Each extensive form has exactly one
chance player predefined, and it is not possible to define any additional
chance players.
\ed

\item\lex{ChanceProb}
\protect \large \begin{verbatim}
ChanceProb[action->ACTION] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the probability of \verb+action+ being chosen at its information
set by the chance player.  It is an error if \verb+action+ is not an action
which is chosen by the chance player.
\item [See also:] \verb+SetChanceProbs+.
\ed

\item\lex{Children}
\protect \large \begin{verbatim} 
Children[node->NODE] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd
Returns the list of children of \verb+node+.
\item [See also:] \verb+Parent+.
\ed

\item\lex{Clear}
\protect \large \begin{verbatim}
Clear[] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Unassigns all variables defined in the current scope.  Returns \verb+True+.
\item [See also:] \verb+Assign+, \verb+UnAssign+.
\ed

\item\lex{Comment}
\protect \large \begin{verbatim}
Comment[efg->EFG] =: TEXT
Comment[nfg->NFG] =: TEXT
\end{verbatim}\normalsize

\bd
Returns the comment associated with the game.
\item [See also:] \verb+SetComment+.
\ed

\item\lex{CompressEfg}
\protect \large \begin{verbatim}
CompressEfg[support->EFSUPPORT] =: EFG 
\end{verbatim}\normalsize

\bd
Creates a copy of the extensive form game on which \verb+support+ is
defined, where all actions not present in \verb+support+ have been
removed.
\ed

\item\lex{CompressNfg}
\protect \large \begin{verbatim}
CompressNfg[support->NFSUPPORT] =: NFG 
\end{verbatim}\normalsize

\bd
Creates a copy of the normal form game on which \verb+support+ is
defined, where all strategies not present in \verb+support+ have been
removed.
\ed

\item\lex{Concat}
\protect \large \begin{verbatim}
Concat[x->NLIST(T), y->NLIST(T)] =: LIST(T) 
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns the concatenation of the lists \verb+x+ and \verb+y+.
\item
[Short form:] \verb%x & y%
\ed

\item\lex{Contains}
\protect \large \begin{verbatim}
Contains[list->NLIST(T), x->T] =: BOOLEAN 
Contains[list->NLIST(T), x->LIST(T)] =: BOOLEAN 
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns \verb+True+ when the value \verb+x+ is contained in \verb+list+.
\item [See also:] \verb+NthElement+.
\ed

\item\lex{CopyTree}
\protect \large \begin{verbatim}
CopyTree[from->NODE, to->NODE] =: NODE 
\end{verbatim}\normalsize

\bd
Copies the subtree rooted at \verb+from+ to the terminal
node \verb+to+ in the same extensive form game.  The nodes in the
copied subtree belong to the same information sets as their counterparts in
the original subtree.  Returns the node \verb+to+.  It is an error if
\verb+from+ and \verb+to+ are not from the same extensive form game,
or if \verb+to+ is not a terminal node.  The function has no effect if
the copying operation would violate the currently marked subgame
structure.

\item
[See also:] \verb+MoveTree+.
\ed

%--D--

\item\lex{Date}
\protect \large \begin{verbatim}
Date[] =: TEXT 
\end{verbatim}\normalsize

\bd
Returns the current date and time. 
\ed

\item\lex{DeleteAction}
\protect \large \begin{verbatim}
DeleteAction[action->ACTION] =: INFOSET 
\end{verbatim}\normalsize

\bd
Deletes \verb+action+ from its information set. 
As a consequence, the corresponding subtrees associated
with the action from each member of the information set are deleted.
Returns the information set to which \verb+action+ belonged.  It is an
error if \verb+action+ is the only action at its information set.
\item [See also:] \verb+Actions+, \verb+InsertAction+.
\ed

\item\lex{DeleteEmptyInfoset}
\protect \large \begin{verbatim}
DeleteEmptyInfoset[infoset->INFOSET] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Deletes \verb+infoset+ from its extensive form game.  An information set
may be deleted only when it has no members; otherwise, this function has
no effect.  Returns \verb+True+ when the information set was successfully
deleted.
\item [See also:] \verb+Members+, \verb+NewInfoset+.
\ed

\item\lex{DeleteMove}
\protect \large \begin{verbatim}
DeleteMove[node->NODE, keep->NODE] =: NODE 
\end{verbatim}\normalsize

\bd
Deletes \verb+node+ from its extensive form game.  The
subtree rooted in node \verb+keep+, which must be a child of
\verb+node+, is kept, and \verb+keep+ takes the place of \verb+node+ in
the tree.  All other subtrees descending from \verb+node+ are deleted.
The kept node \verb+keep+ is returned.  It is an error if \verb+keep+
is not a child of \verb+node+, or if \verb+keep+ and \verb+node+ are not
from the same extensive form game.
\item [See also:] \verb+DeleteTree+, \verb+InsertMove+, \verb+AddMove+.
\ed

\item\lex{DeleteOutcome}
\protect \large \begin{verbatim}
DeleteOutcome[outcome->EFOUTCOME] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd
Removes \verb+outcome+ from its extensive
form game.  All nodes with the specified outcome attached are reset to
having no outcome attached.  Returns the list of nodes to which
the outcome was attached.
\item [See also:] \verb+NewOutcome+.
\ed

\item\lex{DeleteOutcome}
\protect \large \begin{verbatim}
DeleteOutcome[outcome->NFOUTCOME] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Removes \verb+outcome+ from its normal form game.  Returns \verb+True+.
\item [See also:] \verb+NewOutcome+.
\ed


\item\lex{DeleteTree}
\protect \large \begin{verbatim}
DeleteTree[node->NODE] =: NODE 
\end{verbatim}\normalsize

\bd
Deletes the subtree rooted at \verb+node+.  The
node then becomes a terminal node, which is returned.
\item [See also:] \verb+DeleteMove+.
\ed

\item\lex{Divide} 
\protect \large \begin{verbatim}
Divide[x->NUMBER, y->NUMBER] =: NUMBER 
\end{verbatim} \normalsize

\bd
Returns the quotient $x / y$. 
\item [Short form:] \verb+x / y+
\item [See also:] \verb+IntegerDivide+.
\ed

\item\lex{Dot}
\protect \large \begin{verbatim}
Dot[x->LIST(NUMBER), y->LIST(NUMBER)] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the dot product of \verb+x+ and \verb+y+, where the lists are
treated as vectors.
It is an error to attempt to multiply two lists of different
lengths.
\item [Short form:] \verb%x . y%
\ed

%--E--

\item\lex{ElapsedTime}
\protect \large \begin{verbatim}
ElapsedTime[] =: NUMBER 
\end{verbatim}\normalsize

\bd
If the system stopwatch is currently running, returns the
time elapsed since the stopwatch was started.  If the system stopwatch
is not running, returns the time elapsed during the last period during which
the stopwatch was running.
\item
[See also:] \verb+IsWatchRunning+, \verb+StartWatch+, \verb+StopWatch+.
\ed

\item\lex{ElimDom}
\protect \large \begin{verbatim}
ElimDom[support->NFSUPPORT, {strong->False}, 
        {mixed->False}, {time<->0.000000}, 
        {traceFile<->(Output)}, {traceLevel->0}] =: NFSUPPORT 
ElimDom[support->EFSUPPORT, {strong->False}, 
        {mixed->False}, {time<->0.000000}, 
        {traceFile<->(Output)}, {traceLevel->0}] =: EFSUPPORT 
\end{verbatim}\normalsize

\bd
Finds dominated strategies, or actions, as appropriate, in a 
\verb+support+.  The returned support contains only the undominated
strategies or actions; if this support is identical to the input support,
no strategies or actions were found to be dominated.  The following
optional parameters may be specified to modify the behavior of
the elimination:

\bd
\item [strong:] By default, all weakly dominated strategies or actions
are eliminated.  If this is specified \verb+True+, elimination is based
on strict dominance.
\item [mixed:] By default, elimination is done in pure strategies or
actions.  If this is specified \verb+True+, elimination is done by
examining mixtures over other strategies or actions.
\item [time:] Returns the time consumed by the elimination process.
\item [traceFile:] A file containing a log of more detailed information
on the elimination process.  By default, no logging is done.
\item [traceLevel:] An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no output
at all.
\ed
\ed

\item\lex{EnumMixedSolve}
\protect \large \begin{verbatim}
EnumMixedSolve[support->NFSUPPORT, {stopAfter->0}, 
               {precision->Float}, {nPivots<->0}, 
               {time<->0.000000}, {traceFile<->(Output)}, 
               {traceLevel->0}, {cliques->False}] =: LIST(MIXED) 
EnumMixedSolve[support->EFSUPPORT, {asNfg->False}, 
               {stopAfter->0}, {precision->Float}, 
               {nPivots<->0}, {time<->0.000000}, 
               {traceFile<->(Output)}, {traceLevel->0},
               {cliques->False}] =: LIST(BEHAV) 
\end{verbatim}\normalsize
\bd
Returns the extreme points of the set of all Nash equilibria (pure or
mixed) for a two person game using \verb+support+.

The following optional parameters may be used to modify the behavior
of the algorithm:
\bd
\item
[asNfg:] By default, this is \verb+False+.  If it is specified to be
\verb+True+, the extensive form game is solved by recursively converting
its marked subgames into normal form, solving, and reconstructing the
solution as a behavior profile.  {\it Note that currently this algorithm
is only supported on the normal form, so this parameter
must always be specified and {\tt True}.} 
\item
[stopAfter:] By default, all equilibria are found.  This parameter may
be used to specify a maximum number of equilibria to be found.
\item
[precision:] Determines the precision of the computation. Default is
floating point precision (\verb+Float+). 
\item
[nPivots:] Returns the number of pivots done by the
algorithm.
\item
[time:] Returns the time elapsed during the execution
of the algorithm.
\item
[traceFile:] A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no output
at all.
\item
[cliques:] If true, then the connected components and their maximal
cliques are computed.  The output is printed to the console.
\ed
\item [See also:] \verb+EnumPureSolve+.
\ed

\item\lex{EnumPureSolve}
\protect \large \begin{verbatim}
EnumPureSolve[support->NFSUPPORT, {stopAfter->0}, 
              {time<->0.000000}, {traceFile<->(Output)},
              {traceLevel->0}] =: LIST(MIXED) 
EnumPureSolve[support->EFSUPPORT, {asNfg->False}, 
              {stopAfter->0}, {precision->Float}, 
              {time<->0.000000}, {traceFile<->(Output)}, 
              {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd
Returns all pure strategy Nash equilibria of a game using the given
\verb+support+.  The behavior
of the algorithm may be modified by the following optional parameters:
\bd
\item
[asNfg:] By default, this is \verb+False+.  If it is specified to be
\verb+True+, the extensive form game is solved by recursively converting
its marked subgames into normal form, solving, and reconstructing the
solution as a behavior profile.
\item
[stopAfter:] By default, all equilibria are found.  This parameter may
be used to specify a maximum number of equilibria to be found.
\item
[precision:] Determines the precision of the computation. Default is
floating point precision (\verb+Float+). 
\item
[time:] Returns the time elapsed during the execution
of the algorithm.
\item
[traceFile:] A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An integer specifying the level of detail in logging.  Higher
integers correspond to more detail; zero corresponds to no output at all.
\ed
\item
[See also:] \verb+EnumMixedSolve+.
\ed

\item\lex{Equal}
\protect \large \begin{verbatim}
Equal[x->T*, y->T*] =: BOOLEAN
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns \verb+True+ when \verb+x+ and \verb+y+ are equal.  For games,
\verb+x+ and \verb+y+ are considered equal when they refer to the same
game (but not if they refer to two different games with exactly the
same structure, payoffs, and so forth).  A null value is considered equal
to the null value, but is not equal to any non-null value.
\item
[Short form:] \verb+x = y+.
\item
[See also:] \verb+NotEqual+.
\ed

\item\lex{ExePath}
\protect \large \begin{verbatim}
ExePath[{file->True}, {path->True}] =: TEXT 
\end{verbatim} \normalsize

\bd
Returns the path of the GCL executable. 
\bd
\item [file:] Returns the file name.  Default is True.  
\item [path:] Returns the path.  Default is True. 
\ed
\item [See also:] \verb+GetPath+.
\ed

\item\lex{Exp}
\protect \large \begin{verbatim}
Exp[x->NUMBER] =: NUMBER 
\end{verbatim} \normalsize

\bd
Returns the value of the function ${\rm e}^{x}$.
\item [Note:] Result is returned in \verb+Float+ precision, regardless
of the precision of \verb+x+.
\item [See also:] \verb+Log+, \verb+Power+.
\ed


%--F--

\item\lex{Filter}
\protect \large \begin{verbatim}
Filter[x->NLIST(T*), y->NLIST(BOOLEAN)] =: LIST(T)
\end{verbatim} \normalsize

{\it for all types} {\tt T}

\bd
Returns a list with the same dimension structure as \verb+list+, with the
elements for which the corresponding elements of \verb+by+ are \verb+False+
removed.  It is an error if \verb+x+ and \verb+y+ do not have the same
dimensionality.
\item [See also:] \verb+Sort+.
\ed

\item\lex{Flatten}
\protect \large \begin{verbatim}
Flatten[x->NLIST(T*), {levels->0}] =: LIST(T) 
\end{verbatim} \normalsize

{\it for all types} {\tt T}
\bd
Returns a list with the same elements as \verb+x+, with the nesting
structure flattened.  By default, all levels are flattened, returning
a one-dimensional list; the optional parameter \verb+levels+ may be
used to limit the flattening to the topmost \verb+levels+.
\ed

\item\lex{Float}
\protect \large \begin{verbatim}
Float[x->NUMBER] =: NUMBER
\end{verbatim} \normalsize

\bd Converts the internal representation of \verb+x+ to Floating point
precision.
\item [See also:] \verb+Rational+.
\ed

\item\lex{For}
\protect \large \begin{verbatim}
*For[statement-list, boolean-expression, 
    statement-list, statement-list]
\end{verbatim}\normalsize

\bd
Defines a piece of code to be executed repeatedly.  See the section
on control structures for complete information.
\item [Note:] Special function.  Not listable; arguments are not GCl
data types; not documented in \verb+Help+ or \verb+Manual+.  
\item
[See also:] \verb+While+.
\ed

\item\lex{Format}
\protect \large \begin{verbatim}
Format[x->NUMBER, {width<->0}, {decimals<->6}, {expmode<->False}] =: NUMBER 
\end{verbatim} \normalsize

\bd
Sets the formatting style for output of NUMBER data types on output streams.
\bd
\item [width:] The width for a numeric field.  If the width of the
data is greater than \verb+width+, the width is overridden.  (The
default is 0.)
\item [decimals:] The number of decimal places shown for floating point
numbers.
\item [expmode:] If \verb+True+, floating point numbers are printed in
exponential format.
\ed
\item [See also:] \verb+Write+, \verb+ListFormat+.
\ed

\item\lex{Format}
\protect \large \begin{verbatim}
Format[x->TEXT, {quote<->False}] =: TEXT 
\end{verbatim} \normalsize

\bd
Sets the formatting style for output of text on output streams.
\bd
\item [quote:] Whether opening and closing quotation marks are
written.  The default is True.  
\ed
\item [See also:] \verb+Write+, \verb+ListFormat+.
\ed


\item\lex{Format}
\protect \large \begin{verbatim}
Format[x->MIXED, {info<->False}, {names<->False}] =: MIXED
Format[x->BEHAV, {info<->False}, {names<->False}] =: BEHAV
\end{verbatim} \normalsize

\bd
Sets the formatting style for output of solution types on output streams.
\bd
\item [info:] The amount of information to be displayed.  If \verb+True+,
displays all of the information about the solution.  If \verb+False+,
only the strategy or action probabilities are displayed.
\item [names:] If \verb+True+, the profiles are printed in a sparse format,
with only positive-probability strategy or action profiles displayed, tagged
by their strategy or action labels.  If \verb+False+, the whole vector
(including zeroes) is printed, without any labels.
\ed
\item [See also:] \verb+ListFormat+, verb+Write+.
\ed

\item\lex{Format}
\protect \large \begin{verbatim}
Format[x->EFG, {decimals<->6}] =: EFG
Format[x->NFG, {decimals<->6}] =: NFG
\end{verbatim} \normalsize

\bd
Sets the formatting style for .efg and .nfg files.
\bd
\item [nDecimals:] The number of decimal places to use in representing
floating-point numbers.
\ed
\item [See also:] \verb+SaveEfg+, \verb+SaveNfg+.
\ed


%--G--

\item\lex{Game}
\protect \large \begin{verbatim}
Game[player->NFPLAYER] =: NFG 
Game[strategy->STRATEGY] =: NFG 
Game[outcome->NFOUTCOME] =: NFG 
Game[player->EFPLAYER] =: EFG 
Game[node->NODE] =: EFG 
Game[outcome->EFOUTCOME] =: EFG 
Game[infoset->INFOSET] =: EFG 
Game[profile->MIXED] =: NFG 
Game[profile->BEHAV] =: EFG 
Game[support->NFSUPPORT] =: NFG 
Game[support->EFSUPPORT] =: EFG 
Game[support->EFBASIS] =: EFG 
\end{verbatim} \normalsize

\bd
Returns the game on which the parameter is defined.
\ed

\item\lex{GetEnv}
\protect \large \begin{verbatim}
GetEnv[name->TEXT] =: TEXT 
\end{verbatim} \normalsize

\bd
Returns the string associated with environment variable \verb+name+.
\item [See also:] \verb+SetEnv+, \verb+UnSetEnv+.
\ed


\item\lex{GetFormat}
\protect \large \begin{verbatim}
GetFormat[x->NUMBER, {width<->0}, {decimals<->6}, {expmode<->False}] =: NUMBER 
\end{verbatim} \normalsize

\bd Gets the current formatting style for output of {\tt NUMBER} data types
on output streams.  
\bd
\item [width:] The width for a numeric field.  
\item [decimals:] The number of decimal places shown for floating point
numbers.
\item [expmode:] Whether floating point numbers are printed in
exponential format.
\ed
\item [See also:] \verb+Format+.
\ed

\item\lex{GetFormat}
\protect \large \begin{verbatim}
GetFormat[x->TEXT, {quote<->False}] =: TEXT 
\end{verbatim} \normalsize

\bd
Gets the current formatting style for output of text on output streams.
\bd
\item [quote:] Whether opening and closing quotation marks are
written. 
\ed
\item [See also:] \verb+Format+.
\ed


\item\lex{GetFormat}
\protect \large \begin{verbatim}
GetFormat[x->MIXED, {info<->False},{names<->False}] =: MIXED
GetFormat[x->BEHAV, {info<->False},{names<->False}] =: BEHAV
\end{verbatim} \normalsize

\bd Gets the current formatting style for output of solution types on
output streams.  
\bd
\item [info:] Displays all information known about solution if true. If false, just displays strategy or action probabilities.  
\item [names:] If \verb+True+, the profiles are printed in a sparse format,
with only positive-probability strategy or action profiles displayed, tagged
by their strategy or action labels.  If \verb+False+, the whole vector
(including zeroes) is printed, without any labels.
\ed
\item [See also:] \verb+Format+.
\ed

\item\lex{GetFormat}
\protect \large \begin{verbatim}
GetFormat[x->EFG, {nDecimals<->6}] =: EFG
GetFormat[x->NFG, {nDecimals<->6}] =: NFG
\end{verbatim} \normalsize

\bd
Sets the formatting style for .efg and .nfg files.
\bd
\item [nDecimals:] The number of decimal places to use in representing
floating-point numbers.
\ed
\item [See also:] \verb+Format+, \verb+SaveEfg+, \verb+SaveNfg+.
\ed

\item\lex{GetListFormat}
\protect \large \begin{verbatim}
GetListFormat[{braces<->True}, {commas<->True},
              {lf<->2}, {indent<->2}] =: BOOLEAN 
\end{verbatim} \normalsize

\bd
Gets the current formatting style for output of lists on output streams.
\bd
\item [braces:] If \verb+True+, lists are delimited by braces.
\item [commas:] If \verb+True+, elements are delimited by commas.
\item [lf:] Number of levels of list that are displayed with a line feed.
\item [indent:] Number of spaces to indent each level of a list.
\ed
\item [See also:] \verb+Write+, \verb+Format+.
\ed

\item\lex{GetPath}
\protect \large \begin{verbatim}
*GetPath[] =: TEXT 
\end{verbatim} \normalsize

\bd
Returns the path to the file in which the command is included.  Can be
used to identify \verb+Include[]+ files. 
\item [Note:] Special function.  Not listable; not documented in
\verb+Help+ or \verb+Manual+.
\item [See also:] \verb+ExePath+, \verb+Include+.
\ed

\item\lex{Greater}
\protect \large \begin{verbatim}
Greater[x->NUMBER, y->NUMBER] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when \verb+x+ is (strictly) greater than \verb+y+.
\item
[Short form:] \verb+x > y+
\item
[See also:] \verb+GreaterEqual+, \verb+Less+, \verb+LessEqual+.
\ed

\item\lex{Greater}
\protect \large \begin{verbatim}
Greater[x->TEXT, y->TEXT] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when the string \verb+x+ is lexicographically (strictly)
greater than the string \verb+y+, using the native character set of the 
achine.
\item
[Short form:] \verb+x > y+
\item
[See also:] \verb+GreaterEqual+, \verb+Less+, \verb+LessEqual+.
\ed

\item\lex{GreaterEqual}
\protect \large \begin{verbatim}
GreaterEqual[x->NUMBER, y->NUMBER] =: BOOLEAN 
\end{verbatim}\normalsize

\marginpar{Precision issues}
\bd
Returns \verb+True+ when \verb+x+ is at least as large as \verb+y+.
\item
[Short form:] \verb+x >= y+
\item
[See also:] \verb+Greater+, \verb+Less+, \verb+LessEqual+.
\ed

\item\lex{GreaterEqual}
\protect \large \begin{verbatim}
GreaterEqual[x->TEXT, y->TEXT] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when the string \verb+x+ is lexicographically greater than
or equal to the string \verb+y+, using the native character set of the
machine.
\item
[Short form:] \verb+x >= y+
\item
[See also:] {\tt Greater}, {\tt Less}, {\tt LessEqual}.
\ed

%--H--


\item\lex{Help}
\protect \large \begin{verbatim}
Help[x->TEXT, {udf->True}, {bif->True}] =: LIST(TEXT) 
\end{verbatim}\normalsize

\bd 
Returns a list of all function names or function prototypes matching
\verb+x+.  If \verb+x+ is an exact match to a function name, a list of
corresponding function prototypes is returned.  \verb+x+ can also
contain the regular-expression style wildcards \verb+*+ and \verb+?+.
In this case, if there is not an exact match, a list of function names
matching \verb+x+ is returned.  The parameter \verb+udf+ determines if
user defined functions are listed, and \verb+bif+ determines if built
in functions are listed.  Both of these parameters are \verb+True+ by
default.
\item
[See also:] \verb+HelpVars+, \verb+Manual+.
\ed

\item\lex{HelpVars}
\protect \large \begin{verbatim}
HelpVars[x->TEXT] =: LIST(TEXT) 
\end{verbatim}\normalsize

\bd 
Returns a list of all variables matching \verb+x+.  \verb+x+ can
contain regular-expression style wildcards \verb+*+ and \verb+?+. 
In this case,
if there is not an exact match, a list of variables matching \verb+x+
is returned.
\item [See also:] \verb+Help+.
\ed

%--I--

\item\lex{If} 
\protect \large \begin{verbatim}
*If[boolean-expression, statement-list]
*If[boolean-expression, statement-list, statement-list]
\end{verbatim} \normalsize
  
\bd
Defines a block of statements to be executed under certain conditions.
See the section on control structures for complete information. 
\item [Note:] Special function.  Not listable; arguments are not GCL
data types; not documented in \verb+Help+ or \verb+Manual+.  
\ed


\item\lex{Include}
\protect \large \begin{verbatim}
*Include[file->TEXT]
\end{verbatim}\normalsize

\bd
Includes the commands in the specified file as commands
in the running GCL program.  The program treats the command as if it
were replaced by the contents of the file.  \verb+Include+ may only be used
at the top level, that is, it cannot be used inside of \verb+NewFunction+
or flow control structures.
\item [Note:] Special function:  Not listable; cannot be called in a
user defined function; not documented in \verb+Help+ or \verb+Manual+. 
\ed


\item\lex{Index}
\protect \large \begin{verbatim}
Index[list->NLIST(T), x->T] =: LIST(INTEGER) 
Index[list->NLIST(T), x->LIST(T)] =: LIST(INTEGER) 
\end{verbatim} \normalsize

{\tt for all types} {\tt T}
\bd
Returns the list of indices in \verb+list+ where \verb+x+ appears.
\ed

\item\lex{Infoset}
\protect \large \begin{verbatim}
Infoset[action->ACTION*] =: INFOSET 
\end{verbatim} \normalsize

\bd
Returns the information set to which \verb+action+ belongs.  The null
action is assumed to belong to the null information set.
\item [See also:] \verb+Actions+.
\ed

\item\lex{Infoset}
\protect \large \begin{verbatim}
Infoset[node->NODE*] =: INFOSET 
\end{verbatim}\normalsize

\bd
Returns the information set to which \verb+node+ belongs.  All
nonterminal nodes belong to an information set.  By convention,
terminal nodes and the null node, belong to the null information set.
\item [See also:] \verb+Members+.
\ed

\item\lex{InfosetProb}
\protect \large \begin{verbatim}
InfosetProb[profile->BEHAV, infoset->INFOSET*] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the probability of reaching \verb+infoset+ when all players
follow \verb+profile+.  The probability of reaching the null information
set is defined to be null.  It is an error if \verb+profile+ and
\verb+infoset+ are not defined on the same extensive form game.
\item
[See also:] \verb+ActionValue+, \verb+Belief+, \verb+NodeValue+,
\verb+RealizProb+.
\ed

\item\lex{InfosetProbs}
\protect \large \begin{verbatim}
InfosetProbs[profile->BEHAV] =: LIST(LIST(NUMBER)) 
\end{verbatim}\normalsize

\bd
Returns the probability of reaching \verb+infoset+ when all players
follow \verb+profile+.  The probability of reaching the null information
set is defined to be null.  It is an error if \verb+profile+ and
\verb+infoset+ are not defined on the same extensive form game.
\item
[See also:] \verb+ActionValue+, \verb+Belief+, \verb+NodeValue+,
\verb+RealizProb+.
\ed

\item\lex{Infosets}
\protect \large \begin{verbatim}
Infosets[player->EFPLAYER] =: LIST(INFOSET) 
\end{verbatim}\normalsize

\bd
Returns the list of information sets at which 
\verb+player+ has the decision.
\item [See also:] \verb+Player+.
\ed

\item\lex{Input}
\protect \large \begin{verbatim}
Input[file->TEXT] =: INPUT 
\end{verbatim}\normalsize

\bd
Opens a new input stream for reading from the file \verb+text+.  An
error occurs if the file is not able to be opened.
\item
[See also:]  \verb+Output+, \verb+Read+.
\ed

%\item\lex{Insert}
%\protect \large \begin{verbatim}
%Insert[list<->NLIST(T*), x->T*, {n->INTEGER}] =: LIST(T)
%Insert[list<->NLIST(T*), x->NLIST(T*), {n->INTEGER}] =: LIST(T) 
%\end{verbatim}\normalsize

%{\it for all types} {\tt T}
%\bd
%Inserts the element \verb+x+ into \verb+list+.  If \verb+n+ is
%unspecified, \verb+x+ is appended to \verb+list+; otherwise, \verb+x+
%is inserted as the \verb+n+th element.  It is an error if \verb+n+ is
%nonpositive, or if \verb+n+ is greater than the length of \verb+list+.
%\item [See also:] \verb+Remove+.
%\ed

\item\lex{InsertAction}
\protect \large \begin{verbatim}
InsertAction[infoset->INFOSET, at->ACTION] =: ACTION 
InsertAction[infoset->INFOSET] =: ACTION 
\end{verbatim}\normalsize

\bd
Inserts a new action into \verb+infoset+ before the action \verb+at+.  
If \verb+at+ is not specified, the new action is appended to \verb+infoset+'s
actions.
The corresponding new branch is created for
each node belonging to \verb+infoset+.  Returns the newly created action.
\item
[See also:] \verb+Actions+, \verb+DeleteAction+.
\ed

\item\lex{InsertMove}
\protect \large \begin{verbatim}
InsertMove[infoset->INFOSET, node->NODE] =: NODE 
\end{verbatim}\normalsize

\bd
Inserts a new node in the tree at the location of \verb+node+.  The
new node is made a member of \verb+infoset+, and the
corresponding number of branches are created from the new node.  \verb+node+
becomes the first child of the new node.  Returns the new node.
\item [See also:] \verb+AddMove+, \verb+DeleteMove+, \verb+NewInfoset+.
\ed

\item\lex{Integer}
\protect \large \begin{verbatim}
Integer[x->NUMBER] =: INTEGER 
\end{verbatim} \normalsize

\bd
Converts \verb+x+ into an integer value by truncation.
\ed

\item\lex{IntegerDivide} 
\protect \large \begin{verbatim}
IntegerDivide[x->INTEGER, y->INTEGER] =: INTEGER 
\end{verbatim} \normalsize

\bd
Returns the quotient $x / y$, rounded to the next integer
towards zero.  It is an error to attempt to divide by zero.
\item [Short form:] \verb%x DIV y%
\item [See also:] \verb+Divide+, \verb+Modulus+.
\ed

\item\lex{Inverse}
\protect \large \begin{verbatim}
Inverse[x->LIST(LIST(NUMBER))] =: LIST(LIST(NUMBER))
\end{verbatim} \normalsize

\bd
Returns the inverse of the matrix \verb+x+.  It is an error if the
matrix is not square or is singular.
\ed

\item\lex{IsConsistent}
\protect \large \begin{verbatim}
IsConsistent[basis->EFBASIS] =: BOOLEAN
\end{verbatim} \normalsize

\bd
Returns true if \verb+basis+ is a consistent basis -- i. e., if it
is a basis which could be a support for a sequential
equilibrium.\marginpar{give cite here.}  
\ed

\item\lex{IsConstSum}
\protect \large \begin{verbatim}
IsConstSum[nfg->NFG] =: BOOLEAN 
IsConstSum[efg->EFG] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when the game \verb+efg+ or \verb+nfg+ is constant sum.
\ed

\item\lex{IsDefined}
\protect \large \begin{verbatim}
IsDefined[x->T] =: BOOLEAN
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns \verb+True+ if \verb+x+ has been defined.  Useful for testing
the existence of static variables.
\ed

\item\lex{IsEof}
\protect \large \begin{verbatim}
IsEof[input->INPUT] =: BOOLEAN
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when the input stream \verb+Input+ has reached the
end of file.
\item [See also:] \verb+Read+.
\ed

\item\lex{IsList}
\protect \large \begin{verbatim}
IsList[x->T] =: BOOLEAN 
IsList[list->NLIST(T)] =: BOOLEAN 
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd 
Returns \verb+True+ when \verb+x+ is a list or a nested list.
\item
[See also:] \verb+List+.
\ed

\item\lex{IsNash}
\protect \large \begin{verbatim}
IsNash[profile->BEHAV] =: BOOLEAN 
IsNash[profile->MIXED] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when \verb+profile+ is known by Gambit to be a
Nash equilibrium of the corresponding game, and \verb+False+ if
\verb+profile+ is known to not be Nash.  Otherwise, the return value
is \verb+Unknown+.  If \verb+profile+ is complete (probabilities sum
to one for every player, and every information set), then there is a
definitive test for Nash equilibrium.  However if the profile is
incomplete (i. e., it does not specify actions at off the equilibrium
path information sets), then it is possible that a profile (or set of
all completions of the profile) may be Nash, but is not known by
Gambit to be Nash.
\ed

\item\lex{IsNull}
\protect \large \begin{verbatim}
IsNull[x->T*] =: BOOLEAN 
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns \verb+True+ if x is a NULL object of type \verb+T+.  
\ed

\item\lex{IsPerfect}
\protect \large \begin{verbatim}
IsPerfect[profile->MIXED] =: BOOLEAN 
\end{verbatim}\normalsize

\bd 
Returns \verb+True+ if \verb+profile+ is known by Gambit to be a
perfect Nash equilibrium, \verb+False+ if it is known to not be
perfect, and \verb+Unknown+ otherwise.  There is currently no
definitive test in Gambit for whether an arbitrary profile is perfect.
However some of the algorithms (notably \verb+LcpSolve+) will only
return perfect equilibria, which are marked as such.   
\ed

\item\lex{IsPerfectRecall}
\protect \large \begin{verbatim}
IsPerfectRecall[efg->EFG] =: BOOLEAN 
\end{verbatim}\normalsize

\bd 
Returns \verb+True+ if \verb+efg+ is a game of perfect recall, and
\verb+False+ otherwise 
\ed


\item\lex{IsPredecessor}
\protect \large \begin{verbatim}
IsPredecessor[node->NODE, of->NODE] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when \verb+node+ is a predecessor
in the tree of the node \verb+of+.  A node is considered its own predecessor.
\item [See also:] \verb+IsSuccessor+.
\ed

\item\lex{IsSequential}
\protect \large \begin{verbatim}
IsSequential[profile->BEHAV] =: BOOLEAN 
\end{verbatim}\normalsize

\bd 
Returns \verb+True+ if \verb+profile+
is known by Gambit to be an approximation to a
sequential Nash equilibrium, \verb+False+ if it is not, and \verb+Unknown+ if the answer is not known.  There is
currently no definitive test in Gambit for whether an arbitrary
profile is sequential.  However any Nash equilibrium of an extensive
form game which is computed via the \verb+LiapSolve+ or
\verb+QreSolve+ algorithms is sequential.
\ed

\item\lex{IsSubgamePerfect}
\protect \large \begin{verbatim}
IsSubgamePerfect[profile->BEHAV] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ if \verb+profile+
is known by Gambit to be a subgame perfect Nash
equilibrium, \verb+False+ if it is known not to be a subgame perfect equilibrium, and \verb+Unknown+ otherwise.  There is currently no
definitive test in Gambit for whether an arbitrary profile is subgame
perfect.  However, any Nash equilibrium of an extensive form game which
is computed when all subgames are marked will only return a subgame
perfect equilibrium.  
\ed

\item\lex{IsSuccessor}
\protect \large \begin{verbatim}
IsSuccessor[node->NODE, from->NODE] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when \verb+node+ is a successor
in the tree of the node \verb+from+.  A node is considered its own successor.
\item [See also:] \verb+IsPredecessor+.
\ed

\item\lex{IsWatchRunning}
\protect \large \begin{verbatim}
IsWatchRunning[] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when the system stopwatch is currently running.
\item
[See also:] \verb+ElapsedTime+, \verb+StartWatch+, \verb+StopWatch+.
\ed


%--J--

%--K--

\marginpar{Should we put \verb+KQreSolve+ in?}

%--L--

\item\lex{LcpSolve}
\protect \large \begin{verbatim}
LcpSolve[support->NFSUPPORT, {stopAfter->1}, {precision->Float}, 
         {nPivots<->0}, {time<->0}, {traceFile<->(Output)}, 
         {traceLevel->0}] =: LIST(MIXED) 
LcpSolve[support->EFSUPPORT, {asNfg->False}, {stopAfter->1}, 
         {precision->Float}, {nPivots<->0}, {time<->0.000000}, 
         {traceFile<->(Output)}, {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd
Solves the game as a linear complementarity problem, using the
Lemke-Howson algorithm for normal form games, and the
Koller-Megiddo-Stengel sequence form for extensive form games.  


The behavior of the algorithm may be modified by the following
optional parameters:
\bd
\item
[asNfg:] By default, extensive forms are solved by the sequence form.
By setting this parameter to \verb+True+, each marked subgame of the extensive
form is converted to its corresponding reduced normal form, solved
via Lemke-Howson, and the mixed strategy solutions converted back into
behavior profiles.
\item
[stopAfter:] Specifies the maximum number of equilibria to find.  The
default is one. If set to zero then all equilibria reachable by the
algorithm will be found.
\item
[precision:] Determines the precision of the computation. Default is
floating point precision (\verb+Float+). 
\item
[nPivots:] Returns the total number of pivots. 
\item
[time:] Returns the elapsed time for the operation.
\item
[traceFile:] A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no
logging at all.
\ed
\item [See also:] \verb+LpSolve+.
\ed

\item\lex{Length}
\protect \large \begin{verbatim}
Length[list->LIST(T*)] =: INTEGER
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns the number of elements in \verb+list+.
\item
[See also:] \verb+NthElement+, \verb+NumElements+.
\ed

\item\lex{Less}
\protect \large \begin{verbatim}
Less[x->NUMBER, y->NUMBER] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when \verb+x+ is (strictly) less than \verb+y+.
\item [Short form:] \verb+x < y+
\item [See also:] \verb+Greater+, \verb+GreaterEqual+, \verb+LessEqual+.
\ed

\item\lex{Less}
\protect \large \begin{verbatim}
Less[x->TEXT, y->TEXT] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when the string \verb+x+ is lexicographically (strictly)
less than
the string \verb+y+, using the native character set of the machine.
\item [Short form:] \verb+x < y+
\item [See also:] \verb+Greater+, \verb+GreaterEqual+, \verb+LessEqual+.
\ed

\item\lex{LessEqual}
\protect \large \begin{verbatim}
LessEqual[x->NUMBER, y->NUMBER] =: BOOLEAN 
\end{verbatim}\normalsize

\marginpar{Address precision issue}
\bd
Returns \verb+True+ when \verb+x+ is no more than \verb+y+.
\item [Short form:] \verb+x <= y+
\item [See also:] \verb+Greater+, \verb+GreaterEqual+, \verb+Less+.
\ed

\item\lex{LessEqual}
\protect \large \begin{verbatim}
LessEqual[x->TEXT, y->TEXT] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when the string \verb+x+ is lexicographically less than
or equal to the string \verb+y+, using the native character set of the machine.
\item [Short form:] \verb+x <= y+
\item [See also:] \verb+Greater+, \verb+GreaterEqual+, \verb+Less+.
\ed

\item\lex{LiapSolve}
\protect \large \begin{verbatim}
LiapSolve[start->BEHAV, {asNfg->False}, {stopAfter->1}, 
          {nTries->10}, {maxitsN->20}, {tolN->0.000000}, 
          {maxits1->100}, {tol1->0.000000}, {time<->0}, 
          {nEvals<->0}, {traceFile<->(Output)}, 
          {traceLevel->0}] =: LIST(BEHAV) 
LiapSolve[start->MIXED, {stopAfter->1}, {nTries->10}, 
          {maxitsN->20}, {tolN->0.000000}, {maxits1->100}, 
          {tol1->0.000000}, {time<->0}, {nEvals<->0}, 
          {traceFile<->(Output)}, {traceLevel->0}] =: LIST(MIXED) 
\end{verbatim}\normalsize


\bd 
Searches for a Nash equilibrium by minimizing a Lyapunov function
which is zero exactly at Nash equilibria.  The algorithm starts from
the initial starting point determined by the parameter \verb+start+.
The algorithm is not guaranteed to find a Nash equilibrium from any
fixed starting point.  The algorithm thus incorporates the capability
of restarting.  If a Nash equilibrium is not found, it will keep
searching from new randomly chosen starting points until a Nash
equilibrium has been found or the maximum number of tries (parameter
\verb+nTries+) is exceeded, whichever comes first.  The list of
solutions found is returned.

The behavior of the algorithm may be modified by specifying the following
optional parameters:
\bd
\item
[asNfg:] By default, extensive forms are solved in the extensive form.
By setting this parameter to \verb+True+, each marked subgame of the
extensive form is converted to its corresponding reduced normal form game,
solved, and the overall behavior profile reconstructed from these
solutions.
\item
[nTries:] Sets the maximum number of attempts at finding an
equilibrium. Default is 10.
\item
[stopAfter:] Sets the number of equilibria to find.  Default is 1.
\item
[maxitsN:] Sets the maximum number of iterations in the
$n$-dimensional optimization.  Default is 10.
\item
[tolN:] Sets the tolerance for the $n$-dimensional optimization
routine.  Default is 1.0e-10.
\item
[maxits1:] Sets the maximum number of iterations in the
one-dimensional line search.  Default is 100.
\item
[tol1:] Sets the tolerance for the one-dimensional line search.
Default is 2.0e-10.
\item
[time:] Returns the elapsed time for the operation.
\item
[nEvals:] Returns the number of function evaluations for the operation.
\item
[traceFile:] A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no output
at all.
\ed
\ed

\item\lex{LiapValue}
\protect \large \begin{verbatim}
LiapValue[profile->BEHAV] =: NUMBER 
LiapValue[profile->MIXED] =: NUMBER 
\end{verbatim} \normalsize

\bd 
Returns the Lyapunov function value for \verb+profile+.
This value is zero exactly when the
profile is a Nash equilibrium.
\ed

\item\lex{List}
\protect \large \begin{verbatim}
List[x->T, {length->INTEGER}] =: LIST(T)
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Creates a new list of \verb+length+ elements, each equal to \verb+x+.
If \verb+length+ is unspecified, it defaults to 1.
\ed

\item\lex{List}
\protect \large \begin{verbatim}
List[x->NUMBER, {length->1}, {delta->0}] =: LIST(NUMBER) 
\end{verbatim}\normalsize

\bd
Creates an initialized list of \verb+length+ elements, whose $i^{th}$
entry is \verb%x + (i * delta)%.  If \verb+length+ is unspecified,
it defaults to 1; if \verb+delta+ is unspecified, it defaults to 0.
\ed

\item\lex{ListFormat}
\protect \large \begin{verbatim}
ListFormat[{braces<->True}, {commas<->True},
           {lf<->2}, {indent<->2}] =: BOOLEAN
\end{verbatim} \normalsize

\bd
Sets the formatting style for output of lists on output streams.  The
parameters passed are set to the prior style settings on return.

\bd
\item [braces:] If \verb+True+, lists are delimited by braces.
\item [commas:] If \verb+True+, elements are delimited by commas.
\item [lf:] Number of levels of list that are displayed with a line feed.
\item [indent:] Number of spaces to indent each level of a list.
\ed
\item [See also:] \verb+Write+, \verb+Format+.
\ed

\item\lex{LoadEfg}
\protect \large \begin{verbatim}
LoadEfg[file->TEXT] =: EFG 
\end{verbatim}\normalsize

\bd
Loads an extensive form game from an external savefile.
It is an error if the file cannot be opened, or if the file does
not contain a valid extensive form savefile.
\item [See also:] \verb+SaveEfg+.
\ed

\item\lex{LoadNfg}
\protect \large \begin{verbatim}
LoadNfg[file->TEXT] =: NFG 
\end{verbatim}\normalsize

\bd
Loads a normal form game from an external savefile.
It is an error if the file cannot be opened, or if the file does not 
contain a valid normal form savefile.
\item [See also:] \verb+SaveNfg+.
\ed

\item\lex{Log}
\protect \large \begin{verbatim}
Log[x->NUMBER] =: NUMBER 
\end{verbatim} \normalsize

\bd
Computes the natural logarithm of \verb+x+.  It is an error if
\verb+x+ is nonpositive.
\item [Note:] Result is returned in \verb+Float+ precision, regardless of
the precision of \verb+x+.
\item [See also:] \verb+Exp+, \verb+Power+.
\ed

\item\lex{LpSolve}
\protect \large \begin{verbatim}
LpSolve[support->NFSUPPORT, {stopAfter->1}, 
        {precision->Float}, {nPivots<->0}, 
        {time<->0.000000}, {traceFile<->(Output)}, 
        {traceLevel->0}] =: LIST(MIXED) 
LpSolve[support->EFSUPPORT, {asNfg->False}, 
        {stopAfter->1}, {precision->Float}, 
        {nPivots<->0}, {time<->0.000000}, 
        {traceFile<->(Output)}, {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd
Solves a two-person, constant-sum game for a Nash equilibrium as a linear
program.  For extensive form games, the Koller-Megiddo-Stengel
sequence form is used; games not of perfect recall return the empty
list of solutions.

The behavior of the algorithm may be modified by the following optional
parameters:
\bd
\item
[asNfg:] By default, extensive forms are solved by the sequence form.
By setting this parameter to \verb+True+, each marked subgame of the
extensive form is converted to its corresponding reduced normal form,
solved as a linear program, and the mixed strategy solutions converted back
into behavior profiles.
\item
[stopAfter:] Maximum number of equilibria to find.  
\item
[precision:] Determines the precision of the computation. Default is
floating point precision (\verb+Float+). 
\item
[nPivots:] Returns the total number of pivots.
\item
[time:] Returns the elapsed time for the operation.
\item
[traceFile:] A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no
output at all.
\ed
\item [See also:] \verb+LcpSolve+.
\ed

%--M--

\item\lex{Manual}
\protect \large \begin{verbatim}
Manual[x->TEXT, {y->(Output)}] =: BOOLEAN 
\end{verbatim} \normalsize

\bd 
Prints the manual entry for the function \verb+x+.  If there is no
entry for \verb+x+, no output is generated. The parameter
\verb+y+, which is the null output by default, can be used to print
the manual entry to an output stream.
\item [See also:] \verb+Help+, \verb+HelpVars+.
\ed

\item\lex{MarkSubgame}
\protect \large \begin{verbatim}
MarkSubgame[node->NODE] =: BOOLEAN 
\end{verbatim} \normalsize

\bd
Mark \verb+node+ as being the root of a subgame for use in later computation.
Only nodes which are roots of subgames may be marked.  Returns \verb+True+
if \verb+node+ was marked as a subgame (i.e., if it is the root of a subgame).
\item [See also:] \verb+MarkedSubgame+, \verb+Subgames+,
\verb+UnmarkSubgame+.
\ed


\item\lex{MarkedSubgame}
\protect \large \begin{verbatim}
MarkedSubgame[node->NODE] =: BOOLEAN 
\end{verbatim} \normalsize

\bd
Returns \verb+True+ if \verb+node+ is currently marked as a subgame. 
\item [See also:] \verb+MarkSubgame+, \verb+Subgames+, \verb+UnmarkSubgame+.
\ed


\item\lex{Members}
\protect \large \begin{verbatim}
Members[infoset->INFOSET*] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd
Returns the list of nodes which are members of \verb+infoset+.  If
\verb+infoset+ is null, the empty list is returned.
\item [See also:] \verb+Infoset+.
\ed

\item\lex{MergeInfosets}
\protect \large \begin{verbatim}
MergeInfosets[to->INFOSET,
              from->INFOSET] =: INFOSET
\end{verbatim}\normalsize

\bd
Moves all the nodes from the information set \verb+from+ into \verb+to+.
It is an error if the number of actions is not the same at the
two information sets, or if the information sets are not from the
same extensive form game.  The information set \verb+to+ is returned.
\item [See also:] \verb+MoveToInfoset+.
\ed

\item 
\protect \large \begin{verbatim}
Minus[x->NUMBER, y->NUMBER] =: NUMBER 
Minus[x->MIXED, y->MIXED] =: MIXED 
Minus[x->BEHAV, y->BEHAV] =: BEHAV 
\end{verbatim} \normalsize

\bd
Returns the difference $x - y$.
\item [Short form:] \verb+x - y+
\item [See also:] \verb+Divide+, \verb+Plus+, \verb+Times+.
\ed

\item\lex{Mixed}
\protect \large \begin{verbatim}
Mixed[support->NFSUPPORT] =: MIXED 
\end{verbatim}\normalsize

\bd
Returns a mixed strategy profile over \verb+support+ with equal
probabilites for each strategy in the support.  
\item [See also:] \verb+Behav+, \verb+Centroid+.
\ed

\marginpar{Didn't we used to have {\tt Mixed[BEHAV]}?}
\item\lex{Modulus}
\protect \large \begin{verbatim}
Modulus[x->INTEGER, y->INTEGER] =: INTEGER 
\end{verbatim}\normalsize

\bd
Computes the remainder from dividing \verb+y+ into \verb+x+.  It is an
error if \verb+y+ is zero.
\item [Short form:] \verb+x MOD y+
\item [See also:] \verb+IntegerDivide+.
\ed


\item\lex{MoveToInfoset}
\protect \large \begin{verbatim}
MoveToInfoset[node->NODE, infoset->INFOSET] =: NODE 
\end{verbatim}\normalsize

\bd
Removes \verb+node+ from its current information set, and makes it a
member of \verb+infoset+. It is an error if the number of actions at
\verb+node+ is not the same as the number of actions in
\verb+infoset+, or if \verb+node+ and \verb+infoset+ are from
different extensive form games.   
\item [See also:] \verb+MergeInfosets+.
\ed


\item\lex{MoveTree}
\protect \large \begin{verbatim}
MoveTree[from->NODE, to->NODE] =: NODE 
\end{verbatim}\normalsize

\bd
Moves the subtree rooted at \verb+from+ to
the terminal node \verb+to+.  \verb+from+ becomes a terminal node.
Returns \verb+to+.  It is an error if \verb+to+ is not a terminal
node, or if \verb+from+ and \verb+to+ are not from the same extensive
form game.
\item [See also:] \verb+CopyTree+.
\ed

%--N--

\item\lex{Name}
\protect \large \begin{verbatim}
Name[x->T*] =: TEXT
\end{verbatim}\normalsize

{\it for} {\tt T = ACTION, EFG, EFOUTCOME, EFPLAYER, INFOSET,
NFG, NFOUTCOME, NFPLAYER, NODE, STRATEGY} 
\bd
Returns the name of \verb+x+.  The name of a null object is defined
to be the empty string.
\item
[See also:] \verb+SetName+.
\ed

\item\lex{Negate} 
\protect \large \begin{verbatim}
Negate[x->NUMBER] =: NUMBER 
\end{verbatim} \normalsize

\bd
Returns $-x$.
\item
[Short form:] \verb+-x+
\ed

\item\lex{NewEfg}
\protect \large \begin{verbatim} 
NewEfg[{players->{}}] =: EFG 
\end{verbatim}\normalsize

\bd
Creates a new extensive form game.  The default extensive form
game has no players (other than the chance player) defined on it; the
optional parameter \verb+players+ specifies a list of players to be
created and the names to be assigned to them.  Returns the newly created game.
\ed

\item\lex{NewFunction}   
\protect \large \begin{verbatim}
*NewFunction[name[argument-list], body]
\end{verbatim}\normalsize

\bd
Creates a new function.  The function may be called exactly
as if it were a predefined function of the command language.  See the
section on user-defined functions for more detailed information.
\item [Note:]  Special function.  Not listable, cannot be called in a
user defined function; not documented in \verb+Help+ or \verb+Manual+.  
\item [See also:] \verb+DeleteFunction+.
\ed

\item\lex{NewInfoset}
\protect \large \begin{verbatim} 
NewInfoset[player->EFPLAYER, actions->INTEGER] =: INFOSET 
\end{verbatim}\normalsize

\bd
Creates a new information set belonging to \verb+player+, with
\verb+actions+ actions.  It is an error if \verb+actions+ is not
positive.  The newly created information set is returned.
\item [See also:] \verb+DeleteEmptyInfoset+.
\ed

\item\lex{NewNfg}
\protect \large \begin{verbatim}
NewNfg[dim->LIST(INTEGER)] =: NFG 
\end{verbatim}\normalsize

\bd 
Creates a new normal form game with dimensionality \verb+dim+.  No
initialization of the payoffs of the game is done.  Returns the newly
created game.  
\ed

\item\lex{NewOutcome}
\protect \large \begin{verbatim} 
NewOutcome[efg->EFG] =: EFOUTCOME 
\end{verbatim}\normalsize


\bd 
Defines a new outcome in the extensive form game \verb+efg+.  The new
outcome specifies payoffs of zero for all players.  Returns the newly
created outcome.
\item [See also:] \verb+DeleteOutcome+, \verb+SetOutcome+.
\ed


\item\lex{NewOutcome}
\protect \large \begin{verbatim} 
NewOutcome[nfg->NFG] =: NFOUTCOME 
\end{verbatim}\normalsize

\bd 
Defines a new outcome in the normal form game \verb+nfg+.  The new
outcome specifies payoffs of zero for all players.  Returns the newly
created outcome.
\item [See also:] \verb+DeleteOutcome+, \verb+Outcomes+,
\verb+SetOutcome+.
\ed


\item\lex{NewPlayer}
\protect \large \begin{verbatim}
NewPlayer[efg->EFG] =: EFPLAYER 
\end{verbatim}\normalsize

\bd 
Defines a new player in the extensive form game \verb+efg+.  Returns
the newly created player.  
\ed

\item\lex{NextSibling}
\protect \large \begin{verbatim}
NextSibling[node->NODE] =: NODE 
\end{verbatim}\normalsize

\bd
Returns the next sibling of \verb+node+.  If \verb+node+ has no next
sibling, the null node is returned.
\item [See also:] \verb+PriorSibling+.
\ed

\item\lex{Nfg}
\protect \large \begin{verbatim}
Nfg[efg->EFG, {time<->0}] =: NFG 
\end{verbatim}\normalsize

\bd
Creates and returns the (structural) reduced normal form game equivalent
to the extensive form game \verb+efg+.  The optional parameter \verb+time+,
if specified, contains upon completion the amount of time consumed by
the transformation.
\item [See also:] \verb+AgentForm+.
\ed

\item\lex{NodeNumber}
\protect \large \begin{verbatim}
NodeNumber[node->NODE, basis->EFBASIS] =: INTEGER 
\end{verbatim}\normalsize

\bd Returns the number assigned to \verb+node+ in the \verb+EFBASIS+,
\verb+basis+.
\item [See also:] \verb+Basis+. 
\ed

\item\lex{NodeValue}
\protect \large \begin{verbatim}
NodeValue[profile->BEHAV, player->EFPLAYER, node->NODE] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the expected payoff to \verb+player+ at \verb+node+, given
that all players are following \verb+profile+.
\item [See also:] \verb+ActionValue+, \verb+Belief+, \verb+InfosetProb+,
\verb+RealizProb+.
\ed

\item\lex{NodeValues}
\protect \large \begin{verbatim}
NodeValues[profile->BEHAV, player->EFPLAYER] =: LIST(NUMBER) 
\end{verbatim}\normalsize

\bd 
Returns the expected payoff to \verb+player+ at all nodes in the
game, given that all players are following \verb+profile+.  The nodes
are in indexed traversal order.
\item [See also:] \verb+NodeValue+.  
\ed

\item\lex{Nodes}
\protect \large \begin{verbatim}
Nodes[efg->EFG] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd
Returns a list of nodes of the extensive form game \verb+efg+.  The
list is in {\it indexed traversal} order.  This is the order that is
imposed by a lexicographic ordering of the nodes when each node is
identified by the sequence of branch numbers taken to reach it.  
\ed

\item\lex{Nodes}
\protect \large \begin{verbatim}
Nodes[infoset->INFOSET*, basis->EFBASIS] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd
Returns a list of nodes of the information set \verb+infoset+ in the
\verb+basis+.  
\ed

\item\lex{Not}
\protect \large \begin{verbatim}
Not[x->BOOLEAN] =: BOOLEAN 
\end{verbatim}\normalsize

\bd
Returns the boolean inverse of \verb+x+, according to the truth table:
\begin{center}
\begin{tabular}{|c|c|}  \hline
\verb+x+ & \verb+Not[x]+ \\ \hline
\verb+True+ & \verb+False+ \\
\verb+False+ & \verb+True+ \\
\verb+Unknown+ & \verb+Unknown+ \\ \hline
\end{tabular}
\end{center}

\item [Short forms:] \verb+NOT x+, \verb+!x+.
\item [See also:] \verb+And+, \verb+Or+.
\ed

\item\lex{NotEqual}
\protect \large \begin{verbatim}
NotEqual[x->T*, y->T*] =: BOOLEAN
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns \verb+True+ when the values of \verb+x+ and \verb+y+ are
not equal.
\item [Short form:] \verb+x != y+.
\item [See also:] \verb+Equal+.
\ed

\item\lex{BthChar}
\protect \large \begin{verbatim}
NthChar[text->TEXT, n->INTEGER] =: TEXT 
\end{verbatim}\normalsize

\bd
Returns a text string of length 1 containing the \verb+n+th
character from \verb+text+.  By convention, the first character
in a string is indexed by 1.  It is an error if \verb+n+ is nonpositive,
or if \verb+n+ is greater than the length of \verb+text+.
\item [Short forms:] \verb+text[[n]]+, \verb+text#n+.
\item [See also:] \verb+NumChars+.
\ed

\item\lex{NthChild}
\protect \large \begin{verbatim} 
NthChild[node->NODE, n->INTEGER] =: NODE 
\end{verbatim}\normalsize

\bd
Returns the \verb+n+th child of \verb+node+.
By convention, the first child of a node is indexed by 1.
It is an error if \verb+n+ is nonpositive, or if \verb+n+ is greater
than the number of children of \verb+node+.
\item [Short form:] \verb+node#n+.
\item [See also:] \verb+Children+.
\ed

\item\lex{NthElement}
\protect \large \begin{verbatim}
NthElement[list<->NLIST(T*), n->INTEGER] =: T 
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns the \verb+n+th element of \verb+list+.
By convention, the first element of a list is indexed by 1.
It is an error if \verb+n+ is nonpositive, or if \verb+n+ is greater
than the number of elements in \verb+list+.
\item [Short form:] \verb+list[[n]]+, \verb+list_n+.
\item [See also:] \verb+Length+.
\ed

\item\lex{Null}
\protect \large \begin{verbatim}
Null[x->T] =: T*
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns a null object of type \verb+T+.  
\ed

\item\lex{NumChars}
\protect \large \begin{verbatim}
NumChars[text->TEXT] =: INTEGER 
\end{verbatim}\normalsize

\bd
Returns the number of characters in \verb+text+.
\item [See also:] \verb+NthChar+.
\ed

\item\lex{NumElements}
\protect \large \begin{verbatim}
NumElements[list->NLIST(T*)] =: INTEGER 
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns the number of elements in \verb+list+.  The difference between
this function and \verb+Length+ is that this function is not listable,
while \verb+Length+ is.  
\item
[See also:] \verb+NthChar+, \verb+Length+.
\ed




%--O--

\item\lex{Or} 
\protect \large \begin{verbatim}
Or[x->BOOLEAN, y->BOOLEAN] =: BOOLEAN 
\end{verbatim} \normalsize
  
\bd
Returns the disjunction of \verb+x+ and \verb+y+, according to the truth
table:
\begin{center}
\begin{tabular} {|c||c|c|c|} \hline
& \verb+True+ & \verb+False+ & \verb+Unknown+ \\ \hline 
\verb+True+ & \verb+True+ & \verb+True+ & \verb+True+ \\
\verb+False+ & \verb+True+ & \verb+False+ & \verb+Unknown+ \\
\verb+Unknown+ & \verb+True+ & \verb+Unknown+ & \verb+Unknown+ \\ \hline
\end{tabular}
\end{center}
\item
[Short form:] \verb+x || y+, \verb+x OR y+.
\item [See also:] \verb+And+, \verb+Or+.
\ed

\item\lex{Outcome}
\protect \large \begin{verbatim}
Outcome[node->NODE*] =: EFOUTCOME 
\end{verbatim}\normalsize

\bd
Returns the outcome attached to \verb+node+.  If no outcome is attached
to \verb+node+, or if \verb+node+ is null, the null outcome is returned.
\item [See also:] \verb+SetOutcome+.
\ed

\item\lex{Outcome}
\protect \large \begin{verbatim}
Outcome[profile->LIST(STRATEGY)] =: NFOUTCOME 
\end{verbatim}\normalsize

\bd
Returns the outcome associated with the contingency specified by
\verb+profile+.
\item [See also:] \verb+SetOutcome+.
\ed

\item\lex{Outcomes}
\protect \large \begin{verbatim}
Outcomes[efg->EFG] =: LIST(EFOUTCOME) 
\end{verbatim}\normalsize

\bd
Returns the list of outcomes defined on \verb+efg+.
\item [See also:] \verb+DeleteOutcome+, \verb+NewOutcome+.
\ed

\item\lex{Outcomes}
\protect \large \begin{verbatim}
Outcomes[nfg->NFG] =: LIST(NFOUTCOME) 
\end{verbatim}\normalsize

\bd
Returns the list of outcomes defined on \verb+nfg+.
\item [See also:] \verb+DeleteOutcome+, \verb+NewOutcome+.
\ed

\item\lex{Output}
\protect \large \begin{verbatim}
Output[file->TEXT, {append->False}] =: OUTPUT 
\end{verbatim}\normalsize

\bd
Opens a new output stream for writing to \verb+file+.  By default,
an existing file is overwritten; specifying \verb+append+ to be \verb+True+
opens the file in append mode.  An error occurs if \verb+file+ is not
able to be opened.
\item [See also:] \verb+Input+, \verb+ListFormat+, \verb+Format+,
\verb+Write+.
\ed

%--P--

\item\lex{Parent}
\protect \large \begin{verbatim}
Parent[node->NODE*] =: NODE 
\end{verbatim}\normalsize

\bd
Returns the parent of \verb+node+.  If \verb+node+ is the root node,
or if \verb+node+ is null, the null node is returned.
\item [See also:] \verb+Children+.
\ed

\item\lex{Parentheses}
\protect \large \begin{verbatim}
Parentheses[x->T*] =: T 
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns the value passed in \verb+x+.  This is used to control
the order of evaluation of expressions.
\item [Short form:] \verb+(x)+
\ed

\item\lex{Payoff}
\protect \large \begin{verbatim}
Payoff[outcome->EFOUTCOME*, player->EFPLAYER] =: NUMBER 
\end{verbatim}\normalsize
\bd
Returns the payoff to \verb+player+ at \verb+outcome+.  It is an error if
\verb+player+ and \verb+outcome+ are not from the same extensive form game.
\item [See also:] \verb+SetPayoff+.
\ed

\item\lex{Payoff}
\protect \large \begin{verbatim}
Payoff[outcome->NFOUTCOME*, player->NFPLAYER] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the payoff to \verb+player+ at \verb+outcome+.  It is an error if
\verb+player+ and \verb+outcome+ are not from the same game.
\item [See also:] \verb+SetPayoff+.
\ed

\item\lex{Payoff}
\protect \large \begin{verbatim}
Payoff[profile->BEHAV, player->EFPLAYER] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the payoff to \verb+player+ in an extensive form game if all
players follow \verb+profile+.  It is an error if \verb+profile+
and \verb+player+ are not from the same extensive form game.
\ed

\item\lex{Payoff}
\protect \large \begin{verbatim}
Payoff[profile->MIXED, player->NFPLAYER] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the payoff to \verb+player+ in a normal form game if all players
follow \verb+profile+.  It is an error if \verb+profile+ and \verb+player+
are not from the same normal form game.
\ed

\item\lex{Platform}
\protect \large \begin{verbatim}
Platform[] =: TEXT 
\end{verbatim} \normalsize

\bd 
Returns a string identifying the platform that the GCL is
currently running on.  Can be used in user defined functions to define
system dependent variables, such as pathnames and command lines for
shell commands.  
\item [See also:] \verb+Shell+.
\ed

\item\lex{Player}
\protect \large \begin{verbatim}
Player[infoset->INFOSET*] =: EFPLAYER 
\end{verbatim}\normalsize

\bd
Returns the player who makes the decision at \verb+infoset+.
If \verb+infoset+ is null, the null player is returned.
\item [See also:] \verb+Infosets+.
\ed

\item\lex{Player}
\protect \large \begin{verbatim}
Player[strategy->STRATEGY*] =: NFPLAYER 
\end{verbatim}\normalsize

\bd
Returns the player to whom the \verb+strategy+ belongs.
If \verb+strategy+ is null, the null player is returned.
\item [See also:] \verb+Strategies+.
\ed

\item\lex{Players}
\protect \large \begin{verbatim}
Players[efg->EFG] =: LIST(EFPLAYER) 
\end{verbatim} \normalsize

\bd
Returns the list of players defined on \verb+efg+.
\ed

\item\lex{Players}
\protect \large \begin{verbatim}
Players[nfg->NFG] =: LIST(NFPLAYER) 
\end{verbatim} \normalsize

\bd
Returns the list of players defined on \verb+nfg+.
\ed

\item\lex{Plus} 
\protect \large \begin{verbatim}
Plus[x->NUMBER, y->NUMBER] =: NUMBER
Plus[x->MIXED, y->MIXED] =: MIXED
Plus[x->BEHAV, y->BEHAV] =: BEHAV
\end{verbatim} \normalsize

\bd
Returns the sum of \verb+x+ and \verb+y+.
\item [Short form:] \verb%x + y%
\item [See also:] \verb+Divide+, \verb+Minus+, \verb+Times+.
\ed

\item\lex{Plus} 
\protect \large \begin{verbatim}
Plus[x->TEXT, y->TEXT] =: TEXT
\end{verbatim} \normalsize

\bd
Returns the concatenation of the text strings \verb+x+ and \verb+y+.
\item [Short form:] \verb%x + y%
\ed

\item\lex{PolEnumSolve} 
\protect \large \begin{verbatim}
PolEnumSolve[support->NFSUPPORT, {stopAfter->0}, {precision->Float}, 
             {nEvals<->0}, {time<->0.000000}, {traceFile<->(Output)}, 
             {traceLevel->0}] =: LIST(MIXED) 
PolEnumSolve[support->EFSUPPORT, {asNfg->False}, {stopAfter->0}, 
             {precision->Float}, {nEvals<->0}, {time<->0.000000}, 
             {traceFile<->(Output)}, {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim} \normalsize
\bd 
\marginpar{give better  description and cite}
Solves for all totally mixed equilibrium on the support
\verb+support+.  

The following optional parameters may be used to modify the behavior
of the algorithm:
\bd
\item
[asNfg:] By default, this is \verb+False+.  If it is specified to be
\verb+True+, the extensive form game is solved by recursively converting
its marked subgames into normal form, solving, and reconstructing the
solution as a behavior profile.  {\it Note that currently this algorithm
is only supported on the normal form, so this parameter
must always be specified and {\tt True}.} 
\item
[stopAfter:] By default, all equilibria are found.  This parameter may
be used to specify a maximum number of equilibria to be found.
\item
[precision:] Determines the precision of the computation. Default is
floating point precision (\verb+Float+). 
\item
[nEvals:] Returns the number of function evaluations done by the
algorithm.
\item
[time:] Returns the time elapsed during the execution
of the algorithm.
\item
[traceFile:] A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no output
at all.
\ed
\item [See also:] \verb+EnumNashSupports+.
\ed

\item\lex{PossibleNashSupports}
\protect \large \begin{verbatim}
PossibleNashSupports[efg->EFG] =: LIST(EFSUPPORT) 
\end{verbatim} \normalsize

\bd
\marginpar{give better  description and cite}
Returns a list of supports that could contain a completely mixed Nash
equilibrium.
\item [See also:] \verb+PolEnumSolve+.
\ed

\item\lex{Power}
\protect \large \begin{verbatim}
Power[x->NUMBER, y->NUMBER] =: NUMBER 
\end{verbatim} \normalsize

\bd
Computes the value $x^{y}$.
\item [Short form:] \verb%x ^ y%.
\item [Note:] Not implemented for the case where \verb+x+ is of rational
precision, and \verb+y+ is not an integer.
\item [See also:] \verb+Exp+, \verb+Log+.
\ed

\item\lex{Precision}
\protect \large \begin{verbatim}
Precision[x->NUMBER] =: PRECISION
\end{verbatim} \normalsize

\bd
Returns the precision of \verb+x+.
\ed

\item\lex{Print}
\protect \large \begin{verbatim}
Print[x->T*] =: T 
Print[x->NLIST(T*)] =: NLIST(T) 
\end{verbatim} \normalsize

{\it for all types} {\tt T}
\bd
Prints \verb+x+ at the console.  When relevant, the output is
formatted according to the current settings determined by the
\verb+Format+ commands.  Returns \verb+x+.  
\item [Short form:] \verb+<< x+.
\item [See also:] \verb+SetVerbose+, \verb+Write+, \verb+ListFormat+, 
\verb+Format+.  
\ed

\item\lex{PriorAction}
\protect \large \begin{verbatim}
PriorAction[node->NODE] =: ACTION 
\end{verbatim} \normalsize

\bd
Returns the action corresponding to the branch leading to \verb+node+.
If \verb+node+ is the root node, its prior action is the null action.
\ed

\item\lex{PriorSibling}
\protect \large \begin{verbatim}
PriorSibling[node->NODE] =: NODE 
\end{verbatim}\normalsize

\bd
Returns the prior sibling of \verb+node+.  If \verb+node+ has
no prior sibling, the null node is returned.
\item [See also:] \verb+NextSibling+.
\ed


%--Q--

\item\lex{QreGridSolve}
\protect \large \begin{verbatim}
QreGridSolve[support->NFSUPPORT, {pxifile->}, 
               {minLam->0.001000}, {maxLam->500.000000}, 
               {delLam->0.020000}, {powLam->1},{fullGraph->False}, 
               {delp1->0.100000}, {tol1->0.100000}, 
               {delp2->0.010000}, {tol2->0.010000}, 
               {nEvals<->0}, {time<->0.000000}, 
               {traceFile<->(Output)}, 
               {traceLevel->0}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd
Computes the complete logistic quantal response correspondence for
a (small) two-person normal form game on the \verb+support+, for values of
$\lambda$ between $\underline{\lambda}$ and $\bar{\lambda}.$ Returns
the list of mixed profiles computed, one profile for each value of
$\lambda_t$ from lowest to highest.

The operation of the algorithm may be modified by specifying optional
parameters.  See \verb+QreSolve+ for a description of parameters
not listed here:
\bd
\item
[delp1:] Grid size for course search over probability space.  Default
is $0.1$ .
\item
[tol1:] The tolerance on the objective function for course search.
Values of $p$ for which the objective function is less this value are
searched further on a finer grid.  The default is $0.1$.
\item
[delp2:] Grid size for fine search over probability space.  Default is
$0.01$ .
\item
[tol2:] The tolerance on the objective function for fine search.
Values of $p$ for which the objective function is less this value are
kept.  The default is $0.01$.  
\ed
\item [See also:] \verb+QreSolve+.
\ed

\item\lex{QreLambda}
\protect \large \begin{verbatim}
QreLambda[profile->MIXED] =: NUMBER 
QreLambda[profile->BEHAV] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the value of \verb+lambda+ for mixed or behavior profiles
computed by \verb+QreSolve+ or \verb+QreGridSolve+.  Profiles not
created by one of these algorithms have a null lambda value.
\item
[See also:] \verb+QreGridSolve+, \verb+QreSolve+, \verb+QreValue+.
\ed

\item\lex{QreSolve}
\protect \large \begin{verbatim}
QreSolve[start->MIXED, {pxifile->""}, {minLam->0.001000}, 
           {maxLam->500.000000}, {delLam->0.020000}, {powLam->1}, 
           {fullGraph->False}, {maxitsN->20}, {tolN->0.000000}, 
           {maxits1->100}, {tol1->0.000000}, {time<->0}, 
           {nEvals<->0}, {nIters<->0}, {traceFile<->(Output)}, 
           {traceLevel->0}] =: LIST(MIXED) 
QreSolve[start->BEHAV, {pxifile->""}, {minLam->0.001000}, 
           {maxLam->500.000000}, {delLam->0.020000}, {powLam->1}, 
           {fullGraph->False}, {maxitsN->20}, {tolN->0.000000}, 
           {maxits1->100}, {tol1->0.000000}, {time<->0}, 
           {nEvals<->0}, {nIters<->0}, {traceFile<->(Output)}, 
           {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
Computes a branch of the logistic quantal response equilibrium
correspondence for a game. \verb+start+ is
used as the starting point for the computation of $\lambda_{0}$, and
the support over which \verb+start+ is defined is the support over
which the correspondence is computed.

The behavior of the algorithm may be modified by specifying some of the
following optional parameters:
\bd
\item
[pxifile:] Generate output to this file for later retrieval and viewing by
the PXI program.  By default no output file is generated.
\item
[minLam:] Sets $\underline{\lambda}$, the minimum value of $\lambda$.  The 
default value is $\underline{\lambda}=0.001$.
\item
[maxLam:] Sets $\overline{\lambda}$, the maximum value of $\lambda$.  The
default value is $\overline{\lambda}=500.0$.
\item
[delLam:] Sets the constant $\delta$ used in incrementing $\lambda$.  The
default value is $\delta=0.02$.
\item
[powLam:] Sets the exponent $a$ used in incrementing $\lambda$.  The default
value is $a=1$, producing geometric incrementing.  Setting $a=0$ corresponds
to linear incrementing.
\item
[fullGraph:] If \verb+True+, the list of behavior strategy profiles
returned contains the full sequence of profiles computed from each successive
value of $\lambda$.  The default value is \verb+False+, in which case only
the profile for the last value of $\lambda$ computed is returned.
\item
[maxitsN:] Sets the maximum number of iterations for the $n$-dimensional
optimization routine.  The default value is $200$.
\item
[tolN:] Sets the tolerance for the $n$-dimensional optimization routine.
The default is 1.0e-10.
\item
[maxits1:] Sets the maximum number of iterations for the one-dimensional
optimization routine.  The default is $100$.
\item
[tol1:] Sets the tolerance for the one-dimensional optimization routine.
The default is 2.0e-10.
\item
[time:] Returns the amount of time consumed by the
algorithm.
\item
[nEvals:] Returns the number of function evaluations
performed by the algorithm.
\item
[nIters:] Returns the number of iterations performed
by the algorithm.
\item
[traceFile:] A file containing a log of more detailed information on
the execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to
no output at all.
\ed

\item
[Note:] The extensive form version disregards any marked
subgames.
\item [See also:] \verb+QreGridSolve+.
\ed

\item\lex{QreValue}
\protect \large \begin{verbatim}
QreValue[profile->MIXED] =: NUMBER 
QreValue[profile->BEHAV] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the value of the QRE objective function for mixed or behavior
profiles computed by \verb+QreSolve+ or \verb+QreGridSolve+.  The QRE
value for profiles not created by these algorithms is null.
\item
[See also:] \verb+QreGridSolve+, \verb+QreLambda+, \verb+QreSolve+.
\ed

\item\lex{Quit}
\protect \large \begin{verbatim}
Quit
Quit[{value->INTEGER:=0}] =: BOOLEAN
\end{verbatim}\normalsize

\bd
Exits the command language, returning \verb+value+ to the operating system.
\item [Notes:] Not listable.  The brackets \verb+[]+ are optional; if they
are not present, it is treated as \verb+Quit[0]+.
\ed

%--R--

\item\lex{Randomize}
\protect \large \begin{verbatim}
Randomize[x->NUMBER, {seed->0}] =: NUMBER
\end{verbatim}\normalsize

\bd 
Returns a random number distributed uniformly between \verb+0+ and
\verb+1+.  The result is of \verb+Rational+ precision.  The
denominator is equal to \verb+MAXINT=214748367+, and the numerator is
a uniformly distributed integer between \verb+0+ and \verb+MAXINT+.
\ed

\item\lex{Rational}
\protect \large \begin{verbatim}
Rational[x->NUMBER] =: NUMBER
\end{verbatim}\normalsize

\bd
Converts \verb+x+ to a number with rational precision.
\item [See also:] \verb+Float+.
\ed

\item\lex{Read}
\protect \large \begin{verbatim}
Read[input<->INPUT, x<->T] =: INPUT 
Read[input<->INPUT, x<->LIST(T)] =: INPUT
\end{verbatim}\normalsize

{\it for} {\tt T = BOOLEAN, NUMBER, TEXT}
\bd
Reads data of type \verb+T+ from the input stream and assigns it to
\verb+x+.  If \verb+x+ is undefined, then its data type is determined
from the exposed data in the input stream.  If \verb+x+ is previously
defined, then the \verb+Read+ function will expect to find the
corresponding data type in the input stream, and a file read error
will be generated if the exposed data is of the wrong data type.  If
\verb+x+ is previously defined to be a \verb+LIST+, then \verb+Read[in,x]+
will successively read elements into each element of the list.  If the
wrong data type is found for any element of the list, a file read
error will be returned.

The ``exposed data'' in the input stream consists of the following: If
first character is a double quote (\verb+"+), then the exposed data
consists of all characters up until the next double quote.  If the
first character is a \verb+{+, then the exposed data consists of all
the characters up until the next matching \verb+}+.  Otherwise, the
exposed data consists of all characters until the next whitespace.
\item [Short form:] \verb+input >> x+
\item [See also:] \verb+Input+, \verb+IsEof+, \verb+Write+.
\ed

\item\lex{RealizProbs}
\protect \large \begin{verbatim}
RealizProb[profile->BEHAV, node->NODE] =: NUMBER 
\end{verbatim}\normalsize

\bd
Returns the realization probability for \verb+node+ given that all players
are following \verb+profile+.  It is an error if \verb+profile+ and
\verb+node+ are not from the same extensive form game.
\item [See also:] \verb+ActionValue+, \verb+Belief+, \verb+InfosetProb+,
\verb+NodeValue+.
\ed

\item\lex{RealizProbs}
\protect \large \begin{verbatim}
RealizProbs[profile->BEHAV] =: LIST(NUMBER) 
\end{verbatim}\normalsize

\bd

Returns a list of the realization probabilities generated by
\verb+profile+ for all nodes in the game tree.  The nodes are in the
same order as returned by \verb+Nodes+.
\item [See also:] \verb+Nodes+, \verb+RealizProb+, 
\ed

\item\lex{Regret}
\protect \large \begin{verbatim}
Regret[profile->BEHAV, action->ACTION] =: NUMBER 
\end{verbatim} \normalsize

\bd
Returns the gain to a player for deviating to \verb+action+, assuming
all players are following \verb+profile+.  The strategy profile is
a Nash equilibrium if and only if the regrets of all actions are zero.
\ed

\item\lex{Regret}
\protect \large \begin{verbatim}
Regret[profile->MIXED, strategy->STRATEGY] =: NUMBER 
\end{verbatim} \normalsize

\bd
Returns the gain to a player for deviating to \verb+strategy+, assuming
all players are following \verb+profile+.  The strategy profile is
a Nash equilibrium if and only if the regrets of all strategies are
identically zero.
\ed

\item\lex{Regrets}
\protect \large \begin{verbatim}
Regrets[profile->BEHAV] =: LIST(LIST(LIST(NUMBER))) 
\end{verbatim} \normalsize

\bd
Returns a nested list of the regrets generated for each action by
\verb+profile+.  The \verb+(i,j,k)+th entry is the regret for player
\verb+i+, infoset \verb+j+, action \verb+k+.
\ed

\item\lex{Regrets}
\protect \large \begin{verbatim}
Regrets[profile->MIXED] =: LIST(LIST(NUMBER)) 
\end{verbatim} \normalsize

\bd
Returns a nested list of the regrets generated for each strategy by
\verb+profile+.  The \verb+(i,j)+th entry is the regret for player
\verb+i+, strategy \verb+j+.
\ed

\item\lex{Remove}
\protect \large \begin{verbatim}
Remove[list->NLIST(T), n->INTEGER] =: LIST(T) 
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Removes the \verb+n+th element from \verb+list+.  A copy of the list
with the element removed is returned.  It is an error if \verb+n+
is nonpositive, or if \verb+n+ is greater than the length of \verb+list+.
\item [See also:] \verb+Insert+.
\ed

\item\lex{RemoveAction}
\protect \large \begin{verbatim}
RemoveAction[support->EFSUPPORT, action->ACTION] =: EFSUPPORT 
\end{verbatim}\normalsize
\bd
Removes \verb+action+ from \verb+support+.  If
\verb+action+ is not in \verb+support+ there is no
effect.  A copy of the modified support is returned.  It is an error
if \verb+support+ and \verb+action+ are not from the same extensive
form game, or if removing \verb+action+ would result in the support
containing no actions at an information set.
\item [See also:] \verb+AddAction+, \verb+Support+.
\ed

\item\lex{RemoveAction}
\protect \large \begin{verbatim}
RemoveAction[basis->EFBASIS, action->ACTION] =: EFBASIS 
\end{verbatim}\normalsize
\bd
Removes \verb+action+ from \verb+basis+.  If
\verb+action+ is not in \verb+basis+ there is no
effect.  A copy of the modified \verb+EFBASIS+ is returned.  It is an error
if \verb+basis+ and \verb+action+ are not from the same extensive
form game, or if removing \verb+action+ would result in the basis
containing no actions at an information set.
\item [See also:] \verb+AddAction+, \verb+Basis+.
\ed

\item\lex{RemoveNode}
\protect \large \begin{verbatim}
RemoveNode[support->EFBASIS, node->NODE] =: EFBASIS 
\end{verbatim}\normalsize

\bd
Removes \verb+node+ from \verb+support+.  If \verb+node+ is not in
the basis, there is no effect.  A copy of the modified basis is
returned.  
\item [See also:] \verb+AddAction+, \verb+Basis+.
\ed

\item\lex{RemoveStrategy}
\protect \large \begin{verbatim}
RemoveStrategy[support->NFSUPPORT, strategy->STRATEGY] =: NFSUPPORT 
\end{verbatim}\normalsize

\bd
Removes \verb+strategy+ from \verb+support+.  If \verb+strategy+ is not in
the support, there is no effect.  A copy of the modified support is
returned.  It is an error if \verb+support+ and \verb+strategy+ are
not from the same normal form game, or if removing \verb+strategy+
would result in the support containing no strategies for a player.
\item [See also:] \verb+AddStrategy+, \verb+Support+.
\ed

\item\lex{Reveal}
\protect \large \begin{verbatim}
Reveal[infoset->INFOSET, who->LIST(EFPLAYER)] =: INFOSET 
\end{verbatim}\normalsize

\bd
Reveals the list of actions at \verb+infoset+ to the players in \verb+who+,
refining their information partitions at
all information sets in the extensive form game accordingly.  
\ed

\item\lex{RootNode}
\protect \large \begin{verbatim}
RootNode[efg->EFG] =: NODE 
\end{verbatim}\normalsize

\bd
Returns the root node of \verb+efg+.
\ed

%--S--

\item\lex{SaveEfg}
\protect \large \begin{verbatim}
SaveEfg[efg->EFG, file->TEXT] =: EFG 
\end{verbatim}\normalsize

\bd
Writes \verb+efg+ to an external savefile \verb+file+.  It is an error
if \verb+file+ cannot be opened for writing.  Returns \verb+efg+.
\item [See also:] \verb+LoadEfg+.
\ed

\item\lex{SaveNfg}
\protect \large \begin{verbatim}
SaveNfg[nfg->NFG, file->TEXT] =: NFG 
\end{verbatim}\normalsize

\bd
Writes \verb+nfg+ to an external savefile \verb+file+.  It is an
error if \verb+file+ cannot be opened for writing.  Returns \verb+nfg+.
\item [See also:] \verb+LoadNfg+.
\ed

\marginpar{Put in {\tt SeqEquilibSolve}}

\item\lex{SetActionProb}
\protect \large \begin{verbatim} 
SetActionProb[profile<->BEHAV, action->ACTION, 
               value->NUMBER] =: BEHAV 
\end{verbatim}\normalsize

\bd
Sets the component of \verb+profile+ for
\verb+action+ to be equal to \verb+value+, and 
returns \verb+profile+.  It is an error if \verb+profile+ and \verb+action+
are not from the same extensive form game. 
\item [See also:] \verb+ActionProb+, \verb+SetActionProbs+.
\ed

\item\lex{SetActionProbs}
\protect \large \begin{verbatim} 
SetActionProbs[profile<->BEHAV, infoset->INFOSET, 
               value->LIST(NUMBER)] =: BEHAV 
\end{verbatim}\normalsize

\bd
Sets the components of \verb+profile+ for
information set \verb+infoset+ to be equal to \verb+values+.
Returns \verb+profile+.  It is an error if \verb+profile+ and \verb+infoset+
are not from the same extensive form game, or if the length of
\verb+value+ is not the same as the number of actions in \verb+profile+'s
support at \verb+infoset+.
\item [See also:] \verb+ActionProb+.
\ed

\item\lex{SetChanceProbs}
\protect \large \begin{verbatim} 
SetChanceProbs[infoset->INFOSET, 
               probs->LIST(NUMBER)] =: INFOSET 
\end{verbatim}\normalsize

\bd
Sets the action probabilities for 
\verb+infoset+ to the values given in \verb+probs+.  Returns \verb+infoset+. 
An error occurs if \verb+infoset+ does not belong to the chance player.
\item [See also:] \verb+ChanceProb+.
\ed

\item\lex{SetComment}
\protect \large \begin{verbatim}
SetComment[efg->EFG, comment->TEXT] =: EFG
SetComment[nfg->NFG, comment->TEXT] =: NFG
\end{verbatim} \normalsize

\bd
Sets the comment associated with the game.
\item [See also:] \verb+SetComment+.
\ed

\item\lex{SetEnv}
\protect \large \begin{verbatim}
SetEnv[name->TEXT, value->TEXT] =: BOOLEAN 
\end{verbatim} \normalsize

\bd
Sets the environment variable \verb+name+.
\item [See also:] \verb+GetEnv+, \verb+UnSetEnv+.
\ed

\item\lex{SetName}
\protect \large \begin{verbatim}
SetName[x->T, name->TEXT] =: T
\end{verbatim}\normalsize

{\it for} {\tt T = ACTION, EFG, EFPLAYER, INFOSET, NFG, NFOUTCOME, 
NFPLAYER, NODE, EFOUTCOME, STRATEGY}
\bd
Sets the name of \verb+x+ to \verb+name+.  Returns \verb+x+.
\item [See also:] \verb+Name+.
\ed

\item\lex{SetOutcome}
\protect \large \begin{verbatim} 
SetOutcome[node->NODE, outcome->EFOUTCOME*] =: EFOUTCOME 
\end{verbatim}\normalsize

\bd
Attaches \verb+outcome+ to \verb+node+.  Returns the outcome attached.
Note that nonterminal nodes may have outcomes attached; the interpretation
is that nonterminal outcomes represent incremental payoffs.  
It is an error if \verb+node+ and \verb+outcome+ are not from the same
extensive form game.
\item [See also:] \verb+Outcome+.
\ed

\item\lex{SetOutcome}
\protect \large \begin{verbatim} 
SetOutcome[profile->LIST(STRATEGY), outcome->NFOUTCOME] =: NFOUTCOME 
\end{verbatim}\normalsize

\bd 
Attaches \verb+outcome+ to the cell in the normal form game
determined by the pure strategy profile defined by \verb+profile+.
Returns the outcome attached.  It is an error if \verb+profile+ and
\verb+outcome+ are not from the same normal form game. Also,
\verb+profile+ must be a list of strategies consisting of one strategy
for each player in the game.  
\item [See also:] \verb+Outcome+.
\ed

\item\lex{SetPayoff}
\protect \large \begin{verbatim}
SetPayoff[outcome->EFOUTCOME, player->EFPLAYER,
          payoff->NUMBER] =: EFOUTCOME 
\end{verbatim}\normalsize

\bd
Sets the payoff of \verb+outcome+ for \verb+player+ to \verb+payoff+.
It is an error if \verb+outcome+ and \verb+player+ are not from the
same extensive form game.  Returns \verb+outcome+.
\item [See also:] \verb+Payoff+.
\ed

\item\lex{SetPayoff}
\protect \large \begin{verbatim}
SetPayoff[outcome->NFOUTCOME, player->NFPLAYER, 
          payoff->NUMBER] =: NFOUTCOME 
\end{verbatim}\normalsize

\bd
Sets the payoff of \verb+outcome+ for \verb+player+ to \verb+payoff+.
It is an error if \verb+outcome+ and \verb+player+ are not from \verb+nfg+.
Returns \verb+outcome+.
\item [See also:] \verb+Payoff+.
\ed

\item\lex{SetStrategyProb} 
\protect \large \begin{verbatim}
SetStrategyProb[profile<->MIXED, strategy->STRATEGY, 
                 value->NUMBER] =: MIXED 
\end{verbatim} \normalsize

\bd
Sets the components of \verb+profile+ for \verb+strategy+ to be equal
to \verb+value+.  It is an error if \verb+profile+ and \verb+strategy+
are not from the same normal form game.  Returns \verb+profile+.
\item [See also:] \verb+StrategyProb+.
\ed

\item\lex{SetStrategyProbs} 
\protect \large \begin{verbatim}
SetStrategyProbs[profile<->MIXED, player->NFPLAYER, 
                 value->LIST(NUMBER)] =: MIXED 
\end{verbatim} \normalsize

\bd
Sets the components of \verb+profile+ for \verb+player+ to be equal
to \verb+value+.  It is an error if \verb+profile+ and \verb+player+
are not from the same normal form game, or if the length of \verb+value+
is not the same as the number of strategies for \verb+player+ in the
support of \verb+profile+.  Returns \verb+profile+.
\item [See also:] \verb+StrategyProb+.
\ed

\item\lex{Shell}
\protect \large \begin{verbatim}
Shell[{command->""}, {spawn->True}] =: INTEGER 
\end{verbatim} \normalsize

\bd
Runs a child process.  
\bd
\item [command:] A text string to be executed by the shell.  
\item [spawn:] Specifies whether to run in the foreground or
background.  Default is to run in the background.  
\ed
\item [See also:] \verb+Platform+.
\ed

\item\lex{SimpDivSolve}
\protect \large \begin{verbatim}
SimpDivSolve[support->NFSUPPORT, {stopAfter->1}, 
             {nRestarts->1}, {leashLength->0}, 
             {precision->Float}, {nEvals<->0}, 
             {time<->0.000000}, {traceFile<->(Output)}, 
             {traceLevel->0}] =: LIST(MIXED) 
SimpDivSolve[support->EFSUPPORT, {asNfg->False}, 
             {stopAfter->1}, {nRestarts->1}, {leashLength->0}, 
             {precision->Float}, {nEvals<->0}, 
             {time<->0.000000}, {traceFile<->(Output)}, 
             {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd
Computes a Nash equilibrium for a game using a simplicial subdivision
algorithm. 

The behavior of the algorithm may be modified by several optional
parameters:

\bd
\item
[asNfg:] By default, this is \verb+False+.  If it is specified to be
\verb+True+, the extensive form game is solved by recursively converting
its marked subgames into normal form, solving, and reconstructing the
solution as a behavior profile.  {\it Note that currently simplicial
subdivision is only supported on the normal form, so this parameter
must always be specified and {\tt True}.}
\item
[stopAfter:] Maximum number of equilibria to find. Default is 1.  
\item
[precision:] Determines the precision of the computation. Default is
floating point precision (\verb+float+). 
\item 
[nRestarts:] Number of restarts.  At each restart the mesh of the
triangulation is halved.  So this parameter determines the final mesh
by the formula $\frac{1}{2}^{ndivs}$.
\item
[leashLength:] Sets the leash length. Default is 0, which results in no
constraint, or no leash.  Note that if this parameter is set to a value
different from 0, the algorithm is no longer guaranteed to converge.
\item
[time:] Returns the elapsed time for the algorithm.
\item
[traceFile:] A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to
no output at all.
\ed
\ed

\item\lex{Sort}
\protect \large \begin{verbatim}
Sort[x->LIST(NUMBER)] =: LIST(NUMBER)
Sort[x->LIST(TEXT)] =: LIST(TEXT)
\end{verbatim} \normalsize

\bd
Returns a list consisting of the elements of \verb+x+ sorted in
increasing order.
\ed

\item\lex{Sort}
\protect \large \begin{verbatim}
Sort[x->LIST(T), by->LIST(NUMBER)] =: LIST(T)
Sort[x->LIST(T), by->LIST(TEXT)] =: LIST(T)
\end{verbatim} \normalsize

{\it for all types} {\tt T}
\bd
Returns a list consisting of the elements of \verb+list+, sorted
according to the ordering of the elements of \verb+by+.  It is an
error if \verb+list+ and \verb+by+ do not have the same dimensionality.
\ed

\item\lex{StartWatch}
\protect \large \begin{verbatim}
StartWatch[] =: NUMBER 
\end{verbatim}\normalsize

\bd
Starts the system stopwatch.  This function has no
effect if the stopwatch is already running.
Returns the amount of time since the stopwatch was started.
\item [See also:] \verb+ElapsedTime+, \verb+IsWatchRunning+, \verb+StopWatch+.
\ed

\item\lex{StopWatch}
\protect \large \begin{verbatim}
StopWatch[] =: NUMBER 
\end{verbatim}\normalsize

\bd
Stops the system stopwatch.  If the stopwatch was not
running, this function has no effect.  Returns the amount of time
on the stopwatch.
\item [See also:] \verb+ElapsedTime+, \verb+IsWatchRunning+,
\verb+StartWatch+.
\ed

\item\lex{Strategies}
\protect \large \begin{verbatim}
Strategies[player->NFPLAYER, support->NFSUPPORT] =: LIST(STRATEGY) 
\end{verbatim}\normalsize

\bd
Returns the list of strategies from which  \verb+player+ may choose
in \verb+support+.
\item [See also:] \verb+Player+. 
\ed

\item\lex{StrategyNumber}
\protect \large \begin{verbatim}
StrategyNumber[strategy->STRATEGY, sup->NFSUPPORT] =: INTEGER
\end{verbatim}\normalsize

\bd 
Returns the number assigned to \verb+strategy+ in the support
\verb+sup+.  Strategies  for each player are numbered from 1 to
the number of strategies for the player.  If a strategy is not in
the corresponding support, it is assigned a number of
\verb+0+.
\item [See also:] \verb+Strategies+. 
\ed

\item\lex{StrategyProb}
\protect \large \begin{verbatim}
StrategyProb[profile->MIXED, strategy->STRATEGY] =: NUMBER 
\end{verbatim} \normalsize

\bd
Returns the probability that \verb+strategy+ is chosen when all
players are following \verb+profile+.  It is an error if \verb+profile+
and \verb+strategy+ are not from the same normal form game.
\item [See also:] \verb+SetStrategyProbs+.
\ed

\item\lex{StrategyProbs}
\protect \large \begin{verbatim}
StrategyProbs[profile->MIXED] =: LIST(LIST(NUMBER)) 
\end{verbatim} \normalsize

\bd
Returns a nested list of the probabilities for each strategy under
\verb+profile+.  The \verb+(i,j)+th entry is the probability of player
\verb+i= adopting strategy \verb+j+.
\item [See also:] \verb+StrategyProb+, \verb+SetStrategyProbs+.
\ed

\item\lex{StrategyValue}
\protect \large \begin{verbatim}
StrategyValue[profile->MIXED, strategy->STRATEGY] =: NUMBER 
\end{verbatim}\normalsize

\bd 
Returns the expected payoff to a player (who is in control of the
strategy set including \verb+strategy+) of choosing \verb+strategy+ when
all players are following \verb+profile+.  It is an error if
\verb+profile+ and \verb+strategy+ are not from the same normal form
game.
\item [See also:] \verb+StrategyProb+. 
\ed

\item\lex{StrategyValues}
\protect \large \begin{verbatim}
StrategyValues[profile->MIXEd] =: LIST(LIST(NUMBER)) 
\end{verbatim}\normalsize

\bd
Returns a list of expected payoffs of each strategy (to the player
who chooses that strategy).  The \verb+(i,j)+th entry is
the expected payoff to player \verb+i+ of
strategy \verb+j+, where the index numbers correspond to the output of
\verb+Players+ and \verb+Strategies+, respectively.
\ed

\item\lex{Subgames}
\protect \large \begin{verbatim}
Subgames[efg->EFG] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd
Returns the list of nodes which are roots of subgames in \verb+efg+.
The ordering of the list is such that
all children of a node are listed before the node.
\item [See also:] \verb+MarkSubgame+, \verb+MarkedSubgames+, 
\verb+UnmarkSubgame+.
\ed

\item\lex{Support}
\protect \large \begin{verbatim}
Support[efg->EFG] =: EFSUPPORT 
\end{verbatim}\normalsize

\bd
Returns the support of \verb+efg+.  The support contains all actions at every
information set for all players.
\item [See also:] \verb+AddAction+, \verb+RemoveAction+.
\ed

\item\lex{Support}
\protect \large \begin{verbatim}
Support[nfg->NFG] =: NFSUPPORT 
\end{verbatim}\normalsize

\bd
Returns the support of \verb+nfg+.  The support contains all strategies
for all players.
\item [See also:] \verb+AddStrategy+, \verb+RemoveStrategy+.
\ed

\item\lex{Support}
\protect \large \begin{verbatim}
Support[profile->BEHAV] =: EFSUPPORT 
Support[profile->MIXED] =: NFSUPPORT 
\end{verbatim}\normalsize

\bd
Returns the support on which \verb+profile+ is defined.
\item [See also:] \verb+Behav+, \verb+Mixed+.
\ed

%--T--

\item\lex{Text}
\protect \large \begin{verbatim}
Text[x->NUMBER] =: TEXT 
Text[x->TEXT] =: TEXT 
\end{verbatim} \normalsize

\bd
Converts \verb+x+ into a text string.
\ed

\item\lex{Times} 
\protect \large \begin{verbatim}
Times[x->NUMBER, y->NUMBER] =: NUMBER 
\end{verbatim} \normalsize

\bd
Computes the product of \verb+x+ and \verb+y+.
\item [Short form:] \verb+x * y+.
\item [See also:] \verb+Divide+, \verb+Minus+, \verb+Plus+.
\ed

\item\lex{Times}
\protect \large \begin{verbatim}
Times[x->NUMBER, y->MIXED] =: MIXED 
Times[x->NUMBER, y->BEHAV] =: BEHAV 
\end{verbatim} \normalsize

\bd
Computes the product of \verb+x+ and \verb+y+.
\item [Short form:] \verb+x * y+.
\item [See also:] \verb+Minus+, \verb+Plus+.
\ed

\item\lex{Transpose}
\protect \large \begin{verbatim} 
Transpose[x->LIST(LIST(T))] =: LIST(LIST(T)) 
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns the transpose of a rectangular matrix.  It is an error if \verb+list+
is not rectangular.
\ed


%--U--

\item\lex{Unassign}
\protect \large \begin{verbatim}
UnAssign[name->TEXT] =: BOOLEAN
\end{verbatim}\normalsize

\bd
Undefines the variable with name \verb+name+.  Returns 
\verb+True+ if the variable was defined, and \verb+False+ if the
variable was not defined, at the time of the call.
\item [Short form:] \verb+x := +
\item [Note:] For the short form, quotes around \verb+name+ are not
required, and the function is not listable.
\item [See also:] \verb+Assign+, \verb+Clear+.
\ed

\item\lex{UnmarkSubgame}
\protect \large \begin{verbatim}
UnmarkSubgame[node->NODE] =: NODE 
\end{verbatim}\normalsize

\bd
Unmark \verb+node+ as being the root of a subgame for use in later
computation.  If \verb+node+ is not marked as a subgame root, or if
\verb+node+ is the root node, this function has no effect.  Returns
the \verb+node+.
\item [See also:] \verb+MarkSubgame+, \verb+MarkedSubgames+,
\verb+Subgames+.
\ed


\item\lex{UnSetEnv}
\protect \large \begin{verbatim}
UnSetEnv[name->TEXT] =: BOOLEAN 
\end{verbatim} \normalsize

\bd
Unsets the environment variable \verb+name+.
\item [See also:] \verb+GetEnv+, \verb+SetEnv+.
\ed

%--V--

\item\lex{Version}
\protect \large \begin{verbatim}
Version[] =: NUMBER 
\end{verbatim} \normalsize

\bd
Returns the version number of the command language.
\ed

\marginpar{Add {\tt VertEnum}}

%--W--

\item\lex{While} 
\protect \large \begin{verbatim}
*While[boolean-expression, statement-list]
\end{verbatim} \normalsize
  
\bd
Defines a block of statements to be executed repeatedly.
See the section on control structures for complete information.
\item [Note:] Special function.  Not listable; arguments are not GCl
data types; not documented in \verb+Help+ or \verb+Manual+.  
\item
[See also:] \verb+For+.
\ed

\item\lex{Write}
\protect \large \begin{verbatim}
Write[output<->OUTPUT, x->T] =: OUTPUT  
Write[output<->OUTPUT, x->LIST(T)] =: OUTPUT
\end{verbatim}\normalsize

{\it for} {\tt T = BEHAV, BOOLEAN, EFG, EFSUPPORT, INTEGER,
NFG, NFSUPPORT, MIXED, NUMBER, STRATEGY, TEXT}
\bd
Does a formatted write of \verb+x+ to \verb+output+.
\item [Short form:] \verb+output << x+
\item [See also:] \verb+Format+, \verb+ListFormat+, \verb+Output+, \verb+Read+
\ed

%--X--

%--Y--

%--Z--

\end{itemize}

\section{Standard User Defined Functions}
\renewcommand{\mysectionname}{\thesection\,\, USER DEFINED FUNCTIONS}

The functions listed in this section are user defined functions that
are provided in the file \verb+stdudfs.gcl+.  For each function, the
function prototype is followed first by a brief description of what
the function does, and then by the body of the function.  

\begin{itemize}

%--A--

\item\lex{ActionNumber}
\protect \large \begin{verbatim}
ActionNumber[a->ACTION] =: INTEGER 
\end{verbatim}\normalsize

\bd 
Returns the action number of \verb+a+.
\begin{verbatim}
  Index[Actions[Infoset[a]],a]_1
\end{verbatim} 
\ed

\item\lex{Actions}
\protect \large \begin{verbatim}
Actions[infoset->INFOSET] =: LIST(ACTION) 
\end{verbatim}\normalsize

\bd 
Returns a list of all actions in \verb+infoset+.

\begin{verbatim}
  Actions[infoset,Support[Game[infoset]]]
\end{verbatim} 
\ed

\item\lex{Actions}
\protect \large \begin{verbatim}
Actions[efg->EFG] =: LIST(LIST(LIST(ACTION))) 
\end{verbatim}\normalsize

\bd 
Returns a nested list of actions in the game, whose  \verb+(i,j,k)+
entry is action \verb+k+ in information set \verb+j+ of player \verb+i+.

\begin{verbatim}
  Actions[Infosets[Players[efg]]]
\end{verbatim} 
\ed

\item\lex{Actions}
\protect \large \begin{verbatim}
Actions[s->EFSUPPORT] =: LIST(LIST(LIST(ACTION))) 
\end{verbatim}\normalsize

\bd 

A nested list of actions for the support \verb+s+ in the extensive
form game.

\begin{verbatim}
  Actions[Infosets[Game[s]],s]
\end{verbatim} 
\ed

\item\lex{AddMove}
\protect \large \begin{verbatim}
AddMove[i->INFOSET, a->ACTION] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd 
Adds a move determined by infoset \verb+i+ to all nodes with prior
action \verb+a+.  
\begin{verbatim}
  AddMove[i,Filter[n:=Nodes[Game[i]],PriorAction[n]=a]]
\end{verbatim} 
\ed

\item\lex{AllActions}
\protect \large \begin{verbatim}
AllActions[efg->EFG] =: LIST(LIST(LIST(ACTION))) 
\end{verbatim}\normalsize

\bd 
Gives a nested list of all actions in the game, including those of
the chance player.  
\begin{verbatim}
  Actions[AllInfosets[efg]]
\end{verbatim} 
\ed

\item\lex{AllInfosets}
\protect \large \begin{verbatim}
AllInfosets[efg->EFG] =: LIST(LIST(INFOSET)) 
\end{verbatim}\normalsize

\bd 
Gives a nested list of all actions in the game, including those for
chance. 
\begin{verbatim}
  Infosets[{Chance[efg]}&Players[efg]]
\end{verbatim} 
\ed

\item\lex{AllMembers}
\protect \large \begin{verbatim}
AllMembers[efg->EFG] =: LIST(LIST(LIST(NODE))) 
\end{verbatim}\normalsize

\bd 
Returns a list of all member nodes of information sets, including
those of the chance player.
\begin{verbatim}
  Members[AllInfosets[efg]]
\end{verbatim} 
\ed

\item\lex{AllNash}
\protect \large \begin{verbatim}
AllNash[e->EFG, {stopAfter->0}, {nTries->0}, 
        {precision->Float}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
Searches for all Nash equilibria of the extensive form game
\verb+e+.  Returns a list containing the equilibria found.

\begin{verbatim}
  ms:=MarkedSubgames[e];UnmarkSubgames[e];
  s:=ElimAllDom[Nfg[e],strong->True];
  If[NumPlayers[e] = 2, 
    m:=EnumMixedSolve[s,0,precision],
    << InfiniteLoopWarning[stopAfter,nTries];
    m:=LiapSolve[Centroid[s],stopAfter,nTries]
  ];
  MarkSubgames[ms];Behav[m]
\end{verbatim} 
\ed

\item\lex{AllNash}
\protect \large \begin{verbatim}
AllNash[n->NFG, {stopAfter->0}, {nTries->0}, 
        {precision->Float}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
Searches for all Nash equilibria of the normal form game
\verb+n+.  Returns a list containing the equilibria found.

\begin{verbatim}
  s:=ElimAllDom[n,strong->True];
  If[NumPlayers[n] = 2, 
    EnumMixedSolve[s,0,precision],
    << InfiniteLoopWarning[stopAfter,nTries];
    LiapSolve[Centroid[s],stopAfter,nTries]
  ]
\end{verbatim} 
\ed

\item\lex{AllPerfect}
\protect \large \begin{verbatim}
AllPerfect[n->NFG, {stopAfter->0}, {nTries->0}, 
           {precision->Float}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
Searches for all Perfect Nash equilibria of the normal form game
\verb+n+.  Returns a list containing the equilibria found.

\begin{verbatim}
  s:=ElimAllDom[n];
  If[NumPlayers[n] = 2, 
    EnumMixedSolve[s,0,precision],
    << " Not implemented for n-person games";
    List[Centroid[Support[n]],0]
  ]
\end{verbatim} 
\ed

\item\lex{AllSequential}
\protect \large \begin{verbatim}
AllSequential[e->EFG, {stopAfter->0}, {nTries->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
Searches for all sequential Nash equilibria of the extensive form
game \verb+e+.  Returns a list containing the equilibria found.

\begin{verbatim}
  ms:=MarkedSubgames[e];UnmarkSubgames[e];
  << InfiniteLoopWarning[stopAfter,nTries];
  b:=LiapSolve[e,stopAfter->stopAfter,nTries->nTries];
  MarkSubgames[ms];b
\end{verbatim} 
\ed

\item\lex{AllSubgamePerfect}
\protect \large \begin{verbatim}
AllSubgamePerfect[e->EFG, {stopAfter->0}, {nTries->0}, 
                  {precision->Float}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
Searches for all subgame perfect Nash equilibria of the extensive
form game \verb+e+.  Returns a list containing the equilibria found.

\begin{verbatim}
  ms:=MarkedSubgames[e];MarkSubgames[e];
  If[NumPlayers[e] = 2, 
    b:=EnumMixedSolve[e,True,0,precision],
    << InfiniteLoopWarning[stopAfter,nTries];
    b:=LiapSolve[e,asNfg->True,stopAfter->stopAfter,nTries->nTries]
  ];
  MarkSubgames[ms];b
\end{verbatim} 
\ed

\item\lex{Ancestors}
\protect \large \begin{verbatim}
Ancestors[n->NODE] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd 
Returns a nested list of the nodes in the tree following a given one.  
\begin{verbatim}
  If[IsRoot[n],{n},Flatten[{Ancestors[Parent[n]]}&{n}]]
\end{verbatim} 
\ed


%--B--

\item\lex{Behav}
\protect \large \begin{verbatim}
Behav[efg->EFG, list->LIST(LIST(LIST(NUMBER)))] =: BEHAV 
\end{verbatim}\normalsize

\bd 
Converts a nested list of numbers into a Behavior strategy
profile for the game \verb+efg+.
\begin{verbatim}
  SetProbs[Behav[Support[efg]],list]
\end{verbatim} 
\ed

%--C--

\item\lex{CartesianProd}
\protect \large \begin{verbatim}
CartesianProd[l->LIST(LIST(ANYTYPE))] =: LIST(LIST(ANYTYPE)) 
\end{verbatim}\normalsize

\bd 
Constructs the cartesian product of a set of sets.  
\begin{verbatim}
  If[NumElements[l]=1,
    Prepend[l_1,{}],
    r:={};i:=1;
    l1:=l_1;
    l2:=CartesianProd[Remove[l,1]];
    While[i<=Length[l1], r:=r&{Prepend[l1_i,l2]};i:=i+1];
    r
  ]
\end{verbatim} 
\ed
	

\item\lex{Centroid}
\protect \large \begin{verbatim}
Centroid[efg->EFG] =: BEHAV 
\end{verbatim}\normalsize

\bd 
Returns the centroid of an extensive form game.  
\begin{verbatim}
  Behav[Support[efg]]
\end{verbatim} 
\ed

\item\lex{Centroid}
\protect \large \begin{verbatim}
Centroid[nfg->NFG] =: MIXED 
\end{verbatim}\normalsize

\bd 
Returns the centroid of a normal form game.  
\begin{verbatim}
  Mixed[Support[nfg]]
\end{verbatim} 
\ed

\item\lex{Centroid}
\protect \large \begin{verbatim}
Centroid[s->EFSUPPORT] =: BEHAV 
\end{verbatim}\normalsize

\bd 
Returns the centroid of the support \verb+s+ of an extensive form game.  
\begin{verbatim}
  Behav[s]
\end{verbatim} 
\ed

\item\lex{Centroid}
\protect \large \begin{verbatim}
Centroid[s->NFSUPPORT] =: MIXED 
\end{verbatim}\normalsize

\bd 
Returns the centroid of the support \verb+n+ of a normal form game.  
\begin{verbatim}
  Mixed[s]
\end{verbatim} 
\ed

\item\lex{Concat}
\protect \large \begin{verbatim}
Concat[list->LIST(TEXT)]=:TEXT
\end{verbatim}\normalsize

\bd 
Concatenates all of the elements of \verb+list+
\begin{verbatim}
  If[Length[list]=1,list_1,list_1+Concat[Remove[list,1]]];
\end{verbatim} 
\ed


%--D--

\item\lex{DeleteEmptyInfosets}
\protect \large \begin{verbatim}
DeleteEmptyInfosets[efg->EFG] =: LIST(BOOLEAN) 
\end{verbatim}\normalsize

\bd 
Deletes all empty information sets in a game.  
\begin{verbatim}
  DeleteEmptyInfoset[Filter[i:=Infosets[efg],NumMembers[i]=0]]
\end{verbatim} 
\ed

\item\lex{Descendants}
\protect \large \begin{verbatim}
Descendants[n->NODE] =: NLIST(NODE) 
\end{verbatim}\normalsize

\bd 
Gives a nested list of the nodes following \verb+n+.
\begin{verbatim}
  {n}&Descendants[Children[n]]
\end{verbatim} 
\item[Note:] The above version is very slow on large games.
\ed

\item\lex{Dimensions}
\protect \large \begin{verbatim}
Dimensions[x->NLIST(ANYTYPE)] =: LIST(INTEGER) 
\end{verbatim}\normalsize

\bd 
Gives the dimensions of a nested rectangular list. 
\begin{verbatim}
//*  Note:  x is assumed rectangular
  l:=Length[x];
  If[IsList[l],{NumElements[x]}&Dimensions[x_1],{l}]
\end{verbatim} 
\ed


\item\lex{Display}
\protect \large \begin{verbatim}
Display[e->EFG] =: NUMBER 
\end{verbatim}\normalsize

\bd 
Runs a child process to display the game \verb+e+ in the Gambit GUI. 
\begin{verbatim}
  SaveEfg[e,"junk.efg"];
  Shell[GambitExe[]+" junk.efg"]
\end{verbatim} 
\ed

\item\lex{Display}
\protect \large \begin{verbatim}
Display[n->NFG] =: NUMBER 
\end{verbatim}\normalsize

\bd 
Runs a child process to display the game \verb+n+ in the Gambit GUI. 
\begin{verbatim}
  SaveNfg[n,"junk.nfg"];
  Shell[GambitExe[]+" junk.nfg"]
\end{verbatim} 
\ed

%--E--

\item\lex{ElimAllDom}
\protect \large \begin{verbatim}
ElimAllDom[s->NFSUPPORT, {strong->False}, {mixed->False}, 
           {time<->0.000000}, {traceFile<->(Output)}, 
           {traceLevel->0}] =: NFSUPPORT 
ElimAllDom[s->EFSUPPORT, {strong->False}, {mixed->False}, 
           {time<->0.000000}, {traceFile<->(Output)}, 
           {traceLevel->0}] =: EFSUPPORT 
\end{verbatim}\normalsize

\bd 
Successively eliminates dominated strategies in \verb+s+. See
\verb+ElimDom+ for description of parameters.  
\begin{verbatim}
  While[s!=(ss:=ElimDom[s,strong,mixed,time,traceFile,traceLevel]),
    s:=ss
  ];
  s;
\end{verbatim} 
\ed

\item\lex{ElimAllDom}
\protect \large \begin{verbatim}
ElimAllDom[nfg->NFG, {strong->False}, {mixed->False}, 
           {time<->0.000000}, {traceFile<->(Output)}, 
           {traceLevel->0}] =: NFSUPPORT 
\end{verbatim}\normalsize

\bd 
Successively eliminates dominated strategies in \verb+nfg+.  See
\verb+ElimDom+ for description of parameters.  
\begin{verbatim}
  ElimAllDom[Support[nfg],strong,mixed,time,traceFile,traceLevel];
\end{verbatim} 
\ed

\item\lex{ElimAllDom}
\protect \large \begin{verbatim}
ElimAllDom[efg->EFG, {strong->False}, {mixed->False}, 
           {time<->0.000000}, {traceFile<->(Output)}, 
           {traceLevel->0}] =: EFSUPPORT 
\end{verbatim}\normalsize

\bd 
Successively eliminates dominated strategies in \verb+nfg+. See
\verb+ElimDom+ for description of parameters.  
\begin{verbatim}
  ElimAllDom[Support[efg],strong,mixed,time,traceFile,traceLevel];
\end{verbatim} 
\ed

\item\lex{ElimDom}
\protect \large \begin{verbatim}
ElimDom[nfg->NFG, {strong->False}, {mixed->False}, 
        {time<->0.000000}, {traceFile<->(Output)}, 
        {traceLevel->0}] =: NFSUPPORT 
\end{verbatim}\normalsize

\bd 
A version of \verb+ElimDom+ that takes a normal form game instead
of a support.  See the built-in function, \verb+ElimDom+ for a
description of the parameters.
\begin{verbatim}
  ElimDom[Support[nfg],strong,mixed,time,traceFile,traceLevel]
\end{verbatim} 
\ed

\item\lex{ElimDom}
\protect \large \begin{verbatim}
ElimDom[efg->EFG, {strong->False}, {mixed->False}, 
        {time<->0.000000}, {traceFile<->(Output)}, 
        {traceLevel->0}] =: EFSUPPORT 
\end{verbatim}\normalsize

\bd 
A version of \verb+ElimDom+ that takes an extensive form game instead
of a support.  See the built-in function, \verb+ElimDom+ for a
description of the parameters.
\begin{verbatim}
  ElimDom[Support[efg],strong,mixed,time,traceFile,traceLevel]
\end{verbatim} 
\ed

\item\lex{EnumMixedSolve}
\protect \large \begin{verbatim}
EnumMixedSolve[nfg->NFG, {stopAfter->0}, {precision->Float}, 
               {nPivots<->0}, {time<->0.000000}, 
               {traceFile<->(Output)}, {traceLevel->0}, 
               {cliques->False}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
A version of \verb+EnumMixedSolve+ that takes a normal form game instead
of a support.  See the built-in function, \verb+EnumMixedSolve+ for a
description of the parameters.
\begin{verbatim}
  EnumMixedSolve[Support[nfg], stopAfter, precision, nPivots, time, 
  traceFile, traceLevel, cliques]
\end{verbatim} 
\ed

\item\lex{EnumMixedSolve}
\protect \large \begin{verbatim}
EnumMixedSolve[efg->EFG, {asNfg->False}, {stopAfter->0}, 
               {precision->Float}, {nPivots<->0}, 
               {time<->0.000000}, {traceFile<->(Output)}, 
               {traceLevel->0}, {cliques->False}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
A version of \verb+EnumMixedSolve+ that takes an extensive form game instead
of a support.  See the built-in function, \verb+EnumMixedSolve+ for a
description of the parameters.
\begin{verbatim}
  EnumMixedSolve[Support[efg], asNfg,stopAfter, precision, nPivots, time,
  traceFile, traceLevel, cliques]
\end{verbatim} 
\ed

\item\lex{EnumPureSolve}
\protect \large \begin{verbatim}
EnumPureSolve[nfg->NFG, {stopAfter->0}, {time<->0.000000}, 
              {traceFile<->(Output)}, {traceLevel->0}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
A version of \verb+EnumPureSolve+ that takes a normal form game instead
of a support.  See the built-in function, \verb+EnumPureSolve+ for a
description of the parameters.
\begin{verbatim}
  EnumPureSolve[Support[nfg], stopAfter, time, traceFile, traceLevel]
\end{verbatim} 
\ed

\item\lex{EnumPureSolve}
\protect \large \begin{verbatim}
EnumPureSolve[efg->EFG, {stopAfter->0}, {precision->Float}, 
              {time<->0.000000}, {traceFile<->(Output)}, 
              {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
A version of \verb+EnumMixedSolve+ that takes an extensive form
game instead of a support.  See the built-in function,
\verb+EnumMixedSolve+ for a description of the parameters.
\begin{verbatim}
  EnumPureSolve[Support[efg], False, stopAfter, precision, time, 
  traceFile, traceLevel]
\end{verbatim} 
\ed

%--F--

\item\lex{Float}
\protect \large \begin{verbatim}
Float[x->BEHAV] =: BEHAV 
Float[x->MIXED] =: MIXED 
\end{verbatim}\normalsize

\bd 
Converts the internal representation of x to Floating point.  
\begin{verbatim}
  1.0*x;
\end{verbatim} 
\ed

\item\lex{Float}
\protect \large \begin{verbatim}
Float[g->EFG] =: EFG 
\end{verbatim}\normalsize

\bd 
Converts the internal representation of g to Floating point.  
\begin{verbatim}
  gg:=CompressEfg[Support[g]];    // to make a copy
  i:=Infosets[Chance[gg]];
  SetChanceProbs[i,Float[ChanceProb[Actions[i]]]];
  SetPayoffs[Outcomes[gg],Float[Payoffs[Outcomes[gg]]]];
  gg;
\end{verbatim} 
\ed

\item\lex{Float}
\protect \large \begin{verbatim}
Float[g->NFG] =: NFG 
\end{verbatim}\normalsize

\bd 
Converts the internal representation of g to Floating point.  
\begin{verbatim}
  gg:=CompressNfg[Support[g]];    // to make a copy
  SetPayoffs[Outcomes[gg],Float[Payoffs[Outcomes[gg]]]];
  gg;
\end{verbatim} 
\ed

%--G--

\item\lex{GambitExe}
\protect \large \begin{verbatim}
GambitExe[] =: TEXT 
\end{verbatim}\normalsize

\bd 
Returns the path to the directory containing the Gambit GUI executable
file, assuming a standard installation.  
\begin{verbatim}
  p:=Platform[];
  If[p="DOS/Windows" || p="Windows 95/NT",f:="gambit"];
  If[p="HP UX" || p="HPPA",f:="gui_motif_hp"];
  If[p="SPARC" || p="SUN",f:="gui_motif_sun4"];
  If[p="SVR4",f:="gui_SunOS_sun4m"];
  If[p="Linux",f:="gui_Linux"];
  If[p="AIX32" || p="AIX",f:="gui_motif_rs6000"];
  If[(h:=GetEnv["GAMBIT_HOME"])="",p:=ExePath[file->False]+f,p:=h+f];
  p
\end{verbatim} 
\ed

\item\lex{GetIntegerFormat}
\protect \large \begin{verbatim}
GetIntegerFormat[{width<->0}] =: BOOLEAN 
\end{verbatim} \normalsize

\bd 
Gets the current values of the formatting parameters for numeric
data types.  See \verb+Format+ for definitions of the
parameters.  
\begin{verbatim}
  GetFormat[1,width];
  True
\end{verbatim} 
\ed

\item\lex{GetNumericFormat}
\protect \large \begin{verbatim}
GetNumericFormat[{width<->0}, {decimals<->6}, 
                 {expmode<->False}] =: BOOLEAN 
\end{verbatim} \normalsize

\bd 
Gets the current values of the formatting parameters for numeric
data types.  See \verb+Format+ for definitions of the
parameters.  
\begin{verbatim}
  GetFormat[1.0,width,decimals,expmode];
  True
\end{verbatim} 
\ed

\item\lex{GetSolutionFormat}
\protect \large \begin{verbatim}
GetSolutionFormat[{info<->False}, {names<->False}] =: BOOLEAN 
\end{verbatim} \normalsize

\bd
Gets the current values of the formatting parameters for Mixed and
Behavior strategy solution data types.  See \verb+Format+ for
definitions of the parameters.  
\begin{verbatim}
  GetFormat[Centroid[NewEfg[]],info,names];
  True
\end{verbatim} 
\ed

\item\lex{GetTextFormat}
\protect \large \begin{verbatim}
GetTextFormat[{quote<->True}] =: BOOLEAN 
\end{verbatim} \normalsize

\bd
Gets the current values of the formatting parameters for text strings.  See
\verb+Format+ for definitions of the parameters. 
\begin{verbatim}
  GetFormat["",quote];
  True
\end{verbatim} 
\ed

%--H--

\item\lex{History}
\protect \large \begin{verbatim}
History[n->NODE] =: LIST(ACTION) 
\end{verbatim}\normalsize

\bd 
Returns a list containing the sequence of actions connecting the root
node to \verb+n+
\begin{verbatim}
  If[IsRoot[n],{},Flatten[{History[Parent[n]]}&{PriorAction[n]}]]
\end{verbatim} 
\ed

%--I--

\item\lex{InfiniteLoopWarning}
\protect \large \begin{verbatim}
InfiniteLoopWarning[stopAfter->INTEGER, nTries->INTEGER] =: TEXT 
\end{verbatim}\normalsize

\bd 
Generates a warning at the console when a solution algorithm may enter
an infinite loop.  Used by the standard solution algorithms
\verb+AllNash+, \verb+AllSubgamePerfect+, etc.  

\begin{verbatim}
  If[nTries=0,
    If[stopAfter=0,
    " Warning: Entering infinite loop.  Use Ctl-C to exit.",  
    " Warning: Entering possible infinite loop.  Use Ctl-C to exit."],
  " Warning: May not find all"]
\end{verbatim} 
\ed

\item\lex{Infosets}
\protect \large \begin{verbatim}
Infosets[efg->EFG] =: LIST(LIST(INFOSET)) 
\end{verbatim}\normalsize

\bd 
A nested list of information sets in the game. The \verb+(i,j)+th
element is player \verb+i+s \verb+j+th information set.  
\begin{verbatim}
  Infosets[Players[efg]]
\end{verbatim} 
\ed

\item\lex{IsRoot}
\protect \large \begin{verbatim}
IsRoot[n->NODE] =: BOOLEAN 
\end{verbatim}\normalsize

\bd 
Returns \verb+True+ if \verb+n+ is the root node of the game, else
false.  
\begin{verbatim}
  IsNull[Parent[n]]
\end{verbatim} 
\ed

%--J--

%--K--

%--L--

\item\lex{LcpSolve}
\protect \large \begin{verbatim}
LcpSolve[nfg->NFG, {stopAfter->1}, {precision->Float}, 
         {nPivots<->0}, {time<->0.000000}, {traceFile<->(Output)}, 
         {traceLevel->0}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
A version of \verb+LcpSolve+ that takes a normal form
game instead of a support.  See the built-in function,
\verb+LcpSolve+ for a description of the parameters.
\begin{verbatim}
  LcpSolve[Support[nfg], stopAfter, precision, nPivots,
    time, traceFile, traceLevel]
\end{verbatim} 
\ed

\item\lex{LcpSolve}
\protect \large \begin{verbatim}
LcpSolve[efg->EFG, {asNfg->False}, {stopAfter->1}, 
        {precision->Float}, {nPivots<->0}, {time<->0.000000}, 
        {traceFile<->(Output)}, {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
A version of \verb+LcpSolve+ that takes an extensive form
game instead of a support.  See the built-in function,
\verb+LcpSolve+ for a description of the parameters.
\begin{verbatim}
  LcpSolve[Support[efg], asNfg, stopAfter, precision, nPivots,
    time, traceFile, traceLevel]
\end{verbatim} 
\ed

\item\lex{LiapSolve}
\protect \large \begin{verbatim}
LiapSolve[nfg->NFG, {stopAfter->1}, {nTries->10}, {maxitsN->20}, 
          {tolN->0.000000}, {maxits1->100}, {tol1->0.000000}, 
          {time<->0.000000}, {nEvals<->0}, {traceFile<->(Output)}, 
          {traceLevel->0}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
A version of \verb+LiapSolve+ that takes a normal form
game instead of a support.  See the built-in function,
\verb+LiapSolve+ for a description of the parameters.
\begin{verbatim}
  LiapSolve[Centroid[Support[nfg]], stopAfter, nTries,
  maxitsN, tolN, maxits1, tol1, time, nEvals, traceFile,
  traceLevel]
\end{verbatim} 
\ed

\item\lex{LiapSolve}
\protect \large \begin{verbatim}
LiapSolve[efg->EFG, {asNfg->False}, {stopAfter->1}, {nTries->10}, 
          {maxitsN->20}, {tolN->0.000000}, {maxits1->100}, 
          {tol1->0.000000}, {time<->0.000000}, {nEvals<->0}, 
          {traceFile<->(Output)}, {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
A version of \verb+LiapSolve+ that takes an extensive form
game instead of a support.  See the built-in function,
\verb+LiapSolve+ for a description of the parameters.
\begin{verbatim}
  LiapSolve[Centroid[Support[efg]], asNfg, stopAfter, nTries,
  maxitsN, tolN, maxits1, tol1, time, nEvals, traceFile,
  traceLevel]
\end{verbatim} 
\ed

\item\lex{ListForm}
\protect \large \begin{verbatim}
ListForm[behav->BEHAV] =: LIST(LIST(LIST(NUMBER))) 
\end{verbatim}\normalsize

\bd 
This function is provided for backwards compatibility only.  It
provides the same output as \verb+ActionProbs+.
\begin{verbatim}
  ActionProb[behav,Actions[Game[behav]]]
\end{verbatim} 
\ed

\item\lex{ListForm}
\protect \large \begin{verbatim}
ListForm[mixed->MIXED] =: LIST(LIST(NUMBER)) 
\end{verbatim}\normalsize

\bd 
This function is provided for backwards compatibility only.  It
provides the same output as \verb+StrategyProbs+.
\begin{verbatim}
  StrategyProb[mixed,Strategies[Game[mixed]]]
\end{verbatim} 
\ed

\item\lex{LpSolve}
\protect \large \begin{verbatim}
LpSolve[nfg->NFG, {stopAfter->1}, {precision->Float}, 
        {nPivots<->0}, {time<->0.000000}, {traceFile<->(Output)}, 
        {traceLevel->0}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
A version of \verb+LpSolve+ that takes a normal form
game instead of a support.  See the built-in function,
\verb+LpSolve+ for a description of the parameters.
\begin{verbatim}
  LpSolve[Support[nfg], stopAfter, precision, nPivots, time, traceFile, 
  traceLevel]
\end{verbatim} 
\ed

\item\lex{LpSolve}
\protect \large \begin{verbatim}
LpSolve[efg->EFG, {asNfg->False}, {stopAfter->1},
        {precision->Float}, {nPivots<->0}, {time<->0.000000}, 
        {traceFile<->(Output)}, {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
A version of \verb+LpSolve+ that takes an extensive form
game instead of a support.  See the built-in function,
\verb+LpSolve+ for a description of the parameters.
\begin{verbatim}
  LpSolve[Support[efg], asNfg, stopAfter, precision, nPivots, time, 
  traceFile, traceLevel]
\end{verbatim} 
\ed

%--M--

\item\lex{MarkedSubgames}
\protect \large \begin{verbatim}
MarkedSubgames[efg->EFG] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd 
Returns a list of the root nodes of all currently marked subgames.  
\begin{verbatim}
  Filter[n:=Nodes[efg],MarkedSubgame[n]]
\end{verbatim} 
\ed

\item\lex{MarkSubgames}
\protect \large \begin{verbatim}
MarkSubgames[efg->EFG] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd 
Marks all legal subgames in \verb+efg+.  Returns a list of root nodes
of the marked subgames.  
\begin{verbatim}
  MarkSubgame[s:=Subgames[efg]];
  MarkedSubgames[efg]
\end{verbatim} 
\ed


\item\lex{MarkSubgames}
\protect \large \begin{verbatim}
MarkSubgames[n->LIST(NODE)] =: LIST(BOOLEAN) 
\end{verbatim}\normalsize

\bd 
Marks the subgames whose roots are in \verb+n+, leaving all other
subgames unmarked.  Returns a list of \verb+BOOLEAN+, indicating if
the corresponding node was successfully marked (i. e., was a valid
subgame root).
\begin{verbatim}
  UnmarkSubgames[Game[n_1]];MarkSubgame[n]
\end{verbatim} 
\ed

\item\lex{Max}
\protect \large \begin{verbatim}
Max[x->LIST(NUMBER)] =: NUMBER 
\end{verbatim}\normalsize

\bd 
Returns the maximum value in the list \verb+x+.  
\begin{verbatim}
  i:=1;r:=x_1;
  While[i<NumElements[x],i:=i+1;If[x_i>r,r:=x_i]];
  r
\end{verbatim} 
\ed


\item\lex{MaxInt}
\protect \large \begin{verbatim}
MaxInt[] =: INTEGER 
\end{verbatim}\normalsize

\bd 
Returns the maximum integer:
\begin{verbatim}
// MAXINT = 2^31-1
  2147483647
\end{verbatim} 
\ed

\item\lex{Members}
\protect \large \begin{verbatim}
Members[efg->EFG] =: LIST(LIST(LIST(NODE))) 
\end{verbatim}\normalsize

\bd 
Returns a nested list of member nodes of information sets.  The
\verb+(i,j,k)+th element corresponds to player \verb+i+, information
set \verb+j+, action \verb+k+.  
\begin{verbatim}
  Members[Infosets[Players[efg]]]
\end{verbatim} 
\ed

\item\lex{Min}
\protect \large \begin{verbatim}
Min[x->LIST(NUMBER)] =: NUMBER 
\end{verbatim}\normalsize

\bd 
Returns the minimum value in the list \verb+x+.  
\begin{verbatim}
  -Max[-x]
\end{verbatim} 
\ed

\item\lex{Mixed}
\protect \large \begin{verbatim}
Mixed[nfg->NFG, list->LIST(LIST(NUMBER))] =: MIXED 
\end{verbatim}\normalsize

\bd 
Converts a nested list of numerical values into a mixed strategy.  The
\verb+(i,j)+th element of \verb+list+ becomes the probability
player \verb+i+ assigns to strategy \verb+j+. 
\begin{verbatim}
  SetProbs[Mixed[Support[nfg]],list]
\end{verbatim} 
\ed

\item\lex{Mixed}
\protect \large \begin{verbatim}
Mixed[list->LIST(STRATEGY)] =: MIXED 
\end{verbatim}\normalsize

\bd 
Constructs a mixed strategy profile representing the pure strategy
profile given by \verb+list+. It is an error if \verb+list+ does not
contain one strategy for each player.
\begin{verbatim}
  n:=Game[list_1];
  s:=Strategies[n];
  m:=Centroid[n];
  v:=ListForm[m];
  For[i:=1,i<=NumElements[v],i:=i+1,
    For[j:=1,j<=NumElements[v_i],j:=j+1,
      v_i_j:=0/1;
    ];
    v_i_(Index[s_i,list_i]_1) := 1/1
  ];
  SetProbs[m,v];   
\end{verbatim} 
\ed


%--N--

\item\lex{NewInfoset}
\protect \large \begin{verbatim}
NewInfoset[player->EFPLAYER, actions->LIST(TEXT), 
  {name->}] =: INFOSET 
\end{verbatim}\normalsize

\bd 
A version of \verb+NewInfoset+ that assigns \verb+name+ to be the name
of the information set, and \verb+actions_j+ to be the name of action
\verb+j+.  The number of actions created for the new information set
is determined implicitly by the length of the list \verb+actions+.  
\begin{verbatim}
  i:=SetName[NewInfoset[player,Length[actions]],name];
  SetName[Actions[i,Support[Game[player]]],actions];
  i
\end{verbatim} 
\ed

\item\lex{NewNfg}
\protect \large \begin{verbatim}
NewNfg[dim->LIST(INTEGER), outcomes->BOOLEAN] =: NFG }
\end{verbatim}\normalsize

\bd 

Creates an new normal form game with \verb+Length[dim]+ players, and
\verb+dim_i+ strategies for player \verb+i+.  A new outcome is
attached to each cell of the normal form game.  Returns the newly
created game.

\begin{verbatim}
  n:=NewNfg[dim];
  If[outcomes=True,
    NewOutcome[CartesianProd[Strategies[n]]]
  ];
  n;
\end{verbatim} 
\ed

\item\lex{NewOutcome}
\protect \large \begin{verbatim}
NewOutcome[efg->EFG, name->TEXT] =: EFOUTCOME 
\end{verbatim}\normalsize

\bd 
A version of \verb+NewOutcome+ that assigns \verb+name+ to be the name
of the outcome created.  
\begin{verbatim}
  SetName[NewOutcome[efg],name]
\end{verbatim} 
\ed

\item\lex{NewOutcome}
\protect \large \begin{verbatim}
NewOutcome[nfg->NFG, name->TEXT] =: NFOUTCOME 
\end{verbatim}\normalsize

\bd 
A version of \verb+NewOutcome+ that assigns \verb+name+ to be the name
of the outcome created.  
\begin{verbatim}
  SetName[NewOutcome[nfg],name]
\end{verbatim} 
\ed

\item\lex{NewOutcome}
\protect \large \begin{verbatim}
NewOutcome[profile->LIST(STRATEGY)] =: NFOUTCOME 
\end{verbatim}\normalsize

\bd 
Creates a new outcome for the normal form game, attaching it to
the pure profile \verb+profile+.  \verb+profile+ must be a list of
strategies, whose \verb+i+th entry is a strategy for player \verb+i+. 


\begin{verbatim}
  name:=Concat[Name[profile]];
  SetName[SetOutcome[profile,NewOutcome[Game[profile_1]]],name];
\end{verbatim} 
\ed

\item\lex{NewOutcome}
\protect \large \begin{verbatim}
NewOutcome[profile->LIST(STRATEGY), payoff->LIST(NUMBER)] =: NFOUTCOME 
\end{verbatim}\normalsize
 
\bd 
Creates a new outcome for the normal form game, attaching it to
the pure profile \verb+profile+, and sets the payoffs to be the vector
\verb+payoff+.  \verb+profile+ must be a list of strategies, whose
\verb+i+th entry is a strategy for player \verb+i+, and \verb+payoff+
is a list whose \verb+i+th entry is a payoff for player \verb+i+.

\begin{verbatim}
  SetPayoffs[NewOutcome[profile], payoff];
\end{verbatim} 
\ed


\item\lex{NewPlayer}
\protect \large \begin{verbatim}
NewPlayer[efg->EFG, name->TEXT] =: EFPLAYER 
\end{verbatim}\normalsize

\bd 
A version of \verb+NewPlayer+ that assigns \verb+name+ to be the name
of the extensive form player created.  
\begin{verbatim}
  SetName[NewPlayer[efg],name]
\end{verbatim} 
\ed

\item\lex{NewPlayer}
\protect \large \begin{verbatim}
NewPlayer[nfg->NFG, name->TEXT] =: NFPLAYER 
\end{verbatim}\normalsize

\bd 
A version of \verb+NewPlayer+ that assigns \verb+name+ to be the name
of the normal form player created.  
\begin{verbatim}
  SetName[NewPlayer[nfg],name]
\end{verbatim} 
\ed

\item\lex{Nfg}
\protect \large \begin{verbatim}
Nfg[x->NLIST(NUMBER)] =: NFG 
\end{verbatim}\normalsize

\bd 

Creates an \verb+n+ person normal form game from a \verb&n+1&
dimensional nested list \verb+x+ of payoffs.  It is an error if the
array of payoffs is not rectangular.  Entry
\verb+x_(k_1)_(k_2)_..._(k_n)_j+ is the payoff to player \verb+j+ from
the strategy profile where player \verb+i+ adopts strategy \verb+k_i+.
Returns the newly created game.

\begin{verbatim}
  d:=Dimensions[x];
  n:=NewNfg[Remove[d,Length[d]]];
  s:=CartesianProd[Strategies[n]];
  NewOutcome[s,x];
  n
\end{verbatim} 
\ed

\item\lex{NodeTree}
\protect \large \begin{verbatim}
NodeTree[efg->EFG] =: NLIST(NODE) 
\end{verbatim}\normalsize

\bd 
Returns a nested list of nodes in the game tree of \verb+efg+.  
\begin{verbatim}
  Descendants[RootNode[efg]]
\end{verbatim} 
\ed

\item\lex{NodeValues}
\protect \large \begin{verbatim}
NodeValues[behav->BEHAV, node->NODE] =: LIST(NUMBER) 
\end{verbatim}\normalsize

\bd 
Returns a list whose \verb+i+th entry is the value to player \verb+i+
of being at \verb+node+ under \verb+behav+.
\begin{verbatim}
  NodeValue[behav,Players[Game[behav]],node]
\end{verbatim} 
\ed

\item\lex{NonterminalNodes}
\protect \large \begin{verbatim}
NonterminalNodes[efg->EFG] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd 
A list of nonterminal nodes of \verb+efg+.
\begin{verbatim}
  Filter[d:=Nodes[efg],NumChildren[d]>0]
\end{verbatim} 
\ed

\item\lex{NthElement}
\protect \large \begin{verbatim}
NthElement[s<->EFSUPPORT, n->NUMBER] =: LIST(ACTION) 
\end{verbatim}\normalsize

\bd 
Returns the actions in \verb+s+ of player number \verb+n+
\begin{verbatim}
  Actions[s]_n;
\end{verbatim} 
\ed

\item\lex{NthElement}
\protect \large \begin{verbatim}
NthElement[s<->NFSUPPORT, n->NUMBER] =: LIST(STRATEGY) 
\end{verbatim}\normalsize

\bd 
Returns the strategies in \verb+s+ of player number \verb+n+
\begin{verbatim}
  Strategies[s]_n;
\end{verbatim} 
\ed

\item\lex{NumActions}
\protect \large \begin{verbatim}
NumActions[infoset->INFOSET, support->EFSUPPORT] =: INTEGER 
\end{verbatim}\normalsize

\bd 
The number of actions in \verb+infoset+.
\begin{verbatim}
  Length[Actions[infoset,support]] 
\end{verbatim} 
\ed

\item\lex{NumActions}
\protect \large \begin{verbatim}
NumActions[infoset->INFOSET] =: INTEGER 
\end{verbatim}\normalsize

\bd 
The number of actions in  \verb+infoset+.
\begin{verbatim}
  Length[Actions[infoset,Support[Game[infoset]]]] 
\end{verbatim} 
\ed

\item\lex{NumChildren}
\protect \large \begin{verbatim}
NumChildren[n->NODE] =: INTEGER 
\end{verbatim}\normalsize

\bd 
The number of child nodes of \verb+n+.
\begin{verbatim}
  Length[Children[n]]
\end{verbatim} 
\ed

\item\lex{NumMembers}
\protect \large \begin{verbatim}
NumMembers[i->INFOSET] =: INTEGER 
\end{verbatim}\normalsize

\bd 
The number of member nodes in the information set \verb+i+.
\begin{verbatim}
  Length[Members[i]]
\end{verbatim} 
\ed

\item\lex{NumPlayers}
\protect \large \begin{verbatim}
NumPlayers[efg->EFG] =: INTEGER 
\end{verbatim}\normalsize

\bd 
The number of players in the extensive form game \verb+efg+.
\begin{verbatim}
  Length[Players[efg]]
\end{verbatim} 
\ed

\item\lex{NumPlayers}
\protect \large \begin{verbatim}
NumPlayers[nfg->NFG] =: INTEGER 
\end{verbatim}\normalsize

\bd 
The number of players in the normal form game \verb+nfg+.
\begin{verbatim}
  Length[Players[nfg]]
\end{verbatim} 
\ed

\item\lex{NumStrats}
\protect \large \begin{verbatim}
NumStrats[player->NFPLAYER, support->NFSUPPORT] =: INTEGER 
\end{verbatim}\normalsize

\bd 
The number of strategies in \verb+support+ for player \verb+player+.
\begin{verbatim}
  Length[Strategies[player,support]] 
\end{verbatim} 
\ed

%--O--

\item\lex{OneNash}
\protect \large \begin{verbatim}
OneNash[e->EFG, {precision->Float}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
Finds one Nash equilibrium of the extensive form game \verb+e+.
Returns a singleton list containing the equilibrium found.

\begin{verbatim}
  ms:=MarkedSubgames[e];MarkSubgames[e];
  If[NumPlayers[e] = 2 && IsPerfectRecall[e],
    If[IsConstSum[e],
      b:=LpSolve[e,False,1,precision],
      b:=LcpSolve[e,False,1,precision]
    ],
    b:=SimpDivSolve[e,asNfg->True,stopAfter->1,nRestarts->16,
      precision->precision]
  ];
  MarkSubgames[ms];b
\end{verbatim} 
\ed

\item\lex{OneNash}
\protect \large \begin{verbatim}
OneNash[n->NFG, {precision->Float}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
Finds one Nash equilibrium of the normal form game \verb+n+.
Returns a singleton list containing the equilibrium found.

\begin{verbatim}
  s:=ElimAllDom[n];
  If[NumPlayers[n] = 2,
    If[IsConstSum[n],LpSolve[s,1,precision],LcpSolve[s,1,precision]],
    SimpDivSolve[s,stopAfter->1,nRestarts->16,precision->precision]
  ]
\end{verbatim} 
\ed

\item\lex{OnePerfect}
\protect \large \begin{verbatim}
OnePerfect[n->NFG, {precision->Float}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
Finds one Perfect Nash equilibrium of the normal form game
\verb+n+.  Returns a singleton list containing the equilibrium found.

\begin{verbatim}
  s:=ElimAllDom[n,strong->True];
  If[NumPlayers[n] = 2, 
    LcpSolve[s,1,precision],
    << " Not implemented for n-person games";
    List[Centroid[Support[n]],0] // return empty set of mixed
  ]
\end{verbatim} 
\ed

\item\lex{OneSequential}
\protect \large \begin{verbatim}
OneSequential[e->EFG] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
Finds one sequential Nash equilibrium of the extensive form game
\verb+e+.  Returns a singleton list containing the equilibrium found.

\begin{verbatim}
  ms:=MarkedSubgames[e];UnmarkSubgames[e];
  b:=QreSolve[e,fullGraph->False];
  If[!IsSequential[b_1],
    << " Warning: Algorithm did not converge, returning last value"
  ];
  MarkSubgames[ms];b
\end{verbatim} 
\ed

\item\lex{OneSubgamePerfect}
\protect \large \begin{verbatim}
OneSubgamePerfect[e->EFG, {precision->Float}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
Finds one subgame perfect Nash equilibrium of the extensive form
game \verb+e+.  Returns a singleton list containing the equilibrium
found.

\begin{verbatim}
  ms:=MarkedSubgames[e];MarkSubgames[e];
  If[NumPlayers[e] = 2 && IsPerfectRecall[e],
    If[IsConstSum[e],
      b:=LpSolve[e,False,1,precision],
      b:=LcpSolve[e,False,1,precision]
    ],
    b:=SimpDivSolve[e,asNfg->True,stopAfter->1,nRestarts->16,
      precision->precision]
  ];
  MarkSubgames[ms];b
\end{verbatim} 
\ed

\item\lex{OutcomeForm}
\protect \large \begin{verbatim}
OutcomeForm[n->NFG]=:NLIST(NFOUTCOME)
\end{verbatim}\normalsize

\bd 
Gives the game form of \verb+n+ in the form of a nested list, with
entires as the corresponding outcomes for each pure profile. 

\begin{verbatim}
  Outcome[CartesianProd[Strategies[n]]]
\end{verbatim} 
\ed

%--P--

\item\lex{Payoffs}
\protect \large \begin{verbatim}
Payoffs[outcome->EFOUTCOME*] =: LIST(NUMBER) 
Payoffs[outcome->NFOUTCOME*] =: LIST(NUMBER) 
\end{verbatim}\normalsize

\bd 
Returns a list whose \verb+i+th entry is the payoff to player \verb+i+
at \verb+outcome+.
\begin{verbatim}
  Payoff[outcome,Players[Game[outcome]]]
outcome
\end{verbatim} 
\ed

\item\lex{Payoffs}
\protect \large \begin{verbatim}
Payoffs[profile->BEHAV] =: LIST(NUMBER) 
Payoffs[profile->MIXED] =: LIST(NUMBER) 
\end{verbatim}\normalsize

\bd 
Returns a list whose \verb+i+th entry is the payoff to player \verb+i+
in the extensive or normal form game under \verb+profile+.
\begin{verbatim}
  Payoff[profile,Players[Game[profile]]]
\end{verbatim} 
\ed

\item\lex{Payoffs}
\protect \large \begin{verbatim}
Payoffs[profile->LIST(STRATEGY)] =: ANYTYPE 
\end{verbatim}\normalsize

\bd 
Returns a list whose \verb+i+th entry is the payoff to player \verb+i+
in the normal form game under the pure strategy represented by \verb+profile+.
It is an error if \verb+profile+ does not contain a list of
strategies, one for each player, in order.  
\begin{verbatim}
  Payoff[Outcome[profile],Players[Game[profile_1]]]
\end{verbatim} 
\ed


\item\lex{Payoffs}
\protect \large \begin{verbatim}
Payoffs[n->NFG] =: NLIST(NUMBER) 
\end{verbatim}\normalsize

\bd 
Returns a nested list of payoffs in the normal form game, verb+n+.
The \verb+(k_1,k_2, ... , k_n, j)+ entry of the list is the payoff to
player \verb+j+ from the strategy profile where player \verb+i+ adopts
strategy \verb+k_i+.
\begin{verbatim}
  Payoffs[CartesianProd[Strategies[n]]]
\end{verbatim} 
\ed
  

\item\lex{PlayerNumber}
\protect \large \begin{verbatim}
PlayerNumber[p->EFPLAYER] =: INTEGER 
PlayerNumber[p->NFPLAYER] =: INTEGER 
\end{verbatim}\normalsize

\bd 
The player number of player \verb+p+.
\begin{verbatim}
  Index[Players[Game[p]],p]_1
\end{verbatim} 
\ed

\item\lex{Prepend}
\protect \large \begin{verbatim}
Prepend[x->ANYTYPE, l->LIST(ANYTYPE)] =: LIST(ANYTYPE) 
\end{verbatim}\normalsize

\bd 
Inserts \verb+x+ as the first element of the list \verb+l+.  
\begin{verbatim}
  {x}&l
\end{verbatim} 
\ed

\item\lex{Profiles}
\protect \large \begin{verbatim}
Profiles[s->NFSUPPORT] =: NLIST(STRATEGY) 
\end{verbatim}\normalsize

\bd 
Returns a nested list of all the pure strategy profiles for the support
\verb+s+.  Each profile is a list of strategies, one for each player.  
\begin{verbatim}
  CartesianProd[Strategies[s]]
\end{verbatim} 
\ed


\item\lex{Profiles}
\protect \large \begin{verbatim}
Profiles[nfg->NFG] =: NLIST(STRATEGY) 
\end{verbatim}\normalsize

\bd 
Returns a nested list of all the pure strategy profiles for the normal
form game \verb+n+.  Each profile is a list of strategies, one for
each player.
\begin{verbatim}
  Profiles[Support[nfg]]
\end{verbatim} 
\ed

%--Q--

\item\lex{QreSolve}
\protect \large \begin{verbatim}
QreSolve[efg->EFG, {pxifile->}, {minLam->0.001000}, 
           {maxLam->500.000000}, {delLam->0.020000}, {powLam->1}, 
           {fullGraph->False}, {maxitsN->20}, {tolN->0.000000}, 
           {maxits1->100}, {tol1->0.000000}, {time<->0.000000}, 
           {nEvals<->0}, {nIters<->0}, {traceFile<->(Output)}, 
           {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
A version of \verb+QreSolve+ that takes an extensive form
game instead of a support.  See the built-in function,
\verb+QreSolve+ for a description of the parameters.
\begin{verbatim}
  QreSolve[Centroid[Support[efg]],pxifile,minLam,maxLam,delLam,powLam, 
  fullGraph,maxitsN,tolN,maxits1,tol1,time,nEvals,nIters,traceFile,
  traceLevel]
\end{verbatim} 
\ed

\item\lex{QreSolve}
\protect \large \begin{verbatim}
QreSolve[nfg->NFG, {pxifile->}, {minLam->0.001000}, 
           {maxLam->500.000000}, {delLam->0.020000}, {powLam->1}, 
           {fullGraph->False}, {maxitsN->20}, {tolN->0.000000}, 
           {maxits1->100}, {tol1->0.000000}, {time<->0.000000}, 
           {nEvals<->0}, {nIters<->0}, {traceFile<->(Output)}, 
           {traceLevel->0}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
A version of \verb+QreSolve+ that takes a normal form
game instead of a support.  See the built-in function,
\verb+QreSolve+ for a description of the parameters.
\begin{verbatim}
  QreSolve[Centroid[Support[nfg]],pxifile,minLam,maxLam,delLam,powLam,
  fullGraph,maxitsN,tolN,maxits1,tol1,time,nEvals,nIters,traceFile,
  traceLevel]
\end{verbatim} 
\ed

%--R--

\item\lex{Randomize}
\protect \large \begin{verbatim}
Randomize[x->EFG, {seed->0}] =: EFG 
Randomize[x->NFG, {seed->0}] =: NFG 
\end{verbatim}\normalsize

\bd 
Assigns a payoff for each outcome for each player in the extensive
or normal form game \verb+x+ randomly chosen from the uniform
distribution between 0 and 1.  The optional parameter \verb+seed+ may
be used to set the seed of the pseudo-random number generator.  The
identical game randomized with the same seed will always produce the
same results.
\begin{verbatim}
  o:=Outcomes[x];
  pay:=Payoffs[o];
  Randomize[pay_1_1,seed];
  pay:=Randomize[pay];
  SetPayoffs[o,pay];
  x;
\end{verbatim} 
\ed

\item\lex{Rational}
\protect \large \begin{verbatim}
Rational[g->EFG] =: EFG 
\end{verbatim}\normalsize

\bd 
Converts the internal representation of g to Rational.  
\begin{verbatim}
  gg:=CompressEfg[Support[g]];    // to make a copy
  i:=Infosets[Chance[gg]];
  SetChanceProbs[i,Rational[ChanceProb[Actions[i]]]];
  SetPayoffs[Outcomes[gg],Rational[Payoffs[Outcomes[gg]]]];
  gg;
\end{verbatim} 
\ed

\item\lex{Rational}
\protect \large \begin{verbatim}
Rational[g->NFG] =: NFG 
\end{verbatim}\normalsize

\bd 
Converts the internal representation of g to Rational.  
\begin{verbatim}
  gg:=CompressNfg[Support[g]];    // to make a copy
  SetPayoffs[Outcomes[gg],Rational[Payoffs[Outcomes[gg]]]];
  gg;
\end{verbatim} 
\ed

\item\lex{Read}
\protect \large \begin{verbatim}
Read[input<->INPUT, x<->MIXED] =: INPUT 
Read[input<->INPUT, x<->BEHAV] =: INPUT 
\end{verbatim}\normalsize

\bd 
Reads data of type \verb+MIXED+ or \verb+BEHAV+ from the input
stream and assigns it to \verb+x+.  If the wrong data type is found
for any element of the list, a file read error will be returned.
\item [Short form:] \verb+input >> x+
\item [See also:] \verb+Read+, \verb+Input+, \verb+Write+.
\begin{verbatim}
  v:=ListForm[x];
  input >> v;
  SetProbs[x,v];
  input
\end{verbatim} 
\ed

%--S--

\item\lex{SetIntegerFormat}
\protect \large \begin{verbatim}
SetIntegerFormat[{width->0}] =: BOOLEAN 
\end{verbatim}\normalsize

\bd 
Sets the formatting style for output of integer types on output
streams.  See \verb+Format+ for definitions of the parameters.
\item [See also:] \verb+SetListFormat+, \verb+SetTextFormat+, 
\verb+SetSolutionFormat+, \verb+Write+.
\begin{verbatim}
  !IsNull[Format[1,width]]
\end{verbatim} 
\ed

\item\lex{SetListFormat}
\protect \large \begin{verbatim}
SetListFormat[{braces->True}, {commas->True}, 
              {lf->1}, {indent->2}] =: BOOLEAN 
\end{verbatim} \normalsize

\bd
Sets the formatting style for output of lists on output streams. See
\verb+ListFormat+ for definitions of the parameters. 
\item [See also:] \verb+SetNumericFormat+, \verb+SetTextFormat+,
\verb+SetSolutionFormat+, \verb+Write+.
\begin{verbatim}
  ListFormat[braces,commas,lf,indent]
\end{verbatim} 
\ed

\item\lex{SetNumericFormat}
\protect \large \begin{verbatim}
SetNumericFormat[{width->0}, {precis->6}, 
                 {expmode->False}] =: BOOLEAN 
\end{verbatim}\normalsize

\bd Sets the formatting style for output of numeric types on output
streams.  See \verb+Format+ for definitions of the parameters.
\item [See also:] \verb+SetListFormat+, \verb+SetTextFormat+, 
\verb+SetSolutionFormat+, \verb+Write+.
\begin{verbatim}
  !IsNull[Format[1.0,width,decimals,expmode]]
\end{verbatim} 
\ed

\item\lex{SetPayoffs}
\protect \large \begin{verbatim}
SetPayoffs[outcome->EFOUTCOME, payoff->LIST(NUMBER)] =: EFOUTCOME 
SetPayoffs[outcome->NFOUTCOME, payoff->LIST(NUMBER)] =: NFOUTCOME 
\end{verbatim}\normalsize
 
\bd 

Sets the payoffs of \verb+outcome+ to be the vector \verb+payoff+,
where \verb+payoff+ is a list whose \verb+i+th entry is a payoff for
player \verb+i+.
\begin{verbatim}
  SetPayoff[outcome,Players[Game[outcome]],payoff];
  outcome
\end{verbatim} 
\ed

\item\lex{SetProbs}
\protect \large \begin{verbatim}
SetProbs[profile<->BEHAV, value->LIST(LIST(LIST(NUMBER)))] =: BEHAV 
\end{verbatim}\normalsize

\bd 
Sets the probabilities in the \verb+profile+ to the values in
\verb+value+.  
\begin{verbatim}
  SetActionProbs[profile,Infosets[Game[profile]],value];
  profile
\end{verbatim} 
\ed

\item\lex{SetProbs}
\protect \large \begin{verbatim}
SetProbs[profile<->MIXED, value->LIST(LIST(NUMBER))] =: MIXED 
\end{verbatim}\normalsize

\bd 
Sets the probabilities in the \verb+profile+ to the values in
\verb+value+.  
\begin{verbatim}
  SetStrategyProbs[profile,Players[Game[profile]],value];
  profile
\end{verbatim} 
\ed

\item\lex{SetSolutionFormat}
\protect \large \begin{verbatim}
SetSolutionFormat[{info->False}, {names->False}] =: BOOLEAN 
\end{verbatim}\normalsize

\bd Sets the formatting style for output of solution types on output
streams.  See \verb+Format+ for definitions of the parameters.
\item [See also:] \verb+SetListFormat+, \verb+SetTextFormat+, 
\verb+SetNumericFormat+, \verb+Write+.
\begin{verbatim}
  !IsNull[Format[Centroid[NewEfg[]],info,names]]
\end{verbatim} 
\ed

\item\lex{SetTextFormat}
\protect \large \begin{verbatim}
SetTextFormat[{quote->True}] =: BOOLEAN 
\end{verbatim}\normalsize

\bd 
Sets the formatting style for output of text on output streams.
See \verb+Format+ for definitions of the parameters.
\item [See also:] \verb+SetListFormat+, \verb+SetSolutionFormat+, 
\verb+SetNumericFormat+, \verb+Write+.
\begin{verbatim}
  !IsNull[Format["",quote]]
\end{verbatim} 
\ed

\item\lex{SimpDivSolve}
\protect \large \begin{verbatim}
SimpDivSolve[nfg->NFG, {stopAfter->1}, {nRestarts->16}, 
             {leashLength->0}, {precision->Float}, {nEvals<->0}, 
             {time<->0.000000}, {traceFile<->(Output)}, 
             {traceLevel->0}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd 
A version of \verb+SimpDivSolve+ that takes a normal form
game instead of a support.  See the built-in function,
\verb+SimpDivSolve+ for a description of the parameters.
\begin{verbatim}
  SimpDivSolve[Support[nfg], stopAfter, nRestarts, leashLength,
    precision, nEvals, time, traceFile, traceLevel]
\end{verbatim} 
\ed

\item\lex{SimpDivSolve}
\protect \large \begin{verbatim}
SimpDivSolve[efg->EFG, {asNfg->False}, {stopAfter->1}, 
             {nRestarts->16}, {leashLength->0}, {precision->Float}, 
             {nEvals<->0}, {time<->0.000000}, {traceFile<->(Output)}, 
             {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}\normalsize

\bd 
A version of \verb+SimpDivSolve+ that takes an extensive form
game instead of a support.  See the built-in function,
\verb+SimpDivSolve+ for a description of the parameters.
\begin{verbatim}
  SimpDivSolve[Support[efg], asNfg, stopAfter, nRestarts, leashLength,
    precision, nEvals, time, traceFile, traceLevel]
\end{verbatim} 
\ed

\item\lex{Strategies}
\protect \large \begin{verbatim}
Strategies[player->NFPLAYER] =: LIST(STRATEGY) 
\end{verbatim}\normalsize

\bd 
A list of strategies for \verb+player+ in the normal form game.  
\begin{verbatim}
  Strategies[player,Support[Game[player]]]
\end{verbatim} 
\ed

\item\lex{Strategies}
\protect \large \begin{verbatim}
Strategies[s->NFSUPPORT] =: LIST(LIST(STRATEGY)) 
\end{verbatim}\normalsize

\bd 
A list of sets of strategies in the support \verb+s+. The \verb+i+th
element of the list returned is a list of strategies for player
\verb+i+.   
\begin{verbatim}
  Strategies[Players[Game[s]],s]
\end{verbatim} 
\ed


\item\lex{Strategies}
\protect \large \begin{verbatim}
Strategies[nfg->NFG] =: LIST(LIST(STRATEGY)) 
\end{verbatim}\normalsize

\bd 
A list of strategy sets in the normal form game \verb+nfg+. The
\verb+(i,j)+th element of the list is player \verb+i+s \verb+j+th
strategy.  
\begin{verbatim}
  Strategies[Players[nfg]]
\end{verbatim} 
\ed

\item\lex{StrategyValues}
\protect \large \begin{verbatim}
StrategyValues[profile->MIXED] =: LIST(LIST(NUMBER)) 
\end{verbatim}\normalsize

\bd 
Returns the strategy values of \verb+profile+.  The
\verb+(i,j)'th+ element is the value to player \verb+i+ of adopting
strategy \verb+j+. 
\begin{verbatim}
  StrategyValue[profile,Strategies[Game[profile]]];
\end{verbatim} 
\ed

\item\lex{Sum}
\protect \large \begin{verbatim}
Sum[list->LIST(NUMBER)] =: NUMBER 
\end{verbatim}\normalsize

\bd 
The sum of the elements of \verb+list+.  
\begin{verbatim}
  Dot[list,List[1/1,Length[list] ]]
\end{verbatim} 
\ed


%--T--

\item\lex{TerminalNodes}
\protect \large \begin{verbatim}
TerminalNodes[efg->EFG] =: LIST(NODE) 
\end{verbatim}\normalsize

\bd 
The terminal nodes of the game tree of the extensive form game \verb+efg+.
\begin{verbatim}
  Filter[d:=Nodes[efg],NumChildren[d]=0]
\end{verbatim} 
\ed

%--U--

\item\lex{UnmarkSubgames}
\protect \large \begin{verbatim}
UnmarkSubgames[efg->EFG] =: LIST(NODE)
\end{verbatim}\normalsize

\bd 
Unmarks all subgames in \verb+efg+.
\begin{verbatim}
  UnmarkSubgame[Nodes[efg]];
  MarkedSubgames[efg]
\end{verbatim} 
\ed

%--V--

%--W--

%--X--

%--Y--

%--Z--

\end{itemize}

\appendix
\chapter{Sample GCL Programs}
\pagestyle{headings}

\section{A GCL program to build and solve the holdout game}

The following GCL program, in the file ``holdout.gcl'' defines a user
defined function

\begin{verbatim}
  HoldoutGame[ stages->INTEGER, prob1->NUMBER, prob2->NUMBER, 
                 disc->NUMBER, b->NUMBER] =: EFG
\end{verbatim}

\noindent
which can be used to create a finite horizon version of the
``holdout'' game studied in McKelvey and Palfrey, ``Endogeneity of
alternating offers in a bargaining game,'' forthcoming, JET.  To use
the function, include the file ``holdout.gcl'' and then type
\verb+HoldoutGame[n,r1,r2,d,b]+, where \verb+n+ is the number of
stages, \verb+r1+ and \verb+r2+ are the prior probabilities that
players 1 and 2 are a low benefit type, \verb+d+ is the common
discount factor, and \verb+b+ is the common benefit of giving in to
the high type.  For example, the following sequence of commands

\begin{verbatim}
  Include["holdout.gcl"]
  e:= HoldoutGame[1, .5, .5, .9, .5]
  SaveEfg[e,"holdout1.efg"]
  e:= HoldoutGame[7, .5, .5, .9, .5]
  SaveEfg[e,"holdout7.efg"]
\end{verbatim}

\noindent
creates and saves a one stage holdout game and a seven stage holdout
game. These can be loaded by the GUI, and Figures 1 and 2 display the
resulting games, as displayed by the GUI.  The subsequent file
``eaotest.gcl'' contains a GCL program that changes the parameters
\verb+r1+ and \verb+r2+, and then solves for {\em all} Nash equilibria
of the resulting seven stage game to check various theoretical predictions.

\begin{figure}[htp]
\psfig{figure=gclfig1.ps,height=3in,width=6in}
\caption{One stage holdout game}
\end{figure}
\begin{figure}[htp]
\psfig{figure=gclfig2.ps,height=3.5in}
\caption{Seven stage holdout game}
\end{figure}

\newpage
\noindent
This is the contents of the file "holdout.gcl" which defines the
function ``HoldoutGame[]'' used in the above programs.

{\scriptsize 
\begin{verbatim}
//
// A gcl program to construct a multi stage holdout game
//

NewFunction[MultiStageHoldout[ efg<->EFG, node->NODE, isets->LIST(INFOSET), \
            out->LIST(EFOUTCOME), stages->INTEGER, disc->NUMBER],
  // build tree
  i1:=isets_1;
  i2:=isets_2;
  AddMove[i1,node];
  AddMove[i2,node#1];
  If[NumActions[i1]>1, AddMove[i2, node#2] ];
    // attach outcomes
  SetOutcome[node#1#1, out_1 ]; 
  If[NumActions[i2]>1, SetOutcome[node#1#2, out_2 ] ];
  If[NumActions[i1]>1, 
    SetOutcome[node#2#1, out_3 ];
    If[NumActions[i2]>1, SetOutcome[node#2#2, out_4 ] ]
    ];
    // recurse to next stage
  If[NumActions[i1]>1 || NumActions[i2]>1,
    If[stages>1,
      stages;
      diset := NewInfoset[Chance[efg], {"",""} , "Discount"];
      SetChanceProbs[diset,{1.0-disc,disc}];
      AddMove[diset, node#1#1];
      MultiStageHoldout[efg,node#1#1#2,isets,out,stages-1,disc]
    ]
  ]
];

NewFunction[HoldoutGame[ stages->INTEGER,
            prob1->NUMBER, prob2->NUMBER, disc->NUMBER, b->NUMBER],
  e := NewEfg[];
  n := RootNode[e];
    // create chance moves
  ciset1 := NewInfoset[Chance[e], {"High", "Low"} , "Choose 1's type"];
  ciset2 := NewInfoset[Chance[e], {"High", "Low"} , "Choose 2's type"];
  SetChanceProbs[ciset1,{prob1,1.0-prob1}];
  SetChanceProbs[ciset2,{prob2,1.0-prob2}];
  AddMove[ciset1, n];
  AddMove[ciset2, n#1];
  AddMove[ciset2, n#2 ];
    // Define players, actions, and outcomes
  pl1 := NewPlayer[e,"Player 1"];
  pl2 := NewPlayer[e,"Player 2"];
  is1w := NewInfoset[ pl1 , {"H", "G"} ];
  is1s := NewInfoset[ pl1 , {"H"} ];
  is2w := NewInfoset[ pl2 , {"H", "G"} ];
  is2s := NewInfoset[ pl2 , {"H"} ];
  out1:= SetPayoffs[NewOutcome[e],{0.0, 0.0}];
  out2:= SetPayoffs[NewOutcome[e],{1.0, b}];
  out3:= SetPayoffs[NewOutcome[e],{b, 1.0}];
  out4:= SetPayoffs[NewOutcome[e],{b,b}];
  outs:={out1,out2,out3,out4};

    // Create multi stage games
  MultiStageHoldout[ e, n#1#1, {is1w,is2w}, outs, stages, disc];
  MultiStageHoldout[ e, n#1#2, {is1w,is2s}, outs, stages, disc];
  MultiStageHoldout[ e, n#2#1, {is1s,is2w}, outs, stages, disc];
  MultiStageHoldout[ e, n#2#2, {is1s,is2s}, outs, stages, disc];
  nonterm:=NonterminalNodes[e];

    // Make perfect recall 
  For[i:=1,i<=Length[nonterm],i:=i+1,
    p:=Player[Infoset[nonterm_i ] ];
    If[p!=Chance[e],
      Reveal[Infoset[nonterm_i ],{p}] ]
    ];	
  e
]
\end{verbatim}
}

\noindent
This program solves for all equilibria of the seven stage holdout game
illustrated in Figure 2, using various parameters for the chance
moves, to check various theoretical predictions. 
{\scriptsize
\begin{verbatim}
//
// A gcl program to check theoretical results from McKelvey Palfrey 
// paper "Endogeneity of Alternating Offers,"  forthcoming JET.  
//

// Create seven stage holdout game (or read in previously
// saved game to save time). 

b:=.5;
del:=.9;

// Include["holdout.gcl"]
// e:= HoldoutGame[7, .5, .5, del, b]
// SaveEfg[e,"holdout7.efg"]

e:=LoadEfg["holdout7.efg"]

// set variables to refer to the chance moves, 

n:=RootNode[e];
i1:=Infoset[n];
i2:=Infoset[n#1];

// open outfile 
o:=Output["eaotest.out"];
SetListFormat[lf->0,commas->False,braces->False];
SetNumericFormat[precis->3];

// define the constants demarcating the regions of equilibria

R := (1.0-b)/(1.0-del*b);
Q := (del-b) / (del*(1.0-del*b));

o << "\nb: " << b << " del: " << del;
o << " R: " << R << " Q: " << Q << "\n";

// define variable, g,  for actions where players give in.  

a:=Actions[e]
g:=Filter[a,Name[a]="G"]
g:={Flatten[g_1],Flatten[g_2]}

// Now, check various regions to make sure they have the right 
// kinds of equilibria predicted by the theorems.  

o << "\nProbabilities of Giving in by player and move:\n\n"

o << "\nIn these regions there should be just one equilibrium, with";
o << "\nfull alternating offers, lasting J innings (2 J moves)\n ";

For[J:=1,J<=4,J:=J+1,
  r1:=(Q^J+Q^(J-1))/2.0;
  r2:=(R*Q^(J-1))/2.0;
  SetChanceProbs[i1,{1.0-r1,r1}];
  SetChanceProbs[i2,{1.0-r2,r2}];
  s:=AllNash[e];
  o << "\nJ: " << J << " r1: " << r1 << "  r2: " << r2;
  o << "\n                        move";
  o << "\nplayer    1      2      3      4      5      6      7  \n"; 
  For[k:=1,k<=Length[s],k:=k+1,
    o << "   1: " << Float[ActionProb[s_k,g]_1] << "\n";
    o << "   2: " << Float[ActionProb[s_k,g]_2] << "\n\n"
  ]
];

o << "\n\nIn these regions there may be multiple equilibria. At least ";
o << "\none should be full simultaneous offer, lasting M moves:\n";

For[M:=1,M<=4,M:=M+1,
  r1:=(R^(M+1)+R^M)/2.0;
  r2:=r1;
  SetChanceProbs[i1,{1.0-r1,r1}];
  SetChanceProbs[i2,{1.0-r2,r2}];
  s:=AllNash[e];
  o << "\nM: " << M << " r1: " << r1 << "  r2: " << r2;
  o << "\n                        move";
  o << "\nplayer    1      2      3      4      5      6      7  \n"; 
  For[k:=1,k<=Length[s],k:=k+1,
    o << "   1: " << Float[ActionProb[s_k,g]_1] << "\n";
    o << "   2: " << Float[ActionProb[s_k,g]_2] << "\n\n"
  ]
];

// close file

o:=;
\end{verbatim}
}

\noindent
Following is the output from running the above program:
{\scriptsize
\begin{verbatim}

b: 0.500 del: 0.900 R: 0.909 Q: 0.808

Probabilities of Giving in by player and move:


In these regions there should be just one equilibrium, with
full alternating offers, lasting J innings (2 J moves)
 
J: 1 r1: 0.904  r2: 0.500
                        move
player    1      2      3      4      5      6      7  
   1:   0.000  1.000  0.000  0.000  0.000  0.000  0.000  
   2:   1.000  0.000  0.000  0.000  0.000  0.000  0.000  


J: 2 r1: 0.731  r2: 0.367
                        move
player    1      2      3      4      5      6      7  
   1:   0.000  0.712  0.000  1.000  0.000  0.000  0.000  
   2:   0.862  0.000  1.000  0.000  0.000  0.000  0.000  


J: 3 r1: 0.590  r2: 0.270
                        move
player    1      2      3      4      5      6      7  
   1:   0.000  0.468  0.000  0.712  0.000  1.000  0.000  
   2:   0.804  0.000  0.553  0.000  1.000  0.000  0.000  


J: 4 r1: 0.477  r2: 0.198
                        move
player    1      2      3      4      5      6      7  
   1:   0.000  0.367  0.000  0.468  0.000  0.712  0.000  
   2:   0.395  0.000  0.270  0.000  0.299  0.000  1.000  



In these regions there may be multiple equilibria. At least 
one should be full simultaneous offer, lasting M moves:

M: 1 r1: 0.868  r2: 0.868
                        move
player    1      2      3      4      5      6      7  
   1:   0.000  1.000  0.000  0.000  0.000  0.000  0.000  
   2:   1.000  0.000  0.000  0.000  0.000  0.000  0.000  

   1:   1.000  0.000  0.000  0.000  0.000  0.000  0.000  
   2:   0.000  1.000  0.000  0.000  0.000  0.000  0.000  

   1:   0.687  1.000  0.000  0.000  0.000  0.000  0.000  
   2:   0.687  1.000  0.000  0.000  0.000  0.000  0.000  


M: 2 r1: 0.789  r2: 0.789
                        move
player    1      2      3      4      5      6      7  
   1:   0.431  0.687  1.000  0.000  0.000  0.000  0.000  
   2:   0.431  0.687  1.000  0.000  0.000  0.000  0.000  


M: 3 r1: 0.717  r2: 0.717
                        move
player    1      2      3      4      5      6      7  
   1:   0.000  0.679  0.000  1.000  0.000  0.000  0.000  
   2:   0.398  0.000  1.000  0.000  0.000  0.000  0.000  

   1:   0.398  0.000  1.000  0.000  0.000  0.000  0.000  
   2:   0.000  0.679  0.000  1.000  0.000  0.000  0.000  

   1:   0.321  0.431  0.687  1.000  0.000  0.000  0.000  
   2:   0.321  0.431  0.687  1.000  0.000  0.000  0.000  


M: 4 r1: 0.652  r2: 0.652
                        move
player    1      2      3      4      5      6      7  
   1:   0.261  0.321  0.431  0.688  1.000  0.000  0.000  
   2:   0.261  0.321  0.431  0.688  1.000  0.000  0.000  
\end{verbatim}
}

\newpage
\section{A GCL program for econometric estimation}  

This section gives a GCL program for doing maximum likelihood fits of
experimental data to the quantal response equilibrium (QRE) and one
sided error model (OSEM).  The following files define a GCL function 

\begin{verbatim}
  EQre[filename->TEXT] 
\end{verbatim}

\noindent
which takes as input an extensive form in the file ``filename.efg'',
and experimental data from the file ``filename.agg'', and produces as
output ``filename.out'' and ``filename.pxi''.  The file
``filename.out'' contains the maximum likelihood estimates of the data
for the QRE and the OSEM models, along with 95\% confidence intervals
on the parameters of the models, $\lambda$ and $\gamma$, respectively.
The file ``filename.pxi'' contains the ``pxi'' file of the QRE
correspondence, which can be viewed and printed to a postscript file
by the separate program PXI program, written by Eugene Grayver.  

The program is illustrated on an experiment (Game 3) of Brandts and
Holt, ``Adjustment patterns and equilibrium selection in experimental
signaling games,'' IJGT 22 (1993): 279-302.  The extensive form of the
game in ``bhg3.efg'' is displayed in Figure 3:

\begin{figure}[htp]
\centerline{\psfig{figure=gclfig3.ps,height=4in,width=5in}}
\caption{Brandts Holt Experimental Game 3}
\end{figure}

\noindent
The input data file ``bhg3.agg'' follows:

\begin{verbatim}
  .01 0.70 .01
  1.0 0.0  1.0 0.0  1.0 0.0 0.0  0.0 1.0 0.0 
  1
  32 1 18 21 48 2 0  4 18 0
\end{verbatim}

\noindent
The program is run by typing 

\begin{verbatim}
  Include["eqre.gcl"]
  EQre["bhg3"]
\end{verbatim}

\noindent
Figure 4 displays the pxi file, and the following output is in
``bhg3.out'':

\begin{verbatim}
  Using Nash: (Behav) { { 1.000000 0.000000 }{ 1.000000 0.000000 } }
  { { 1.000000 0.000000 0.000000 }{ 0.000000 1.000000 0.000000 } }

  minLam: 0.010000 maxLam: 0.700000 delLam: 0.010000
  delGam: 0.001000 eps: 0.000000


    Player  Infoset   n         f       QRE      OSEM

        1      1     32      0.9697    0.9462    0.8375
        1      1      1      0.0303    0.0538    0.1625
        1      2     18      0.4615    0.6014    0.8375
        1      2     21      0.5385    0.3986    0.1625
        2      1     48      0.9600    0.6860    0.7833
        2      1      2      0.0400    0.1779    0.1083
        2      1      0      0.0000    0.1361    0.1083
        2      2      4      0.1818    0.1086    0.1083
        2      2     18      0.8182    0.7186    0.7833
        2      2      0      0.0000    0.1728    0.1083
  Lam\Gam                    0.0000    0.1078    0.6750
  Lam\Gam_lo                           0.0957    0.5590
  Lam\Gam_hi                           0.1252    0.7730
  LogLik                              -69.529   -78.295
\end{verbatim}


\newpage
\begin{figure}[htp]
\centerline{\psfig{figure=gclfig4a.ps,height=3.5in,width=5.5in}}
\vspace{.5in}
\centerline{\psfig{figure=gclfig4b.ps,height=3.25in,width=6.5in}}
\caption{BH (1993) Game 3. Graphical display of ``pxi'' file }
\end{figure}

\noindent
The program is contained in three files, whose contents follow.  First
is the contents of ``eqre.gcl'':

{\scriptsize
\begin{verbatim}
//
//  This gcl program estimates the principal branch of
//  the QRE and corresponding OSEM for a given extensive 
//  form game, finds MLE fits to experimental data 
//  and computes 95% confidence intervals for each model. 
//
//  The extensive form is assumed to be in filename.efg
//  and the data is in filename.agg.  The first line
//  in the agg file should contain the bounds for lambda 
//  The second line should contain an equilibrium selection 
//  to be used by the OSEM model. The third line gives 
//  the number of data sets
//  for which the estimation is to be conducted.  This 
//  should be followed by at least that many sets of data.
//
//  The output is put in filename.out, and the pxifile is put in
//  filename.pxi
//

Include["eqreml.gcl"]

NewFunction[EQre[filename->TEXT],
  //  Load efg and open agg file for reading
  width:=0;precis:=0;quote:=True;lf:=0;
  GetNumericFormat[width<->width,precis<->precis];
  GetTextFormat[quote<->quote];
  GetListFormat[lf<->lf];

  e := LoadEfg[filename&".efg"];
  in := Input[filename&".agg"];

  // read in range of lambdas for QRE estimation
  min:=max:=del:=0.0;
  in >> min >> max >> del;

  // read in nash equilibrium selection to be used for OSEM model
  nash :=Centroid[e];
  datlist := Integer[ListForm[nash]];
  in >> nash;

  //  Load data into dat
  ndat:=0;
  in >> ndat;
  dat := {};
  For[i := 1, i <= ndat, i := i+1,
    dat := dat & {datlist};
    in >> dat_i;
  ];

  pxi := filename&".pxi";
  out := filename&".out";

  EQreML[e,dat,min,max,del,out,pxi,nash];
  SetNumericFormat[width,precis];
  SetTextFormat[quote];
  SetListFormat[lf->lf];
];
\end{verbatim}
}

\noindent
Following is the contents of ``eqreml.gcl'':

{\scriptsize
\begin{verbatim}
//
// A gcl program to estimate the principal branch of the 
// QRE for an extensive form game, and find the maximum likelihood 
// estimate of lambda for a list of aggregate experimental data
// 
// e is the normal form game
// dat is a list of observations.  Each observation is in the form of  
//      a LIST(LIST(LIST(INTEGER))), where the integers correspond to
//	the number times the corresponding action (for that player in
//	that information set) was chosen.  So for a 2 player game where
//	each player has two information sets with two actions each, the 
//      element in dat {{{43, 32}, {12, 20}}, {{15, 32}, {16, 28}}} is 
//	used to indicate that player 1 chose the first action at the
//	first information set 43 times, etc.  
// min is the minimum value for Lambda used by QreSolve[]
// max is the maximum value for Lambda used by QreSolve[]
// del is the increment for Lambda used by QreSolve[]
// out is the name of a file in which the results will be written
// pxi is the name of a file where the pxi file is written
// nash is a Nash equilibrium selection that is passed for use
//     in estimating the OSEM model 

Include["loglike.gcl"]

NewFunction[EQreML[e<->EFG,dat->LIST(LIST(LIST(LIST(INTEGER)))),min->NUMBER,max->NUMBER,\
  del->NUMBER,out->TEXT,pxi->TEXT,nash->BEHAV],
  o := Output[out];

  gob := QreSolve[e, minLam->min, maxLam->max, delLam->del,fullGraph->True, \
    pxifile->pxi];

  size := Length[gob];

  eps:=0.0000000001;
  For[i := size , i>=1 , i:=i-1,
    If[QreValue[gob_i] > eps, 
      o << "\nRemoved element: " << i << " lambda: " << QreLambda[gob_i];
      gob:=Remove[gob,i]; 
    ];
  ];
  lamlist:=QreLambda[gob];
  size := Length[gob];

  goblist := ListForm[gob];
  exdat := Float[dat];

  numactions := Length[ListForm[nash]];
  numisets := Length[numactions];
  numplayers := Length[numisets];

  o << "\nUsing Nash: " << nash << "\n";
  o << "\nminLam: " << min << " maxLam: " << max << " delLam: " << del;

  delgam := .001;
  o << "\ndelGam: " << delgam << " eps: " << eps << "\n\n";

  gamsize := Integer[1./delgam] - 1;
  gamlist := List[delgam, gamsize, delgam];

  c := Float[Centroid[e]];
  n := nash;
  osem := (1.0-gamlist)*c + gamlist*n;
  osemlist := ListForm[osem];

  // compute maximum likelihoods and pretty-print results to output file

  SetTextFormat[quote->False];

  ldat := Length[Length[Length[Length[dat]]]];

  For[ii:=1, ii<=ldat, ii:=ii+1,
    goblogl := LogLike[exdat_ii,gob];
    osemlogl := LogLike[exdat_ii, osem];
    header:="\n  Player  Infoset   n         f       QRE      OSEM\n";
    o << header;

    gobllmax := ArgMax[goblogl];
    osemllmax := ArgMax[osemlogl];
    For[i:=1, i<=numplayers, i:=i+1,
      For[j:=1, j<=numisets_i, j:=j+1,
        sum:=Sum[exdat_ii_i_j];
        For[k:=1,k<=numactions_i_j,k:=k+1,
          nob:=exdat_ii_i_j_k;
          SetNumericFormat[precis->0,width->7];
          o << "\n" << i << j << nob;
          SetNumericFormat[precis->4,width->10];
          If[sum != 0.0, o << "  " << nob/sum, o << " " << 0.0];
          o << goblist_gobllmax_i_j_k;
          o << osemlist_osemllmax_i_j_k;
        ];
      ];
    ];
    LamCI := LamHiLo[goblogl, lamlist, 1.9205, gobllmax];
    GamCI := LamHiLo[osemlogl, gamlist, 1.9205, osemllmax];
    o << "\nLam\Gam                " << 0.0 <<  lamlist_gobllmax << gamlist_osemllmax;
    o << "\nLam\Gam_lo                       " << LamCI_1 << GamCI_1;
    o << "\nLam\Gam_hi                       " << LamCI_2 << GamCI_2;
    SetNumericFormat[precis->3, width->10];
    o << "\nLogLik                           " << goblogl_gobllmax << osemlogl_osemllmax << "\n";
  ];
];
\end{verbatim}
}

\noindent
Following is the contents of ``loglike.gcl'':

{\scriptsize
\begin{verbatim}
//
// Some user defined functions for maximum likelihood estimation
// 

// log likelihood of the data for a given solution
// note that the data must be of type MIXED
// So if data is LIST(LIST(INTEGER)), then call function by  
// LogLik[Mixed[n,Float[data]],sol]

NewFunction[ LogLike[dat->LIST(LIST(NUMBER)), sol->MIXED], 
  x:= dat * Log [ ListForm[sol]];
  Sum[Sum[x]];
];

NewFunction[ LogLike[dat->MIXED, sol->MIXED], 
  x:= ListForm[dat] * Log [ ListForm[sol]];
  Sum[Sum[x]];
];

// log likelihood of the data for a given solution
// note that the data must be of type BEHAV
// So if data is LIST(LIST(LIST(INTEGER))), then call function by  
// LogLik[Behav[n,Float[data]],sol]

NewFunction[ LogLike[dat->BEHAV, sol->BEHAV], 
  x:= ListForm[dat] * Log [ ListForm[sol]];
  Sum[Sum[Sum[x]]];
];

NewFunction[ LogLike[dat->LIST(LIST(LIST(NUMBER))), sol->BEHAV], 
  x:= dat * Log [ ListForm[sol]];
  Sum[Sum[Sum[x]]];
];

// This function computes confidence intervals for a solution
// Here list is the list of likelihood values, lam is the list of parameters
// (assumed to have the same length as list, range is 1/2 of the chi^2 value
// (use 1.9205 for a 95% confidence interval), and llmaxind is the location of the 
// maximum (assumed correct) 

NewFunction[LamHiLo[list->LIST(NUMBER),lam->LIST(NUMBER),range->NUMBER,llmaxind->INTEGER],
  newlist := list -(list_llmaxind-range);
  t1:={};
  t2:={};
  llsize := Length[lam];
  For[z:=2, z<=llsize, z:=z+1,
    If[newlist_z >= 0.0, 
    t1:=t1&{z}; 
    t2:=t2&{lam_z};];
  ];
  flag := True;
  t1:=t1-(t1_1 - 1);
  len:=Length[t1];
  If[len != t1_len, flag:=False];
  lhilo:={t2_1,t2_len};
];
\end{verbatim}
}

\bibliographystyle{chicagob}
\bibliography{gambit}
\addcontentsline{toc}{chapter}{Bibliography}
\input{gclman.ind}
\end{document}






