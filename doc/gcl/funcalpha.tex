%
% $Header$
%
% Description: Alphabetical listing of built-in GCL functions for manual
%

\chapter{Alphabetical function reference}

%----------

\section*{Accuracy}\label{PrimAccuracy}
\index{Accuracy (GCL primitive function)}
\begin{verbatim}
Accuracy[profile->BEHAV] =: NUMBER
Accuracy[profile->MIXED] =: NUMBER
\end{verbatim}

Returns the accuracy of \verb+profile+.  The accuracy is the error
that is allowed in computation of which Nash refinements the profile
satisfied.  Thus, if the profile is marked as Nash, then no deviation
by any player can yield an improvement of more than the accuracy.  

%----------

\section*{ActionNumber}\label{PrimActionNumber}
\index{ActionNumber (GCL primitive function)}
\begin{verbatim}
ActionNumber[action->ACTION, sup->EFSUPPORT] =: INTEGER 
ActionNumber[action->ACTION, basis->EFBASIS] =: INTEGER
\end{verbatim}

Returns the number assigned to \verb+action+ in the support \verb+sup+
(or basis \verb+basis+).  For each information set, actions are
numbered from 1 to the number of actions at the information set.  If
an action is not in the corresponding support or basis, it is assigned
a number of \verb+0+.

\textbf{See also:} \helpref{\texttt{Actions}}{PrimActions}.

%----------

\section*{ActionProb}\label{PrimActionProb}
\index{ActionProb (GCL primitive function)}
\begin{verbatim}
ActionProb[profile->BEHAV, action->ACTION] =: NUMBER 
\end{verbatim}

Returns the probability that \verb+action+ is chosen at its
information set when all players are following \verb+profile+.
If \verb+action+ is a chance action, the probability of chance selecting
the action is returned.  If the probability is not specified by the 
profile, the null value is returned.  It is an error if \verb+profile+
and \verb+action+ are not from the same extensive form game.

\textbf{See also:} \helpref{\texttt{ActionProbs}}{ExtActionProbs},
\helpref{\texttt{SetActionProbs}}{PrimSetActionProbs}.

%----------

\section*{Actions}\label{PrimActions}
\index{Actions (GCL primitive function)}
\begin{verbatim} 
Actions[infoset->INFOSET*, support->EFSUPPORT] =: LIST(ACTION) 
Actions[infoset->INFOSET*, basis->EFBASIS] =: LIST(ACTION) 
\end{verbatim}

Returns the list of actions available at \verb+infoset+ in
\verb+support+ or \verb+basis+.  If \verb+infoset+ is the null
information set, the empty list of actions is returned.  It is an
error if \verb+infoset+ and \verb+support+ are not from the same
extensive form game.

\textbf{See also:} \helpref{\texttt{DeleteAction}}{PrimDeleteAction},
\helpref{\texttt{InsertAction}}{PrimInsertAction}.

%----------

\section*{ActionValue}\label{PrimActionValue}
\index{ActionValue (GCL primitive function)}
\begin{verbatim}
ActionValue[profile->BEHAV, action->ACTION] =: NUMBER 
\end{verbatim}

Returns the expected payoff to a player (who is in control of the
information set including \verb+action+) of choosing \verb+action+ when
all players are following \verb+profile+.  If the value is not
well-defined, the null value is returned.  It is an error if
\verb+profile+ and \verb+action+ are not from the same extensive form
game, or if \verb+action+ is an action at an information set owned by
the chance player.

\textbf{See also:}
\helpref{\texttt{ActionValues}}{ExtActionValues},
\helpref{\texttt{Belief}}{PrimBelief},
\helpref{\texttt{InfosetProb}}{PrimInfosetProb},
\helpref{\texttt{NodeValue}}{PrimNodeValue},
\helpref{\texttt{RealizProb}}{PrimRealizProb}.

%----------

\section*{AddAction}\label{PrimAddAction}
\index{AddAction (GCL primitive function)}
\begin{verbatim}
AddAction[support->EFSUPPORT, action->ACTION] =: EFSUPPORT 
AddAction[basis->EFBASIS, action->ACTION] =: EFSUPPORT 
\end{verbatim}

Adds \verb+action+ to the \verb+support+.  If the action is already in
the support, no change is made.  A copy of the modified support is
returned.  It is an error if \verb+support+ and \verb+action+ are not from the
same extensive form game.

\textbf{See also:}
\helpref{\texttt{RemoveAction}}{PrimRemoveAction},
\helpref{\texttt{Support}}{PrimSupport}.

%----------

\section*{AddMove}\label{PrimAddMove}
\index{AddMove (GCL primitive function)}
\begin{verbatim}
AddMove[infoset->INFOSET, node->NODE] =: NODE 
\end{verbatim}

Places a terminal \verb+node+ into the information set
\verb+infoset+.  The result is \verb+node+ becomes a decision node,
with number of branches equal to the number of actions in \verb+infoset+.
New child nodes are created as successor nodes to the actions in the
information set.  The child which succeeds the first action is returned.
It is an error if \verb+node+ and \verb+infoset+ are not from the same
extensive form game, or if \verb+node+ is not a terminal node.

\textbf{See also:} \helpref{\texttt{InsertMove}}{PrimInsertMove},
\helpref{\texttt{DeleteMove}}{PrimDeleteMove},
\helpref{\texttt{NewInfoset}}{PrimNewInfoset}.

%----------

\section*{AddNode}\label{PrimAddNode}
\index{AddNode (GCL primitive function)}
\begin{verbatim}
AddNode[basis->EFBASIS, node->NODE] =: EFBASIS
\end{verbatim}

Describe me!

%----------

\section*{AddStrategy}\label{PrimAddStrategy}
\index{AddStrategy (GCL primitive function)}
\begin{verbatim}
AddStrategy[support->NFSUPPORT, strategy->STRATEGY] =: NFSUPPORT 
\end{verbatim}

Adds \verb+strategy+ to the \verb+support+.  If the strategy is already
in the support, no change is made.  A copy of the modified support is
returned.  It is an error if \verb+support+ and \verb+strategy+ are not
from the same normal form game.

\textbf{See also:}
\helpref{\texttt{RemoveStrategy}}{PrimRemoveStrategy},
\helpref{\texttt{Support}}{PrimSupport}.

%----------

\section*{AgentForm}\label{PrimAgentForm}
\index{AgentForm (GCL primitive function)}
\begin{verbatim}
AgentForm[efg->EFG, {time<->0}] =: NFG 
\end{verbatim}

Creates and returns the agent normal form representation of \verb+efg+.
The optional parameter \verb+time+, if specified, returns the amount
of time consumed by the conversion.

\textbf{See also:} \helpref{\texttt{Nfg}}{PrimNfg}.

%----------

\section*{And}\label{PrimAnd}
\index{And (GCL primitive function)}
\begin{verbatim}
And[x->BOOLEAN, y->BOOLEAN] =: BOOLEAN 
\end{verbatim}

Computes the logical conjunction of \verb+x+ and \verb+y+, defined by the
truth table:

\begin{center}
\begin{tabular}{|c|ccc|} \hline
\ruledrow{ & \texttt{True} & \texttt{False} & \texttt{Unknown}}
\row{\texttt{True} & \texttt{True} & \texttt{False} & \texttt{Unknown}}
\row{\texttt{False} & \texttt{False} & \texttt{False} & \texttt{False}}
\ruledrow{\texttt{Unknown} & \texttt{Unknown} & \texttt{False} & \texttt{Unknown}} 
\end{tabular}
\end{center}

\shortform \verb+x && y+, \verb+x AND y+.

\seealso \helpref{\texttt{Not}}{PrimNot}, \helpref{\texttt{Or}}{PrimOr}.

%----------

\section*{ArgMax}\label{PrimArgMax}
\index{ArgMax (GCL primitive function)}
\begin{verbatim}
ArgMax[x->LIST(NUMBER)] =: INTEGER 
\end{verbatim}

Returns the index of the first element of the list \verb+x+ which
attains the maximum value of any elements in the list.  

%----------

\section*{Assign}\label{PrimAssign}
\index{Assign (GCL primitive function)}
\begin{verbatim}
Assign[name->TEXT, value<->T*] =: T
\end{verbatim}
\foralltypes

Creates a new variable \verb+name+, with return value of \verb+value+.
Returns the value assigned.  If \verb+name+ is already a defined
variable in the current scope, then if it is of type \verb+T+, it is
modified to have return value of \verb+value+.  If it is of a
different data type, an error results.

\textbf{Short form:} \verb+x := value+

\textbf{Note:} For the short form, quotes around \verb+name+ are not
required, and the function is not listable.

\textbf{See also:} \funcxref{Clear}{PrimClear},
\helpref{\texttt{UnAssign}}{PrimUnAssign}.

%--B--

\section*{Basis}\label{PrimBasis}
\index{Basis (GCL primitive function)}
\begin{verbatim}
Basis[efg->EFG] =: EFBASIS
\end{verbatim}

\noindent Describe me!

%----------

\section*{Behav}\label{PrimBehav}
\index{Behav (GCL primitive function)}
\begin{verbatim}
Behav[mixed->MIXED] =: BEHAV 
\end{verbatim}
\noindent
Converts \verb+mixed+ to the equivalent behavior strategy profile on
the associated extensive form game using Kuhn's Theorem.  It is an
error if there is no extensive form game associated with the normal
form game of \verb+profile+.  Note that this function assumes that the
associated extensive form game is a game of perfect recall.  If it is
not, then the resulting behavior profile is unpredictable, and may not
be a valid profile.

\vspace{12pt} \noindent
\textbf{See also:} 
\helpref{\texttt{IsPerfectRecall}}{PrimIsPerfectRecall},
\helpref{\texttt{Mixed}}{PrimMixed}.

\latexignore{\hrule}

\begin{verbatim}
Behav[support->EFSUPPORT] =: BEHAV 
\end{verbatim}

\noindent
Returns a behavior strategy profile with equal
probabilities for all actions in \verb+support+ in the same information set. 

\vspace{12pt} \noindent
\textbf{See also:} \helpref{\texttt{Centroid}}{ExtCentroid},
\helpref{\texttt{Mixed}}{PrimMixed}.

%----------

\section*{Belief}\label{PrimBelief}
\index{Belief (GCL primitive function)}
\begin{verbatim}
Belief[profile->BEHAV, node->NODE] =: NUMBER 
\end{verbatim}

\noindent
Returns the probability of being at \verb+node+, conditional on the
player who chooses at \verb+node+ knowing she is in \verb+node+'s
information set, assuming all players follow \verb+profile+.  The null
value is returned if the belief value is not well-defined, or if
\verb+node+ is terminal.  It is an error if \verb+profile+ and \verb+node+
are not from the same extensive form game.

\vspace{12pt} \noindent
\textbf{See also:}
\helpref{\texttt{ActionValue}}{PrimActionValue},
\helpref{\texttt{Beliefs}}{ExtBeliefs},
\helpref{\texttt{InfosetProb}}{PrimInfosetProb},
\helpref{\texttt{NodeValue}}{PrimNodeValue},
\helpref{\texttt{RealizProb}}{PrimRealizProb}.

%--C--

\section*{Chance}\label{PrimChance}
\index{Chance (GCL primitive function)}
\begin{verbatim}
Chance[efg->EFG] =: EFPLAYER 
\end{verbatim}

\noindent
Returns the chance, or nature, player defined on \verb+efg+.  Each
extensive form has exactly one chance player predefined, and it is not
possible to define any additional chance players. 

%----------

\section*{ChanceProb}\label{PrimChanceProb}
\index{ChanceProb (GCL primitive function)}
\begin{verbatim}
ChanceProb[action->ACTION] =: NUMBER 
\end{verbatim}

\noindent
Returns the probability of \verb+action+ being chosen at its information
set by the chance player.  It is an error if \verb+action+ is not an action
which is chosen by the chance player.

\seealso \funcxref{SetChanceProbs}{PrimSetChanceProbs}.

%----------

\section*{Children}\label{PrimChildren}
\index{Children (GCL primitive function)}
\begin{verbatim} 
Children[node->NODE] =: LIST(NODE) 
\end{verbatim}

\noindent
Returns the list of children of \verb+node+.

\seealso \funcxref{Parent}{PrimParent}.

%----------

\section*{Clear}\label{PrimClear}
\index{Clear (GCL primitive function)}
\begin{verbatim}
Clear[] =: BOOLEAN 
\end{verbatim}

\noindent
Unassigns all variables defined in the current scope.  Returns \verb+True+.

\seealso \funcxref{Assign}{PrimAssign}, \funcxref{UnAssign}{PrimUnAssign}.

%----------

\section*{Comment}\label{PrimComment}
\index{Comment (GCL primitive function)}
\begin{verbatim}
Comment[efg->EFG] =: TEXT
Comment[nfg->NFG] =: TEXT
\end{verbatim}

\noindent
Returns the comment associated with the game.

\seealso \funcxref{SetComment}{PrimSetComment}.

%----------

\section*{CompressEfg}\label{PrimCompressEfg}
\index{CompressEfg (GCL primitive function)}
\begin{verbatim}
CompressEfg[support->EFSUPPORT] =: EFG 
\end{verbatim}

\noindent
Creates a copy of the extensive form game on which \verb+support+ is
defined, where all actions not present in \verb+support+ have been
removed.

%----------

\section*{CompressNfg}\label{PrimCompressNfg}
\index{CompressNfg (GCL primitive function)}
\begin{verbatim}
CompressNfg[support->NFSUPPORT] =: NFG 
\end{verbatim}

\noindent
Creates a copy of the normal form game on which \verb+support+ is
defined, where all strategies not present in \verb+support+ have been
removed.

%----------

\section*{Concat}\label{PrimConcat}
\index{Concat (GCL primitive function)}
\begin{verbatim}
Concat[x->NLIST(T), y->NLIST(T)] =: LIST(T) 
\end{verbatim}
\foralltypes

\noindent
Returns the concatenation of the lists \verb+x+ and \verb+y+.

\shortform \verb%x & y%.

%----------

\section*{Contains}\label{PrimContains}
\index{Contains (GCL primitive function)}
\begin{verbatim}
Contains[list->NLIST(T), x->T] =: BOOLEAN 
Contains[list->NLIST(T), x->LIST(T)] =: BOOLEAN 
\end{verbatim}
\foralltypes

\noindent
Returns \verb+True+ when the value \verb+x+ is contained in \verb+list+.

\seealso \funcxref{NthElement}{PrimNthElement}.

%----------

\section*{CopyTree}\label{PrimCopyTree}
\index{CopyTree (GCL primitive function)}
\begin{verbatim}
CopyTree[from->NODE, to->NODE] =: NODE 
\end{verbatim}

\noindent
Copies the subtree rooted at \verb+from+ to the terminal
node \verb+to+ in the same extensive form game.  The nodes in the
copied subtree belong to the same information sets as their counterparts in
the original subtree.  Returns the node \verb+to+.  It is an error if
\verb+from+ and \verb+to+ are not from the same extensive form game,
or if \verb+to+ is not a terminal node.  The function has no effect if
the copying operation would violate the currently marked subgame
structure.

\seealso \funcxref{MoveTree}{PrimMoveTree}.

%----------

\section*{Creator}\label{PrimCreator}
\index{Creator (GCL primitive function)}
\begin{verbatim}
Creator[profile->MIXED] =: TEXT
Creator[profile->BEHAV] =: TEXT
\end{verbatim}

\noindent
Returns the GCL function name (excluding the ``Solve'' suffix) of
the algorithm that was called to create the profile. For
BEHAV profiles, the string includes an indication of whether the
extensive or normal form version of the algorithm was used.  Thus,
\verb+Liap[EFG]+ and \verb+Liap[NFG]+ are used to identify the
extensive and normal form versions of the algorithm.  A profile
created by the user is identified by \verb+User+.  

%--D--

\section*{Date}\label{PrimDate}
\index{Date (GCL primitive function)}
\begin{verbatim}
Date[] =: TEXT 
\end{verbatim}

\noindent Returns the current date and time. 

%----------

\section*{DeleteAction}\label{PrimDeleteAction}
\index{DeleteAction (GCL primitive function)}
\begin{verbatim}
DeleteAction[action->ACTION] =: INFOSET 
\end{verbatim}

\noindent
Deletes \verb+action+ from its information set. 
As a consequence, the corresponding subtrees associated
with the action from each member of the information set are deleted.
Returns the information set to which \verb+action+ belonged.  It is an
error if \verb+action+ is the only action at its information set.

\seealso \funcxref{Actions}{PrimActions},
\funcxref{InsertAction}{PrimInsertAction}.

%----------

\section*{DeleteEmptyInfoset}\label{PrimDeleteEmptyInfoset}
\index{DeleteEmptyInfoset (GCL primitive function)}
\begin{verbatim}
DeleteEmptyInfoset[infoset->INFOSET] =: BOOLEAN 
\end{verbatim}

\noindent
Deletes \verb+infoset+ from its extensive form game.  An information set
may be deleted only when it has no members; otherwise, this function has
no effect.  Returns \verb+True+ when the information set was successfully
deleted.

\seealso \funcxref{Members}{PrimMembers},
\funcxref{NewInfoset}{PrimNewInfoset}.

%----------

\section*{DeleteMove}\label{PrimDeleteMove}
\index{DeleteMove (GCL primitive function)}
\begin{verbatim}
DeleteMove[node->NODE, keep->NODE] =: NODE 
\end{verbatim}

\noindent
Deletes \verb+node+ from its extensive form game.  The
subtree rooted in node \verb+keep+, which must be a child of
\verb+node+, is kept, and \verb+keep+ takes the place of \verb+node+ in
the tree.  All other subtrees descending from \verb+node+ are deleted.
The kept node \verb+keep+ is returned.  It is an error if \verb+keep+
is not a child of \verb+node+, or if \verb+keep+ and \verb+node+ are not
from the same extensive form game.

\seealso \funcxref{AddMove}{PrimAddMove}, 
\funcxref{DeleteTree}{PrimDeleteTree},
\funcxref{InsertMove}{PrimInsertMove}.

%----------

\section*{DeleteOutcome}\label{PrimDeleteOutcome}
\index{DeleteOutcome (GCL primitive function)}
\begin{verbatim}
DeleteOutcome[outcome->EFOUTCOME] =: LIST(NODE) 
\end{verbatim}

\noindent
Removes \verb+outcome+ from its extensive form game.  All nodes with
the specified outcome attached are reset to having no outcome
attached.  Returns the list of nodes to which the outcome was
attached.

\seealso \funcxref{NewOutcome}{PrimNewOutcome}.

\begin{verbatim}
DeleteOutcome[outcome->NFOUTCOME] =: BOOLEAN 
\end{verbatim}

\noindent
Removes \verb+outcome+ from its normal form game.  Returns \verb+True+.

\seealso \funcxref{NewOutcome}{PrimNewOutcome}.

%----------

\section*{DeleteTree}\label{PrimDeleteTree}
\index{DeleteTree (GCL primitive function)}
\begin{verbatim}
DeleteTree[node->NODE] =: NODE 
\end{verbatim}

\noindent
Deletes the subtree rooted at \verb+node+.  The
node then becomes a terminal node, which is returned.

\seealso \funcxref{DeleteMove}{PrimDeleteMove}.

%----------

\section*{Divide}\label{PrimDivide}
\index{Divide (GCL primitive function)}
\begin{verbatim}
Divide[x->NUMBER, y->NUMBER] =: NUMBER 
\end{verbatim}

\noindent Returns the quotient $x / y$. 

\shortform \verb+x / y+

\seealso \funcxref{IntegerDivide}{PrimIntegerDivide}.

%----------

\section*{Dot}\label{PrimDot}
\index{Dot (GCL primitive function)}
\begin{verbatim}
Dot[x->LIST(NUMBER), y->LIST(NUMBER)] =: NUMBER 
\end{verbatim}

\noindent
Returns the dot product of \verb+x+ and \verb+y+, where the lists are
treated as vectors.  It is an error to attempt to multiply two lists
of different lengths.

\shortform \verb%x . y%

%--E--

\section*{ElapsedTime}\label{PrimElapsedTime}
\index{ElapsedTime (GCL primitive function)}
\begin{verbatim}
ElapsedTime[] =: NUMBER 
\end{verbatim}

\noindent
If the system stopwatch is currently running, returns the
time elapsed since the stopwatch was started.  If the system stopwatch
is not running, returns the time elapsed during the last period during which
the stopwatch was running.

\seealso \funcxref{IsWatchRunning}{PrimIsWatchRunning},
\funcxref{StartWatch}{PrimStartWatch},
\funcxref{StopWatch}{PrimStopWatch}.

%----------

\section*{EnumMixedSolve}\label{PrimEnumMixedSolve}
\index{EnumMixedSolve (GCL primitive function)}
\begin{verbatim}
EnumMixedSolve[support->NFSUPPORT, {stopAfter->0}, 
               {precision->Float}, {nPivots<->0}, 
               {time<->0.000000}, {traceFile<->(Output)}, 
               {traceLevel->0}, {cliques->False}] =: LIST(MIXED) 
EnumMixedSolve[support->EFSUPPORT, {asNfg->False}, 
               {stopAfter->0}, {precision->Float}, 
               {nPivots<->0}, {time<->0.000000}, 
               {traceFile<->(Output)}, {traceLevel->0},
               {cliques->False}] =: LIST(BEHAV) 
\end{verbatim}

\noindent
Returns the extreme points of the set of all Nash equilibria (pure or
mixed) for a two person game using \verb+support+.

The following optional parameters may be used to modify the behavior
of the algorithm:
\begin{itemize}
\item
\textbf{asNfg:} By default, this is \verb+False+.  If it is specified to be
\verb+True+, the extensive form game is solved by recursively converting
its marked subgames into normal form, solving, and reconstructing the
solution as a behavior profile.  {\it Note that currently this algorithm
is only supported on the normal form, so this parameter
must always be specified and {\tt True}.} 
\item
\textbf{stopAfter:} By default, all equilibria are found.  This parameter may
be used to specify a maximum number of equilibria to be found.
\item
\textbf{precision:} Determines the precision of the computation. Default is
floating point precision (\verb+Float+). 
\item
\textbf{nPivots:} Returns the number of pivots done by the
algorithm.
\item
\textbf{time:} Returns the time elapsed during the execution
of the algorithm.
\item
\textbf{traceFile:} A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
\textbf{traceLevel:} An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no output
at all.
\item
\textbf{cliques:} If true, then the connected components and their maximal
cliques are computed.  The output is printed to the console.
\end{itemize}

\seealso \funcxref{EnumPureSolve}{PrimEnumPureSolve}.

%----------

\section*{EnumPureSolve}\label{PrimEnumPureSolve}
\index{EnumPureSolve (GCL primitive function)}

\begin{verbatim}
EnumPureSolve[support->NFSUPPORT, {stopAfter->0}, 
              {time<->0.000000}, {traceFile<->(Output)},
              {traceLevel->0}] =: LIST(MIXED) 
EnumPureSolve[support->EFSUPPORT, {asNfg->False}, 
              {stopAfter->0}, {precision->Float}, 
              {time<->0.000000}, {traceFile<->(Output)}, 
              {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}

\noindent
Returns all pure strategy Nash equilibria of a game using the given
\verb+support+.  The behavior
of the algorithm may be modified by the following optional parameters:
\begin{itemize}
\item
\textbf{asNfg:} By default, this is \verb+False+.  If it is specified to be
\verb+True+, the extensive form game is solved by recursively converting
its marked subgames into normal form, solving, and reconstructing the
solution as a behavior profile.
\item
\textbf{stopAfter:} By default, all equilibria are found.  This parameter may
be used to specify a maximum number of equilibria to be found.
\item
\textbf{precision:} Determines the precision of the computation. Default is
floating point precision (\verb+Float+). 
\item
\textbf{time:} Returns the time elapsed during the execution
of the algorithm.
\item
\textbf{traceFile:} A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
\textbf{traceLevel:} An integer specifying the level of detail in logging.  Higher
integers correspond to more detail; zero corresponds to no output at all.
\end{itemize}

\seealso \funcxref{EnumMixedSolve}{PrimEnumMixedSolve}.

%----------

\section*{Equal}\label{PrimEqual}
\index{Equal (GCL primitive function)}
\begin{verbatim}
Equal[x->T*, y->T*] =: BOOLEAN
\end{verbatim}
\foralltypes

\noindent
Returns \verb+True+ when \verb+x+ and \verb+y+ are equal.  For games,
\verb+x+ and \verb+y+ are considered equal when they refer to the same
game (but not if they refer to two different games with exactly the
same structure, payoffs, and so forth).  A null value is considered equal
to the null value, but is not equal to any non-null value.

\shortform \verb+x = y+.

\seealso \funcxref{NotEqual}{PrimNotEqual}.

%----------

\section*{ExePath}\label{PrimExePath}
\index{ExePath (GCL primitive function)}
\begin{verbatim}
ExePath[{file->True}, {path->True}] =: TEXT 
\end{verbatim}

\noindent
Returns the path of the GCL executable. 
\begin{itemize}
\item [file:] Returns the file name.  Default is True.  
\item [path:] Returns the path.  Default is True. 
\end{itemize}

\seealso \funcxref{GetPath}{PrimGetPath}.

%----------

\section*{Exp}\label{PrimExp}
\index{Exp (GCL primitive function)}
\texttt{Exp[x->\popref{NUMBER}{DatatypeNUMBER}] =: \popref{NUMBER}{DatatypeNUMBER}} 

\description{Returns the value of the function ${\rm e}^{x}$.}

\note Result is returned in \verb+Float+ precision, regardless
of the precision of \verb+x+.

\seealso \funcxref{Log}{PrimLog}, \funcxref{Power}{PrimPower}.

%--F--

\section*{Filter}\label{PrimFilter}
\index{Filter (GCL primitive function)}
\begin{verbatim}
Filter[x->NLIST(T*), y->NLIST(BOOLEAN)] =: LIST(T)
\end{verbatim}
\foralltypes

\noindent
Returns a list with the same dimension structure as \verb+list+, with the
elements for which the corresponding elements of \verb+by+ are \verb+False+
removed.  It is an error if \verb+x+ and \verb+y+ do not have the same
dimensionality.

\seealso \funcxref{Sort}{PrimSort}.

%----------

\section*{Flatten}\label{PrimFlatten}
\index{Flatten (GCL primitive function)}
\begin{verbatim}
Flatten[x->NLIST(T*), {levels->0}] =: LIST(T) 
\end{verbatim}
\foralltypes

\noindent
Returns a list with the same elements as \verb+x+, with the nesting
structure flattened.  By default, all levels are flattened, returning
a one-dimensional list; the optional parameter \verb+levels+ may be
used to limit the flattening to the topmost \verb+levels+.

%----------

\section*{Float}\label{PrimFloat}
\index{Float (GCL primitive function)}
\begin{verbatim}
Float[x->NUMBER] =: NUMBER
\end{verbatim}

\noindent
Converts the internal representation of \verb+x+ to floating point
precision.

\seealso \funcxref{Rational}{PrimRational}.

%----------

\section*{For}\label{PrimFor}
\index{For (GCL primitive function)}
\begin{verbatim}
For[statement-list, boolean-expression, 
    statement-list, statement-list]
\end{verbatim}

\noindent
Defines a piece of code to be executed repeatedly.  See the section
on control structures for complete information.

\note Special function.  Not listable; arguments are not GCL
data types; not documented in \verb+Help+ or \verb+Manual+.  

\seealso \funcxref{While}{PrimWhile}.

%----------

\section*{Format}\label{PrimFormat}
\index{Format (GCL primitive function)}
\begin{verbatim}
Format[x->NUMBER, {width<->0}, {decimals<->6}, {expmode<->False}] =: NUMBER 
\end{verbatim}

\noindent
Sets the formatting style for output of NUMBER data types on output streams.
\begin{itemize}
\item \textbf{width:} The width for a numeric field.  If the width of the
data is greater than \verb+width+, the width is overridden.  (The
default is 0.)
\item \textbf{decimals:} The number of decimal places shown for floating point
numbers.
\item \textbf{expmode:} If \verb+True+, floating point numbers are printed in
exponential format.
\end{itemize}

\seealso \funcxref{ListFormat}{PrimListFormat},
\funcxref{Write}{PrimWrite}.

\latexignore{\hrule}

\begin{verbatim}
Format[x->TEXT, {quote<->False}] =: TEXT 
\end{verbatim}

\noindent
Sets the formatting style for output of text on output streams.
\begin{itemize}
\item \textbf{quote:} Whether opening and closing quotation marks are
written.  The default is \verb+True+.  
\end{itemize}

\seealso \funcxref{ListFormat}{PrimListFormat},
\funcxref{Write}{PrimWrite}.

\latexignore{\hrule}

\begin{verbatim}
Format[x->MIXED, {info<->False}, {names<->False}] =: MIXED
Format[x->BEHAV, {info<->False}, {names<->False}] =: BEHAV
\end{verbatim}

\noindent
Sets the formatting style for output of solution types on output streams.
\begin{itemize}
\item \textbf{info:} The amount of information to be displayed.  If \verb+True+,
displays all of the information about the solution.  If \verb+False+,
only the strategy or action probabilities are displayed.
\item \textbf{names:} If \verb+True+, the profiles are printed in a sparse format,
with only positive-probability strategy or action profiles displayed, tagged
by their strategy or action labels.  If \verb+False+, the whole vector
(including zeroes) is printed, without any labels.
\end{itemize}

\seealso \funcxref{ListFormat}{PrimListFormat},
\funcxref{Write}{PrimWrite}.

\latexignore{\hrule}

\begin{verbatim}
Format[x->EFG, {decimals<->6}] =: EFG
Format[x->NFG, {decimals<->6}] =: NFG
\end{verbatim}

\noindent
Sets the formatting style for .efg and .nfg files.
\begin{itemize}
\item \textbf{nDecimals:} The number of decimal places to use in representing
floating-point numbers.
\end{itemize}

\seealso \funcxref{SaveEfg}{PrimSaveEfg},
\funcxref{SaveNfg}{PrimSaveNfg}.

%--G--

\section*{Game}\label{PrimGame}
\index{Game (GCL primitive function)}
\texttt{Game[player->\popref{NFPLAYER}{DatatypeNFPLAYER}] =: \popref{NFG}{DatatypeNFG}} \\
\texttt{Game[strategy->\popref{STRATEGY}{DatatypeSTRATEGY}] =: \popref{NFG}{DatatypeNFG}} \\ 
\texttt{Game[outcome->\popref{NFOUTCOME}{DatatypeNFOUTCOME}] =: \popref{NFG}{DatatypeNFG}} \\
\texttt{Game[player->\popref{EFPLAYER}{DatatypeEFPLAYER}] =: \popref{EFG}{DatatypeEFG}} \\ 
\texttt{Game[node->\popref{NODE}{DatatypeNODE}] =: \popref{EFG}{DatatypeEFG}} \\ 
\texttt{Game[outcome->\popref{EFOUTCOME}{DatatypeEFOUTCOME}] =: \popref{EFG}{DatatypeEFG}} \\ 
\texttt{Game[infoset->\popref{INFOSET}{DatatypeINFOSET}] =: \popref{EFG}{DatatypeEFG}} \\ 
\texttt{Game[profile->\popref{MIXED}{DatatypeMIXED}] =: \popref{NFG}{DatatypeNFG}} \\
\texttt{Game[profile->\popref{BEHAV}{DatatypeBEHAV}] =: \popref{EFG}{DatatypeEFG}} \\ 
\texttt{Game[support->\popref{NFSUPPORT}{DatatypeNFSUPPORT}] =: \popref{NFG}{DatatypeNFG}} \\ 
\texttt{Game[support->\popref{EFSUPPORT}{DatatypeEFSUPPORT}] =: \popref{EFG}{DatatypeEFG}} \\ 
\texttt{Game[support->\popref{EFBASIS}{DatatypeEFBASIS}] =: \popref{EFG}{DatatypeEFG}} 

\description{Returns the game on which the parameter is defined.}

%----------

\section*{GetEnv}\label{PrimGetEnv}
\index{GetEnv (GCL primitive function)}
\texttt{GetEnv[name->\popref{TEXT}{DatatypeTEXT}] =: \popref{TEXT}{DatatypeTEXT}} 

\description{Returns the string associated with environment variable
\texttt{name}.}

\seealso \funcxref{SetEnv}{PrimSetEnv},
\funcxref{UnSetEnv}{PrimUnSetEnv}.

%----------

\section*{GetFormat}\label{PrimGetFormat}
\index{GetFormat (GCL primitive function)}
\texttt{GetFormat[x->\popref{NUMBER}{DatatypeNUMBER}, \{width<->0\},} \\
\texttt{\hspace*{60pt}\{decimals<->6\}, \{expmode<->False\}] =: \popref{NUMBER}{DatatypeNUMBER}} 

\description{%
Gets the current formatting style for output of \texttt{NUMBER} data types
on output streams.  
\begin{itemize}
\item \textbf{width:} The width for a numeric field.  
\item \textbf{decimals:} The number of decimal places shown for floating point
numbers.
\item \textbf{expmode:} Whether floating point numbers are printed in
exponential format.
\end{itemize} }

\seealso \funcxref{Format}{PrimFormat}.

\newsignature
\texttt{GetFormat[x->\popref{TEXT}{DatatypeTEXT}, \{quote<->False\}] =: \popref{TEXT}{DatatypeTEXT}}

\description{Gets the current formatting style for output of text on output
streams.
\begin{itemize}
\item \textbf{quote:} Whether opening and closing quotation marks are
written. 
\end{itemize} }

\seealso \funcxref{Format}{PrimFormat}.

\newsignature
\texttt{GetFormat[x->\popref{MIXED}{DatatypeMIXED}, \{info<->False\}, \{names<->False\}] =: \popref{MIXED}{DatatypeMIXED}} \\
\texttt{GetFormat[x->\popref{BEHAV}{DatatypeBEHAV}, \{info<->False\}, \{names<->False\}] =: \popref{BEHAV}{DatatypeBEHAV}}

\description{Gets the current formatting style for output of solution types on
output streams.  
\begin{itemize}
\item \textbf{info:} Displays all information known about solution if \texttt{True}. If \texttt{False}, just displays strategy or action probabilities.  
\item \textbf{names:} If \texttt{True}, the profiles are printed in a sparse format,
with only positive-probability strategy or action profiles displayed, tagged
by their strategy or action labels.  If \texttt{False}, the whole vector
(including zeroes) is printed, without any labels.
\end{itemize} }

\seealso \funcxref{Format}{PrimFormat}.

\newsignature
\texttt{GetFormat[x->\popref{EFG}{DatatypeEFG}, \{nDecimals<->6\}] =: \popref{EFG}{DatatypeEFG}} \\
\texttt{GetFormat[x->\popref{NFG}{DatatypeNFG}, \{nDecimals<->6\}] =: \popref{NFG}{DatatypeNFG}}

\description{Sets the formatting style for .efg and .nfg files.
\begin{itemize}
\item \textbf{nDecimals:} The number of decimal places to use in representing
floating-point numbers.
\end{itemize}}

\seealso \funcxref{Format}{PrimFormat}, 
\funcxref{SaveEfg}{PrimSaveEfg}, \funcxref{SaveNfg}{PrimSaveNfg}.

%----------

\section*{GetListFormat}\label{PrimGetListFormat}
\index{GetListFormat (GCL primitive function)}
\begin{verbatim}
GetListFormat[{braces<->True}, {commas<->True},
              {lf<->2}, {indent<->2}] =: BOOLEAN 
\end{verbatim}

\noindent
Gets the current formatting style for output of lists on output streams.
\begin{itemize}
\item \textbf{braces:} If \verb+True+, lists are delimited by braces.
\item \textbf{commas:} If \verb+True+, elements are delimited by commas.
\item \textbf{lf:} Number of levels of list that are displayed with a line feed.
\item \textbf{indent:} Number of spaces to indent each level of a list.
\end{itemize}

\seealso \funcxref{Format}{PrimFormat}, \funcxref{Write}{PrimWrite}.

%----------

\section*{GetPath}\label{PrimGetPath}
\index{GetPath (GCL primitive function)}
\begin{verbatim}
GetPath[] =: TEXT 
\end{verbatim}

\noindent
Returns the path to the file in which the command is included.  Can be
used to identify \verb+Include[]+ files. 

\note Special function.  Not listable; not documented in
\verb+Help+ or \verb+Manual+.

\seealso \funcxref{ExePath}{PrimExePath},
\funcxref{Include}{PrimInclude}.

%----------

\section*{Greater}\label{PrimGreater}
\index{Greater (GCL primitive function)}
\begin{verbatim}
Greater[x->NUMBER, y->NUMBER] =: BOOLEAN 
\end{verbatim}

\noindent
Returns \verb+True+ when \verb+x+ is (strictly) greater than \verb+y+.

\shortform \verb+x > y+

\seealso \funcxref{GreaterEqual}{PrimGreaterEqual},
\funcxref{Less}{PrimLess}, \funcxref{LessEqual}{PrimLessEqual}.

\begin{verbatim}
Greater[x->TEXT, y->TEXT] =: BOOLEAN 
\end{verbatim}

\noindent
Returns \verb+True+ when the string \verb+x+ is lexicographically (strictly)
greater than the string \verb+y+, using the native character set of the 
machine.

\shortform \verb+x > y+

\seealso \funcxref{GreaterEqual}{PrimGreaterEqual},
\funcxref{Less}{PrimLess}, \funcxref{LessEqual}{PrimLessEqual}.

%----------

\section*{GreaterEqual}\label{PrimGreaterEqual}
\index{GreaterEqual (GCL primitive function)}
\begin{verbatim}
GreaterEqual[x->NUMBER, y->NUMBER] =: BOOLEAN 
\end{verbatim}

%\marginpar{Precision issues}
\noindent
Returns \verb+True+ when \verb+x+ is at least as large as \verb+y+.

\shortform \verb+x >= y+

\seealso \funcxref{Greater}{PrimGreater},
\funcxref{Less}{PrimLess}, \funcxref{LessEqual}{PrimLessEqual}.

\begin{verbatim}
GreaterEqual[x->TEXT, y->TEXT] =: BOOLEAN 
\end{verbatim}

\noindent
Returns \verb+True+ when the string \verb+x+ is lexicographically greater than
or equal to the string \verb+y+, using the native character set of the
machine.

\shortform \verb+x >= y+

\seealso \funcxref{Greater}{PrimGreater},
\funcxref{Less}{PrimLess}, \funcxref{LessEqual}{PrimLessEqual}.

%--H--

\section*{Help}\label{PrimHelp}
\index{Help (GCL primitive function)}
\begin{verbatim}
Help[x->TEXT, {udf->True}, {bif->True}] =: LIST(TEXT) 
\end{verbatim}

\noindent
Returns a list of all function names or function prototypes matching
\verb+x+.  If \verb+x+ is an exact match to a function name, a list of
corresponding function prototypes is returned.  \verb+x+ can also
contain the regular-expression style wildcards \verb+*+ and \verb+?+.
In this case, if there is not an exact match, a list of function names
matching \verb+x+ is returned.  The parameter \verb+udf+ determines if
user defined functions are listed, and \verb+bif+ determines if built
in functions are listed.  Both of these parameters are \verb+True+ by
default.

\seealso \funcxref{HelpVars}{PrimHelpVars},
\funcxref{Manual}{PrimManual}.

%----------

\section*{HelpVars}\label{PrimHelpVars}
\index{HelpVars (GCL primitive function)}
\begin{verbatim}
HelpVars[x->TEXT] =: LIST(TEXT) 
\end{verbatim}

\noindent
Returns a list of all variables matching \verb+x+.  \verb+x+ can
contain regular-expression style wildcards \verb+*+ and \verb+?+.  In
this case, if there is not an exact match, a list of variables
matching \verb+x+ is returned.

\seealso \funcxref{Help}{PrimHelp}.

%--I--

\section*{If}\label{PrimIf}
\index{If (GCL primitive function)}
\begin{verbatim}
If[boolean-expression, statement-list]
If[boolean-expression, statement-list, statement-list]
\end{verbatim}
  
\noindent
Defines a block of statements to be executed under certain conditions.
See the section on control structures for complete information. 

\note Special function.  Not listable; arguments are not GCL
data types; not documented in \verb+Help+ or \verb+Manual+.  

%----------

\section*{Include}\label{PrimInclude}
\index{Include (GCL primitive function)}
\begin{verbatim}
Include[file->TEXT]
\end{verbatim}

\noindent
Includes the commands in the specified file as commands
in the running GCL program.  The program treats the command as if it
were replaced by the contents of the file.  \verb+Include+ may only be used
at the top level, that is, it cannot be used inside of \verb+NewFunction+
or flow control structures.

\note Special function:  Not listable; cannot be called in a
user defined function; not documented in \verb+Help+ or \verb+Manual+. 

%----------

\section*{Index}\label{PrimIndex}
\index{Index (GCL primitive function)}
\begin{verbatim}
Index[list->NLIST(T), x->T] =: LIST(INTEGER) 
Index[list->NLIST(T), x->LIST(T)] =: LIST(INTEGER) 
\end{verbatim}
\foralltypes

\noindent
Returns the list of indices in \verb+list+ where \verb+x+ appears.

%----------

\section*{Infoset}\label{PrimInfoset}
\index{Infoset (GCL primitive function)}
\begin{verbatim}
Infoset[action->ACTION*] =: INFOSET 
\end{verbatim}

\noindent
Returns the information set to which \verb+action+ belongs.  The null
action is assumed to belong to the null information set.

\seealso \funcxref{Actions}{PrimActions}.

\newsignature

\begin{verbatim}
Infoset[node->NODE*] =: INFOSET 
\end{verbatim}

\noindent
Returns the information set to which \verb+node+ belongs.  All
nonterminal nodes belong to an information set.  By convention,
terminal nodes and the null node, belong to the null information set.

\seealso \funcxref{Members}{PrimMembers}.

%----------

\section*{InfosetProb}\label{PrimInfosetProb}
\index{InfosetProb (GCL primitive function)}
\begin{verbatim}
InfosetProb[profile->BEHAV, infoset->INFOSET*] =: NUMBER 
\end{verbatim}

\noindent
Returns the probability of reaching \verb+infoset+ when all players
follow \verb+profile+.  The probability of reaching the null information
set is defined to be null.  It is an error if \verb+profile+ and
\verb+infoset+ are not defined on the same extensive form game.

\seealso
\funcxref{ActionValue}{PrimActionValue},
\funcxref{Belief}{PrimBelief},
\funcxref{NodeValue}{PrimNodeValue},
\funcxref{RealizProb}{PrimRealizProb}.

%----------

\section*{InfosetValue}\label{PrimInfosetValue}
\index{InfosetValue (GCL primitive function)}
\begin{verbatim}
InfosetValue[profile->BEHAV, infoset->INFOSET*] =: NUMBER 
\end{verbatim}

\noindent
Returns the value to the controlling player of reaching \verb+infoset+
when all players follow \verb+profile+.  It is an error if
\verb+profile+ and \verb+infoset+ are not defined on the same
extensive form game.

\seealso
\funcxref{ActionValue}{PrimActionValue},
\funcxref{Belief}{PrimBelief},
\funcxref{NodeValue}{PrimNodeValue},
\funcxref{RealizProb}{PrimRealizProb}.

%----------

\section*{Infosets}\label{PrimInfosets}
\index{Infosets (GCL primitive function)}
\begin{verbatim}
Infosets[player->EFPLAYER] =: LIST(INFOSET) 
\end{verbatim}

\noindent
Returns the list of information sets at which \verb+player+ has the
decision.

\seealso \funcxref{Player}{PrimPlayer}.

%----------

\section*{Input}\label{PrimInput}
\index{Input (GCL primitive function)}
\begin{verbatim}
Input[file->TEXT] =: INPUT 
\end{verbatim}

\noindent
Opens a new input stream for reading from the file \verb+text+.  An
error occurs if the file is not able to be opened.

\seealso \funcxref{Output}{PrimOutput}, \funcxref{Read}{PrimRead}.

%----------

%\item\lex{Insert}
%\protect \large \begin{verbatim}
%Insert[list<->NLIST(T*), x->T*, {n->INTEGER}] =: LIST(T)
%Insert[list<->NLIST(T*), x->NLIST(T*), {n->INTEGER}] =: LIST(T) 
%\end{verbatim}\normalsize

%{\it for all types} {\tt T}
%\bd
%Inserts the element \verb+x+ into \verb+list+.  If \verb+n+ is
%unspecified, \verb+x+ is appended to \verb+list+; otherwise, \verb+x+
%is inserted as the \verb+n+th element.  It is an error if \verb+n+ is
%nonpositive, or if \verb+n+ is greater than the length of \verb+list+.
%\item [See also:] \verb+Remove+.
%\ed

%----------

\section*{InsertAction}\label{PrimInsertAction}
\index{InsertAction (GCL primitive function)}
\begin{verbatim}
InsertAction[infoset->INFOSET, at->ACTION] =: ACTION 
InsertAction[infoset->INFOSET] =: ACTION 
\end{verbatim}

\noindent
Inserts a new action into \verb+infoset+ before the action \verb+at+.
If \verb+at+ is not specified, the new action is appended to
\verb+infoset+'s actions.  The corresponding new branch is created for
each node belonging to \verb+infoset+.  Returns the newly created
action.

\seealso \funcxref{Actions}{PrimActions},
\funcxref{DeleteAction}{PrimDeleteAction}.

%----------

\section*{InsertMove}\label{PrimInsertMove}
\index{InsertMove (GCL primitive function)}
\begin{verbatim}
InsertMove[infoset->INFOSET, node->NODE] =: NODE 
\end{verbatim}

\noindent
Inserts a new node in the tree at the location of \verb+node+.  The
new node is made a member of \verb+infoset+, and the
corresponding number of branches are created from the new node.  \verb+node+
becomes the first child of the new node.  Returns the new node.

\seealso \funcxref{AddMove}{PrimAddMove},
\funcxref{DeleteMove}{PrimDeleteMove},
\funcxref{NewInfoset}{PrimNewInfoset}.

%----------

\section*{Integer}\label{PrimInteger}
\index{Integer (GCL primitive function)}
\begin{verbatim}
Integer[x->NUMBER] =: INTEGER 
\end{verbatim}

\noindent
Converts \verb+x+ into an integer value by truncation.

%----------

\section*{IntegerDivide}\label{PrimIntegerDivide}
\index{IntegerDivide (GCL primitive function)}
\begin{verbatim}
IntegerDivide[x->INTEGER, y->INTEGER] =: INTEGER 
\end{verbatim}

\noindent
Returns the quotient $x / y$, rounded to the next integer
towards zero.  It is an error to attempt to divide by zero.

\shortform \verb%x DIV y%

\seealso \funcxref{Divide}{PrimDivide}, \funcxref{Modulus}{PrimModulus}.

%----------

\section*{Inverse}\label{PrimInverse}
\index{Inverse (GCL primitive function)}
\begin{verbatim}
Inverse[x->LIST(LIST(NUMBER))] =: LIST(LIST(NUMBER))
\end{verbatim} 

\noindent
Returns the inverse of the matrix \verb+x+.  It is an error if the
matrix is not square or is singular.

%----------

\section*{IsConsistent}\label{PrimIsConsistent}
\index{IsConsistent (GCL primitive function)}
\begin{verbatim}
IsConsistent[basis->EFBASIS] =: BOOLEAN
\end{verbatim}

\noindent
Returns true if \verb+basis+ is a consistent basis -- i. e., if it
is a basis which could be a support for a sequential
equilibrium (\cite{KrepsWilson:1982}).

%----------

\section*{IsConstSum}\label{PrimIsConstSum}
\index{IsConstSum (GCL primitive fucntion)}
\begin{verbatim}
IsConstSum[nfg->NFG] =: BOOLEAN 
IsConstSum[efg->EFG] =: BOOLEAN 
\end{verbatim}

\noindent
Returns \verb+True+ when the game \verb+efg+ or \verb+nfg+ is constant sum.

%----------

\section*{IsDefined}\label{PrimIsDefined}
\index{IsDefined (GCL primitive function)}
\begin{verbatim}
IsDefined[x->T] =: BOOLEAN
\end{verbatim}
\foralltypes

\noindent
Returns \verb+True+ if \verb+x+ has been defined.  Useful for testing
the existence of static variables.

%----------

\section*{IsDominated}\label{PrimIsDominated}
\index{IsDominated (GCL primitive function)}
\begin{verbatim}
IsDominated[strategy->STRATEGY, support->NFSUPPORT, {strong->False}, 
            {mixed->False}, {precision->Rational}, {time<->0.000000}, 
            {traceFile<->(Output)}, {traceLevel->0}] =: BOOLEAN
IsDominated[profile->MIXED, {strong->False}, {mixed->False}, 
            {time<->0.000000}, {traceFile<->(Output)}, 
            {traceLevel->0}] =: BOOLEAN,
IsDominated[action->ACTION, support->EFSUPPORT, {strong->False}, 
            {conditional->False}, {time<->0.000000}, {traceFile<->(Output)}, 
            {traceLevel->0}] =: BOOLEAN }
\end{verbatim}

\noindent
Determines if the \verb+strategy+ or \verb+action+ is dominated in
\verb+support+, or if the \verb+profile+ is dominated in its
support. The following optional parameters may be specified to modify
the behavior of the elimination:
\begin{itemize}
\item \textbf{strong:} By default, determines if the strategy or action is
weakly dominated.  By specifying \verb+True+, strong dominance is
used.
\item \textbf{mixed:} By default, only checks for domination by pure
strategies or actions.  Specified \verb+True+, to check for domination
by mixtures over other strategies.  Note that mixed domination is only
implemented for normal form games (i.e, for the first function
prototype above).
\item \textbf{conditional:} If this is true, checks for conditional domination.
\item \textbf{precision:} Default precision is Rational.  Note that the precision
parameter is only applicable for mixed domination.  Pure strategy
domination always uses Rational precision.  For the \verb+profile+ version of the 
function, the precision used is the precision of \verb+profile+.  
\item \textbf{time:} Returns the time consumed by the computation.
\item \textbf{traceFile:} A file containing a log of more detailed information
on the elimination process.  By default, no logging is done.
\item \textbf{traceLevel:} An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no output
at all.
\end{itemize}

%----------

\section*{IsEof}\label{PrimIsEof}
\index{IsEof (GCL primitive function)}
\begin{verbatim}
IsEof[input->INPUT] =: BOOLEAN
\end{verbatim}

\noindent
Returns \verb+True+ when the input stream \verb+Input+ has reached the
end of file.

\seealso \funcxref{Read}{PrimRead}.

%----------

\section*{IsList}\label{PrimIsList}
\index{IsList (GCL primitive function)}
\begin{verbatim}
IsList[x->T] =: BOOLEAN 
IsList[list->NLIST(T)] =: BOOLEAN 
\end{verbatim}
\foralltypes

\noindent
Returns \verb+True+ when \verb+x+ is a list or a nested list.

\seealso \funcxref{List}{PrimList}.

%----------

\section*{IsNash}\label{PrimIsNash}
\index{IsNash (GCL primitive function)}
\begin{verbatim}
IsNash[profile->BEHAV] =: BOOLEAN 
IsNash[profile->MIXED] =: BOOLEAN 
\end{verbatim}

\noindent
Returns \verb+True+ when \verb+profile+ is known by Gambit to be a
Nash equilibrium of the corresponding game, and \verb+False+ if
\verb+profile+ is known to not be Nash.  Otherwise, the return value
is \verb+Unknown+.  If \verb+profile+ is complete (probabilities sum
to one for every player, and every information set), then there is a
definitive test for Nash equilibrium.  However if the profile is
incomplete (i. e., it does not specify actions at off the equilibrium
path information sets), then it is possible that a profile (or set of
all completions of the profile) may be Nash, but is not known by
Gambit to be Nash.

%----------

\section*{IsNull}\label{PrimIsNull}
\index{IsNull (GCL primitive function)}
\begin{verbatim}
IsNull[x->T*] =: BOOLEAN 
\end{verbatim}
\foralltypes

\noindent
Returns \verb+True+ if x is a NULL object of type \verb+T+.  

%----------

\section*{IsPerfect}\label{PrimIsPerfect}
\index{IsPerfect (GCL primitive function)}
\begin{verbatim}
IsPerfect[profile->MIXED] =: BOOLEAN 
\end{verbatim}

\noindent
Returns \verb+True+ if \verb+profile+ is known by Gambit to be a
perfect Nash equilibrium, \verb+False+ if it is known to not be
perfect, and \verb+Unknown+ otherwise.  There is currently no
definitive test in Gambit for whether an arbitrary profile is perfect.
However some of the algorithms (notably \verb+LcpSolve+) will only
return perfect equilibria, which are marked as such.   

%----------

\section*{IsPerfectRecall}\label{PrimIsPerfectRecall}
\index{IsPerfectRecall (GCL primitive function)}
\begin{verbatim}
IsPerfectRecall[efg->EFG] =: BOOLEAN 
\end{verbatim}

\noindent
Returns \verb+True+ if \verb+efg+ is a game of perfect recall, and
\verb+False+ otherwise 

%----------

\section*{IsPredecessor}\label{PrimIsPredecessor}
\index{IsPredecessor (GCL primitive function)}
\begin{verbatim}
IsPredecessor[node->NODE, of->NODE] =: BOOLEAN 
\end{verbatim}

\noindent
Returns \verb+True+ when \verb+node+ is a predecessor
in the tree of the node \verb+of+.  A node is considered its own predecessor.

\seealso \funcxref{IsSuccessor}{PrimIsSuccessor}.

%----------

\section*{IsSequential}\label{PrimIsSequential}
\index{IsSequential (GCL primitive function)}
\begin{verbatim}
IsSequential[profile->BEHAV] =: BOOLEAN 
\end{verbatim}

\noindent
Returns \verb+True+ if \verb+profile+ is known by Gambit to be an
approximation to a sequential Nash equilibrium, \verb+False+ if it is
not, and \verb+Unknown+ if the answer is not known.  There is
currently no definitive test in Gambit for whether an arbitrary
profile is sequential.  However any Nash equilibrium of an extensive
form game which is computed via the \verb+LiapSolve+ or
\verb+QreSolve+ algorithms is sequential. 

%----------

\section*{IsSubgamePerfect}\label{PrimIsSubgamePerfect}
\index{IsSubgamePerfect (GCL primitive function)}
\begin{verbatim}
IsSubgamePerfect[profile->BEHAV] =: BOOLEAN 
\end{verbatim}

\noindent
Returns \verb+True+ if \verb+profile+ is known by Gambit to be a
subgame perfect Nash equilibrium, \verb+False+ if it is known not to
be a subgame perfect equilibrium, and \verb+Unknown+ otherwise.  There
is currently no definitive test in Gambit for whether an arbitrary
profile is subgame perfect.  However, any Nash equilibrium of an
extensive form game which is computed when all subgames are marked
will only return a subgame perfect equilibrium. 

%----------

\section*{IsSuccessor}\label{PrimIsSuccessor}
\index{IsSuccessor (GCL primitive function)}
\begin{verbatim}
IsSuccessor[node->NODE, from->NODE] =: BOOLEAN 
\end{verbatim}

\noindent
Returns \verb+True+ when \verb+node+ is a successor
in the tree of the node \verb+from+.  A node is considered its own successor.

\seealso \funcxref{IsPredecessor}{PrimIsPredecessor}.

%----------

\section*{IsWatchRunning}\label{PrimIsWatchRunning}
\index{IsWatchRunning (GCL primitive function)}
\begin{verbatim}
IsWatchRunning[] =: BOOLEAN 
\end{verbatim}

\noindent
Returns \verb+True+ when the system stopwatch is currently running.

\seealso \funcxref{ElapsedTime}{PrimElapsedTime},
\funcxref{StartWatch}{PrimStartWatch},
\funcxref{StopWatch}{PrimStopWatch}.

%--J--

%--K--

%--L--

\section*{LcpSolve}\label{PrimLcpSolve}
\index{LcpSolve (GCL primitive function)}
\begin{verbatim}
LcpSolve[support->NFSUPPORT, {stopAfter->1}, {precision->Float}, 
         {nPivots<->0}, {time<->0}, {traceFile<->(Output)}, 
         {traceLevel->0}] =: LIST(MIXED) 
LcpSolve[support->EFSUPPORT, {asNfg->False}, {stopAfter->1}, 
         {precision->Float}, {nPivots<->0}, {time<->0.000000}, 
         {traceFile<->(Output)}, {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}

\noindent
Solves the game as a linear complementarity problem, using the
Lemke-Howson algorithm for normal form games, and the
Koller-Megiddo-Stengel sequence form for extensive form games.  

The behavior of the algorithm may be modified by the following
optional parameters:
\begin{itemize}
\item
\textbf{asNfg:} By default, extensive forms are solved by the sequence form.
By setting this parameter to \verb+True+, each marked subgame of the extensive
form is converted to its corresponding reduced normal form, solved
via Lemke-Howson, and the mixed strategy solutions converted back into
behavior profiles.
\item
\textbf{stopAfter:} Specifies the maximum number of equilibria to find.  The
default is one. If set to zero then all equilibria reachable by the
algorithm will be found.
\item
\textbf{precision:} Determines the precision of the computation. Default is
floating point precision (\verb+Float+). 
\item
\textbf{nPivots:} Returns the total number of pivots. 
\item
\textbf{time:} Returns the elapsed time for the operation.
\item
\textbf{traceFile:} A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
\textbf{traceLevel:} An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no
logging at all.
\end{itemize}

\seealso \funcxref{LpSolve}{PrimLpSolve}.

%----------

\section*{Length}\label{PrimLength}
\index{Length (GCL primitive function)}
\begin{verbatim}
Length[list->LIST(T*)] =: INTEGER
\end{verbatim}
\foralltypes

\noindent
Returns the number of elements in \verb+list+.

\seealso \funcxref{NthElement}{PrimNthElement},
\funcxref{NumElements}{PrimNumElements}.

%----------

\section*{Less}\label{PrimLess}
\index{Less (GCL primitive function)}
\begin{verbatim}
Less[x->NUMBER, y->NUMBER] =: BOOLEAN 
\end{verbatim}

\noindent
Returns \verb+True+ when \verb+x+ is (strictly) less than \verb+y+.

\shortform \verb+x < y+

\seealso \funcxref{Greater}{PrimGreater},
\funcxref{GreaterEqual}{PrimGreaterEqual},
\funcxref{LessEqual}{PrimLessEqual}.

\newsignature

\begin{verbatim}
Less[x->TEXT, y->TEXT] =: BOOLEAN 
\end{verbatim}

\noindent
Returns \verb+True+ when the string \verb+x+ is lexicographically
(strictly) less than the string \verb+y+, using the native character
set of the machine.

\shortform \verb+x < y+

\seealso \funcxref{Greater}{PrimGreater},
\funcxref{GreaterEqual}{PrimGreaterEqual},
\funcxref{LessEqual}{PrimLessEqual}.

%----------

\section*{LessEqual}\label{PrimLessEqual}
\index{LessEqual (GCL primitive function)}
\begin{verbatim}
LessEqual[x->NUMBER, y->NUMBER] =: BOOLEAN 
\end{verbatim}

%\marginpar{Address precision issue}
\noindent
Returns \verb+True+ when \verb+x+ is no more than \verb+y+.

\shortform \verb+x <= y+

\seealso \funcxref{Greater}{PrimGreater},
\funcxref{GreaterEqual}{PrimGreaterEqual},
\funcxref{Less}{PrimLess}.

\newsignature

\begin{verbatim}
LessEqual[x->TEXT, y->TEXT] =: BOOLEAN 
\end{verbatim}

\noindent
Returns \verb+True+ when the string \verb+x+ is lexicographically less than
or equal to the string \verb+y+, using the native character set of the machine.

\shortform \verb+x <= y+

\seealso \funcxref{Greater}{PrimGreater},
\funcxref{GreaterEqual}{PrimGreaterEqual},
\funcxref{Less}{PrimLess}.

%----------

\section*{LiapSolve}\label{PrimLiapSolve}
\index{LiapSolve (GCL primitive function)}
\begin{verbatim}
LiapSolve[start->BEHAV, {asNfg->False}, {stopAfter->1}, 
          {nTries->10}, {accuracy->0.000000}, {time<->0}, 
          {nEvals<->0}, {traceFile<->(Output)}, 
          {traceLevel->0}] =: LIST(BEHAV)
LiapSolve[start->MIXED, {stopAfter->1}, {nTries->10}, 
          {accuracy->0.000000}, {time<->0}, {nEvals<->0}, 
          {traceFile<->(Output)}, {traceLevel->0}] =: LIST(MIXED)
\end{verbatim}

\noindent
Searches for a Nash equilibrium by minimizing a Lyapunov function
which is zero exactly at Nash equilibria.  The algorithm starts from
the initial starting point determined by the parameter \verb+start+.
The algorithm is not guaranteed to find a Nash equilibrium from any
fixed starting point.  The algorithm thus incorporates the capability
of restarting.  If a Nash equilibrium is not found, it will keep
searching from new randomly chosen starting points until a Nash
equilibrium has been found or the maximum number of tries (parameter
\verb+nTries+) is exceeded, whichever comes first.  The list of
solutions found is returned.

The behavior of the algorithm may be modified by specifying the following
optional parameters:
\begin{itemize}
\item
\textbf{asNfg:} By default, extensive forms are solved in the extensive form.
By setting this parameter to \verb+True+, each marked subgame of the
extensive form is converted to its corresponding reduced normal form game,
solved, and the overall behavior profile reconstructed from these
solutions.
\item
\textbf{nTries:} Sets the maximum number of attempts at finding an
equilibrium. Default is 10.
\item
\textbf{stopAfter:} Sets the number of equilibria to find.  Default is 1.
\item
\textbf{accuracy:} Resulting solutions are ``epsilon equilibria'' to at least
this accuracy.  I. e., no unilateral deviation by any player will
result in an improvement of more than the accuracy.  Default is
$1.0e-8$.
\item
\textbf{time:} Returns the elapsed time for the operation.
\item
\textbf{nEvals:} Returns the number of function evaluations for the operation.
\item
\textbf{traceFile:} A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
\textbf{traceLevel:} An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no output
at all.
\end{itemize}

%----------

\section*{LiapValue}\label{PrimLiapValue}
\index{LiapValue (GCL primitive function)}
\begin{verbatim}
LiapValue[profile->BEHAV] =: NUMBER 
LiapValue[profile->MIXED] =: NUMBER 
\end{verbatim} 

\noindent
Returns the Lyapunov function value for \verb+profile+.  This value is
zero exactly when the profile is a Nash equilibrium. 

%----------

\section*{List}\label{PrimList}
\index{List (GCL primitive function)}
\begin{verbatim}
List[x->T, {length->INTEGER}] =: LIST(T)
\end{verbatim}
\foralltypes

\noindent
Creates a new list of \verb+length+ elements, each equal to \verb+x+.
If \verb+length+ is unspecified, it defaults to 1.

\newsignature

\begin{verbatim}
List[x->NUMBER, {length->1}, {delta->0}] =: LIST(NUMBER) 
\end{verbatim}

\noindent
Creates an initialized list of \verb+length+ elements, whose $i^{th}$
entry is \verb%x + (i * delta)%.  If \verb+length+ is unspecified,
it defaults to 1; if \verb+delta+ is unspecified, it defaults to 0.

%----------

\section*{ListFormat}\label{PrimListFormat}
\index{ListFormat (GCL primitive function)}
\begin{verbatim}
ListFormat[{braces<->True}, {commas<->True},
           {lf<->2}, {indent<->2}] =: BOOLEAN
\end{verbatim}

\noindent
Sets the formatting style for output of lists on output streams.  The
parameters passed are set to the prior style settings on return.
\begin{itemize}
\item \textbf{braces:} If \verb+True+, lists are delimited by braces.
\item \textbf{commas:} If \verb+True+, elements are delimited by commas.
\item \textbf{lf:} Number of levels of list that are displayed with a line feed.
\item \textbf{indent:} Number of spaces to indent each level of a list.
\end{itemize}

\seealso \funcxref{Format}{PrimFormat}, \funcxref{Write}{PrimWrite}.

%----------

\section*{LoadEfg}\label{PrimLoadEfg}
\index{LoadEfg (GCL primitive function)}
\begin{verbatim}
LoadEfg[file->TEXT] =: EFG 
\end{verbatim}

\noindent
Loads an extensive form game from an external savefile.
It is an error if the file cannot be opened, or if the file does
not contain a valid extensive form savefile.

\seealso \funcxref{SaveEfg}{PrimSaveEfg}.

%----------

\section*{LoadNfg}\label{PrimLoadNfg}
\index{LoadNfg (GCL primitive function)}
\begin{verbatim}
LoadNfg[file->TEXT] =: NFG 
\end{verbatim}

\noindent
Loads a normal form game from an external savefile.
It is an error if the file cannot be opened, or if the file does not 
contain a valid normal form savefile.

\seealso \funcxref{SaveNfg}{PrimSaveNfg}.

%----------

\section*{Log}\label{PrimLog}
\index{Log (GCL primitive function)}
\begin{verbatim}
Log[x->NUMBER] =: NUMBER 
\end{verbatim}

\noindent
Computes the natural logarithm of \verb+x+.  It is an error if
\verb+x+ is nonpositive.

\note Result is returned in \verb+Float+ precision, regardless of
the precision of \verb+x+.

\seealso \funcxref{Exp}{PrimExp}, \funcxref{Power}{PrimPower}.

%----------

\section*{LpSolve}\label{PrimLpSolve}
\index{LpSolve (GCL primitive function)}
\begin{verbatim}
LpSolve[support->NFSUPPORT, {precision->Float}, {nPivots<->0}, 
        {time<->0.000000}, {traceFile<->(Output)}, 
        {traceLevel->0}] =: LIST(MIXED) 
LpSolve[support->EFSUPPORT, {asNfg->False}, {precision->Float}, 
        {nPivots<->0}, {time<->0.000000}, 
        {traceFile<->(Output)}, {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}

\noindent
Solves a two-person, constant-sum game for a Nash equilibrium as a linear
program.  For extensive form games, the Koller-Megiddo-Stengel
sequence form is used; games not of perfect recall return the empty
list of solutions.

The behavior of the algorithm may be modified by the following optional
parameters:
\begin{itemize}
\item
\textbf{asNfg:} By default, extensive forms are solved by the sequence form.
By setting this parameter to \verb+True+, each marked subgame of the
extensive form is converted to its corresponding reduced normal form,
solved as a linear program, and the mixed strategy solutions converted back
into behavior profiles.
\item
\textbf{precision:} Determines the precision of the computation. Default is
floating point precision (\verb+Float+). 
\item
\textbf{nPivots:} Returns the total number of pivots.
\item
\textbf{time:} Returns the elapsed time for the operation.
\item
\textbf{traceFile:} A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
\textbf{traceLevel:} An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no
output at all.
\end{itemize}

\seealso \funcxref{LcpSolve}{PrimLcpSolve}.

%--M--

\section*{Manual}\label{PrimManual}
\index{Manual (GCL primitive function)}
\begin{verbatim}
Manual[x->TEXT, {y->(Output)}] =: BOOLEAN 
\end{verbatim}

\noindent
Prints the manual entry for the function \verb+x+.  If there is no
entry for \verb+x+, no output is generated. The parameter
\verb+y+, which is the null output by default, can be used to print
the manual entry to an output stream.

\seealso \funcxref{Help}{PrimHelp}, \funcxref{HelpVars}{PrimHelpVars}.

%----------

\section*{MarkSubgame}\label{PrimMarkSubgame}
\index{MarkSubgame (GCL primitive function)}
\begin{verbatim}
MarkSubgame[node->NODE] =: BOOLEAN 
\end{verbatim}

\noindent
Mark \verb+node+ as being the root of a subgame for use in later computation.
Only nodes which are roots of subgames may be marked.  Returns \verb+True+
if \verb+node+ was marked as a subgame (i.e., if it is the root of a subgame).

\seealso \funcxref{MarkedSubgame}{PrimMarkedSubgame},
\funcxref{Subgames}{PrimSubgames},
\funcxref{UnMarkSubgame}{PrimUnMarkSubgame}.

%----------

\section*{MarkedSubgame}\label{PrimMarkedSubgame}
\index{MarkedSubgame (GCL primitive function)}
\begin{verbatim}
MarkedSubgame[node->NODE] =: BOOLEAN 
\end{verbatim}

\noindent
Returns \verb+True+ if \verb+node+ is currently marked as a subgame. 

\seealso \funcxref{MarkSubgame}{PrimMarkSubgame},
\funcxref{Subgames}{PrimSubgames},
\funcxref{UnMarkSubgame}{PrimUnMarkSubgame}.

%----------

\section*{Members}\label{PrimMembers}
\index{Members (GCL primitive function)}
\begin{verbatim}
Members[infoset->INFOSET*] =: LIST(NODE) 
\end{verbatim}

\noindent
Returns the list of nodes which are members of \verb+infoset+.  If
\verb+infoset+ is null, the empty list is returned.

\seealso \funcxref{Infoset}{PrimInfoset}.

%----------

\section*{MergeInfosets}\label{PrimMergeInfosets}
\index{MergeInfosets (GCL primitive function)}
\begin{verbatim}
MergeInfosets[to->INFOSET,
              from->INFOSET] =: INFOSET
\end{verbatim}

\noindent
Moves all the nodes from the information set \verb+from+ into \verb+to+.
It is an error if the number of actions is not the same at the
two information sets, or if the information sets are not from the
same extensive form game.  The information set \verb+to+ is returned.

\seealso \funcxref{MoveToInfoset}{PrimMoveToInfoset}.

%----------

\section*{Minus}\label{PrimMinus}
\index{Minus (GCL primitive function)}
\begin{verbatim}
Minus[x->NUMBER, y->NUMBER] =: NUMBER 
Minus[x->MIXED, y->MIXED] =: MIXED 
Minus[x->BEHAV, y->BEHAV] =: BEHAV 
\end{verbatim}

\noindent
Returns the difference $x - y$.

\shortform \verb+x - y+

\seealso \funcxref{Divide}{PrimDivide},
\funcxref{Plus}{PrimPlus}, \funcxref{Times}{PrimTimes}.

%----------

\section*{Mixed}\label{PrimMixed}
\index{Mixed (GCL primitive function)}
\begin{verbatim}
Mixed[support->NFSUPPORT] =: MIXED 
\end{verbatim}

\noindent
Returns a mixed strategy profile over \verb+support+ with equal
probabilites for each strategy in the support.  

\seealso \funcxref{Behav}{PrimBehav}, 
\funcxref{Centroid}{ExtCentroid}.

%----------

\section*{Modulus}\label{PrimModulus}
\index{Modulus (GCL primitive function)}
\begin{verbatim}
Modulus[x->INTEGER, y->INTEGER] =: INTEGER 
\end{verbatim}

\noindent
Computes the remainder from dividing \verb+y+ into \verb+x+.  It is an
error if \verb+y+ is zero.

\shortform \verb+x MOD y+

\seealso \funcxref{IntegerDivide}{PrimIntegerDivide}.

%----------

\section*{MoveToInfoset}\label{PrimMoveToInfoset}
\index{MoveToInfoset (GCL primitive function)}
\begin{verbatim}
MoveToInfoset[node->NODE, infoset->INFOSET] =: NODE 
\end{verbatim}

\noindent
Removes \verb+node+ from its current information set, and makes it a
member of \verb+infoset+. It is an error if the number of actions at
\verb+node+ is not the same as the number of actions in
\verb+infoset+, or if \verb+node+ and \verb+infoset+ are from
different extensive form games.   

\seealso \funcxref{MergeInfosets}{PrimMergeInfosets}.

%----------

\section*{MoveTree}\label{PrimMoveTree}
\index{MoveTree (GCL primitive function)}
\begin{verbatim}
MoveTree[from->NODE, to->NODE] =: NODE 
\end{verbatim}

\noindent
Moves the subtree rooted at \verb+from+ to
the terminal node \verb+to+.  \verb+from+ becomes a terminal node.
Returns \verb+to+.  It is an error if \verb+to+ is not a terminal
node, or if \verb+from+ and \verb+to+ are not from the same extensive
form game.

\seealso \funcxref{CopyTree}{PrimCopyTree}.

%--N--

\section*{Name}\label{PrimName}
\index{Name (GCL primitive function)}
\begin{verbatim}
Name[x->ACTION*] =: TEXT
Name[x->EFG*] =: TEXT
Name[x->EFOUTCOME*] =: TEXT
Name[x->EFPLAYER*] =: TEXT
Name[x->INFOSET*] =: TEXT
Name[x->NFG*] =: TEXT
Name[x->NFOUTCOME*] =: TEXT
Name[x->NFPLAYER*] =: TEXT
Name[x->NODE*] =: TEXT
Name[x->STRATEGY*] =: TEXT
\end{verbatim}

\noindent
Returns the name of \verb+x+.  The name of a null object is defined
to be the empty string.

\seealso \funcxref{SetName}{PrimSetName}.

%----------

\section*{Negate}\label{PrimNegate}
\index{Negate (GCL primitive function)}
\begin{verbatim}
Negate[x->NUMBER] =: NUMBER 
\end{verbatim}

\noindent
Returns $-x$.

\shortform \verb+-x+

%----------

\section*{NewEfg}\label{PrimNewEfg}
\index{NewEfg (GCL primitive function)}
\begin{verbatim} 
NewEfg[{players->{}}] =: EFG 
\end{verbatim}

\noindent
Creates a new extensive form game.  The default extensive form
game has no players (other than the chance player) defined on it; the
optional parameter \verb+players+ specifies a list of players to be
created and the names to be assigned to them.  Returns the newly created game.

%----------

\section*{NewFunction}\label{PrimNewFunction}
\index{NewFunction (GCL primitive function)}
\begin{verbatim}
NewFunction[name[argument-list], body]
\end{verbatim}

\noindent
Creates a new function.  The function may be called exactly
as if it were a predefined function of the command language.  See the
section on user-defined functions for more detailed information.

\note Special function.  Not listable, cannot be called in a
user defined function; not documented in \verb+Help+ or \verb+Manual+.  

% DeleteFunction is currently not implemented
%\seealso \funcxref{DeleteFunction}{PrimDeleteFunction}.

%----------

\section*{NewInfoset}\label{PrimNewInfoset}
\index{NewInfoset (GCL primitive function)}
\begin{verbatim} 
NewInfoset[player->EFPLAYER, actions->INTEGER] =: INFOSET 
\end{verbatim}

\noindent
Creates a new information set belonging to \verb+player+, with
\verb+actions+ actions.  It is an error if \verb+actions+ is not
positive.  The newly created information set is returned.

\seealso \funcxref{DeleteEmptyInfoset}{PrimDeleteEmptyInfoset}.

%----------

\section*{NewNfg}\label{PrimNewNfg}
\index{NewNfg (GCL primitive function)}
\begin{verbatim}
NewNfg[dim->LIST(INTEGER)] =: NFG 
\end{verbatim}

\noindent
Creates a new normal form game with dimensionality \verb+dim+.  No
initialization of the payoffs of the game is done.  Returns the newly
created game.  

%----------

\section*{NewOutcome}\label{PrimNewOutcome}
\index{NewOutcome (GCL primitive function)}
\begin{verbatim} 
NewOutcome[efg->EFG] =: EFOUTCOME 
\end{verbatim}

\noindent
Defines a new outcome in the extensive form game \verb+efg+.  The new
outcome specifies payoffs of zero for all players.  Returns the newly
created outcome.

\seealso \funcxref{DeleteOutcome}{PrimDeleteOutcome},
\funcxref{Outcomes}{PrimOutcomes}, \funcxref{SetOutcome}{PrimSetOutcome}.

\newsignature

\begin{verbatim}
NewOutcome[nfg->NFG] =: NFOUTCOME 
\end{verbatim}

\noindent
Defines a new outcome in the normal form game \verb+nfg+.  The new
outcome specifies payoffs of zero for all players.  Returns the newly
created outcome.

\seealso \funcxref{DeleteOutcome}{PrimDeleteOutcome},
\funcxref{Outcomes}{PrimOutcomes}, \funcxref{SetOutcome}{PrimSetOutcome}.

%----------

\section*{NewPlayer}\label{PrimNewPlayer}
\index{NewPlayer (GCL primitive function)}
\begin{verbatim}
NewPlayer[efg->EFG] =: EFPLAYER 
\end{verbatim}

\noindent
Defines a new player in the extensive form game \verb+efg+.  Returns
the newly created player.  

%----------

\section*{NextSibling}\label{PrimNextSibling}
\index{NextSibling (GCL primitive function)}
\begin{verbatim}
NextSibling[node->NODE] =: NODE 
\end{verbatim}

\noindent
Returns the next sibling of \verb+node+.  If \verb+node+ has no next
sibling, the null node is returned.

\seealso \funcxref{PriorSibling}{PrimPriorSibling}.

%----------

\section*{Nfg}\label{PrimNfg}
\index{Nfg (GCL primitive function)}
\begin{verbatim}
Nfg[efg->EFG, {time<->0}] =: NFG 
\end{verbatim}

\noindent
Creates and returns the (structural) reduced normal form game equivalent
to the extensive form game \verb+efg+.  The optional parameter \verb+time+,
if specified, contains upon completion the amount of time consumed by
the transformation.

\seealso \funcxref{AgentForm}{PrimAgentForm}.

%----------

\section*{NodeNumber}\label{PrimNodeNumber}
\index{NodeNumber (GCL primitive function)}
\begin{verbatim}
NodeNumber[node->NODE, basis->EFBASIS] =: INTEGER 
\end{verbatim}

\noindent
Returns the number assigned to \verb+node+ in \verb+basis+.

\seealso \funcxref{Basis}{PrimBasis}.

%----------

\section*{NodeValue}\label{PrimNodeValue}
\index{NodeValue (GCL primitive function)}
\begin{verbatim}
NodeValue[profile->BEHAV, player->EFPLAYER, node->NODE] =: NUMBER 
\end{verbatim}

\noindent
Returns the expected payoff to \verb+player+ at \verb+node+, given
that all players are following \verb+profile+.

\seealso
\funcxref{ActionValue}{PrimActionValue},
\funcxref{Belief}{PrimBelief},
\funcxref{InfosetProb}{PrimInfosetProb},
\funcxref{RealizProb}{PrimRealizProb}. 

%----------

\section*{Nodes}\label{PrimNodes}
\index{Nodes (GCL primitive function)}
\begin{verbatim}
Nodes[efg->EFG] =: LIST(NODE) 
\end{verbatim}

\noindent
Returns a list of nodes of the extensive form game \verb+efg+.  The
list is in prefix traversal order.  This is the order that is
imposed by a lexicographic ordering of the nodes when each node is
identified by the sequence of branch numbers taken to reach it.  

\newsignature

\begin{verbatim}
Nodes[infoset->INFOSET*, basis->EFBASIS] =: LIST(NODE) 
\end{verbatim}

\noindent
Returns a list of nodes of the information set \verb+infoset+ in the
\verb+basis+.  

%----------

\section*{Not}\label{PrimNot}
\index{Not (GCL primitive function)}
\begin{verbatim}
Not[x->BOOLEAN] =: BOOLEAN 
\end{verbatim}

\noindent
Returns the boolean inverse of \verb+x+, according to the truth table:
\latexonly{
\begin{center}
\begin{tabular}{|c|c|}  \hline
\texttt{x} & \texttt{Not[x]} \\ \hline
\texttt{True} & \texttt{False} \\
\texttt{False} & \texttt{True} \\
\texttt{Unknown} & \texttt{Unknown} \\ \hline
\end{tabular}
\end{center}}

\htmlonly{
%\begin{verbatim}
%  x        Not[x]
%
%  True     False
%  False    True
%  Unknown  Unknown
%\end{verbatim}
\begin{tabular}{|c|c|}  \hline
\ruledrow{\texttt{x} & \texttt{Not[x]}}
\row{\texttt{True} & \texttt{False}}
\row{\texttt{False} & \texttt{True}}
\ruledrow{\texttt{Unknown} & \texttt{Unknown}}
\end{tabular}
}

\shortform \verb+NOT x+, \verb+!x+

\seealso \funcxref{And}{PrimAnd}, \funcxref{Or}{PrimOr}.

%----------

\section*{NotEqual}\label{PrimNotEqual}
\index{NotEqual (GCL primitive function)}
\begin{verbatim}
NotEqual[x->T*, y->T*] =: BOOLEAN
\end{verbatim}
\foralltypes

\noindent
Returns \verb+True+ when the values of \verb+x+ and \verb+y+ are
not equal.

\shortform \verb+x != y+

\seealso \funcxref{Equal}{PrimEqual}.

%----------

\section*{NthChar}\label{PrimNthChar}
\index{NthChar (GCL primitive function)}
\begin{verbatim}
NthChar[text->TEXT, n->INTEGER] =: TEXT 
\end{verbatim}

\noindent
Returns a text string of length 1 containing the \verb+n+th
character from \verb+text+.  By convention, the first character
in a string is indexed by 1.  It is an error if \verb+n+ is nonpositive,
or if \verb+n+ is greater than the length of \verb+text+.

\shortform \verb+text[[n]]+, \verb+text#n+

\seealso \funcxref{NumChars}{PrimNumChars}.

%----------

\section*{NthChild}\label{PrimNthChild}
\index{NthChild (GCL primitive function)}
\begin{verbatim} 
NthChild[node->NODE, n->INTEGER] =: NODE 
\end{verbatim}

\noindent
Returns the \verb+n+th child of \verb+node+.
By convention, the first child of a node is indexed by 1.
It is an error if \verb+n+ is nonpositive, or if \verb+n+ is greater
than the number of children of \verb+node+.

\shortform \verb+node#n+

\seealso \funcxref{Children}{PrimChildren}.

%----------

\section*{NthElement}\label{PrimNthElement}
\index{NthElement (GCL primitive function)}
\begin{verbatim}
NthElement[list<->NLIST(T*), n->INTEGER] =: T 
\end{verbatim}
\foralltypes

\noindent
Returns the \verb+n+th element of \verb+list+.
By convention, the first element of a list is indexed by 1.
It is an error if \verb+n+ is nonpositive, or if \verb+n+ is greater
than the number of elements in \verb+list+.

\shortform \verb+list[[n]]+, \verb+list_n+

\seealso \funcxref{Length}{PrimLength}.

%----------

\section*{Null}\label{PrimNull}
\index{Null (GCL primitive function)}
\begin{verbatim}
Null[x->T] =: T*
\end{verbatim}
\foralltypes

\noindent
Returns a null object of type \verb+T+.  

%----------

\section*{NumChars}\label{PrimNumChars}
\index{NumChars (GCL primitive function)}
\begin{verbatim}
NumChars[text->TEXT] =: INTEGER 
\end{verbatim}

\noindent
Returns the number of characters in \verb+text+.

\seealso \funcxref{NthChar}{PrimNthChar}.

%----------

\section*{NumElements}\label{PrimNumElements}
\index{NumElements (GCL primitive function)}
\begin{verbatim}
NumElements[list->NLIST(T*)] =: INTEGER 
\end{verbatim}
\foralltypes

\noindent
Returns the number of elements in \verb+list+.  The difference between
this function and \verb+Length+ is that this function is not listable,
while \verb+Length+ is.  

\seealso \funcxref{Length}{PrimLength}, \funcxref{NthChar}{PrimNthChar}.

%--O--

\section*{Or}\label{PrimOr}
\index{Or (GCL primitive function)}
\begin{verbatim}
Or[x->BOOLEAN, y->BOOLEAN] =: BOOLEAN 
\end{verbatim} 
  
\noindent Returns the disjunction of \verb+x+ and \verb+y+, according to the truth
table:
\begin{center}
\begin{tabular}{|c|ccc|} \hline
\ruledrow{ & \texttt{True} & \texttt{False} & \texttt{Unknown}}
\row{\texttt{True} & \texttt{True} & \texttt{True} & \texttt{True}}
\row{\texttt{False} & \texttt{True} & \texttt{False} & \texttt{Unknown}}
\ruledrow{\texttt{Unknown} & \texttt{True} & \texttt{Unknown} & \texttt{Unknown}}
\end{tabular}
\end{center}

\shortform \verb+x || y+, \verb+x OR y+

\seealso \funcxref{And}{PrimAnd}, \funcxref{Not}{PrimNot}.

%----------

\section*{Outcome}\label{PrimOutcome}
\index{Outcome (GCL primitive function)}
\begin{verbatim}
Outcome[node->NODE*] =: EFOUTCOME 
\end{verbatim}

\noindent
Returns the outcome attached to \verb+node+.  If no outcome is attached
to \verb+node+, or if \verb+node+ is null, the null outcome is returned.

\seealso \funcxref{SetOutcome}{PrimSetOutcome}.

\newsignature

\begin{verbatim}
Outcome[profile->LIST(STRATEGY)] =: NFOUTCOME 
\end{verbatim}

\noindent Returns the outcome associated with the contingency specified by
\verb+profile+.

\seealso \funcxref{SetOutcome}{PrimSetOutcome}.

%----------

\section*{Outcomes}\label{PrimOutcomes}
\index{Outcomes (GCL primitive function)}
\begin{verbatim}
Outcomes[efg->EFG] =: LIST(EFOUTCOME) 
\end{verbatim}

\noindent
Returns the list of outcomes defined on \verb+efg+.

\seealso \funcxref{DeleteOutcome}{PrimDeleteOutcome},
\funcxref{NewOutcome}{PrimNewOutcome}.

\newsignature

\begin{verbatim}
Outcomes[nfg->NFG] =: LIST(NFOUTCOME) 
\end{verbatim}

\noindent
Returns the list of outcomes defined on \verb+nfg+.

\seealso \funcxref{DeleteOutcome}{PrimDeleteOutcome},
\funcxref{NewOutcome}{PrimNewOutcome}.

%----------

\section*{Output}\label{PrimOutput}
\index{Output (GCL primitve function)}
\begin{verbatim}
Output[file->TEXT, {append->False}, {close->True}] =: OUTPUT 
\end{verbatim}

\noindent
Opens a new output stream for writing to \verb+file+.  An error occurs
if \verb+file+ is not able to be opened.  By default, an existing file
is overwritten; specifying \verb+append+ to be \verb+True+ opens the
file in append mode.  Also, by default, the file is closed after every
write operation to the file; specifying \verb+close+ to be
\verb+False+ will leave the file open between write operations.  This
may speed up output to a file, but will mean that the file is not
closed until all references to the output stream are UnAssigned.

\seealso \funcxref{Format}{PrimFormat}, \funcxref{Input}{PrimInput},
\funcxref{ListFormat}{PrimListFormat}, \funcxref{Write}{PrimWrite}.

%--P--

\section*{Parent}\label{PrimParent}
\index{Parent (GCL primitive function)}
\begin{verbatim}
Parent[node->NODE*] =: NODE 
\end{verbatim}

\noindent
Returns the parent of \verb+node+.  If \verb+node+ is the root node,
or if \verb+node+ is null, the null node is returned.

\seealso \funcxref{Children}{PrimChildren}.

%----------

\section*{Parentheses}\label{PrimParentheses}
\index{Parenthesis (GCL primitive function)}
\begin{verbatim}
Parentheses[x->T*] =: T 
\end{verbatim}
\foralltypes

\noindent
Returns the value passed in \verb+x+.  This is used to control
the order of evaluation of expressions.

\shortform \verb+(x)+

%----------

\section*{Payoff}\label{PrimPayoff}
\index{Payoff (GCL primitive function)}
\begin{verbatim}
Payoff[outcome->EFOUTCOME*, player->EFPLAYER] =: NUMBER 
\end{verbatim}

\noindent
Returns the payoff to \verb+player+ at \verb+outcome+.  It is an error if
\verb+player+ and \verb+outcome+ are not from the same extensive form game.

\seealso \funcxref{SetPayoff}{PrimSetPayoff}.

\newsignature

\begin{verbatim}
Payoff[outcome->NFOUTCOME*, player->NFPLAYER] =: NUMBER 
\end{verbatim}

\noindent
Returns the payoff to \verb+player+ at \verb+outcome+.  It is an error if
\verb+player+ and \verb+outcome+ are not from the same normal form game.

\seealso \funcxref{SetPayoff}{PrimSetPayoff}.

\newsignature

\begin{verbatim}
Payoff[profile->BEHAV, player->EFPLAYER] =: NUMBER 
\end{verbatim}

\noindent
Returns the payoff to \verb+player+ in an extensive form game if all
players follow \verb+profile+.  It is an error if \verb+profile+
and \verb+player+ are not from the same extensive form game.

\newsignature

\begin{verbatim}
Payoff[profile->MIXED, player->NFPLAYER] =: NUMBER 
\end{verbatim}

\noindent
Returns the payoff to \verb+player+ in a normal form game if all players
follow \verb+profile+.  It is an error if \verb+profile+ and \verb+player+
are not from the same normal form game.

%----------

\section*{Platform}\label{PrimPlatform}
\index{Platform (GCL primitive function)}
\begin{verbatim}
Platform[] =: TEXT 
\end{verbatim}

Returns a string identifying the platform that the GCL is
currently running on.  Can be used in user defined functions to define
system dependent variables, such as pathnames and command lines for
shell commands.  

\seealso \funcxref{Shell}{PrimShell}.

%----------

\section*{Player}\label{PrimPlayer}
\index{Player (GCL primitive function)}
\begin{verbatim}
Player[infoset->INFOSET*] =: EFPLAYER 
\end{verbatim}

\noindent
Returns the player who makes the decision at \verb+infoset+.
If \verb+infoset+ is null, the null player is returned.

\seealso \funcxref{Infosets}{PrimInfosets}.

\newsignature

\begin{verbatim}
Player[strategy->STRATEGY*] =: NFPLAYER 
\end{verbatim}

\noindent
Returns the player to whom the \verb+strategy+ belongs.
If \verb+strategy+ is null, the null player is returned.

\seealso \funcxref{Strategies}{PrimStrategies}.

%----------

\section*{Players}\label{PrimPlayers}
\index{Players (GCL primitive function)}
\begin{verbatim}
Players[efg->EFG] =: LIST(EFPLAYER) 
\end{verbatim}

\noindent
Returns the list of players defined on \verb+efg+.

\newsignature

\begin{verbatim}
Players[nfg->NFG] =: LIST(NFPLAYER) 
\end{verbatim}

\noindent
Returns the list of players defined on \verb+nfg+.

%----------

\section*{Plus}\label{PrimPlus}
\index{Plus (GCL primitive function)}
\begin{verbatim}
Plus[x->NUMBER, y->NUMBER] =: NUMBER
Plus[x->MIXED, y->MIXED] =: MIXED
Plus[x->BEHAV, y->BEHAV] =: BEHAV
\end{verbatim}

\noindent
Returns the sum of \verb+x+ and \verb+y+.

\shortform \verb%x + y%

\seealso \funcxref{Divide}{PrimDivide},
\funcxref{Minus}{PrimMinus}, \funcxref{Times}{PrimTimes}.

\newsignature

\begin{verbatim}
Plus[x->TEXT, y->TEXT] =: TEXT
\end{verbatim}

\noindent
Returns the concatenation of the text strings \verb+x+ and \verb+y+.

\shortform \verb%x + y%

%----------

\section*{PolEnumSolve}\label{PrimPolEnumSolve}
\index{PolEnumSolve (GCL primitive function)}
\begin{verbatim}
PolEnumSolve[support->NFSUPPORT, {stopAfter->0}, {nEvals<->0}, 
             {time<->0.000000}, {traceFile<->(Output)}, {traceLevel->0}, 
             {singularSupps<->{  }}, {recurse->True}] =: LIST(MIXED)
PolEnumSolve[support->EFSUPPORT, {asNfg->False}, {stopAfter->0}, 
             {nEvals<->0}, {time<->0.000000}, {traceFile<->(Output)}, 
             {traceLevel->0}, {singularSupps<->{  }}, 
             {recurse->True}] =: LIST(BEHAV)
\end{verbatim}

\noindent
Solves for all totally mixed Nash equilibrium on \verb+support+.  If
\verb+recurse+ is \verb+True+, the algorithm iterates through all
sub-supports of \verb+support+ to find the full support equilibria on
each sub-support.  Supports with singular solutions are reported in
\verb+singularSupps+.  These supports are skipped by the algorithm
when determined to have singular solutions.

\noindent
On each sub-support, the algorithm starts with a cube containing the
space of possible solutions and proceeds recursively.  The recursion
step begins with a subcube.  The subcube is discarded if the cube is
irrelevant in the sense of lying outside the space of possible
solutions.  Otherwise a modified Newton's method is used to search for
a solution in the subcube.  In the event that such a solution is
found, Taylor's series information at the solution is used to inquire
whether the solution is necessarily the unique solution in the
subcube.  If Newton's method leaves the subcube before finding a
solution, Taylor's series information at the center is used to inquire
whether we can be sure that the subcube contains no solutions.  If
neither of these procedures resolves the issue, the subcube is
subdivided and this recursion is performed on each smaller subcube.
Supports with singular solutions 

\noindent
The following optional parameters may be used to modify the behavior
of the algorithm:
\begin{itemize}
\item
\textbf{stopAfter:} By default, all equilibria are found.  This parameter may
be used to specify a maximum number of equilibria to be found.
\item
\textbf{asNfg:} Only applicable to the extensive form version.  By default,
this is \verb+False+.  If it is specified to be \verb+True+, the
extensive form game is solved by recursively converting its marked
subgames into normal form, solving, and reconstructing the solution as
a behavior profile.
\item
\textbf{precision:} Determines the precision of the computation. Default is
floating point precision (\verb+Float+). 
\item
\textbf{nEvals:} Returns the number of function evaluations done by the
algorithm.
\item
\textbf{time:} Returns the time elapsed during the execution
of the algorithm.
\item
\textbf{traceFile:} A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
\textbf{traceLevel:} An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no output
at all.
\item
\textbf{singularSupps:} Returns a list of the supports which have singular solutions. 
\item
\textbf{recurse:} Recurses to find totally mixed equilibria on all
subsupports of \verb+support+.
\end{itemize}

\seealso \funcxref{PossibleNashSupports}{PrimPossibleNashSupports}.

%----------

\section*{PossibleNashSupports}\label{PrimPossibleNashSupports}
\index{PossibleNashSupports (GCL primitive function)}
\begin{verbatim}
PossibleNashSupports[efg->EFG] =: LIST(EFSUPPORT) 
\end{verbatim}

\noindent
%\marginpar{give better  description and cite}
Returns the list of supports that could be the supports of Nash
equilibria.  Specifically, the supports returned are those in which no
pure strategy is weakly dominated by another strategy in the support,
since such a pure strategy would have a lower expected payoff for any
mixed strategy vector that assigned positive probability to all
elements of the support and no other strategies, and no pure strategy
in the support is strictly dominated (relative to the support) by a
pure strategy outside the support.

\seealso \funcxref{PolEnumSolve}{PrimPolEnumSolve}.

%----------

\section*{Power}\label{PrimPower}
\index{Power (GCL primitive function)}
\begin{verbatim}
Power[x->NUMBER, y->NUMBER] =: NUMBER 
\end{verbatim} 

\noindent Computes the value $x^{y}$.

\shortform \verb%x ^ y%

\note Not implemented for the case where \verb+x+ is of rational
precision, and \verb+y+ is not an integer.

\seealso \funcxref{Exp}{PrimExp}, \funcxref{Log}{PrimLog}.

%----------

\section*{Precision}\label{PrimPrecision}
\index{Precision (GCL primitive function)}
\begin{verbatim}
Precision[x->NUMBER] =: PRECISION
\end{verbatim}

\noindent Returns the precision of \verb+x+.

%----------

\section*{Print}\label{PrimPrint}
\index{Print (GCL primitive function)}
\begin{verbatim}
Print[x->T*] =: T 
Print[x->NLIST(T*)] =: NLIST(T) 
\end{verbatim}
\foralltypes

\noindent
Prints \verb+x+ at the console.  When relevant, the output is
formatted according to the current settings determined by the
\verb+Format+ commands.  Returns \verb+x+.  

\shortform \verb+<< x+

\seealso \funcxref{Format}{PrimFormat}, \funcxref{ListFormat}{PrimListFormat},
%\funcxref{SetVerbose}{PrimSetVerbose},
\funcxref{Write}{PrimWrite}.

%----------

\section*{PriorAction}\label{PrimPriorAction}
\index{PriorAction (GCL primitive function)}
\begin{verbatim}
PriorAction[node->NODE] =: ACTION 
\end{verbatim} 

\noindent
Returns the action corresponding to the branch leading to \verb+node+.
If \verb+node+ is the root node, its prior action is the null action.

%----------

\section*{PriorSibling}\label{PrimPriorSibling}
\index{PriorSibling (GCL primitive function)}
\begin{verbatim}
PriorSibling[node->NODE] =: NODE 
\end{verbatim}

\noindent
Returns the prior sibling of \verb+node+.  If \verb+node+ has
no prior sibling, the null node is returned.

\seealso \funcxref{NextSibling}{PrimNextSibling}.

%--Q--

\section*{QreGridSolve}\label{PrimQreGridSolve}
\index{QreGridSolve (GCL primitive function)}
\begin{verbatim}
QreGridSolve[support->NFSUPPORT, {pxifile->}, 
             {minLam->0.001000}, {maxLam->500.000000}, 
             {delLam->0.020000}, {powLam->1},{fullGraph->False}, 
             {delp1->0.100000}, {tol1->0.100000}, 
             {delp2->0.010000}, {tol2->0.010000}, 
             {nEvals<->0}, {time<->0.000000}, 
             {traceFile<->(Output)}, 
             {traceLevel->0}] =: LIST(MIXED) 
\end{verbatim}

\noindent
Computes the complete logistic quantal response correspondence for a
(small) two-person normal form game on the \verb+support+, for values
of $\lambda$ between \texttt{minLam} and \texttt{maxLam}.  Returns the
list of mixed profiles computed, one profile for each value of
$\lambda_t$ from lowest to highest.

The operation of the algorithm may be modified by specifying optional
parameters.  See \verb+QreSolve+ for a description of parameters
not listed here:
\begin{itemize}
\item
\textbf{delp1:} Grid size for course search over probability space.  Default
is $0.1$ .
\item
\textbf{tol1:} The tolerance on the objective function for course search.
Values of $p$ for which the objective function is less this value are
searched further on a finer grid.  The default is $0.1$.
\item
\textbf{delp2:} Grid size for fine search over probability space.  Default is
$0.01$ .
\item
\textbf{tol2:} The tolerance on the objective function for fine search.
Values of $p$ for which the objective function is less this value are
kept.  The default is $0.01$.  
\end{itemize}

\seealso \funcxref{QreSolve}{PrimQreSolve}.

%----------

\section*{QreLambda}\label{PrimQreLambda}
\index{QreLambda (GCL primitive function)}
\begin{verbatim}
QreLambda[profile->MIXED] =: NUMBER 
QreLambda[profile->BEHAV] =: NUMBER 
\end{verbatim}

\noindent
Returns the value of \verb+lambda+ for mixed or behavior profiles
computed by \verb+QreSolve+ or \verb+QreGridSolve+.  Profiles not
created by one of these algorithms have a null lambda value.

\seealso \funcxref{QreGridSolve}{PrimQreGridSolve},
\funcxref{QreSolve}{PrimQreSolve}, \funcxref{QreValue}{PrimQreValue}.

%----------

\section*{QreSolve}\label{PrimQreSolve}
\index{QreSolve (GCL primitive function)}
\begin{verbatim}
QreSolve[start->MIXED, {pxifile->""}, {minLam->0.001000}, 
         {maxLam->500.000000}, {delLam->0.020000}, {powLam->1}, 
         {fullGraph->False}, {accuracy->0.000000}, {time<->0}, 
         {nEvals<->0}, {nIters<->0}, {traceFile<->(Output)}, 
         {traceLevel->0}] =: LIST(MIXED),
QreSolve[start->BEHAV, {pxifile->""}, {minLam->0.001000}, 
         {maxLam->500.000000}, {delLam->0.020000}, {powLam->1}, 
         {fullGraph->False}, {accuracy->0.000000}, {time<->0}, 
         {nEvals<->0}, {nIters<->0}, {traceFile<->(Output)}, 
         {traceLevel->0}] =: LIST(BEHAV),
\end{verbatim}

\noindent
Computes a branch of the logistic quantal response equilibrium
correspondence for a game.  The profile \texttt{start} is
used as the starting point for the computation of $\lambda_{0}$, and
the support over which \texttt{start} is defined is the support over
which the correspondence is computed.

The behavior of the algorithm may be modified by specifying some of the
following optional parameters:
\begin{itemize}
\item
\textbf{pxifile:} Generate output to this file for later retrieval and viewing by
the PXI program.  By default no output file is generated.
\item
\textbf{minLam:} Sets the minimum value of $\lambda$.  The 
default value is 0.001.
\item
\textbf{maxLam:} Sets the maximum value of $\lambda$.  The
default value is 500.0.
\item
\textbf{delLam:} Sets the constant $\delta$ used in incrementing $\lambda$.  The
default value is $\delta=0.02$.
\item
\textbf{powLam:} Sets the exponent $a$ used in incrementing $\lambda$.  The default
value is $a=1$, producing geometric incrementing.  Setting $a=0$ corresponds
to linear incrementing.
\item
\textbf{fullGraph:} If \verb+True+, the list of behavior strategy profiles
returned contains the full sequence of profiles computed from each successive
value of $\lambda$.  The default value is \verb+False+, in which case only
the profile for the last value of $\lambda$ computed is returned.
\item
\textbf{accuracy:} Resulting solutions are ``epsilon QRE'' to at least this
accuracy.  I. e., for the given $\lambda$, no unilateral deviation by
any player will result in an improvement of more than the accuracy.
Default is $1.0e-8$.
\item
\textbf{time:} Returns the amount of time consumed by the
algorithm.
\item
\textbf{nEvals:} Returns the number of function evaluations
performed by the algorithm.
\item
\textbf{nIters:} Returns the number of iterations performed
by the algorithm.
\item
\textbf{traceFile:} A file containing a log of more detailed information on
the execution of the algorithm.  By default, no logging is done.
\item
\textbf{traceLevel:} An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to
no output at all.
\end{itemize}

\note The extensive form version disregards any marked
subgames.

\seealso \funcxref{QreGridSolve}{PrimQreGridSolve}.

%----------

\section*{QreValue}\label{PrimQreValue}
\index{QreValue (GCL primitive function)}
\begin{verbatim}
QreValue[profile->MIXED] =: NUMBER 
QreValue[profile->BEHAV] =: NUMBER 
\end{verbatim}

\noindent
Returns the value of the QRE objective function for mixed or behavior
profiles computed by \verb+QreSolve+ or \verb+QreGridSolve+.  The QRE
value for profiles not created by these algorithms is null.

\seealso \funcxref{QreGridSolve}{PrimQreGridSolve},
\funcxref{QreLambda}{PrimQreLambda}, \funcxref{QreSolve}{PrimQreSolve}.

%----------

\section*{Quit}\label{PrimQuit}
\index{Quit (GCL primitive function)}
\begin{verbatim}
Quit
Quit[{value->INTEGER:=0}] =: BOOLEAN
\end{verbatim}

\noindent
Exits the command language, returning \texttt{value} to the operating system.

\note Not listable.  The brackets \texttt{[]} are optional; 
\texttt{Quit} without brackets is equivalent to \texttt{Quit[0]}.

%--R--

\section*{Randomize}\label{PrimRandomize}
\index{Randomize (GCL primitive function)}
\begin{verbatim}
Randomize[x->NUMBER, {seed->0}] =: NUMBER
\end{verbatim}

\noindent
Returns a random number distributed uniformly between \verb+0+ and
\verb+1+.  The result is of \verb+Rational+ precision.  The
denominator is equal to \verb+MAXINT=214748367+, and the numerator is
a uniformly distributed integer between \verb+0+ and \verb+MAXINT+.

%----------

\section*{Rational}\label{PrimRational}
\index{Rational (GCL primitive function)}
\begin{verbatim}
Rational[x->NUMBER] =: NUMBER
\end{verbatim}

\noindent
Converts \texttt{x} to a number with rational precision.

\seealso \funcxref{Float}{PrimFloat}.

%----------

\section*{Read}\label{PrimRead}
\index{Read (GCL primitive function)}
\begin{verbatim}
Read[input<->INPUT, x<->T] =: INPUT 
Read[input<->INPUT, x<->LIST(T)] =: INPUT
\end{verbatim}
\textit{for} \texttt{T = BOOLEAN, NUMBER, TEXT}

\noindent
Reads data of type \verb+T+ from the input stream and assigns it to
\verb+x+.  If \verb+x+ is undefined, then its data type is determined
from the exposed data in the input stream.  If \verb+x+ is previously
defined, then the \verb+Read+ function will expect to find the
corresponding data type in the input stream, and a file read error
will be generated if the exposed data is of the wrong data type.  If
\verb+x+ is previously defined to be a \verb+LIST+, then \verb+Read[in,x]+
will successively read elements into each element of the list.  If the
wrong data type is found for any element of the list, a file read
error will be returned.

\noindent
The ``exposed data'' in the input stream consists of the following: If
first character is a double quote (\verb+"+), then the exposed data
consists of all characters up until the next double quote.  If the
first character is a \verb+{+, then the exposed data consists of all
the characters up until the next matching \verb+}+.  Otherwise, the
exposed data consists of all characters until the next whitespace.

\shortform \texttt{input >> x}

\seealso \funcxref{Input}{PrimInput}, \funcxref{IsEof}{PrimIsEof},
\funcxref{ReadText}{PrimReadText}, \funcxref{Write}{PrimWrite}.

%----------

\section*{ReadText}\label{PrimReadText}
\index{ReadText (GCL primitive function)}
\begin{verbatim}
ReadText[input<->INPUT, {x<->}, until->TEXT] =: INPUT
ReadText[input<->INPUT, {x<->}, n->INTEGER] =: INPUT
\end{verbatim}

\noindent
Reads data of type \verb+TEXT+ from the input stream and assigns it to
\verb+x+.  The first signature reads from \verb+input+ until the
string \verb+until+ is reached.  For example, setting
\verb+until->"\n"+ will read a line of text frin \verb+input+.  The
second signature reads \verb+n+ characters from \verb+input+.  

\seealso \funcxref{Input}{PrimInput}, \funcxref{IsEof}{PrimIsEof},
\funcxref{Read}{PrimRead}, \funcxref{Write}{PrimWrite}.

%----------

\section*{RealizProb}\label{PrimRealizProb}
\index{RealizProb (GCL primitive function)}
\begin{verbatim}
RealizProb[profile->BEHAV, node->NODE] =: NUMBER 
\end{verbatim}

\noindent
Returns the realization probability for \verb+node+ given that all players
are following \verb+profile+.  It is an error if \verb+profile+ and
\verb+node+ are not from the same extensive form game.

\seealso \funcxref{ActionValue}{PrimActionValue},
\funcxref{Belief}{PrimBelief}, \funcxref{InfosetProb}{PrimInfosetProb},
\funcxref{NodeValue}{PrimNodeValue}.

%----------

\section*{Regret}\label{PrimRegret}
\index{Regret (GCL primitive function)}
\begin{verbatim}
Regret[profile->BEHAV, action->ACTION] =: NUMBER 
\end{verbatim}

\noindent
Returns the gain to a player for deviating to \verb+action+, assuming
all players are following \verb+profile+.  The strategy profile is
a Nash equilibrium if and only if the regrets of all actions are zero.

\newsignature

\begin{verbatim}
Regret[profile->MIXED, strategy->STRATEGY] =: NUMBER 
\end{verbatim}

\noindent
Returns the gain to a player for deviating to \verb+strategy+, assuming
all players are following \verb+profile+.  The strategy profile is
a Nash equilibrium if and only if the regrets of all strategies are
identically zero.

%----------

\section*{Regrets}\label{PrimRegrets}
\index{Regrets (GCL primitive function)}
\begin{verbatim}
Regrets[profile->MIXED] =: LIST(LIST(NUMBER)) 
\end{verbatim}

\noindent
Returns a nested list of the regrets generated for each strategy by
\verb+profile+.  The \verb+(i,j)+th entry is the regret for player
\verb+i+, strategy \verb+j+.

%----------

\section*{Remove}\label{PrimRemove}
\index{Remove (GCL primitive function)}
\begin{verbatim}
Remove[list->NLIST(T), n->INTEGER] =: LIST(T) 
\end{verbatim}
\foralltypes

\noindent
Removes the \verb+n+th element from \verb+list+.  A copy of the list
with the element removed is returned.  It is an error if \verb+n+
is nonpositive, or if \verb+n+ is greater than the length of \verb+list+.

%\seealso \funcxref{Insert}{PrimInsert}.

%----------

\section*{RemoveAction}\label{PrimRemoveAction}
\index{RemoveAction (GCL primitive function)}
\begin{verbatim}
RemoveAction[support->EFSUPPORT, action->ACTION] =: EFSUPPORT 
\end{verbatim}

\noindent
Removes \verb+action+ from \verb+support+.  If
\verb+action+ is not in \verb+support+ there is no
effect.  A copy of the modified support is returned.  It is an error
if \verb+support+ and \verb+action+ are not from the same extensive
form game, or if removing \verb+action+ would result in the support
containing no actions at an information set.

\seealso \funcxref{AddAction}{PrimAddAction},
\funcxref{Support}{PrimSupport}.

\newsignature

\begin{verbatim}
RemoveAction[basis->EFBASIS, action->ACTION] =: EFBASIS 
\end{verbatim}

\noindent
Removes \verb+action+ from \verb+basis+.  If
\verb+action+ is not in \verb+basis+ there is no
effect.  A copy of the modified \verb+EFBASIS+ is returned.  It is an error
if \verb+basis+ and \verb+action+ are not from the same extensive
form game, or if removing \verb+action+ would result in the basis
containing no actions at an information set.

\seealso \funcxref{AddAction}{PrimAddAction}, \funcxref{Basis}{PrimBasis}.

%----------

\section*{RemoveNode}\label{PrimRemoveNode}
\index{RemoveNode (GCL primitive function)}
\begin{verbatim}
RemoveNode[support->EFBASIS, node->NODE] =: EFBASIS 
\end{verbatim}

\noindent
Removes \verb+node+ from \verb+support+.  If \verb+node+ is not in
the basis, there is no effect.  A copy of the modified basis is
returned.  

\seealso \funcxref{AddAction}{PrimAddAction}, \funcxref{Basis}{PrimBasis}.

%----------

\section*{RemoveStrategy}\label{PrimRemoveStrategy}
\index{RemoveStrategy (GCL primitive function)}
\begin{verbatim}
RemoveStrategy[support->NFSUPPORT, strategy->STRATEGY] =: NFSUPPORT 
\end{verbatim}

\noindent
Removes \verb+strategy+ from \verb+support+.  If \verb+strategy+ is not in
the support, there is no effect.  A copy of the modified support is
returned.  It is an error if \verb+support+ and \verb+strategy+ are
not from the same normal form game, or if removing \verb+strategy+
would result in the support containing no strategies for a player.

\seealso \funcxref{AddStrategy}{PrimAddStrategy},
\funcxref{Support}{PrimSupport}.

%----------

\section*{Reveal}\label{PrimReveal}
\index{Reveal (GCL primitive function)}
\begin{verbatim}
Reveal[infoset->INFOSET, who->LIST(EFPLAYER)] =: INFOSET 
\end{verbatim}

\noindent
Reveals the list of actions at \verb+infoset+ to the players in \verb+who+,
refining their information partitions at
all information sets in the extensive form game accordingly.  

%----------

\section*{RootNode}\label{PrimRootNode}
\index{RootNode (GCL primitive function)}
\begin{verbatim}
RootNode[efg->EFG] =: NODE 
\end{verbatim}

\noindent
Returns the root node of \verb+efg+.

%--S--

\section*{SaveEfg}\label{PrimSaveEfg}
\index{SaveEfg (GCL primitive function)}
\begin{verbatim}
SaveEfg[efg->EFG, file->TEXT] =: EFG 
\end{verbatim}

\noindent
Writes \verb+efg+ to an external savefile \verb+file+.  It is an error
if \verb+file+ cannot be opened for writing.  Returns \verb+efg+.

\seealso \funcxref{LoadEfg}{PrimLoadEfg}.

%----------

\section*{SaveNfg}\label{PrimSaveNfg}
\index{SaveNfg (GCL primitive function)}
\begin{verbatim}
SaveNfg[nfg->NFG, file->TEXT] =: NFG 
\end{verbatim}

Writes \verb+nfg+ to an external savefile \verb+file+.  It is an
error if \verb+file+ cannot be opened for writing.  Returns \verb+nfg+.

\seealso \funcxref{LoadNfg}{PrimLoadNfg}.

%----------

%\marginpar{Put in {\tt SeqEquilibSolve}}

%----------

\section*{SequenceForm}\label{PrimSequenceForm}
\index{SequenceForm (GCL primitive function)}
\begin{verbatim} 
SequenceForm[efg->EFG] =: NLIST(NUMBER)
\end{verbatim}

\noindent
Returns the sequence form of an extensive form game \verb+efg+, where
the sequence form is as defined in Koller, Megiddo and von Stengel
(\cite{KolMegSte:94}.  The sequence form is returned as a nested list,
with the indices in the reverse order from the numbers of the players.
Thus, if there are three players, the \verb+(i,j,k)+th element is a
vector of payoffs for player \verb+3+s \verb+i+th sequence, player
\verb+2+s \verb+j+th sequence, and player \verb+1+s \verb+k+th
sequence.  The components of the payoff vectors are in the same order
as the player numbers.

\seealso \funcxref{SequenceFormStrats}{PrimSequenceFormStrats},
\funcxref{SequenceFormConstraints}{PrimSequenceFormConstraints},
\funcxref{WriteSequenceForm}{PrimWriteSequenceForm}.

%----------

\section*{SequenceFormConstraints}\label{PrimSequenceFormConstraints}
\index{SequenceFormConstraints (GCL primitive function)}
\begin{verbatim} 
SequenceFormConstraints[efg->EFG, 
                        player->EFPLAYER] =: LIST(LIST(NUMBER))
\end{verbatim}

\noindent
Returns the matrix of constraints on the strategies for
\verb+player+ in the sequence form game for \verb+efg+.  Each row
represents a separate constraint, and each column represents the
corresponding sequence for that player.

\seealso \funcxref{SequenceForm}{PrimSequenceForm},
\funcxref{SequenceFormStrats}{PrimSequenceFormStrats},
\funcxref{WriteSequenceForm}{PrimWriteSequenceForm}.

%----------

\section*{SequenceFormStrats}\label{PrimSequenceFormStrats}
\index{SequenceFormStrats (GCL primitive function)}
\begin{verbatim} 
SequenceFormStrats[efg->EFG, 
                   player->EFPLAYER] =: LIST(LIST(ACTION))
\end{verbatim}

\noindent
Returns the sequence form strategies (or sequences) for
\verb+player+ for the sequence form game for \verb+efg+. Each
sequence form strategy is represented by a row in the matrix, which is
a list of actions for that player corresponding to the sequence.  

\seealso \funcxref{SequenceForm}{PrimSequenceForm},
\funcxref{SequenceFormConstraints}{PrimSequenceFormConstraints},
\funcxref{WriteSequenceForm}{PrimWriteSequenceForm}.

%----------

\section*{SetActionProb}\label{PrimSetActionProb}
\index{SetActionProb (GCL primitive function)}
\begin{verbatim} 
SetActionProb[profile<->BEHAV, action->ACTION, 
              value->NUMBER] =: BEHAV 
\end{verbatim}

\noindent
Sets the component of \verb+profile+ for
\verb+action+ to be equal to \verb+value+, and 
returns \verb+profile+.  It is an error if \verb+profile+ and \verb+action+
are not from the same extensive form game. 

\seealso \funcxref{ActionProb}{PrimActionProb},
\funcxref{SetActionProbs}{PrimSetActionProbs}.

%----------

\section*{SetActionProbs}\label{PrimSetActionProbs}
\index{SetActionProbs (GCL primitive function)}
\begin{verbatim} 
SetActionProbs[profile<->BEHAV, infoset->INFOSET, 
               value->LIST(NUMBER)] =: BEHAV 
\end{verbatim}

\noindent
Sets the components of \verb+profile+ for
information set \verb+infoset+ to be equal to \verb+values+.
Returns \verb+profile+.  It is an error if \verb+profile+ and \verb+infoset+
are not from the same extensive form game, or if the length of
\verb+value+ is not the same as the number of actions in \verb+profile+'s
support at \verb+infoset+.

\seealso \funcxref{ActionProb}{PrimActionProb}.

%----------

\section*{SetChanceProbs}\label{PrimSetChanceProbs}
\index{SetChanceProbs (GCL primitive function)}
\begin{verbatim} 
SetChanceProbs[infoset->INFOSET, 
               probs->LIST(NUMBER)] =: INFOSET 
\end{verbatim}

\noindent
Sets the action probabilities for 
\verb+infoset+ to the values given in \verb+probs+.  Returns \verb+infoset+. 
An error occurs if \verb+infoset+ does not belong to the chance player.

\seealso \funcxref{ChanceProb}{PrimChanceProb}.

%----------

\section*{SetComment}\label{PrimSetComment}
\index{SetComment (GCL primitive function)}
\begin{verbatim}
SetComment[efg->EFG, comment->TEXT] =: EFG
SetComment[nfg->NFG, comment->TEXT] =: NFG
\end{verbatim}

\noindent
Sets the comment associated with the game.

\seealso \funcxref{Comment}{PrimComment}.

%----------

\section*{SetEnv}\label{PrimSetEnv}
\index{SetEnv (GCL primitive function)}
\begin{verbatim}
SetEnv[name->TEXT, value->TEXT] =: BOOLEAN 
\end{verbatim}

\noindent
Sets the environment variable \verb+name+.

\seealso \funcxref{GetEnv}{PrimGetEnv}, \funcxref{UnSetEnv}{PrimUnSetEnv}.

%----------

\section*{SetName}\label{PrimSetName}
\index{SetName (GCL primitive function)}
\begin{verbatim}
SetName[x->T, name->TEXT] =: T
\end{verbatim}
\textit{for} \texttt{T = ACTION, EFG, EFPLAYER, INFOSET, NFG, NFOUTCOME, 
NFPLAYER, NODE, EFOUTCOME, STRATEGY}

\noindent
Sets the name of \verb+x+ to \verb+name+.  Returns \verb+x+.

\seealso \funcxref{Name}{PrimName}.

%----------

\section*{SetOutcome}\label{PrimSetOutcome}
\index{SetOutcome (GCL primitive function)}
\begin{verbatim} 
SetOutcome[node->NODE, outcome->EFOUTCOME*] =: EFOUTCOME 
\end{verbatim}

\noindent
Attaches \verb+outcome+ to \verb+node+.  Returns the outcome attached.
Note that nonterminal nodes may have outcomes attached; the interpretation
is that nonterminal outcomes represent incremental payoffs.  
It is an error if \verb+node+ and \verb+outcome+ are not from the same
extensive form game.

\seealso \funcxref{Outcome}{PrimOutcome}.

\newsignature

\begin{verbatim} 
SetOutcome[profile->LIST(STRATEGY), outcome->NFOUTCOME] =: NFOUTCOME 
\end{verbatim}

\noindent
Attaches \verb+outcome+ to the cell in the normal form game
determined by the pure strategy profile defined by \verb+profile+.
Returns the outcome attached.  It is an error if \verb+profile+ and
\verb+outcome+ are not from the same normal form game. Also,
\verb+profile+ must be a list of strategies consisting of one strategy
for each player in the game.  

\seealso \funcxref{Outcome}{PrimOutcome}.

%----------

\section*{SetPayoff}\label{PrimSetPayoff}
\index{SetPayoff (GCL primitive function)}
\begin{verbatim}
SetPayoff[outcome->EFOUTCOME, player->EFPLAYER,
          payoff->NUMBER] =: EFOUTCOME 
\end{verbatim}

\noindent
Sets the payoff of \verb+outcome+ for \verb+player+ to \verb+payoff+.
It is an error if \verb+outcome+ and \verb+player+ are not from the
same extensive form game.  Returns \verb+outcome+.

\seealso \funcxref{Payoff}{PrimPayoff}.

\newsignature

\begin{verbatim}
SetPayoff[outcome->NFOUTCOME, player->NFPLAYER, 
          payoff->NUMBER] =: NFOUTCOME 
\end{verbatim}

\noindent
Sets the payoff of \verb+outcome+ for \verb+player+ to \verb+payoff+.
It is an error if \verb+outcome+ and \verb+player+ are not from \verb+nfg+.
Returns \verb+outcome+.

\seealso \funcxref{Payoff}{PrimPayoff}.

%----------

\section*{SetStrategyProb}\label{PrimSetStrategyProb}
\index{SetStrategyProb (GCL primitive function)}
\begin{verbatim}
SetStrategyProb[profile<->MIXED, strategy->STRATEGY, 
                value->NUMBER] =: MIXED 
\end{verbatim}

\noindent
Sets the components of \verb+profile+ for \verb+strategy+ to be equal
to \verb+value+.  It is an error if \verb+profile+ and \verb+strategy+
are not from the same normal form game.  Returns \verb+profile+.

\seealso \funcxref{StrategyProb}{PrimStrategyProb}.

%----------

\section*{SetStrategyProbs}\label{PrimSetStrategyProbs}
\index{SetStrategyProbs (GCL primitive function)}
\begin{verbatim}
SetStrategyProbs[profile<->MIXED, player->NFPLAYER, 
                 value->LIST(NUMBER)] =: MIXED 
\end{verbatim}

\noindent
Sets the components of \verb+profile+ for \verb+player+ to be equal
to \verb+value+.  It is an error if \verb+profile+ and \verb+player+
are not from the same normal form game, or if the length of \verb+value+
is not the same as the number of strategies for \verb+player+ in the
support of \verb+profile+.  Returns \verb+profile+.

\seealso \funcxref{StrategyProb}{PrimStrategyProb}.

%----------

\section*{Shell}\label{PrimShell}
\index{Shell (GCL primitive function)}
\begin{verbatim}
Shell[{command->""}, {spawn->True}] =: INTEGER 
\end{verbatim}

\noindent
Runs a child process.  
\begin{itemize}
\item \textbf{command:} A text string to be executed by the shell.  
\item \textbf{spawn:} Specifies whether to run in the foreground or
background.  Default is to run in the background.  
\end{itemize}

\seealso \funcxref{Platform}{PrimPlatform}.

%----------

\section*{SimpDivSolve}\label{PrimSimpDivSolve}
\index{SimpDivSolve (GCL primitive function)}
\begin{verbatim}
SimpDivSolve[support->NFSUPPORT, {stopAfter->1}, 
             {nRestarts->1}, {leashLength->0}, 
             {precision->Float}, {nEvals<->0}, 
             {time<->0.000000}, {traceFile<->(Output)}, 
             {traceLevel->0}] =: LIST(MIXED) 
SimpDivSolve[support->EFSUPPORT, {asNfg->False}, 
             {stopAfter->1}, {nRestarts->1}, {leashLength->0}, 
             {precision->Float}, {nEvals<->0}, 
             {time<->0.000000}, {traceFile<->(Output)}, 
             {traceLevel->0}] =: LIST(BEHAV) 
\end{verbatim}

\noindent
Computes a Nash equilibrium for a game using a simplicial subdivision
algorithm. The behavior of the algorithm may be modified by several optional
parameters:
\begin{itemize}
\item
\textbf{asNfg:} By default, this is \verb+False+.  If it is specified to be
\verb+True+, the extensive form game is solved by recursively converting
its marked subgames into normal form, solving, and reconstructing the
solution as a behavior profile.  {\it Note that currently simplicial
subdivision is only supported on the normal form, so this parameter
must always be specified and {\tt True}.}
\item
\textbf{stopAfter:} Maximum number of equilibria to find. Default is 1.  
\item
\textbf{precision:} Determines the precision of the computation. Default is
floating point precision (\texttt{Float}). 
\item 
\textbf{nRestarts:} Number of restarts.  At each restart the mesh of the
triangulation is halved.  So this parameter determines the final mesh
by the formula $2^{-ndivs}$.
\item
\textbf{leashLength:} Sets the leash length. Default is 0, which results in no
constraint, or no leash.  Note that if this parameter is set to a value
different from 0, the algorithm is no longer guaranteed to converge.
\item
\textbf{time:} Returns the elapsed time for the algorithm.
\item
\textbf{traceFile:} A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
\textbf{traceLevel:} An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to
no output at all.
\end{itemize}

%----------

\section*{Sort}\label{PrimSort}
\index{Sort (GCL primitive function)}
\begin{verbatim}
Sort[x->LIST(NUMBER)] =: LIST(NUMBER)
Sort[x->LIST(TEXT)] =: LIST(TEXT)
\end{verbatim}

\noindent
Returns an list consisting of the elements of \verb+x+ sorted in
increasing order.

\newsignature

\begin{verbatim}
Sort[x->LIST(T), by->LIST(NUMBER)] =: LIST(T)
Sort[x->LIST(T), by->LIST(TEXT)] =: LIST(T)
\end{verbatim}
\foralltypes

\noindent
Returns a list consisting of the elements of \verb+list+, sorted
according to the ordering of the elements of \verb+by+.  It is an
error if \verb+list+ and \verb+by+ do not have the same dimensionality.

%----------

\section*{StartWatch}\label{PrimStartWatch}
\index{StartWatch (GCL primitive function)}
\begin{verbatim}
StartWatch[] =: NUMBER 
\end{verbatim}

\noindent
Starts the system stopwatch.  This function has no
effect if the stopwatch is already running.
Returns the amount of time since the stopwatch was started.

\seealso \funcxref{ElapsedTime}{PrimElapsedTime},
\funcxref{IsWatchRunning}{PrimIsWatchRunning},
\funcxref{StopWatch}{PrimStopWatch}.

%----------

\section*{StopWatch}\label{PrimStopWatch}
\index{StopWatch (GCL primitive function)}
\begin{verbatim}
StopWatch[] =: NUMBER 
\end{verbatim}

\noindent
Stops the system stopwatch.  If the stopwatch was not
running, this function has no effect.  Returns the amount of time
on the stopwatch.

\seealso \funcxref{ElapsedTime}{PrimElapsedTime},
\funcxref{IsWatchRunning}{PrimIsWatchRunning},
\funcxref{StartWatch}{PrimStartWatch}.

%----------

\section*{Strategies}\label{PrimStrategies}
\index{Strategies (GCL primitive function)}
\begin{verbatim}
Strategies[player->NFPLAYER, support->NFSUPPORT] =: LIST(STRATEGY) 
\end{verbatim}

\noindent
Returns the list of strategies from which  \verb+player+ may choose
in \verb+support+.

\seealso \funcxref{Player}{PrimPlayer}.

%----------

\section*{StrategyNumber}\label{PrimStrategyNumber}
\index{StrategyNumber (GCL primitive function)}
\begin{verbatim}
StrategyNumber[strategy->STRATEGY, sup->NFSUPPORT] =: INTEGER
\end{verbatim}

\noindent
Returns the number assigned to \verb+strategy+ in the support
\verb+sup+.  Strategies  for each player are numbered from 1 to
the number of strategies for the player.  If a strategy is not in
the corresponding support, it is assigned a number of
\verb+0+.

\seealso \funcxref{Strategies}{PrimStrategies}.

%----------

\section*{StrategyProb}\label{PrimStrategyProb}
\index{StrategyProb (GCL primitive function)}
\begin{verbatim}
StrategyProb[profile->MIXED, strategy->STRATEGY] =: NUMBER 
\end{verbatim}

\noindent
Returns the probability that \verb+strategy+ is chosen when all
players are following \verb+profile+.  It is an error if \verb+profile+
and \verb+strategy+ are not from the same normal form game.

\seealso \funcxref{SetStrategyProbs}{PrimSetStrategyProbs}.

%----------

\section*{StrategyProbs}\label{PrimStrategyProbs}
\index{StrategyProbs (GCL primitive function)}
\begin{verbatim}
StrategyProbs[profile->MIXED] =: LIST(LIST(NUMBER)) 
\end{verbatim}

\noindent
Returns a nested list of the probabilities for each strategy under
\verb+profile+.  The \verb+(i,j)+th entry is the probability of player
\verb+i= adopting strategy \verb+j+.

\seealso \funcxref{StrategyProb}{PrimStrategyProb},
\funcxref{SetStrategyProbs}{PrimSetStrategyProbs}.

%----------

\section*{StrategyValue}\label{PrimStrategyValue}
\index{StrategyValue (GCL primitive function)}
\begin{verbatim}
StrategyValue[profile->MIXED, strategy->STRATEGY] =: NUMBER 
\end{verbatim}

\noindent
Returns the expected payoff to a player (who is in control of the
strategy set including \verb+strategy+) of choosing \verb+strategy+ when
all players are following \verb+profile+.  It is an error if
\verb+profile+ and \verb+strategy+ are not from the same normal form
game.

\seealso \funcxref{StrategyProb}{PrimStrategyProb}.

%----------

\section*{StrategyValues}\label{PrimStrategyValues}
\index{StrategyValues (GCL primitive function)}
\begin{verbatim}
StrategyValues[profile->MIXEd] =: LIST(LIST(NUMBER)) 
\end{verbatim}

Returns a list of expected payoffs of each strategy (to the player
who chooses that strategy).  The \verb+(i,j)+th entry is
the expected payoff to player \verb+i+ of
strategy \verb+j+, where the index numbers correspond to the output of
\verb+Players+ and \verb+Strategies+, respectively.

%----------

\section*{Subgames}\label{PrimSubgames}
\index{Subgames (GCL primitive function)}
\begin{verbatim}
Subgames[efg->EFG] =: LIST(NODE) 
\end{verbatim}

\noindent
Returns the list of nodes which are roots of subgames in \verb+efg+.
The ordering of the list is such that
all children of a node are listed before the node.

\seealso \funcxref{MarkSubgame}{PrimMarkSubgame},
\funcxref{MarkedSubgame}{PrimMarkedSubgame},
\funcxref{UnMarkSubgame}{PrimUnMarkSubgame}.

%----------

\section*{Support}\label{PrimSupport}
\index{Support (GCL primitive function)}
\begin{verbatim}
Support[efg->EFG] =: EFSUPPORT 
\end{verbatim}

\noindent
Returns the support of \verb+efg+.  The support contains all actions at every
information set for all players.

\seealso \funcxref{AddAction}{PrimAddAction},
\funcxref{RemoveAction}{PrimRemoveAction}.

\newsignature

\begin{verbatim}
Support[nfg->NFG] =: NFSUPPORT 
\end{verbatim}

\noindent
Returns the support of \verb+nfg+.  The support contains all strategies
for all players.

\seealso \funcxref{AddStrategy}{PrimAddStrategy},
\funcxref{RemoveStrategy}{PrimRemoveStrategy}.

\newsignature

\begin{verbatim}
Support[profile->BEHAV] =: EFSUPPORT 
Support[profile->MIXED] =: NFSUPPORT 
\end{verbatim}

\noindent
Returns the support on which \verb+profile+ is defined.

\seealso \funcxref{Behav}{PrimBehav}, \funcxref{Mixed}{PrimMixed}.

%--T--

\section*{Text}\label{PrimText}
\index{Text (GCL primitive function)}
\begin{verbatim}
Text[x->NUMBER] =: TEXT 
Text[x->TEXT] =: TEXT 
\end{verbatim}

\noindent
Converts \texttt{x} into a text string.

%----------

\section*{Times}\label{PrimTimes}
\index{Times (GCL primitive function)}
\begin{verbatim}
Times[x->NUMBER, y->NUMBER] =: NUMBER 
\end{verbatim}

\noindent
Computes the product of \verb+x+ and \verb+y+.

\shortform \verb+x * y+.

\seealso \funcxref{Divide}{PrimDivide}, \funcxref{Minus}{PrimMinus},
\funcxref{Plus}{PrimPlus}.

\newsignature

\begin{verbatim}
Times[x->NUMBER, y->MIXED] =: MIXED 
Times[x->NUMBER, y->BEHAV] =: BEHAV 
\end{verbatim}

\noindent
Computes the product of \verb+x+ and \verb+y+.

\shortform \verb+x * y+.

\seealso \funcxref{Minus}{PrimMinus}, \funcxref{Plus}{PrimPlus}.

%----------

\section*{Transpose}\label{PrimTranspose}
\index{Transpose (GCL primitive function)}
\begin{verbatim} 
Transpose[x->LIST(LIST(T))] =: LIST(LIST(T)) 
\end{verbatim}
\foralltypes

\noindent
Returns the transpose of a rectangular matrix.  It is an error if \texttt{list}
is not rectangular.

%--U--

\section*{UnAssign}\label{PrimUnAssign}
\index{UnAssign (GCL primitive function)}
\begin{verbatim}
UnAssign[name->TEXT] =: BOOLEAN
\end{verbatim}

\noindent
Undefines the variable with name \verb+name+.  Returns 
\verb+True+ if the variable was defined, and \verb+False+ if the
variable was not defined, at the time of the call.

\shortform \verb+x := +

\note For the short form, quotes around \verb+name+ are not
required, and the function is not listable.

\seealso \funcxref{Assign}{PrimAssign}, \funcxref{Clear}{PrimClear}.

%----------

\section*{UnDominated}\label{PrimUnDominated}
\index{UnDominated (GCL primitive function)}
\begin{verbatim}
UnDominated[support->NFSUPPORT, {strong->False}, 
            {mixed->False}, {precision->Rational}, {time<->0.000000}, 
            {traceFile<->(Output)}, {traceLevel->0}] =: NFSUPPORT 
UnDominated[support->EFSUPPORT, {strong->False}, {conditional->False}, 
            {time<->0.000000}, {traceFile<->(Output)}, 
            {traceLevel->0}] =: EFSUPPORT 
\end{verbatim}

\noindent
Finds dominated strategies, or actions, as appropriate, in a 
\verb+support+.  The returned support contains only the UnDominated
strategies or actions; if this support is identical to the input support,
no strategies or actions were found to be dominated.  The following
optional parameters may be specified to modify the behavior of
the elimination:

\begin{itemize}
\item \textbf{strong:} By default, all weakly dominated strategies or actions
are eliminated.  If this is specified \verb+True+, elimination is based
on strict dominance.
\item \textbf{mixed:} By default, elimination is done in pure strategies or
actions.  If this is specified \verb+True+, elimination is done by
examining mixtures over other strategies or actions.  Note that mixed 
elimination is only implemented for normal form games.  
\item \textbf{conditional:} Dominance computations are conditional on
reaching infoset containing the action.  For example, a behavior
strategy may be strongly dominated conditional on reaching its
information set, but only weakly dominated in the entire game.  Only
relevant for extensive form games.
\item \textbf{precision:} Default precision is Rational.  Note that the precision
parameter is only applicable for mixed domination.  Pure strategy
domination always uses Rational precision.
\item \textbf{time:} Returns the time consumed by the elimination process.
\item \textbf{traceFile:} A file containing a log of more detailed information
on the elimination process.  By default, no logging is done.
\item \textbf{traceLevel:} An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no output
at all.
\end{itemize}

%----------

\section*{UnMarkSubgame}\label{PrimUnMarkSubgame}
\index{UnMarkSubgame (GCL primitive function)}
\begin{verbatim}
UnMarkSubgame[node->NODE] =: NODE 
\end{verbatim}

\noindent
Unmark \verb+node+ as being the root of a subgame for use in later
computation.  If \verb+node+ is not marked as a subgame root, or if
\verb+node+ is the root node, this function has no effect.  Returns
the \verb+node+.

\seealso \funcxref{MarkSubgame}{PrimMarkSubgame},
\funcxref{MarkedSubgame}{PrimMarkedSubgame},
\funcxref{Subgames}{PrimSubgames}.

%----------

\section*{UnSetEnv}\label{PrimUnSetEnv}
\index{UnSetEnv (GCL primitive function)}
\begin{verbatim}
UnSetEnv[name->TEXT] =: BOOLEAN 
\end{verbatim}

\noindent
Unsets the environment variable \verb+name+.

\seealso \funcxref{GetEnv}{PrimGetEnv}, \funcxref{SetEnv}{PrimSetEnv}.

%--V--

\section*{Version}\label{PrimVersion}
\index{Version (GCL primitive function)}
\begin{verbatim}
Version[] =: NUMBER 
\end{verbatim} 

\noindent
Returns the version number of the command language.

%\marginpar{Add {\tt VertEnum}}

%--W--

\section*{While}\label{PrimWhile}
\index{While (GCL primitive function)}
\begin{verbatim}
While[boolean-expression, statement-list]
\end{verbatim}
  
\noindent
Defines a block of statements to be executed repeatedly.
See the section on control structures for complete information.

\note Special function.  Not listable; arguments are not GCL
data types; not documented in \verb+Help+ or \verb+Manual+.  

\seealso \funcxref{For}{PrimFor}.

%----------

\section*{Write}\label{PrimWrite}
\index{Write (GCL primitive function)}
\begin{verbatim}
Write[output<->OUTPUT, x->T] =: OUTPUT  
Write[output<->OUTPUT, x->LIST(T)] =: OUTPUT
\end{verbatim}
\textit{for} \texttt{T = BEHAV, BOOLEAN, EFG, EFSUPPORT, INTEGER,
NFG, NFSUPPORT, MIXED, NUMBER, STRATEGY, TEXT}

\noindent
Does a formatted write of \verb+x+ to \verb+output+.

\shortform \verb+output << x+

\seealso \funcxref{Format}{PrimFormat}, \funcxref{ListFormat}{PrimListFormat},
\funcxref{Output}{PrimOutput}, \funcxref{Read}{PrimRead}.

%----------

\section*{WriteSequenceForm}\label{PrimWriteSequenceForm}
\index{WriteSequenceForm (GCL primitive function)}
\begin{verbatim} 
WriteSequenceForm[output<->OUTPUT, efg->EFG] =: OUTPUT
\end{verbatim}

\noindent
Writes the sequence form for the game \verb+efg+ to output.  

\seealso \funcxref{SequenceForm}{PrimSequenceForm},
\funcxref{SequenceFormConstraints}{PrimSequenceFormConstraints},
\funcxref{SequenceFormStrats}{PrimSequenceFormStrats}.

%--X--

%--Y--

%--Z--

