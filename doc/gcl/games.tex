%
% $Header$
%
% Description: GCL manual chapter on building games
%

\chapter{Building and Modifying Games}

The whole point of the GCL is to provide an environment to enable
building and doing computations on games.  This chapter describes how
to build and solve normal and extensive form games in the GCL.  

\section{\rindex{Normal form games}}

A normal form game is a set of $n$ players, each with a strategy
set, together with a function from the cartesian product of strategy
sets to a set of outcomes. Each outcome results in a payoff to each of
the players.  To construct a normal form game, one must therefore
define each of these parts.  A series of GCl functions are available
for building and editing normal form games.  A complete list is given
in the sections on ``Normal Form Manipulation'' in the Categorical
Function Reference section of the manual.  Some of the more important
functions are given in Table 2.  User defined functions are preceded
with a \#, and all other functions are built in functions.  

\begin{table}[htp]
\begin{center}
\begin{tabular} {|l||l|} \hline
Function Name	& Description \\ 
\hline
\verb+  DeleteOutcome[o]+ &Deletes outcome \verb+o+ from its game. \\

\verb+  NewOutcome[n]+ &Returns a new outcome for the game \verb+n+\\ 
\verb+# NewOutcome[n, name]+ &Returns a new oucome named \verb+name+ for game \verb+n+ \\ 
\verb+# NewOutcome[p]+ &Attaches a new outcome with zero payoffs to
the pure profile \verb+p+\\ 

\verb+  Outcome[p]+ &The outcome attached to the pure strategy profile \verb+p+\\ 

\verb+  OutcomeForm[n]+ &The game form for game \verb+n+\\ 

\verb+  Outcomes[n]+ &List of outcomes defined for game \verb+n+\\ 

\verb+  SetOutcome[p, o]+ &Attach outcome \verb+o+ to pure strategy profile \verb+p+\\ 

\verb+  NewNfg[dim]+ &A new normal form with dimensions \verb+dim+\\ 
\verb+# NewNfg[dim, True]+ &A new normal form with dimensions \verb+dim+, outcomes in all cells\\ 

\verb+  Nfg[e]+ &Converts extensive form game \verb+e+ to normal form\\ 
\verb+# Nfg[x]+ &Converts nested list of numbers \verb+x+ to normal form\\ 

\verb+  Payoff[o, pl]+ &Payoff of outcome \verb+o+ to player \verb+pl+\\ 
\verb+  Payoff[m, pl]+ &Payoff of mixed profile \verb+m+ to player \verb+pl+\\ 

\verb+# Payoffs[p]+ &Payoffs of pure strategy \verb+p+\\ 
\verb+# Payoffs[n]+ &Normal form game payoffs of \verb+n+ as a nested list\\ 
\verb+# Payoffs[o]+ &Payoffs of outcome \verb+o+\\ 
\verb+# Payoffs[m]+ &Payoffs of mixed profile \verb+m+ \\ 
\verb+# Randomize[n,j]+ &Randomizes the payoffs in \verb+n+ with seed \verb+j+\\
\verb+# Strategies[pl]+ &Strategies for player \verb+pl+\\ 
\verb+# Strategies[n]+ &Strategies for game \verb+n+ \\ 

\verb+  SetPayoff[o, pl, pay]+ &Set payoff to player \verb+pl+ in outcome \verb+o+ to \verb+pay+\\ 

\verb+# SetPayoffs[o, pay]+ &Set payoffs of outcome \verb+o+ to vector \verb+pay+.  \\ 
\hline
\multicolumn{2}{c}{\ }\\
\multicolumn{2}{c}{Table 2}\\
\multicolumn{2}{c}{Normal form Building and Editing Functions}\\
\end{tabular}
\end{center}
\end{table}
\medskip


\subsection{Creating a normal form game}\index{Normal forms!creating}

The function \texttt{NewNfg} is used to create a new normal form game.
Thus, the command

\begin{verbatim}
GCL1:= NewNfg[{2,3,2}]
\end{verbatim}

\noindent 
will create a new normal form game with three players, where the first
player has two strategies, the second player has three strategies, and
the third player has two strategies.  Since no outcomes have been
defined, all strategy $n$-tuples of pure strategies result in the
``null'' outcome, which has payoff of zero for all players.  

The game created by \verb+NewNfg+ is not very interesting, because all
payoffs for all strategies are zero.  To make it more interesting,
outcomes must be created and associated with strategy $n$-tuples.  To
create a separate outcome for each pure strategy, one can specify the
second argument in \verb+NewNfg+ to be \verb+TRUE+.  These outcomes
will still have zero payoffs until they are changed. The function
\verb+Randomize+ can be used to randomize the payoffs of each outcome
in the game.  In this way, \verb+NewNfg+ can be used to create
more interesting games by using it as an argument to other functions
that accept Normal form games as arguments.

For example to create a random two person $2\times 2$ normal form
game, with a seed of \verb+34+ for the random number generator, you can
use the function \texttt{Randomize} to randomize the payoffs of the
original game.

\begin{verbatim}
GCL2:= Randomize[NewNfg[{2,2},True],34]
\end{verbatim}  

\noindent
You can look at the payoffs of the game by using the standard UDF,
\texttt{Payoffs} (we use \verb+Float+ to convert the game to floating
point precision first):

\begin{verbatim}
GCL3:= << Payoffs[Float[Randomize[NewNfg[{2,2},True],34]]]
{ { { 0.159964, 0.026784 }, { 0.421515, 0.399322 } },
  { { 0.233245, 0.923402 }, { 0.039071, 0.695271 } } }
\end{verbatim}  

\noindent
Here, the payoffs are written in a nested list, where the
\verb+(i,j)+th component is the vector of payoffs when player 1 takes
strategy \verb+i+ and player 2 takes strategy \verb+j+.  The game can
be solved for all mixed Nash equilibrium by

\begin{verbatim}
GCL4:= << AllNash[Randomize[NewNfg[{2,2},True],34]]
{ (Mixed) { 1.000000 0.000000 }{ 0.000000 1.000000 },
  (Mixed) { 0.000000 1.000000 }{ 1.000000 0.000000 },
  (Mixed) { 0.379795 0.620205 }{ 0.839199 0.160801 } }
\end{verbatim}

In all of the above examples, all work is thrown out, and the normal
form game is created anew in each successive command.  You can avoid
such wasteful computation, and minimize the typing you need to do by
saving intermediate results in a variable.  For example, the above
could be done as follows:

\begin{verbatim}
GCL1:= n:=Randomize[NewNfg[{2,2},True],34];
GCL2:= p:=Payoffs[n];
GCL3:= m:=EnumMixedSolve[n];
\end{verbatim}

The first statement creates a variable \verb+n+ to store the normal
form game.  This variable is then used as an argument in the next two
function calls.  The second two statements create variables \verb+p+
and \verb+m+ to store the nested list of payoffs of the game, and the
list of mixed strategy solutions of the game.  Any of these variables
can then be used as input to other function calls, as long as the data
type of the variable is the same as the data type of the 

The above also illustrates another important principle of the GCL.
All of the functions in the GCL (with a few exeptions, noted in the
Function Reference Section) return objects of some specific data type.
Any object returned by a function can be stored in a variable.  While
the GCL supports a large number specialized data types, the data
typing is all implicit.  In other words, you never have to declare
what data type a variable will be before it is used.  A variable takes
on the data type of the object that is first assigned to it.    

\subsection{Setting payoffs and modifying a normal form
game}\index{Normal forms!payoffs}  

The payoffs in a normal form can be set to have specific values using
the \texttt{SetPayoff} command.  The following sequence of statements
illustrates how to build a simple prisoner's dilemma game, by first
creating a normal form game of the correct dimension, and then
modifying the payoffs one by one.  

\begin{verbatim}
GCL1:= n:=NewNfg[{2,2}]
GCL2:= s:=Strategies[n]
GCL3:= NewOutcome[{s_1_1,s_2_1},{9.0,9.0}]
GCL4:= NewOutcome[{s_1_1,s_2_2},{0.0,10.0}]
GCL5:= NewOutcome[{s_1_2,s_2_1},{10.0,0.0}]
GCL6:= NewOutcome[{s_1_2,s_2_2},{1.0,1.0}]
GCL7:= << Payoffs[n]
{ { { 9.000000, 9.000000 }, { 0.000000, 10.000000 } },
  { { 10.000000, 0.000000 }, { 1.000000, 1.000000 } } }
\end{verbatim}

Note that the above can be done equivalently and more simply by using
the standard UDF, \texttt{Nfg} to create the game directly from a payoff
list:

\begin{verbatim}
GCL1:= n:=Nfg[{{{9,9},{0,10}},{{10,0},{1,1}}}]
GCL2:= << Payoffs[n]
{ { { 9.000000, 9.000000 }, { 0.000000, 10.000000 } },
  { { 10.000000, 0.000000 }, { 1.000000, 1.000000 } } }
\end{verbatim}

\noindent
You can name the strategies if you want by using \texttt{Strategies} to
get a list of the strategies in the game, and \texttt{SetName} to name
them.

\begin{verbatim}
GCL3:= s:=Strategies[n]
GCL4:= SetName[s_1,{"Cooperate","Defect"}]
GCL5:= SetName[s_2,{"Cooperate","Defect"}]
GGCL6:= << Name[s]
{ { Cooperate, Defect },
  { Cooperate, Defect } }
\end{verbatim}

We now give a more complicated example, in which one can use
listability of vector and matrix operations to set the payoffs in the
normal form according to a formula.  In this example, we create a
version of the ``stag hunt'' game.

\begin{verbatim}
GCL1:= << strat:=List[1,3,1]
{ 1, 2, 3 }
GCL2:= << stratSets:=List[strat,2]
{ { 1, 2, 3 },
  { 1, 2, 3 } }
GCL3:= << effort:=CartesianProd[stratSets] 
{ { { 1, 1 }, { 1, 2 }, { 1, 3 } },
  { { 2, 1 }, { 2, 2 }, { 2, 3 } },
  { { 3, 1 }, { 3, 2 }, { 3, 3 } } }
GCL4:= << pay:=Min[effort]-.5*effort
{ { { 0.500, 0.500 }, { 0.500, 0.000 }, { 0.500, -0.500 } },
  { { 0.000, 0.500 }, { 1.000, 1.000 }, { 1.000, 0.500 } },
  { { -0.500, 0.500 }, { 0.500, 1.000 }, { 1.500, 1.500 } } }
GCL5:= << n:=Nfg[pay]
(Nfg) ""
\end{verbatim}

First, the set of effort levels for a player (consisting of the list
of integers from one to 3) is constructed and stored in the variable
\verb+strat+.  (While this variable is called \verb+strat+ its data
type is \verb+LIST(INTEGER)+, not \verb+STRATEGY+.)  Second, the set
of strategy sets for both players is assembled in \verb+stratSets+.
Third, the set of pure strategy profiles is assembled by taking the
cartesian product of the strategy sets, and converted to \verb+NUMBER+
to give a vector of efforts for each pure strategy profile.  The
result is stored in the variable \verb+effort+.  Fourth, the vector of
payoffs for each pure strategy profile is computed by taking, for
vector of payoffs, the minimum effort across players, and subtracting
the cost of effort for each player.  Finally, a game is constructed
with these payoffs, by using the function \verb+Nfg+.  If you now ask
to see the payoffs for the game via \verb+Payoffs[nfg]+ you will see
an array just like \verb+pay+.

The fourth step in the above calculation illustrates a subtle but
important point about listable functions.  The function \texttt{Min}
requires an argument of type \verb+LIST(NUMBER)+ and returns type
\verb+NUMBER+.  It is being called with an argument of type
\verb+LIST(LIST(LIST(NUMBER)))+, and dimensionality $3\times 3\times
2$, .  Hence, the function will be run as a listable function on the
innermost vectors in the nested list, generating a result of type
\verb+LIST(LIST(NUMBER))+, and dimensionality $3\times 3$, each entry
of which contains the minimum of the vector in that cell.  Thus:

\begin{verbatim}
GCL6:= << Min[effort]
{ { 1, 1, 1 },
  { 1, 2, 2 },
  { 1, 2, 3 } }
\end{verbatim}

\noindent
To subtract the component \verb+.5*effort+ from this, the function
\verb+Minus+ requires data of type \verb+NUMBER+ for both arguments.
It is being run with the first argument of type
\verb+LIST(LIST(NUMBER))+, and dimension $3\times 3$, and the second of
type \verb+LIST(LIST(LIST(NUMBER)))+, and dimension $3\times 3\times
2$.  The first two levels of the list for both arguments match
in dimensionality.  Then it encounters a \verb+NUMBER+ in the first
argument, and a \verb+LIST(NUMBER)+ of dimension $2$ on the second.
Hence, \verb+Minus+ runs listably on its second argument, yielding a
\verb+LIST(NUMBER)+ of dimension $2$ for each entry in the $3\times 3$
nested list of \verb+Min[effort]+. 

The functions used in the above construction will accept nested lists
of any level.  Hence, the above can be extended into a user defined
function which allows one to build a stag hunt game for an arbitrary
number of players and strategies:

\begin{verbatim}
NewFunction[StagHuntNfg[n->INTEGER,maxeff->INTEGER,cost->NUMBER]=:NFG,
  strats:=List[1,maxeff,1];
  effort:=CartesianProd[List[strats,n]];
  Nfg[Min[effort]-cost*effort];
];
\end{verbatim}

\noindent
The statements in this user defined function are analagous to the
steps in the two person example above.  Once the above function has
been defined, then you can then use it as follows:

\begin{verbatim}
n:=StagHuntNfg[4,2,.5];
\end{verbatim}

\noindent
to create a four person stag hunt game where each player has two
strategy choices (effort levels) and the cost of effort is \verb+.5+.

Once a normal form game has been defined, there are a number of
solution algorithms that can be applied to solve the game.  How to
solve normal form games is discussed in the next chapter.  Until you
get to that point, you might want to save your work:

\subsection{Saving and loading normal forms}\index{Normal
forms!saving}\index{Normal forms!loading}

Once a normal form game has been constructed, it can be saved in a
similar way to an extensive form game.  The command 

\begin{verbatim}
SaveNfg[n, "filename.nfg" ]
\end{verbatim}

\noindent
will save the normal form game \verb+n+ to the file
\verb+filename.nfg+.  It is recommended that the filename extension
\verb+.nfg+ be used when saving normal form games, as the Gambit
Graphics user interface recognizes this extension as containing normal
form games.  Once a normal form game has been saved to an external
file, it can be loaded by the command \texttt{LoadNfg}, as follows:

\begin{verbatim}
n := LoadNfg["filename.nfg" ]
\end{verbatim}



\section{\rindex{Extensive forms}}

\subsection{Creating a new extensive form}\index{Extensive forms!creating}

The function \texttt{NewEfg} can be used to create a new extensive form
game.  In order to do anything with it, a variable should be created
to be the new extensive form game.  Thus, the command

\begin{verbatim}
e := NewEfg[]
\end{verbatim}

\noindent will create a new extensive form game stored in \verb+e+.
The game is a trivial game with only one node, a \verb+root node+, and
one player, \verb+chance+.  You can create a game whose data is which
has two players, named \verb+Fred+ and \verb+Alice+ by specifying


\begin{verbatim}
e := NewEfg[{"Fred", "Alice"} ]
\end{verbatim}

For an arbitrary extensive form game, a number of commands are
available to get information about the game.  A complete list is given
in the section on ``Getting Information'' in the Categorical Function
Reference section of this manual.  Some of the more important
functions are given in Table 3.  

\begin{table}[htp]
\begin{center}
\begin{tabular} {|l||l|} \hline
Function Name	& Description \\ 
\hline
\verb+# Actions[i]+ & Actions at information set \verb+i+ \\
\verb+# Actions[e]+ & Actions in the game \verb+e+ \\
\verb+  Chance[e]+ & Chance player of \verb+e+ \\
\verb+  Children[n]+ & Child nodes of node \verb+n+ \\
\verb+# History[n]+ & History of actions preceeding node \verb+n+ \\
\verb+  Infoset[n]+ & Information set that node \verb+n+ belongs to\\
\verb+  Infoset[a]+ & Information set that action \verb+a+ belongs to\\
\verb+  Infosets[e]+ & Information sets in the game \verb+e+\\
\verb+  Members[i]+ & Member nodes of information set \verb+i+\\
\verb+  Nodes[e]+ & Nodes in the game tree of the game \verb+e+\\
\verb+# NonterminalNodes[e]+ & Nonterminal nodes of game \verb+e+\\
\verb+  NthChild[n,j]+ & The \verb+j+th child of node \verb+n+ \\
\verb+  Outcome[n]+ & Outcome attached to node \verb+n+ \\
\verb+  Outcomes[e]+ & Outcomes for the game \verb+e+ \\
\verb+  Parent[n]+ & Parent node of node \verb+n+ \\
\verb+  Payoff[o,p]+ & Payoff  of outcome \verb+o+ for player \verb+p+ \\
\verb+# Payoffs[o]+ & Payoff vector of outcome \verb+o+ \\
\verb+# Payoffs[b]+ & Payoff vector of profile \verb+b+ \\
\verb+  Player[i]+ & Player of information set \verb+i+ \\
\verb+  Players[e]+ & Players of the game \verb+e+ \\
\verb+  PriorAction[n]+ & Action preceeding node \verb+n+ \\
\verb+  RootNode[e]+ & Root node of \verb+e+ \\
\verb+# TerminalNodes[e]+ & Terminal nodes of game \verb+e+\\
\hline
\multicolumn{2}{c}{\ }\\
\multicolumn{2}{c}{Table 3}\\
\multicolumn{2}{c}{Extensive form information functions}\\
\end{tabular}
\end{center}
\end{table}
\medskip

The \verb+NthChild[n,j]+\texttt{NthChild} function has a short form of
\verb+n#j+.  So the second child of the third child of the root node
of \verb+e+ can be accessed (if it exists) by the command
\verb+RootNode[e]#3#2+.

\subsection{Modifying an extensive form}\index{Extensive forms!modifying}

A series of extensive form game editing functions are available for
modifying an extensive form game. A complete list is given in the
section on ``Extensive form manipulation'' in the Categorical Function
Reference section of this manual.  The more important functions for
building a game are given in Table 4.

\begin{table}[htp]
\begin{center}
\begin{tabular} {|l||l|} \hline
Function Name	& Description \\ 
\hline
\verb+  AddMove[i,n]+ &Adds a move from infoset \verb+i+ to node \verb+n+ \\
\verb+# AddMove[i,a]+ &Adds a move from infoset \verb+i+ to action \verb+a+ \\
\verb+  CopyTree[n1,n2]+ &Copies tree rooted at node \verb+n1+ to node \verb+n2+ \\
\verb+  InsertAction[i]+ &Inserts an action into information set \verb+i+ \\
\verb+  InsertMove[i,n]+ &Inserts a move from infoset \verb+i+ at node \verb+n+\\
\verb+  MergeInfosets[i1,i2]+ &Moves nodes from infoset \verb+i2+ into \verb+i1+\\
\verb+  MoveToInfoset[n,i]+ &Moves node \verb+n+ into infoset \verb+i+\\
\verb+  NewInfoset[p,j]+ &Creates a new infoset for player \verb+p+ with \verb+j+ actions\\
\verb+# NewInfoset[p,list]+ &Creates a new infoset for \verb+p+ with action names as in \verb+list+\\
\verb+# NewOutcome[e,t]+ &Creates a new outcome for the game \verb+e+
with name \verb+t+\\
\verb+# NewPlayer[e,t]+ &Creates a new player for the game \verb+e+
with name \verb+t+\\
\verb+# Randomize[e,j]+ &Randomizes the payoffs in \verb+e+ with seed \verb+j+\\
\verb+  Reveal[i,list]+ &Reveals infoset \verb+i+ to players in \verb+list+\\
\verb+  SetChanceProbs[i,list]+ &Sets chance probs in infoset \verb+i+ to values in \verb+list+\\
\verb+  SetOutcome[n,o]+ &Attaches outcome \verb+o+ to node \verb+n+ \\
\verb+  SetPayoff[o,p,v]+ &Sets payoff of outcome \verb+o+ for player \verb+o+ to value \verb+v+\\
\verb+# SetPayoffs[o,list]+ &Sets payoff of outcome \verb+o+ to values in \verb+list+\\
\hline
\multicolumn{2}{c}{\ }\\
\multicolumn{2}{c}{Table 4}\\
\multicolumn{2}{c}{Extensive form building functions}\\
\end{tabular}
\end{center}
\end{table}
\medskip

The functions in Table 4 can be used to build up any valid extensive
form game from a trivial game.  The basic procedure by which a more
complex game is constructed from a simple game is:

\begin{itemize}
\item
Create a new game, and create all players.  
\item
Iteratively add moves to the game.  This involves two steps
\begin{itemize}
\item
Construct a ``template'' for a move by creating an information set for
a player with the desired choices (actions).  

\item
Add the move to the game for the appropriate histories of actions.  
\end{itemize}
\item
Reveal information about the moves to players that observe them.  

\item
Compute payoffs and attach outcomes to the game.  
\end{itemize}

The next to last step (revealing information) may require considerable
care for games with complex information structures.  It is usually
easiest to wait to do this step until the entire game tree is built,
since currently, the GCL does not maintain a game of perfect recall as
you add new moves.  Hence, if you reveal a move of player 1 to player
2, and then add new moves to the game for the player 2, the move that
was revealed to player 2 will not be ``remembered'' by player 2 at the
new moves.

The following sequence of commands builds the game tree for a simple
poker game as described in \cite{Mye:91}, and whose game tree is given
in Figure~\ref{fig:poker}.  

\begin{figure}[htp]
\label{fig:poker}
\psfig{figure=poker.ps,height=2in}
\vspace{.25in}
\begin{verbatim} 
                         Game Description:

Fred (Player 1) and Alice (Player 2) each ante $1.00 into the pot.
Fred draws a card from a deck; Fred observes the card; Alice does not. 
Fred moves:
  If Fred Folds, 
    Fred wins the pot if his card is Red (net gain of $1.00 to Fred).
    Fred loses the pot if his card is Black (net loss of $1.00 to Fred).
  If Fred Raises, then Fred throws a dollar in the pot, and Alice moves:
    If Alice Passes, then Fred wins the pot (net gain of $1.00 to Fred)
    If Alice Meets, she throws a dollar in the pot; Fred must show the card: 
      If the card is Red Fred wins the pot (net gain of $2.00 to Fred).
      If the card is Black Alice wins the pot (net loss of $2.00 to Fred)
\end{verbatim}
\caption{A simple poker game}
\end{figure}
\medskip

To construct this game, first we create a new game, and the players.
We create the players separately, using \texttt{NewPlayer} so that we
have variables to refer to them later:

\begin{verbatim}
e := NewEfg[];
fred := NewPlayer[ e, "Fred"];
alice := NewPlayer[e,"Alice"];
\end{verbatim}

Now, we iteratively add moves to the game, by creating an information
set with a template for the move, and then adding that move to the
game at the appropriate histories: 

\begin{verbatim}
deal := NewInfoset[ Chance[e], {"Red", "Black"}];
AddMove[deal,RootNode[e]];
fredmove := NewInfoset[ fred , {"Raise", "Fold"} ];
AddMove[ fredmove, TerminalNodes[e]];
alicemove := NewInfoset[ alice , {"Meet", "Pass"} ];
fredraised:=Filter[t:=TerminalNodes[e],Name[PriorAction[t]]="Raise"]
AddMove[alicemove,fredraised];
\end{verbatim}

In the above, the first move, \verb+deal+, is a chance move. It is
added at the root node of the game.  The second move is called
\verb+fredmove+, and is added at the terminal nodes of the tree, since
Fred gets to take this move for any draw of the card.  Since there are
two terminal nodes the call to \texttt{AddMove}  here is a listable call,
and adds the move to both terminal nodes of the tree.  The third move
is called \verb+alicemove+.  Alice only gets to move if Fred chooses
to raise.  So the step computing \verb+fredraised+ identifies all of
the terminal nodes whose prior action was named \verb+"Raise"+.  The
move \verb+alicemove+ is added at all of these nodes, via a listable
call to \verb+AddMove+.  At this point, if you execute the command

\begin{verbatim}
Display[e]
\end{verbatim}

\noindent
you can bring up the Gambit GUI to view a graphics display of the game
in it's current state. You will see that the game tree looks like that
in Figure~\ref{fig:poker}, except there are no payoffs yet, and Fred
only has one information set.  This is because you did not yet account
for the fact that the deal is revealed to Fred.  You can reveal the
deal to Fred (but not to Alice) via

\begin{verbatim}
Reveal[deal,{fred}];
\end{verbatim}

\noindent
and if you now display the game, then except for the fact that no
payoffs have yet been defined, the game tree should look like that in
Figure~\ref{fig:poker}.  Note that an alternate way to get the
information structure correct is to create separate information sets
for Fred's moves from the outset.  So, the commands 

\begin{verbatim}
fredmove := NewInfoset[ fred , {"Raise", "Fold"} ];
AddMove[ fredmove, TerminalNodes[e]];
\end{verbatim}

\noindent
in the above example, could be replaced with:

\begin{verbatim}
fredred := NewInfoset[ fred , {"Raise", "Fold"} ];
fredblack := NewInfoset[ fred , {"Raise", "Fold"} ];
AddMove[ fredred, RootNode[e]#1];
AddMove[ fredblack, RootNode[e]#2];
\end{verbatim}

\noindent
(Here, the short form \verb+n#j+ for
\verb+NthChild[n,j]+\texttt{NthChild} is used to refer to the
\verb+j+th child of node \verb+n+).  A move from the information set
\verb+fredred+ is added to the first child of the root node (which is
the action for chance in which the red card is selected) and a move
from the second information set \verb+fredblack+ is added to the
second child of the root node.  Now, since two separate information
sets for Fred are created from the outset, there is no need to reveal
the deal to Fred.  As with life in general, in the GCL there is
usually more than one way to skin a cat.

To complete construction of this game, we must now add payoffs. This
can be done with the following sequence of commands. 

\begin{verbatim}
ante := 1.00;
raise := 1.00;
win := SetPayoffs[NewOutcome[e, "Win"],{ante,-ante}];
winbig := SetPayoffs[NewOutcome[e, "Win Big"],{ante+raise,-ante-raise}];
lose := SetPayoffs[NewOutcome[e, "Lose"],{-ante,ante}];
losebig := SetPayoffs[NewOutcome[e, "Lose Big"],{-ante-raise,ante+raise}];
SetOutcome[TerminalNodes[e],{winbig,win,win,losebig,win,lose}]
\end{verbatim}

This example has shown how to construct a simple game without any
recursive structure.  This game would be easier to create in the
Gambit GUI.  The usefulness of the GCL in constructing games comes
when the game is larger, or has some repetitive structure to it.  In
Appendix A, part 1, we give an example showing how to construct a multi stage
holdout game using user defined functions. 

\subsection{Saving and loading extensive forms}\index{Extensive forms!loading}\index{Extensive forms!saving}

Once an extensive form game has been constructed, it can be saved by
the command 

\begin{verbatim}
SaveEfg[e, "filename.efg" ]
\end{verbatim}

\noindent where \verb+e+ is the extensive form game, and
\verb+filename.efg+ is the filename of the file to be created.  It is
recommended that the filename extension \verb+.efg+ be used when
saving extensive form games, as the Gambit graphics user interface
recognizes this extension as containing extensive form games.  Once an
extensive form game has been saved to an external file, it can be
loaded by the command \texttt{LoadEfg}, as follows:

\begin{verbatim}
e := LoadEfg["filename.efg" ]
\end{verbatim}

\section{Creating a normal form from an extensive form}\index{Normal
forms!creating!from extensive form}

A normal form game can also be created from an extensive form game.
If \verb+e+ is an extensive form game, then the command 

\begin{verbatim}
n := Nfg[e]
\end{verbatim}

\noindent
will create a normal form game \verb+n+ which is the reduced normal
form game associated with the extensive form game \verb+e+.  

Strategies in the reduced normal form are given default names
consisting of a series of digits, where the \verb+j+th digit in the
strategy name corresponds to the branch number taken at the player's
\verb+j+th information set.  To illustrate, here we create the reduced
normal form of the game of poker encountered earlier.  

\begin{verbatim}
GCL1:= e:=LoadEfg["poker.efg"]
GCL2:= << Name[Actions[e]]
{ { { Raise, Fold }, { Raise, Fold } },
  { { Meet, Pass } } }
GCL3:= n:=Nfg[e];
GCL4:= << Name[Strategies[n]]
{ { 11, 12, 21, 22 },
  { 1, 2 } }
\end{verbatim}

In the normal form game, player 1 has four strategies.  Player 1's
second strategy has name \verb+12+.  This indicates that the player
took strategy 1 (Raise) in the first information set, and action 2
(Fold) in the second information set.  

When a normal form game \verb+n+ is created from an extensive form
game, the GCL will ``remember'' the extensive form game that \verb+n+
is associated with, as long as neither the extensive or normal form
game is edited.  Any mixed strategy solutions computed on the normal
form game \verb+n+ can be converted back to a behavior strategy of the
game \verb+e+ by using the command \texttt{Behav}.  Thus

\begin{verbatim}
n := Nfg[e];
m := EnumMixedSolve[n];
b := Behav[m]
\end{verbatim}

\noindent
will convert the game \verb+e+ to reduced normal form, solve it using
the \texttt{EnumMixedSolve} algorithm, and then convert all mixed profiles found back
to behavior profiles, and display the list, \verb+b+ of behavior
profiles found. The avove can also be done in one command without saving
intermediate steps as follows:  
  
\begin{verbatim}
b := Behav[EnumMixedSolve[Nfg[e]]]
\end{verbatim}
