%
% $Header$
%
% Description: GCL manual chapter on solving games
%

\chapter{Solving Games}\index{Solving games}

Every finite game has at least one \rindex{Nash
equilibrium}\index{equilibrium!Nash} in either pure or mixed
strategies (\cite{Nash:1950}).  Various refinements of Nash
equilibrium are frequently used to select reasonable equilibria in
games with multiple equilibria.  The most commonly studied refinements
are {\em perfect} and {\em proper} equilibria for normal form games,
and {\em subgame perfect} and {\em sequential} equilibria for
extensive form games\footnote{Definitions of perfect and subgame perfect
equilibria are from \cite{Selten:1975}, proper equilibrium from
\cite{Myerson:78}, and sequential equilibrium from
\cite{KrepsWilson:1982}.  See \cite{vanDamme:1987} or \cite{Mye:91}
for general treatments of refinements.}

The best way to compute an equilibrium depends on many factors, the
most important of which are the number of players, the number of
equilibrium you want to find, and what kind of refinement you are
looking for.  For a detailed discussion of these issues, see
\cite{McKMcL:1996}.  In general, it is easier to solve two person
games than n-person games, it is easier to find one equilibrium than
to find all, and it is easier to find a Nash equilibrium than a
refinement.

The computational complexity of solving for equilibria of games also
typically at least exponential in the number of strategies or actions.
Consequently, you will find it quite easy to build games in Gambit
which cannot be solved (in any reasonable amount of time) by Gambit.

When solving games of any reasonable size, it is therefore good to try
and simplify things as much as possible before launching into a
solution algorithm.  One way of simplifying a game is by reducing the
size of the strategy set by elimination of dominated strategies.  For
extensive form games, a second way of simplifying the problem is by
taking account of the subgame structure of the game, and then
recursively solve the game from the end.

\section{\rindex{Supports} and dominance elimination}\index{Dominance elimination}

The GCL data types \verb+NFSUPPORT+ and \verb+EFSUPPORT+ can be used
to represent a \bindex{support} in a normal or extensive form game.  A
support for a normal form game is a selection of non-empty subsets of
strategies for all players in the game.  A support for an extensive
form game is a selection of non-empty subsets of actions for all
information sets in the game.

The main use of supports is to represent the sets of strategies that
remain after dominated strategies have been eliminated from the game.
All of the built-in functions for solution algorithms in the GCL take
an \texttt{NFSUPPORT} or \texttt{EFSUPPORT} as their first parameter,
hence can be run on any support of the game.

The command \verb+Support[g]+\texttt{Support} returns the full support
of the normal or extensive form game \verb+g+.  The full support is
the support in which no strategies (or actions) have been eliminated.
The function \texttt{UnDominated} can be used to find the dominated
strategies or strategies in a support of a game.  \texttt{UnDominated}
returns a support containing the undominated strategies for each
player (or actions for each information set, in the case of extensive
for games).  By default weak domination is used, and only domination
by pure strategies is considered. By setting one or both of the
optional parameters \verb+strong+ and \verb+mixed+ to true, strong
domination can be used, and domination by mixed strateies can be
considered\footnote{Elimination by mixed strategies is only
implemented for normal form games in this version.}  The following
sequence of commands shows the computation of the full supports and
the support resulting from weak dominance elimination in the extensive
and reduced normal form of the poker example of the previous chapter.

\begin{verbatim}
GCL1:= e:=LoadEfg["poker.efg"]
GCL2:= efsupp:=UnDominated[e]
GCL3:= << Name[Actions[e]]
{ { { Raise, Fold }, { Raise, Fold } },
  { { Meet, Pass } } }
GCL4:= << Name[Actions[efsupp]]
{ { { Raise }, { Raise, Fold } },
  { { Meet, Pass } } }
GCL5:= n:=Nfg[e];
GCL6:= nfsupp:=UnDominated[n];
GCL7:= << Name[Strategies[n]]
{ { 11, 12, 21, 22 },
  { 1, 2 } }
GCL8:= << Name[Strategies[nfsupp]]
{ { 11, 12 },
  { 1, 2 } }
\end{verbatim}

In the above example, for the extensive form game, the action with
name "Fold" is dominated, and eliminated by \verb+UnDominated+.
Correspondingly, in the reduced normal form game, the strategies in
which the first player takes the second action at the first
information set is eliminated.  

A user defined function \texttt{IterativeUnDominated} can be used to
iteratively eliminate dominated strategies in a game, until no further
dominance elimination is possible.  This function returns the final
support.  So the commands

\begin{verbatim}
n:=LoadNfg["mygame.nfg"];
s:=IterativeUnDominated[n,strong->True,mixed->True];
\end{verbatim}

\noindent
will find the set of all strategies that remain after iterative
elimination by mixed strategies of strongly dominated strategies in
the game \verb+n+.

While the main use of supports is to represent strategies that
remain after dominance elimination, you can also construct your own
support for a game using the commands \texttt{RemoveStrategy} and
\texttt{AddStrategy}.

\section{\rindex{Subgames}}

For extensive form games, Gambit recognizes and supports the notion of
a {\bf subgame}.  If \verb+efg+ is an extensive form game, the
command \verb+Subgames[efg]+ returns a list of nodes
representing the roots of valid subgames.

You can control the way the extensive form solution algorithms deal
with subgames by ``marking'' or ``unmarking'' subgames.  All of the
extensive form solution algorithms recursively solve the extensive
form game by subgames, but only for subgames that are marked.  Terminal
marked subgames are solved first, and then for any solution of the
subgame, the parent game is pruned, plugging in the continuation value
generated by the terminal subgame.  The marked subgames that are now
terminal are then recursively solved in a similar manner, and so on,
until the game starting at the root node is reached.  Be warned that
if there are multiple equilibria to each subgame, the size of the set
of solutions to the full game that are generated by this procedure can
be exponential with the number of subgames.

When you first construct a game, the only subgame that is marked is
the root node of the tree.  This node always represents a valid
subgame, and it is not possible to unmark the root node.  If
\verb+node+ is the root of a valid non-trivial subgame, then the
built-in functions \texttt{MarkSubgame} and \texttt{UnMarkSubgame} can be
used to mark and unmark the specific subgames starting at that node.
\texttt{MarkedSubgame} can be used to check if the subgame is marked.
The user defined functions \texttt{MarkSubgames} and
\texttt{UnMarkSubgames} can be used to mark and unmark all valid
subgames in the game.  \texttt{MarkedSubgames} returns a lsit of root
nodes of all currently marked subgames.

The technique of marking subgames can be used to control whether a
solution algorithm that finds Nash equilibria returns any Nash
equilibrium or only subgame perfect Nash equilibria of the game.  If
no subgames are marked, the algorithm will return Nash equilibria
which may not be subgame perfect.  If you first mark all subgames,the
algorithm will return subgame perfect equilibria.

\section{Mixed and Behavior strategy profiles}
\index{Profiles!mixed}\index{Profiles!behav}

The data types \texttt{MIXED} and \texttt{BEHAV} are used to represent
mixed and behavior strategy profiles for normal and extensive form
games, respectively.  Mixed and behavior strategy profiles can be
defined on any support of the game.  A mixed strategy profile is a
specification of a numeric value (usually interpreted as a
probability) for each strategy in the support.  Similarly, a behavior
strategy profile is a specification of a numeric value (usually
interpreted as a probability) for each action in the support.

The simplest way of generating a mixed profile for a game is to use
the built-in function \texttt{Centroid}, which generates a mixed or
behavior strategy profile in which every player adopts each of their
strategies (or each action in an information set) with equal
probability.  For example, if \verb+g+ is a variable representing an
extensive or normal form game, and \verb+s+ is a support for the game
\verb+g+, then the commands \verb+Centroid[g]+ or \verb+Centroid[s]+
generate mixed strategy profiles for the normal form game \verb+nfg+,
and for the support, \verb+s+, respectively.  You can use the built-in
function \texttt{SetStrategyProbs} or \texttt{SetActionProbs} to change
the strategy probabilites for a mixed profile.  You can also use the
standard user defined functions \texttt{Mixed} or \texttt{Behav} to
generate a mixed profile from a nested list of numeric data, as long
as the nested list is of the correct dimensions.

Basic arithmetic operations are defined on mixed and behavior profiles
as well.  So you can take linear combinations of mixed profiles to
create new mixed profiles, as illustrated in this example:

\begin{verbatim}  
GCL1:= n:=Nfg[{{{3,1},{0,0}},{{0,1},{3,0}},{{1,0},{1,3}}}];
GCL2:= << c:=Centroid[n]
(Mixed) { 1/3 1/3 1/3 }{ 1/2 1/2 }
GCL3:= << cc:=Mixed[n,{{1,0,0},{1,0}}]
(Mixed) { 1 0 0 }{ 1 0 }
GCL4:= << m:=1/2*c+1/2*cc
(Mixed) { 2/3 1/6 1/6 }{ 3/4 1/4 }
\end{verbatim}

In most cases, the value assigned to an action or strategy is
interpreted as the probability with which a player adopts the
corresponding action or strategy.  However, the data for \verb+MIXED+
need not be legitimate probabilities.  For example, it would be valid
to create a mixed profile using the command
\verb+Mixed[n,{{1,2,3},{4,5}}]+.  Probabilities are not
required to add up to one, or even to be positive.  This feature is
especially useful in econometric analysis, as the \verb+MIXED+ and
\verb+BEHAV+ data types can be used to represent choice frequencies of
corresponding actions or strategies.  

All of the solution algorithms that operate on games or their supports
return lists of mixed or behavior profiles to representing the
solutions.  Some algorithms compute important additional information
about the profile that may not be recoverable from knowledge of just
the strategy probabilies.  Consequently, the \verb+MIXED+ an
\verb+BEHAV+ data types keep track of who created them, and what
properties are known about them.  A series of functions are available
to query profiles to return this information.  These functions are
listed in section on ``information about solutions'' in the
Categorical Function Reference chapter.  To view all of the
information that is known about a mixed or behavior profile, you can
change the format by which solutions are displayed using the
\texttt{Format} function.

\section{Solution Algorithms}\index{Solving games!Algorithms}

\subsection{\texttt{Enum}}
\index{Algorithms!enumeration!{\tt EnumMixedSolve}}
\index{Algorithms!enumeration!{\tt EnumPureSolve}}

The two \texttt{Enum} functions can be used to enumerate the pure or
mixed Nash equilibria for a normal form game.

The \texttt{EnumPureSolve} function enumerates all pure strategy Nash
equilibria in the support of a normal form game.  This algorithm
simply investigates all pure strategy profiles, checking each for the
Nash equilibrium conditions.  By default, the algorithm finds all pure
strategy Nash equilibrium.  Optionally it can be set to find the first
\verb+k+ Nash equilibria.  This algorithm will work on any normal form
game.

The \texttt{EnumMixedSolve} function enumerates all Nash equilibria (pure
and mixed) for a given support of a two person normal form game.  More
precisely, it finds the set of extreme Nash equilibria, as defined in
\cite{Man:64}.  For any normal form game, as shown in
Mangasarian, every Nash equilibrium can be expressed as a convex
combination of the extreme Nash equilibria.  For generic games, there
are just a finite number of Nash equilibria, which coincide with the
extreme equilibria.  By default, all extreme equilibria are found.
Optionally, the algorithm can be set to find the first \verb+k+
equilibria.  This algorithm works only on two-person normal form
games.

\subsection{Quantal Response Equilibrium}
\index{Algorithms!quantal response!{\tt QreSolve}}
\index{Algorithms!quantal response!{\tt QreGridSolve}}

The \texttt{QreSolve} function computes a branch of the logistic
quantal response equilibrium correspondence (as described in
\cite{McKPal:95a} for normal form games, and in
\cite{McKPal:95b} for extensive form games.  The branch is
computed for values of $\lambda$ between $\underline{\lambda}$ and
$\bar{\lambda}.$ The algorithm starts at $\lambda_0 =
\underline{\lambda}$ if $\delta>0,$ or $\lambda_0 = \bar{\lambda}$ if
$\delta<0$. It then increments according to the formula
$$
\lambda_{t+1} = \lambda_t +\delta \lambda_t^a,
$$ 
where $\underline\lambda,$ $\bar\lambda,$ $\delta,$ and $a$ are
parameters that can be specified.  In the computation for the first value of
$\lambda_0$, the algorithm begins its search for a solution at a user
specified starting point.  At each
successive value of $\lambda_t,$ the algorithm begins its search at
the point found in step $t - 1.$ 

The {\em principal branch} of the logistic quantal response
equilibrium mapping is the branch that is connected to the centroid of
the game at $\lambda = 0$.  This branch can be computed by setting
$\lambda_0$ sufficiently small.  As discussed in McKelvey and Palfrey,
for generic normal form games, the principal branch of the quantal
response equilibrium correspondence converges to a unique selection
from the set of Nash equilibria as $\lambda$ goes to infinity.
Similarly, for generic extensive form games, the principal branch of
the quantal response mapping converges to a unique selection from the
set of sequential equilibria as $\lambda$ goes to infinity.  Hence, in
extensive form games, this algorithm can be used to compute an
approximation to a sequential equilibrium.

The \texttt{QreGridSolve} function performs a two stage grid search to
compute the {\em complete} logistic quantal response correspondence.
Points are evaluated in terms of the value of an objective function,
that measures the distance between the original point, and the best
response to the best response (under the logistic best response
function.)  Points that are close (within 'tol') to being fixed points
are kept, others are discarded.  A two stage procedure is used, in
which the entire space is searched on a course grid of mesh 'delp1'.
Any points on the course grid for which the value of the objective
function is less than 'tol1' are then searched on a finer grid of mesh
'delp2' around that point.  Points on the finer grid for which the
value of the objective function is below 'tol2' = 'tol' are kept.
This procedure is very computationally intensive, and is only feasible
for small two-person normal form games.

\subsection{Linear Complementarity Program}
\index{Algorithms!linear complementarity!{\tt LcpSolve}}

The \texttt{LcpSolve} function formulates and solves the game as a linear
complementarity problem.  This algorithm works for two person
games in either extensive or normal form.  
 
For a normal form game, the game is solved via the Lemke-Howson
Algorithm.  (See, eg.,
\cite{LemHow:64}) using lexicographic rule for insuring
termination, as developed in \cite{Eav:71}.  This algorithm can also
be used to find the set of {\em accessible} Nash equilibria, by
tracing out the pattern of connectedness of the complemenary basic
feasible solutions, as described in \cite{Sha:74}.  The set of
accessible equilibria is frequently the same as the set of all Nash
equilibria, but this is not always so.

For an extensive form game, this algorithm implements Koller, Megiddo
and von Stengel's {\em sequence form} (\cite{KolMegSte:94}. The
sequence form is a formulation of the set of Nash equilibria as the
solution to a non linear complementarity problem in variables that
correspond to ``sequences'' in the extensive form, which they show can
be solved by Lemke's algorithm (\cite{Lem:65}) for linear
complementarity problems.  The method has nice properties in terms of
its computational complexity, as it only grows linearly in the size of
the extensive form game.

\subsection{Lyapunov Function}
\index{Algorithms!Lyapunov function!{\tt LiapSolve}}

The \texttt{LiapSolve} function finds Nash equilibria via the Lyapunov
function method described in \cite{McK:91}.  This method works on
either the extensive or normal form.  This algorithm casts the problem
as a function minimization problem by use of a Lyapunov function for
Nash equilibria.  This is a continuously differentiable non negative
function whose zeros coincide with the set of Nash equilibria of the
game.  A standard descent algorithm is used to find a constrained
local minimum of the function from any given starting location.  Since
a local minimum need not be a global minimum (with value 0,) the
algorithm is not guaranteed to find a Nash equilibrium from any fixed
starting point.  The algorithm thus incorporates the capability of
restarting.  The algorithm starts from the initial starting point
determined by the parameter 'start'.  If a Nash equilibrium is not
found, it will keep searching from new randomly chosen starting points
until the desired number of Nash equilibria have been found or the
maximum number of tries (\verb+nTries+) is exceeded, whichever
comes first.

\subsection{Linear Program}
\index{Algorithms!linear programming!{\tt LpSolve}}

The \texttt{LpSolve} algorithm finds the minimax solution (a Nash
equilibrium) for a two person constant-sum game in normal form, by
solving it as a linear program.

\subsection{Simpicial Subdivision}
\index{Algorithms!simplicial subdivision!{\tt SimpDivSolve}}

The \texttt{SimpDivSolve} algorithm computes a Nash equilibrium to a
n-person normal form game based on a simplicial subdivision algorithm.
The algorithm implemented is that of \cite{VTH:1987}.  The algorithm
is a simplicial subdivision algorithm which can start at any point in
the simplex.  The algorithm starts with a given grid size, follows a
path of almost completely labeled subsimplexes, and converges to a
completely labeled sub-simplex that approximates the solution.
Additional accuracy is obtained by refining the grid size and
restarting from the previously found point.  The idea is that by
restarting at a close approximation to the solution, each successive
increase in accuracy will yield a short path, and hence be quick.

In its pure form, the algorithm is guaranteed to find at least one
mixed strategy equilibrium to any n-person game.  Experience shows
that the algorithm works well, and is acceptably fast for many
moderate size problems.  But in some examples it can be quite slow.
The reason for this is that sometimes after restarting with a refined
grid size, even though the starting point is a good approximation to
the solution, the algorithm will go to the boundary of the simplex
before converging back to a point that is close to the original
starting point.  When this occurs, each halving of the grid size will
take twice as long to converge as the previous grid size.  If a high
degree of accuracy is required, or if the normal form is large, this
can result in the algorithm taking a long time to converge.

In order to combat the above difficulty, a parameter 'leash' has been
added to the algorithm which places a limit on the distance which the
algorithm can wander from the restart point. (Setting this parameter
to 0 results in no limit, and gives the pure form of the algorithm.)
With this parameter set to a non trivial value, the algorithm is no
longer guaranteed to converge, and setting small values of the
parameter will sometimes yield lack of convergence.  However,
experience shows that values of the parameter on the order of 10
generally do not destroy convergence, and yield much faster
convergence.

\section{Computing Nash equilibria and refinements}\index{Nash equilibrium}
\index{equilibrium!refinements}

As mentioned above, the appropriate algorithm to use to compute a
particular kind of Nash equilibrium depends on a number of different
factors, such as the number of players in the game, how many
equilibria are desired, and whether one wants to find refinements.  In
addition, in some cases it may be advantageous to eliminate dominated
strategies or mark subgames before proceeding.

For each of a number of common equilibrium refinements, the GCL
provides standard user defined functions to compute either one or ``all''
equilibria of the given type.  These user defined functions pick the
appropriate algorithm for the required computation, and select the
type of dominance elimination and subgame marking for the desired
computation.

\subsection{Normal form equilibria}\index{equilibrium!refinements!normal form}

For normal form games, the GCL provides standard user defined
functions for the computation of Nash equilibria\index{Nash
equilibrium} (\texttt{OneNash} and \texttt{AllNash}), and perfect
equilibria (\texttt{OnePerfect}, \texttt{AllPerfect})\footnote{The
functions for computing perfect equilibrium are only implemented for
two person games}.  Table 5 gives the settings that are used for these
UDFs.

\medskip
\begin{center}
\begin{tabular}{|l|l|p{2cm}|l|l|}
\hline
Type & UnDominated & Game Type & Algorithm & Notes \\
\hline
OneNash & Weak & 2-person const sum & Lp & \\ \cline{3-5}
        &      & 2-person general  sum & Lcp& \\ \cline{3-5}
        &      & n person              & SimpDiv & \\
\hline
AllNash & Strong & 2 person       & EnumMixed & \\ \cline{3-5}
        &        & n person       & Liap      & Not guaranteed\\
\hline
\hline
OnePerfect & Weak & 2 person     & Lcp    & \\ \cline{3-5}
           &        & n person     &     &Not implemented  \\
\hline
AllPerfect & Weak & 2 person      & EnumMixed & \\ \cline{3-5}
           &        & n person      &     & Not implemented\\
\hline
\multicolumn{5}{c}{\ }\\
\multicolumn{5}{c}{Table 5}\\
\multicolumn{5}{c}{Standard UDFs for normal form equilibria}\\
\end{tabular}
\end{center}
\medskip

The standard user defined functions for finding ``all'' equilibria
should be used with some care.  These algorithms are sometimes not
guaranteed to find all solutions if they are terminated by the user
(see Table 5).  Rather, these functions for computing ``all''
equilibria will only find all equilibria (for generic games) in a weak
probabilistic sense: Given any number less than one, there is an
amount of time such that if the algorithm is run for at least that amount of
time it will find all solutions with probability higher than the given
number.  However, for an arbitrary game, there is no way of knowing
{\it a priori} how long to run the algorithm in order to achieve the
desired probability.  

For example in $n$ person games, with $n$ greater than two, there are
no algorithms yet implemented in Gambit to find all equilibria in a
finite amount of time.  In these cases, the corresponding user defined
function is designed to enter an infinite loop, continuing to search
for new solutions from new random starting points as long as you are
willing to wait (see documentation in function reference section).
The algorithm can be terminated by a \verb+ctrl-C+ from the console.
These functions (for computing all equilibria) have two optional
arguments, \verb+stopAfter+ to specify the maximum number of
equilibria to find before stopping, and \verb+nTries+ to specify the
maximum number of attempts to find equilibria before stopping. If
either of these parameters is set to a positive value, then the
computation will stop when the parameter reaches the specified value.
So for a three person game \verb+n+, the command
\verb+AllNash[n,2,10]+ will compute a maximum of two Nash equilibria,
taking at most ten tries to do so, whereas the command
\verb+AllNasn[n]+ will enter an infinite loop, continuing to search
for new equilibria until you terminate execution.

\subsection{Extensive form equilibria}
\index{equilibrium!refinements!extensive form}

For extensive form games, the GCL provides standard user defined
functions for the computation of Nash equilibria\index{Nash
equilibrium} (\texttt{OneNash} and \texttt{AllNash}), subgame perfect
equilibria (\texttt{OnePerfect}, \texttt{AllPerfect}), and sequential
equilibria (\texttt{OneSequential},
\texttt{AllSequential})\footnote{The functions for computing perfect
equilibrium are only implemented for two person games}.  Table 6 gives
the settings that are used for these UDFs.  

\medskip
\begin{center}
\begin{tabular}{|l|l|l|p{2cm}|l|l|}
\hline
Type & Subgames & UnDominated & Game Type & Algorithm & Notes\\
\hline
OneNash & Mark & Weak &  2-person const sum & EF/Lp &\\ \cline{4-6}
        &      &      &  2-person general sum & EF/Lcp &\\ \cline{4-6}
        &      &      &  n-person             & NF/SimpDiv &\\
\hline
AllNash &  UnMark & Strong &  2-person       & NF/EnumMixed &\\ \cline{4-6}
        &         &        &  n-person       & NF/Liap &Not guaranteed\\
\hline
\hline
OneSubgamePerfect &  Mark & Weak &  2-person const sum& EF/Lp &\\ \cline{4-6}
                  &       &      &  2-person general sum & EF/Lcp &\\ \cline{4-6}
                  &       &      &  n-person        & NF/SimpDiv &\\
\hline
AllSubgamePerfect &  Mark & Strong &  2-person    & NF/EnumMixed &\\ \cline{4-6}
                  &       &        &  n-person    & NF/Liap &Not guaranteed\\
\hline
\hline
OneSequential &  UnMark & None &  2 or n-person   & EF/Qre &\\ \cline{4-6}
\hline
AllSequential &         &       &  2 or n-person   & EF/Liap &Not guaranteed\\
\hline
\multicolumn{6}{c}{\ }\\
\multicolumn{6}{c}{Table 6}\\
\multicolumn{6}{c}{Standard UDFs for extensive form equilibria}\\
\end{tabular}
\end{center}
\medskip

In Table 6, the column headed ``Subgames'' indicates whether all
subgames are marked or unmarked before solving.  In the column headed
``algorithm'', the prefix \verb+EF+ or \verb+NF+ on the algorithm
indicates whether the game is first converted to normal form before
solving.  For example to find all Nash equilibria of a two person
extensive form game, all subgames are unmarked, the game is converted
to normal form, strongly dominated strategies are iterateively
eliminated, and the resulting game is then solved with the
\verb+EnumMixed+ algorithm.  The resulting set of mixed strategies is
converted back to behavior strategies of the original extensive form
game.  Inspection of the body of the UDF, which is given in the
Function Reference section of the manual (or via the
\verb+Manual["AllNash"]+ command) will reveal the details:

\begin{verbatim}
ms:=MarkedSubgames[e];UnMarkSubgames[e];
s:=IterativeUnDominated[Nfg[e],strong->True];
If[NumPlayers[e] = 2, 
  m:=EnumMixedSolve[s,0,precision],
  << InfiniteLoopWarning[stopAfter,nTries];
  m:=LiapSolve[Centroid[s],stopAfter,nTries]
];
MarkSubgames[ms];Behav[m]
\end{verbatim} 

Note that some of the settings for the UDFs of Table 6 are chosen for
efficiency in particular problems.  But they may not result in the
fastest solution in all cases.  For example, in the above example, for
$n$-person games, \verb+AllNash+ applies \verb+LiapSolve+ to the normal form.
In many cases, it may be better to apply \verb+LiapSolve+ directly to
the extensive form.  You can easily define a UDFs to suit your own
needs (or redefine the standard UDFs) if you find this to be the case
in the problems you work with.  

As in the normal form case, the functions for computing all equilibria
of extensive form games are sometimes not guaranteed to find all
solutions in finite time (see Table 6).  In these cases, the same
comments that are made in the section on normal form solution
algorithms apply here: The corresponding user defined function is
designed to enter an infinite loop, continuing to search for new
solutions from new random starting points as long as you are willing
to wait (see documentation in function reference section).  The
algorithm can be terminated by a \verb+ctrl-C+ from the console.  As
with the normal form functions, these functions (for computing all
equilibria) have two optional arguments, \verb+stopAfter+ to specify
the maximum number of equilibria to find before stopping, and
\verb+nTries+ to specify the maximum number of attempts to find
equilibria before stopping. If either of these parameters is set to a
positive value, then the computation will stop when the parameter
reaches the specified value.

\section{Solution information}
\index{Solutions!information}

Once a game has been solved, there are a number of functions for
finding out information about the solution.  A full list is given in
the section on Solution information in the function reference section.
Some of the more important functions are given in Table 7. 

\begin{table}[htp]
\begin{center}
\begin{tabular} {|l||l|} \hline
Function Name	& Description \\ 
\hline
\verb+  ActionProb[b,a]+ & Prob of action \verb+a+ for profile \verb+b+\\
\verb+# ActionProbs[b]+ & Nested list of all action probs for \verb+b+ \\ 
\verb+  ActionValue[b,a]+ & Value of action \verb+a+ for profile \verb+b+\\ 
\verb+# ActionValues[b]+ & Nested list of all action values for \verb+b+ \\ 
\verb+  Belief[b,n]+ & Prob of node \verb+n+ conditional on its
infoset under \verb+b+\\ 
\verb+# Beliefs[b]+ & Nested list of all beliefs under \verb+b+\\ 
\verb+  Behav[m]+ & \verb+Behav profile associated with mixed profile \verb+m+\\
\verb+  InfosetProb[b,i]+ & Probability of information set \verb+i+
under \verb+b+\\ 
\verb+# InfosetProbs[b]+ & Nested list of all infoset probabilities\\
\verb+  InfosetValue[b,i]+ & Value of information set \verb+i+
under \verb+b+\\ 
\verb+# InfosetValues[b]+ & Nested list of all infoset values
for \verb+b+\\ 
\verb+  IsNash[p]+ &\verb+True+ if \verb+p+ is known to be Nash\\
\verb+  IsPerfect[m]+ &\verb+True+ if \verb+m+ is known to be perfect\\
\verb+  IsSequential[b]+ &\verb+True+ if \verb+b+ is known sequential\\
\verb+  IsSubgamePerfect[b]+ &  \verb+True+ if \verb+b+ is known subgame perfect\\ 
\verb+  NodeValue[b,p,n]+ & Value of \verb+b+ to player \verb+p+ at
node \verb+n+\\ 
\verb+# NodeValues[b,n]+ & List of values of \verb+b+ to all players at node \verb+n+\\
\verb+# NodeValues[b,p]+ & List of values of \verb+b+ to player \verb+p+ at all nodes\\
\verb+  Payoff[p,pl]+ & Payoff of profile \verb+p+ for player \verb+pl+\\
\verb+# Payoffs[p]+ & List of payoffs to all players of profile \verb+p+\\
\verb+  RealizProb[b,n]+ & Probability of reaching node \verb+n+ under \verb+b+\\
\verb+# RealizProbs[b]+ & Realization probabilites of all nodes under \verb+b+\\ 
\verb+  SetActionProbs[b,i.v]+ & Sets action probabilies of \verb+b+ at infoset \verb+i+ to \verb+v+\\
\verb+  SetStrategyProbs[m,p,v]+ & Sets strategy probs of \verb+m+ for
player \verb+p+ to \verb+v+\\
\verb+  StrategyProb[m,s]+ & Probability of strategy \verb+s+ under \verb+m+ \\
\verb+  StrategyProbs[m]+ & Nested list of all strategy probs for \verb+m+\\
\hline
\multicolumn{2}{c}{\ }\\
\multicolumn{2}{c}{Table 7}\\
\multicolumn{2}{c}{Solution information functions}\\
\end{tabular}
\end{center}
\end{table}
\medskip

