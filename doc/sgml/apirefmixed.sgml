<sect1 id="apiref.mixed">
<title>Mixed strategy profiles</title>

<para>
</para>

<sect2 id="apiref.mixed.getcreator">
<title>GetCreator</title>
<indexterm><primary>GetCreator</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtText MixedSolution::GetCreator(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetCreator</function> returns a text string identifying the algorithm used to create
the profile.  A profile created or modified by the user is identified by
<literal>User</literal>.
</para>

</sect2>
	
<sect2 id="apiref.mixed.getgame">
<title>GetGame</title>
<indexterm><primary>GetGame</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtNfgGame MixedSolution::GetGame(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetGame</function> 
returns the normal form game to which the profile belongs.
</para>

</sect2>


<sect2 id="apiref.mixed.getlabel">
<title>GetLabel</title>
<indexterm><primary>GetLabel</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtText MixedSolution::GetLabel(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetLabel</function>
returns the text label of the profile.  
The empty string is returned if the profile object is null.
</para>

</sect2>


<sect2 id="apiref.mixed.getliapvalue">
<title>GetLiapValue</title>
<indexterm><primary>GetLiapValue</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtNumber MixedSolution::GetLiapValue(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>LiapValue</function>
returns the Lyapunov function value for <parameter>profile</parameter>.
This is a nonnegative value which is zero exactly when the
profile is a Nash equilibrium.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>


<sect2 id="apiref.mixed.getpayoff">
<title>GetPayoff</title>
<indexterm><primary>GetPayoff</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtNumber MixedSolution::GetPayoff(gbtNfgPlayer p_player) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetPayoff</function> returns the expected payoff to player
<parameter>player</parameter>, when all players play according to
the profile.  An error occurs if the parameters are
not from the same game.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>


<sect2 id="apiref.mixed.getstrategyprob">
<title>GetStrategyProb</title>
<indexterm><primary>GetStrategyProb</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtNumber MixedSolution::GetStrategyProb(gbtNfgStrategy p_strategy) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetStrategyProb</function>
returns the probability
that <parameter>strategy</parameter> is chosen when all players are
following <parameter>profile</parameter>.  It is an error if
<parameter>profile</parameter> and <parameter>strategy</parameter> are
not from the same normal form game.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if the probability specified in the profile is rational.
</para>
</note>

</sect2>

<sect2 id="apiref.mixed.getstrategyvalue">
<title>GetStrategyValue</title>
<indexterm><primary>GetStrategyValue</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtNumber MixedSolution::GetStrategyValue(gbtNfgStrategy) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetStrategyValue</function>
returns the expected
payoff to a player (who is in control of the strategy set including
<parameter>strategy</parameter>) of choosing
<parameter>strategy</parameter> when all players are following
<parameter>profile</parameter>.  It is an error if
<parameter>profile</parameter> and <parameter>strategy</parameter> are
not from the same normal form game.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>


<sect2 id="apiref.mixed.isnash">
<title>IsNash</title>
<indexterm><primary>IsNash</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtTriState MixedSolution::IsNash(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>IsNash</function>
returns <literal>True</literal> when <parameter>profile</parameter>
is known by Gambit to be a
Nash equilibrium of the corresponding game, and <parameter>False</parameter>
if <parameter>profile</parameter> is known to not be Nash.
Otherwise, the return value
is <literal>Unknown</literal>. 
If <parameter>profile</parameter> is complete (probabilities sum
to one for every player, and every information set), then there is a
definitive test for Nash equilibrium.  However if the profile is
incomplete (i. e., it does not specify actions at off the equilibrium
path information sets), then it is possible that a profile (or set of
all completions of the profile) may be Nash, but is not known by
Gambit to be Nash.
</para>

<note>
<para>
The Python implementation returns a value of <literal>1</literal> for
<literal>True</literal>, <literal>0</literal> for <literal>False</literal>,
and <literal>-1</literal> for <literal>Unknown</literal>.
</para>
</note>

</sect2>


<sect2 id="apiref.mixed.isperfect">
<title>IsPerfect</title>
<indexterm><primary>IsPerfect</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtTriState MixedSolution::IsPerfect(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>IsPerfect</function>
returns <literal>True</literal> if <parameter>profile</parameter>
is known by Gambit to be a
perfect Nash equilibrium, <literal>False</literal> if it is known to not be
perfect, and <literal>Unknown</literal> otherwise.  There is currently no
definitive test in Gambit for whether an arbitrary profile is perfect.
However some of the algorithms (notably <function>LcpSolve</function>)
will only
return perfect equilibria, which are marked as such.   
</para>

<note>
<para>
The Python implementation returns a value of <literal>1</literal> for
<literal>True</literal>, <literal>0</literal> for <literal>False</literal>,
and <literal>-1</literal> for <literal>Unknown</literal>.
</para>
</note>

</sect2>


<sect2 id="apiref.mixed.isproper">
<title>IsProper</title>
<indexterm><primary>IsProper</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtTriState MixedSolution::IsProper(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>IsProper</function>
returns <literal>True</literal> if <parameter>profile</parameter>
is known by Gambit to be a
proper Nash equilibrium, <literal>False</literal> if it is known to not be
proper, and <literal>Unknown</literal> otherwise.  There is currently no
definitive test in Gambit for whether an arbitrary profile is proper.
However some algorithms will only
return proper equilibria, which are marked as such.   
</para>

<note>
<para>
The Python implementation returns a value of <literal>1</literal> for
<literal>True</literal>, <literal>0</literal> for <literal>False</literal>,
and <literal>-1</literal> for <literal>Unknown</literal>.
</para>
</note>

</sect2>

<sect2 id="apiref.mixed.setlabel">
<title>SetLabel</title>
<indexterm><primary>SetLabel</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void MixedSolution::SetLabel(const gbtText &amp;p_label)
</synopsis>
</para>
</formalpara>

<para>
<function>SetLabel</function> sets the text label of the profile.
</para>

</sect2>


<sect2 id="apiref.mixed.setstrategyprob">
<title>SetStrategyProb</title>
<indexterm><primary>SetStrategyProb</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void MixedSolution::SetStrategyProb(gbtNfgStrategy, gbtNumber)
</synopsis>
</para>
</formalpara>

<para>
<function>SetStrategyProb</function>
sets the component of <parameter>profile</parameter> for 
<parameter>strategy</parameter> to be equal
to <parameter>value</parameter>.  It is an error if <parameter>profile</parameter> and <parameter>strategy</parameter>
are not from the same normal form game.  Returns <parameter>profile</parameter>.
</para>

</sect2>

</sect1>
