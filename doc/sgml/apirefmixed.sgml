<sect1 id="apiref.mixed">
<title>Mixed strategy profiles</title>

<para>
</para>

<sect2 id="apiref.mixed.getcreator">
<title>GetCreator</title>
<indexterm><primary>GetCreator</primary></indexterm>
<indexterm><primary>Creator (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gText MixedSolution::GetCreator(void) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
Creator[profile->MIXED] =: TEXT
</synopsis>
</para>
</formalpara>

<para>
<function>GetCreator</function> (<function>Creator</function> in the
GCL) returns a text string identifying the algorithm used to create
the profile.  A profile created or modified by the user is identified by
<literal>User</literal>.
</para>

</sect2>
	
<sect2 id="apiref.mixed.getgame">
<title>GetGame</title>
<indexterm><primary>GetGame</primary></indexterm>
<indexterm><primary>Game (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtNfgGame MixedSolution::GetGame(void) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
Game[profile->MIXED] =: NFG
</synopsis>
</para>
</formalpara>

<para>
<function>GetGame</function> (or <function>Game</function> in the GCL)
returns the normal form game to which the profile belongs.
</para>

</sect2>


<sect2 id="apiref.mixed.getlabel">
<title>GetLabel</title>
<indexterm><primary>GetLabel</primary></indexterm>
<indexterm><primary>Name (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gText MixedSolution::GetLabel(void) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
This function is not available in the GCL.
</para>
</formalpara>

<para>
<function>GetLabel</function>
returns the text label of the profile.  
The empty string is returned if the profile object is null.
</para>

</sect2>


<sect2 id="apiref.mixed.getliapvalue">
<title>GetLiapValue</title>
<indexterm><primary>GetLiapValue</primary></indexterm>
<indexterm><primary>LiapValue (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber MixedSolution::GetLiapValue(void) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
LiapValue[profile->MIXED] =: NUMBER 
</synopsis>
</para>
</formalpara>

<para>
<function>LiapValue</function>
returns the Lyapunov function value for <parameter>profile</parameter>.
This is a nonnegative value which is zero exactly when the
profile is a Nash equilibrium.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>


<sect2 id="apiref.mixed.getpayoff">
<title>GetPayoff</title>
<indexterm><primary>GetPayoff</primary></indexterm>
<indexterm><primary>Payoff (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber MixedSolution::GetPayoff(gbtNfgPlayer p_player) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
Payoff[profile->MIXED, player->NFPLAYER] =: NUMBER 
</synopsis>
</para>
</formalpara>

<para>
<function>GetPayoff</function> (<function>Payoff</function> in the
GCL) returns the expected payoff to player
<parameter>player</parameter>, when all players play according to
the profile.  An error occurs if the parameters are
not from the same game.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>


<sect2 id="apiref.mixed.getstrategyprob">
<title>GetStrategyProb</title>
<indexterm><primary>GetStrategyProb</primary></indexterm>
<indexterm><primary>StrategyProb (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber MixedSolution::GetStrategyProb(gbtNfgStrategy p_strategy) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
StrategyProb[profile->MIXED, strategy->STRATEGY] =: NUMBER 
</synopsis>
</para>
</formalpara>

<para>
<function>GetStrategyProb</function>
(<function>StrategyProb</function> in the GCL) returns the probability
that <parameter>strategy</parameter> is chosen when all players are
following <parameter>profile</parameter>.  It is an error if
<parameter>profile</parameter> and <parameter>strategy</parameter> are
not from the same normal form game.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if the probability specified in the profile is rational.
</para>
</note>

</sect2>

<sect2 id="apiref.mixed.getstrategyvalue">
<title>GetStrategyValue</title>
<indexterm><primary>GetStrategyValue</primary></indexterm>
<indexterm><primary>StrategyValue (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber MixedSolution::GetStrategyValue(gbtNfgStrategy) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
StrategyValue[profile->MIXED, strategy->STRATEGY] =: NUMBER 
</synopsis>
</para>
</formalpara>

<para>
<function>GetStrategyValue</function>
(<function>StrategyValue</function> in the GCL) returns the expected
payoff to a player (who is in control of the strategy set including
<parameter>strategy</parameter>) of choosing
<parameter>strategy</parameter> when all players are following
<parameter>profile</parameter>.  It is an error if
<parameter>profile</parameter> and <parameter>strategy</parameter> are
not from the same normal form game.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>


<sect2 id="apiref.mixed.isnash">
<title>IsNash</title>
<indexterm><primary>IsNash</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gTriState MixedSolution::IsNash(void) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
IsNash[profile->MIXED] =: BOOLEAN 
</synopsis>
</para>
</formalpara>

<para>
<function>IsNash</function>
returns <literal>True</literal> when <parameter>profile</parameter>
is known by Gambit to be a
Nash equilibrium of the corresponding game, and <parameter>False</parameter>
if <parameter>profile</parameter> is known to not be Nash.
Otherwise, the return value
is <literal>Unknown</literal>. 
If <parameter>profile</parameter> is complete (probabilities sum
to one for every player, and every information set), then there is a
definitive test for Nash equilibrium.  However if the profile is
incomplete (i. e., it does not specify actions at off the equilibrium
path information sets), then it is possible that a profile (or set of
all completions of the profile) may be Nash, but is not known by
Gambit to be Nash.
</para>

<note>
<para>
The Python implementation returns a value of <literal>1</literal> for
<literal>True</literal>, <literal>0</literal> for <literal>False</literal>,
and <literal>-1</literal> for <literal>Unknown</literal>.
</para>
</note>

</sect2>


<sect2 id="apiref.mixed.isperfect">
<title>IsPerfect</title>
<indexterm><primary>IsPerfect</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gTriState MixedSolution::IsPerfect(void) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
IsPerfect[profile->MIXED] =: BOOLEAN 
</synopsis>
</para>
</formalpara>

<para>
<function>IsPerfect</function>
returns <literal>True</literal> if <parameter>profile</parameter>
is known by Gambit to be a
perfect Nash equilibrium, <literal>False</literal> if it is known to not be
perfect, and <literal>Unknown</literal> otherwise.  There is currently no
definitive test in Gambit for whether an arbitrary profile is perfect.
However some of the algorithms (notably <function>LcpSolve</function>)
will only
return perfect equilibria, which are marked as such.   
</para>

<note>
<para>
The Python implementation returns a value of <literal>1</literal> for
<literal>True</literal>, <literal>0</literal> for <literal>False</literal>,
and <literal>-1</literal> for <literal>Unknown</literal>.
</para>
</note>

</sect2>


<sect2 id="apiref.mixed.isproper">
<title>IsProper</title>
<indexterm><primary>IsProper</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gTriState MixedSolution::IsProper(void) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
IsProper[profile->MIXED] =: BOOLEAN 
</synopsis>
</para>
</formalpara>

<para>
<function>IsProper</function>
returns <literal>True</literal> if <parameter>profile</parameter>
is known by Gambit to be a
proper Nash equilibrium, <literal>False</literal> if it is known to not be
proper, and <literal>Unknown</literal> otherwise.  There is currently no
definitive test in Gambit for whether an arbitrary profile is proper.
However some algorithms will only
return proper equilibria, which are marked as such.   
</para>

<note>
<para>
The Python implementation returns a value of <literal>1</literal> for
<literal>True</literal>, <literal>0</literal> for <literal>False</literal>,
and <literal>-1</literal> for <literal>Unknown</literal>.
</para>
</note>

</sect2>

<sect2 id="apiref.mixed.mixed">
<title>Mixed (GCL only)</title>
<indexterm><primary>Mixed (GCL function)</primary></indexterm>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
Mixed[support->NFSUPPORT] =: MIXED 
</synopsis>
</para>
</formalpara>

<para>
<function>Mixed</function>
returns a mixed strategy profile over <parameter>support</parameter> with equal
probabilities for each strategy in the support.  
</para>

</sect2>


<sect2 id="apiref.mixed.setlabel">
<title>SetLabel</title>
<indexterm><primary>SetLabel</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void MixedSolution::SetLabel(const gText &amp;p_label)
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
This function is not available in the GCL.
</para>
</formalpara>

<para>
<function>SetLabel</function> 
sets the text label of the profile.  The GCL version returns the profile.
</para>

</sect2>


<sect2 id="apiref.mixed.setstrategyprob">
<title>SetStrategyProb</title>
<indexterm><primary>SetStrategyProb</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void MixedSolution::SetStrategyProb(gbtNfgStrategy, gNumber)
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
SetStrategyProb[profile<->MIXED, strategy->STRATEGY, 
                value->NUMBER] =: MIXED 
</synopsis>
</para>
</formalpara>

<para>
<function>SetStrategyProb</function>
sets the component of <parameter>profile</parameter> for 
<parameter>strategy</parameter> to be equal
to <parameter>value</parameter>.  It is an error if <parameter>profile</parameter> and <parameter>strategy</parameter>
are not from the same normal form game.  Returns <parameter>profile</parameter>.
</para>

</sect2>

<sect2 id="apiref.mixed.setstrategyprobs">
<title>SetStrategyProbs (GCL only)</title>
<indexterm><primary>SetStrategyProbs (GCL only)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
This function is not available in C++ or Python.  Use
<function>SetStrategyProb</function> instead.
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
SetStrategyProbs[profile<->MIXED, player->NFPLAYER, 
                 value->LIST(NUMBER)] =: MIXED 
</synopsis>
</para>
</formalpara>

<para>
<function>SetStrategyProbs</function> sets the components of
<parameter>profile</parameter> for <parameter>player</parameter> to be
equal to <parameter>value</parameter>.  It is an error if
<parameter>profile</parameter> and <parameter>player</parameter> are
not from the same normal form game, or if the length of
<parameter>value</parameter> is not the same as the number of
strategies for <parameter>player</parameter> in the support of
<parameter>profile</parameter>.  Returns
<parameter>profile</parameter>.
</para>

</sect2>


<sect2 id="apiref.mixed.strategyprobs">
<title>StrategyProbs (GCL only)</title>
<indexterm><primary>StrategyProbs (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
This function is not available in C++ or Python.  Use
<function>GetStrategyProb</function> instead.
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
StrategyProbs[profile->MIXED] =: LIST(LIST(NUMBER)) 
</synopsis>
</para>
</formalpara>

<para>
<function>StrategyProbs</function>
returns a nested list of the probabilities for each strategy under
<parameter>profile</parameter>.
The (i,j)th entry is the probability of player
i adopting strategy j.
</para>

</sect2>

<sect2 id="apiref.mixed.strategyvalues">
<title>StrategyValues (GCL only)</title>
<indexterm><primary>StrategyValues (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
This function is not available in C++ or Python.  Use
<function>GetStrategyValue</function> instead.
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
StrategyValues[profile->MIXED] =: LIST(LIST(NUMBER)) 
</synopsis>
</para>
</formalpara>

<para>
<function>StrategyValues</function>
returns a list of expected payoffs of each strategy (to the player
who chooses that strategy).  The (i,j)th entry is
the expected payoff to player i of
strategy j, where the index numbers correspond to the output of
<function>Players</function> and
<function>Strategies</function>, respectively.
</para>

</sect2>

</sect1>

