<sect1 id="apiref.player">
<title>Players</title>

<para>
Players represent the strategic actors in a game.  Additionally,
in extensive form games, a player object is used to represent the
nonstrategic &quot;chance&quot; or &quot;nature&quot; player used to
indicate exogenous randomizations. 
</para>

<para>
Players in extensive form games are considered different objects than
those in normal form games, even when the normal form game is another
representation of an extensive form game (for example, if the normal
form is created by computing the reduced normal form of an extensive
form).  This limitation is intended to disappear in future versions.
</para>

<sect2 id="apiref.player.getid">
<title>GetId</title>
<indexterm><primary>GetId</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
int gbtGamePlayer::GetId(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetId</function> returns the ID number of the player.
This ID number is unique within the game.  By convention, the chance
player has ID number zero, and all personal players have positive
ID numbers.
</para>

</sect2>

<sect2 id="apiref.player.getinfoset">
<title>GetInfoset</title>
<indexterm><primary>GetInfoset</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGameInfoset gbtGamePlayer::GetInfoset(int p_index) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetInfoset</function> returns the information set numbered
<parameter>p_index</parameter> from the list of information sets at
which the player has the decision.  Each player's information sets are
numbered sequentially beginning at one. 
An exception is thrown (<errorname>gbtIndexException</errorname> in
C++, <errorname>IndexError</errorname> in Python) if the index is out
of range.
</para>

</sect2>


<sect2 id="apiref.player.getlabel">
<title>GetLabel</title>
<indexterm><primary>GetLabel</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
std::string gbtGamePlayer::GetLabel(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetLabel</function> returns the text label of the player.
</para>

</sect2>


<sect2>
<title>GetStrategy</title>
<indexterm><primary>GetStrategy</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGameStrategy gbtGamePlayer::GetStrategy(int p_index) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetStrategy</function> returns the strategy numbered
<parameter>p_index</parameter> from the list of strategies for the
player.  Each player's strategies are numbered sequentially beginning
at one.  An exception is thrown (<errorname>gbtIndexException</errorname> in
C++, <errorname>IndexError</errorname> in Python) if the index is out
of range.

</para>

</sect2>

<sect2 id="apiref.player.ischance">
<title>IsChance</title>
<indexterm><primary>IsChance</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
bool gbtGamePlayer::IsChance(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>IsChance</function> returns <literal>True</literal> (nonzero)
if the player is the chance player, and <literal>False</literal> (zero)
if the player is a personal player.
</para>

</sect2>

<sect2 id="apiref.player.isdeleted">
<title>IsDeleted</title>
<indexterm><primary>IsDeleted</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
bool gbtGamePlayer::IsDeleted(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>IsDeleted</function> returns <literal>True</literal> (nonzero)
if the player has been deleted from its game.  Any attempts to operate
on a deleted object throw a <errorname>gbtGameDeletedException</errorname>
(mapped to <errorname>RuntimeError</errorname> in Python).
</para>

</sect2>

<sect2 id="apiref.player.newinfoset">
<title>NewInfoset</title>
<indexterm><primary>NewInfoset</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGameInfoset gbtGamePlayer::NewInfoset(int p_actions)
</synopsis>
</para>
</formalpara>

<para>
<function>NewInfoset</function> creates a new information set
belonging to the player, with <parameter>actions</parameter> actions.
The newly created information set is returned. 
</para>

</sect2>


<sect2 id="apiref.player.numinfosets">
<title>NumInfosets</title>
<indexterm><primary>NumInfosets</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
int gbtGamePlayer::NumInfosets(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>NumInfosets</function> returns how many information
sets are defined where the player has the decision.
</para>

</sect2>

<sect2 id="apiref.player.numsequences">
<title>NumSequences</title>
<indexterm><primary>NumSequences</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
int gbtGamePlayer::NumSequences(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>NumStrategies</function> returns the number of sequences
associated with the player's strategy set
(as defined by the Koller-Megiddo-von Stengel sequence form representation).
</para>

</sect2>

<sect2 id="apiref.player.numstrategies">
<title>NumStrategies</title>
<indexterm><primary>NumStrategies</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
int gbtGamePlayer::NumStrategies(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>NumStrategies</function> returns how many strategies the
player has in the game.
</para>

</sect2>


<sect2 id="apiref.player.setlabel">
<title>SetLabel</title>
<indexterm><primary>SetLabel</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtGamePlayer::SetLabel(const std::string &amp;p_label)
</synopsis>
</para>
</formalpara>

<para>
<function>SetLabel</function> sets the text label associated with the player.
</para>

</sect2>

</sect1>
