<sect1 id="apiref.nash">
<title>Computing Nash equilibria</title>

<para>
This section describes the methods implemented in Gambit to compute Nash
equilibria.  A goal of the development of the 0.97.1.x versions of Gambit is to
provide interfaces to these methods that allow for greater flexibility and
customization, as well as moving towards making use of external libraries
for computation where available (for example, linear programming libraries).  As such,
these interfaces are likely to evolve over the release series.
</para>

<para>
This section is primarily concerned with calling conventions and high-level
descriptions of the algorithms.  More detailed technical information on the
methods, citations, and some general hints on computing equilbria in games can
be found in <xref linkend="app.alg">.
</para>

<sect2 id="apiref.nash.nashenummixed">
<title>NashEnumMixed</title>
<indexterm><primary>NashEnumMixed</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
#include "nash/nfgmixed.h"
gbtList&lt;gbtMixedProfile&lt;T&gt; &gt; gbtNashEnumMixedNfg(const gbtGame &amp;p_game, const T &amp;p_precision, int p_stopAfter = 0);
</synopsis>
Implemented for types <type>double</type> and
<type>gbtRational</type>.
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
gambit.NashEnumMixedNfg(game, useRational = True, stopAfter = 0)
</synopsis>
</para>
</formalpara>

<para>
<function>NashEnumMixedNfg</function> computes extreme points of the
set of Nash equilibria (pure or mixed) for any two-person strategic game.
The parameter <parameter>p_stopAfter</parameter> constrains the algorithm
to stop after finding the specified number of equilibria; the default
value of zero instructs the algorithm to compute all the extreme points.
</para>

<para>
This method is available in both floating-point and rational precision.
The precision is specified in C++ by passing a dummy value of the
desired type as the second parameter; in Python, the second parameter
is a boolean value which specifies the use of rational precision if
<literal>True</literal>.
</para>

</sect2>


<sect2 id="apiref.nash.nashenumpoly">
<title>NashEnumPoly</title>
<indexterm><primary>NashEnumPoly</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
#include "nash/efgpoly.h"
gbtList&lt;gbtBehavProfile&lt;double&gt; &gt; gbtNashEnumPolyEfg(const gbtGame &amp;p_game);

#include "nash/nfgpoly.h"
gbtList&lt;gbtMixedProfile&lt;double&gt; &gt; gbtNashEnumPolyNfg(const gbtGame &amp;p_game);
</synopsis>
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
gambit.NashEnumPolyEfg(game)
gambit.NashEnumPolyNfg(game)
</synopsis>
</para>
</formalpara>

<para>
<function>NashEnumPolyEfg</function> and
<function>NashEnumPolyNfg</function>
solve for all totally mixed Nash equilibria of the game
in the behavior or strategy spaces, respectively.
The algorithm starts with a cube containing the
space of possible solutions and proceeds recursively.  The recursion
step begins with a subcube.  The subcube is discarded if the cube is
irrelevant in the sense of lying outside the space of possible
solutions.  Otherwise a modified Newton's method is used to search for
a solution in the subcube.  In the event that such a solution is
found, Taylor's series information at the solution is used to inquire
whether the solution is necessarily the unique solution in the
subcube.  If Newton's method leaves the subcube before finding a
solution, Taylor's series information at the center is used to inquire
whether we can be sure that the subcube contains no solutions.  If
neither of these procedures resolves the issue, the subcube is
subdivided and this recursion is performed on each smaller subcube.
</para>

</sect2>


<sect2 id="apiref.nash.nashenumpure">
<title>NashEnumPure</title>
<indexterm><primary>NashEnumPure</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
#include "nash/efgpure.h"
gbtList&lt;gbtBehavProfile&lt;gbtRational&gt; &gt; gbtNashEnumPureEfg(const gbtGame &amp;p_game, int p_stopAfter);

#include "nash/nfgpure.h"
gbtList&lt;gbtMixedProfile&lt;gbtRational&gt; &gt; gbtNashEnumPureNfg(const gbtGame &amp;p_game, int p_stopAfter);
</synopsis>
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
gambit.NashEnumPureEfg(game, stopAfter = 0)
gambit.NashEnumPureNfg(game, stopAfter = 0)
</synopsis>
</para>
</formalpara>

<para>
<function>NashEnumPureEfg</function> and <function>NashEnumPureNfg</function>
compute all pure-behavior and pure-strategy Nash equilibria, respectively,
of <parameter>p_game</parameter>.
The parameter <parameter>p_stopAfter</parameter> constrains the algorithm
to stop after finding the specified number of equilibria; the default
value of zero instructs the algorithm to compute all the pure-strategy
Nash equilibria.
</para>

</sect2>

<sect2 id="apiref.nash.nashlcp">
<title>NashLcp</title>
<indexterm><primary>NashLcp</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
#include "nash/efglcp.h"
gbtList&lt;gbtBehavProfile&lt;T&gt; &gt; gbtNashLcpEfg(const gbtGame &amp;p_game, const T &amp;p_precision, int p_stopAfter = 0, int p_maxDepth = 0);

#include "nash/nfglcp.h"
gbtList&lt;gbtMixedProfile&lt;T&gt; &gt; gbtNashLcpNfg(const gbtGame &amp;p_game, const T &amp;p_precision, int p_stopAfter = 0, int p_maxDepth = 0);
</synopsis>
Implemented for types <type>double</type> and <type>gbtRational</type>.
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
gambit.NashLcpEfg(game, useRational = True, stopAfter = 0, maxDepth = 0)
gambit.NashLcpNfg(game, useRational = True, stopAfter = 0, maxDepth = 0)
</synopsis>
</para>
</formalpara>

<para>
<function>NashLcp</function>
solves a game as a linear complementarity problem, using the
Lemke-Howson algorithm for normal form games, and the
Koller-Megiddo-von Stengel sequence form for extensive form games.  
The parameter <parameter>p_stopAfter</parameter> constrains the algorithm
to stop after finding the specified number of equilibria; the default
value of zero instructs the algorithm to compute all accessible Nash 
equilibria.  The parameter <parameter>p_maxDepth</parameter> constrains
the algorithm to take at most the specified number of pivots; the
default value of zero does not restrict the depth of the search.
</para>

<para>
This method is available in both floating-point and rational precision.
The precision is specified in C++ by passing a dummy value of the
desired type as the second parameter; in Python, the second parameter
is a boolean value which specifies the use of rational precision if
<literal>True</literal>.
</para>

</sect2>

<sect2 id="apiref.nash.nashliap">
<title>NashLiap</title>
<indexterm><primary>NashLiap</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
gbtList &lt;gbtBehavProfile&lt;double&gt; &gt;
gbtNashLiapEfg(const gbtBehavProfile&lt;double&gt; &, 
               int p_maxitsN = 100, double p_tolN = 1.0e-8,
               int p_maxits1 = 100, double p_tol1 = .0001);
gbtList &lt;gbtMixedProfile&lt;double&gt; &gt;
gbtNashLiapNfg(const gbtMixedProfile&lt;double&gt; &, 
               int p_maxitsN = 100, double p_tolN = 1.0e-8,
               int p_maxits1 = 100, double p_tol1 = .0001);
</synopsis>
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
gambit.NashLiapEfg(behav, maxitsN = 100, tolN = 1.0e-8, maxits1 = 100, tol1 = .0001)
gambit.NashLiapNfg(mixed, maxitsN = 100, tolN = 1.0e-8, maxits1 = 100, tol1 = .0001)
</synopsis>
</para>
</formalpara>

<para>
These functions attempt to compute one (approximate) Nash equilibrium by
minimizing a Lyapunov function which is zero exactly at Nash equilibria.  
The extensive form version operates in the space of behavior profiles,
and the normal form version in the space of strategy profiles.
The function returns a list, which contains one profile if a candidate
approximate equilibrium is found, and zero profiles if not.
Minimization is implemented by a Polak-Ribiere conjugate gradient descent
method, constrained to the product of simplices defined by the strategy space.
</para>

<para>
The method takes a behavior or strategy profile (respectively) as a starting point.
The algorithm is not guaranteed to find an equilibrium from any particular
starting point, so it is generally recommended to try many different starting
points in searching for equilibria.  This can be done either by randomly
selecting starting points, or using some type of grid or other adaptive procedure.
</para>

<para>
The behavior of the algorithm is controlled by the following
parameters:
<itemizedlist>
<listitem>
<para>
<parameter>maxitsN</parameter>: The maximum number of steps to take in the
optimization algorithm.
</para>
</listitem>
<listitem>
<para>
<parameter>tolN</parameter>: The tolerance criterion for accepting a profile
as a candidate approximate equilibrium.  Setting this smaller will reject more
profiles; setting this larger will be more tolerant, but will accept profiles
that may be far from an equilibrium.
</para>
</listitem>
<listitem>
<para>
<parameter>maxits1</parameter>: The maximum number of steps to take in the
one-dimensional phase of each iteration.
</para>
</listitem>
<listitem>
<para>
<parameter>tol1</parameter>: The tolerance criterion for accepting a profile
as a minimum in the one-dimensional phase.
</para>
</listitem>
</itemizedlist>
Most users will want to focus on adjusting <parameter>maxitsN</parameter> and
<parameter>tolN</parameter>.
</para>

</sect2>

<sect2 id="apiref.nash.nashlp">
<title>NashLp</title>
<indexterm><primary>NashLp</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
#include "nash/efglp.h"
gbtList&lt;gbtBehavProfile&lt;T&gt; &gt; gbtNashLpEfg(const gbtGame &amp;p_game, const T &amp;p_precision);

#include "nash/nfglp.h"
gbtList&lt;gbtMixedProfile&lt;T&gt; &gt; gbtNashLpNfg(const gbtGame &amp;p_game, const T &amp;p_precision);
</synopsis>
Implemented for types <type>double</type> and <type>gbtRational</type>.
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
gambit.NashLpEfg(game, useRational = True)
gambit.NashLpNfg(game, useRational = True)
</synopsis>
</para>
</formalpara>

<para>
<function>NashLp</function> computes equilibria of zero-sum games
using a linear programming formulation.
</para>

<para>
This method is available in both floating-point and rational precision.
The precision is specified in C++ by passing a dummy value of the
desired type as the second parameter; in Python, the second parameter
is a boolean value which specifies the use of rational precision if
<literal>True</literal>.
</para>

</sect2>

<sect2 id="apiref.nash.nashlogit">
<title>NashLogit</title>
<indexterm><primary>NashLogit</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
#include "nash/efglogit.h"
gbtList&lt;gbtBehavProfile&lt;double&gt; &gt; gbtNashLogitEfg(const gbtGame &amp;p_game);

#include "nash/nfglogit.h"
gbtList&lt;gbtMixedProfile&lt;double&gt; &gt; gbtNashLogitNfg(const gbtGame &amp;p_game);
</synopsis>
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
gambit.NashLogitEfg(game)
gambit.NashLogitNfg(game)
</synopsis>
</para>
</formalpara>

<para>
<function>NashLogitEfg</function> and
<function>NashLogitNfg</function>
computes (an approximation to) the equilibrium at the end of the
principal branch of the logit quantal response equilibrium correspondence
in the behavior or strategy spaces, respectively.
</para>

</sect2>


<sect2 id="apiref.nash.nashsimpdiv">
<title>NashSimpdiv</title>
<indexterm><primary>NashSimpdiv</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
#include "nash/nfgsimpdiv.h"
gbtList&lt;gbtMixedProfile&lt;T&gt; &gt; gbtNashSimpdivNfg(const gbtMixedProfile&lt;T&gt; &amp;p_start, int p_leashLength = 0);
</synopsis>
Implemented for types <type>double</type> and <type>gbtRational</type>.
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
gambit.NashSimpdivNfg(start, leashLength = 0)
</synopsis>
</para>
</formalpara>

<para>
<function>NashSimpdiv</function> attempts to compute a Nash equilibrium
of a normal form game using a simplicial subdivision method.  The algorithm
can be started at any point in the space of mixed strategy profiles;
if multiple equilibria exist, the equilibrium found may depend upon
the choice of the starting point.  In its pure form, the method is guaranteed
to find an equilibrium, but may take a long time to do so.  The behavior
of the algorithm may be modified by specifying 
<parameter>p_leashLength</parameter> which constrains how far the algorithm
will search; the default value of zero represents no constraint.
Experience indicates that this parameter sometimes speeds up the process
of locating an equilibrium; however, it also means the algorithm may fail
to locate an equilibrium with the constraint.
</para>

<para>
This method is available in both floating-point and rational precision.
The precision is specified by the precision of the profile passed as
a starting point.
</para>

</sect2>

<sect2 id="apiref.nash.nashyamamoto">
<title>NashYamamoto</title>
<indexterm><primary>NashYamamoto</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
#include "nash/nfgyamamoto.h"
gbtList&lt;gbtMixedProfile&lt;double&gt; &gt; gbtNashYamamotoNfg(const gbtGame &amp;p_game);
</synopsis>
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
gambit.NashYamamotoNfg(game)
</synopsis>
</para>
</formalpara>

<para>
<function>NashYamamotoNfg</function> computes a proper Nash equilibrium
of a normal form game using the path-following method of Yamamoto.
</para>

<warning>
<para>
The implementation of Yamamoto's algorithm is new in version 0.97.1.0,
and is known not to work on many games yet.
</para>
</warning>


</sect2>

</sect1>


