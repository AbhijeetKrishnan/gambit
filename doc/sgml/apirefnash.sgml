<sect1 id="apiref.nash">
<title>Computing Nash equilibria</title>

<para>
This section, which is under construction, describes only the Python
interface to the algorithms for computing Nash equilibria.  In the current
release, this interface is very limited.  We are specifically looking for
feedback as how best to structure the Nash equilbrium algorithms'
interfaces in both C++ and Python.
</para>

<para>
Among the limitations currently:
<itemizedlist>
<listitem>
<para>Only the floating-point versions of the algorithms are available
(all numerical operations in the Python interface are floating-point,
anyway);
</para>
</listitem>
<listitem>
<para>No automatic conversion to normal form is done (unlike the old GCL
interface);
</para>
</listitem>
<listitem>
<para>No solving-by-subgames is available
</para>
</listitem>
<listitem>
<para>
Some algorithm parameters are not exposed
</para>
</listitem>
</itemizedlist>
</para>


<sect2 id="apiref.nash.enummixedsolve">
<title>EnumMixedSolve</title>
<indexterm><primary>EnumMixedSolve</primary></indexterm>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
gambit.EnumMixedSolve(support)
</synopsis>
</para>
</formalpara>

<para>
<function>EnumMixedSolve</function> returns the extreme points of the set
of all Nash equilibria (pure or
mixed) for a two person normal form game using <parameter>support</parameter>.
</para>

</sect2>


<sect2 id="apiref.nash.enumpolysolve">
<title>EnumPolySolve</title>
<indexterm><primary>EnumPolySolve</primary></indexterm>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
gambit.EnumPolySolve(support)
</synopsis>
</para>
</formalpara>

<para>
<function>EnumPolySolve</function>
solves for all mixed Nash equilibria on <parameter>support</parameter>.
On each sub-support, the algorithm starts with a cube containing the
space of possible solutions and proceeds recursively.  The recursion
step begins with a subcube.  The subcube is discarded if the cube is
irrelevant in the sense of lying outside the space of possible
solutions.  Otherwise a modified Newton's method is used to search for
a solution in the subcube.  In the event that such a solution is
found, Taylor's series information at the solution is used to inquire
whether the solution is necessarily the unique solution in the
subcube.  If Newton's method leaves the subcube before finding a
solution, Taylor's series information at the center is used to inquire
whether we can be sure that the subcube contains no solutions.  If
neither of these procedures resolves the issue, the subcube is
subdivided and this recursion is performed on each smaller subcube.
</para>

</sect2>


<sect2 id="apiref.nash.enumpuresolve">
<title>EnumPureSolve</title>
<indexterm><primary>EnumPureSolve</primary></indexterm>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
gambit.EnumPureSolve(support)
</synopsis>
</para>
</formalpara>

<para>
Returns all pure strategy Nash equilibria of a game using the given
<parameter>support</parameter>.  
</para>

</sect2>

<sect2 id="apiref.nash.lcpsolve">
<title>LcpSolve</title>
<indexterm><primary>LcpSolve</primary></indexterm>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
gambit.LcpSolve(support)
</synopsis>
</para>
</formalpara>

<para>
<function>LcpSolve</function>
solves a game as a linear complementarity problem, using the
Lemke-Howson algorithm for normal form games, and the
Koller-Megiddo-von Stengel sequence form for extensive form games.  
</para>

</sect2>

<sect2 id="apiref.nash.liapsolve">
<title>LiapSolve</title>
<indexterm><primary>LiapSolve</primary></indexterm>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
gambit.LiapSolve(gbtEfgSupport p_support,
                 int p_stopAfter,
                 int p_nTries,
                 int p_maxIters)
gambit.LiapSolve(gbtNfgSupport p_support,
                 int p_stopAfter,
                 int p_nTries,
                 int p_maxIters)
</synopsis>
</para>
</formalpara>

<para>
<function>LiapSolve</function>
searches for a Nash equilibrium by minimizing a Lyapunov function
which is zero exactly at Nash equilibria.  
The algorithm is not guaranteed to find a Nash equilibrium from any
fixed starting point.  The algorithm thus incorporates the capability
of restarting.  Until either the maximum specified number of equilibria
are found, or until the upper bound on the number of attempts is reached,
the algorithm will search from new randomly chosen starting points.
</para>

<para>
The list of equilibria found is returned.  Note that it is possible
(and in some games likely) that the same equilibrium may appear more
than once in the returned list.
</para>

<para>
The behavior of the algorithm is controlled by the following
parameters:
<itemizedlist>
<listitem>
<para>
<parameter>asNfg</parameter> By default, extensive forms are solved in
the extensive form.  By setting this parameter to
<literal>True</literal>, each marked subgame of the extensive form is
converted to its corresponding reduced normal form game, solved, and
the overall behavior profile reconstructed from these solutions.
</para>
</listitem>
<listitem>
<para>
<parameter>nTries</parameter>: Sets the maximum number of attempts at finding an
equilibrium. Default is 10.
</para>
</listitem>
<listitem>
<para>
<parameter>stopAfter</parameter>: Sets the number of equilibria to find.  Default is 1.
</para>
</listitem>
</itemizedlist>
</para>

</sect2>


<sect2 id="apiref.nash.lpsolve">
<title>LpSolve</title>
<indexterm><primary>LpSolve</primary></indexterm>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
gambit.LpSolve(support)
</synopsis>
</para>
</formalpara>

<para>
<function>LpSolve</function>
solves a two-person, constant-sum game for one Nash equilibrium as a linear
program.  For extensive form games, the Koller-Megiddo-von Stengel
sequence form is used; games not of perfect recall return the empty
list of solutions.
</para>

</sect2>


<sect2 id="apiref.nash.simpdivsolve">
<title>SimpDivSolve</title>
<indexterm><primary>SimpDivSolve</primary></indexterm>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
gambit.SimpDivSolve(support)
</synopsis>
</para>
</formalpara>

<para>
<function>SimpDivSolve</function> computes a Nash equilibrium for a
normal form game using a simplicial subdivision algorithm.
</para>

</sect2>


<sect2 id="apiref.nash.yamamotosolve">
<title>YamamotoSolve</title>
<indexterm><primary>YamamotoSolve</primary></indexterm>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
gambit.YamamotoSolve(support)
</synopsis>
</para>
</formalpara>

<para>
<function>YamamotoSolve</function> computes a proper Nash equilibrium for a
normal form game using the path-following algorithm of Yamamoto.
</para>

<warning>
<para>
The implementation of Yamamoto's algorithm is new in version 0.97.1.0,
and is known not to work on many games yet.  Testing and feedback is
welcome!
</para>
</warning>

</sect2>


</sect1>

