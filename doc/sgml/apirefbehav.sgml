<sect1 id="apiref.behav">
<title>Behavior strategy profiles</title>

<para>
</para>


<sect2 id="apiref.behav.getactionprob">
<title>GetActionProb</title>
<indexterm><primary>GetActionProb</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber BehavSolution::GetActionProb(gbtEfgAction p_action) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetActionProb</function>
returns the probability that
<parameter>action</parameter> is chosen at its information set when
all players are following <parameter>profile</parameter>.  If
<parameter>action</parameter> is a chance action, the probability of
chance selecting the action is returned.  If the probability is not
specified by the profile, the null value is returned.  It is an error
if <parameter>profile</parameter> and <parameter>action</parameter>
are not from the same extensive form game.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if the probability specified in the profile is rational.
</para>
</note>

</sect2>


<sect2 id="apiref.behav.getactionvalue">
<title>GetActionValue</title>
<indexterm><primary>GetActionValue</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber BehavSolution::GetActionValue(gbtEfgAction) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetActionValue</function> returns the expected payoff to a
player (who is in control of the information set including
<parameter>action</parameter>) of choosing
<parameter>action</parameter> when all players are following
<parameter>profile</parameter>.  If the value is not well-defined, the
null value is returned.  It is an error if
<parameter>profile</parameter> and <parameter>action</parameter> are
not from the same extensive form game, or if
<parameter>action</parameter> is an action at an information set owned
by the chance player.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>

<sect2 id="apiref.behav.getbelief">
<title>GetBelief</title>
<indexterm><primary>GetBelief</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber BehavSolution::GetBelief(gbtEfgNode) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetBelief</function> returns the probability of being at
<parameter>node</parameter>, conditional on the player who chooses at
<parameter>node</parameter> knowing she is in
<parameter>node</parameter>'s information set, assuming all players
follow <parameter>profile</parameter>.  The null value is returned if
the belief value is not well-defined, or if
<parameter>node</parameter> is terminal.  It is an error if
<parameter>profile</parameter> and <parameter>node</parameter> are not
from the same extensive form game.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>

<sect2 id="apiref.behav.getcreator">
<title>GetCreator</title>
<indexterm><primary>GetCreator</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtText BehavSolution::GetCreator(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetCreator</function> 
returns a text string identifying the algorithm used to create
the profile.  The string includes an indication of whether the
extensive or normal form version of the algorithm was used.  Thus,
<literal>Liap[EFG]</literal> and <literal>Liap[NFG]</literal> are used
to identify the extensive and normal form versions of the
<function>LiapSolve</function> algorithm.  A profile created or modified 
by the user is identified by <literal>User</literal>.
</para>

</sect2>

<sect2 id="apiref.behav.getgame">
<title>GetGame</title>
<indexterm><primary>GetGame</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtEfgGame BehavSolution::GetGame(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetGame</function>
returns the extensive form game to which the profile belongs.
</para>

</sect2>


<sect2 id="apiref.behav.getinfosetprob">
<title>GetInfosetProb</title>
<indexterm><primary>GetInfosetProb</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber BehavSolution::GetInfosetProb(gbtEfgInfoset) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetInfosetProb</function> returns the probability of reaching
<parameter>infoset</parameter> when all players follow
<parameter>profile</parameter>.  The probability of reaching the null
information set is defined to be null.  It is an error if
<parameter>profile</parameter> and <parameter>infoset</parameter> are
not defined on the same extensive form game.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>

<sect2 id="apiref.behav.getinfosetvalue">
<title>GetInfosetValue</title>
<indexterm><primary>GetInfosetValue</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber BehavSolution::GetInfosetValue(gbtEfgInfoset) const
</synopsis>
</para>
</formalpara>

<para>
<function>InfosetValue</function>
returns the value to the controlling player of reaching 
<parameter>infoset</parameter>
when all players follow <parameter>profile</parameter>.
It is an error if
<parameter>profile</parameter> and <parameter>infoset</parameter>
are not defined on the same
extensive form game.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>


<sect2 id="apiref.behav.getlabel">
<title>GetLabel</title>
<indexterm><primary>GetLabel</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtText BehavSolution::GetLabel(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetLabel</function> returns the text label of the profile.
</para>

</sect2>


<sect2 id="apiref.behav.getliapvalue">
<title>GetLiapValue</title>
<indexterm><primary>GetLiapValue</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber BehavSolution::GetLiapValue(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetLiapValue</function> returns the Lyapunov function value for
<parameter>profile</parameter>.  This is a nonnegative value which is
zero exactly when the profile is a Nash equilibrium.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>

<sect2 id="apiref.behav.getnodevalue">
<title>GetNodeValue</title>
<indexterm><primary>GetNodeValue</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber BehavSolution::GetNodeValue(gbtEfgNode, gbtEfgPlayer) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetNodeValue</function>
returns the expected payoff to <parameter>player</parameter> at
<parameter>node</parameter>, given
that all players are following <parameter>profile</parameter>.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>

<sect2 id="apiref.behav.getpayoff">
<title>GetPayoff</title>
<indexterm><primary>GetPayoff</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber BehavSolution::GetPayoff(gbtEfgPlayer p_player) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetPayoff</function> returns the expected payoff to player
<parameter>player</parameter>, when all players play according to
<parameter>profile</parameter>.  An error occurs if the parameters are
not from the same game.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>


<sect2 id="apiref.behav.getrealizprob">
<title>GetRealizProb</title>
<indexterm><primary>GetRealizProb</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber BehavSolution::GetRealizProb(gbtEfgNode) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetRealizProb</function>
returns the realization probability for <parameter>node</parameter>
given that all players
are following <parameter>profile</parameter>.  It is an error if
<parameter>profile</parameter> and
<parameter>node</parameter> are not from the same extensive form game.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>

<sect2 id="apiref.behav.getregret">
<title>GetRegret</title>
<indexterm><primary>GetRegret</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber BehavSolution::GetRegret(gbtEfgAction p_action) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetRegret</function> returns the gain to a player for deviating to
<parameter>action</parameter> assuming all players are following
<parameter>profile</parameter>.  A strategy profile is a Nash
equilibrium if and only if the regrets of all actions or strategies
are zero.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>


<sect2 id="apiref.behav.isnash">
<title>IsNash</title>
<indexterm><primary>IsNash</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtTriState BehavSolution::IsNash(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>IsNash</function>
returns <literal>True</literal> when <parameter>profile</parameter>
is known by Gambit to be a
Nash equilibrium of the corresponding game, and <literal>False</literal>
if <parameter>profile</parameter> is known to not be Nash.
Otherwise, the return value
is <literal>Unknown</literal>. 
If <parameter>profile</parameter> is complete (probabilities sum
to one for every player, and every information set), then there is a
definitive test for Nash equilibrium.  However if the profile is
incomplete (i. e., it does not specify actions at off the equilibrium
path information sets), then it is possible that a profile (or set of
all completions of the profile) may be Nash, but is not known by
Gambit to be Nash.
</para>

<note>
<para>
The Python implementation returns a value of <literal>1</literal> for
<literal>True</literal>, <literal>0</literal> for <literal>False</literal>,
and <literal>-1</literal> for <literal>Unknown</literal>.
</para>
</note>

</sect2>


<sect2 id="apiref.behav.issequential">
<title>IsSequential</title>
<indexterm><primary>IsSequential</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtTriState BehavSolution::IsSequential(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>IsSequential</function>
returns <literal>True</literal> if <parameter>profile</parameter>
is known by Gambit to be an approximation to a
sequential Nash equilibrium, <literal>False</literal> if it is not,
and <literal>Unknown</literal> if the answer is not known.  There is
currently no definitive test in Gambit for whether an arbitrary
profile is sequential.  However any Nash equilibrium of an extensive
form game which is computed via the <function>LiapSolve</function> or
<function>QreSolve</function> algorithms is sequential.
</para>

<note>
<para>
The Python implementation returns a value of <literal>1</literal> for
<literal>True</literal>, <literal>0</literal> for <literal>False</literal>,
and <literal>-1</literal> for <literal>Unknown</literal>.
</para>
</note>

</sect2>


<sect2 id="apiref.behav.issubgameperfect">
<title>IsSubgamePerfect</title>
<indexterm><primary>IsSubgamePerfect</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtTriState BehavSolution::IsSequential(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>IsSubgamePerfect</function>
returns <literal>True</literal> if <parameter>profile</parameter>
is known by Gambit to be a subgame perfect Nash
equilibrium, <literal>False</literal> if it is known not to be a 
subgame perfect equilibrium, and <literal>Unknown</literal> otherwise.
There is currently no
definitive test in Gambit for whether an arbitrary profile is subgame
perfect.  However, any Nash equilibrium of an extensive form game which
is computed when all subgames are marked will only return a subgame
perfect equilibrium.  
</para>

<note>
<para>
The Python implementation returns a value of <literal>1</literal> for
<literal>True</literal>, <literal>0</literal> for <literal>False</literal>,
and <literal>-1</literal> for <literal>Unknown</literal>.
</para>
</note>

</sect2>

<sect2 id="apiref.behav.setactionprob">
<title>SetActionProb</title>
<indexterm><primary>SetActionProb</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void BehavSolution::SetStrategyProb(gbtEfgAction, gNumber)
</synopsis>
</para>
</formalpara>

<para>
<function>SetActionProb</function> 
sets the component of <parameter>profile</parameter> for
<parameter>action</parameter> to be equal to <parameter>value</parameter>,
and returns <parameter>profile</parameter>.  It is an error if 
<parameter>profile</parameter> and <parameter>action</parameter>
are not from the same extensive form game. 
</para>

</sect2>

<sect2 id="apiref.behav.setlabel">
<title>SetLabel</title>
<indexterm><primary>SetLabel</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void BehavSolution::SetLabel(const gbtText &amp;p_label)
</synopsis>
</para>
</formalpara>

<para>
<function>SetLabel</function> sets the text label of the profile.
</para>

</sect2>


</sect1>
