<sect1 id="apiref.behav">
<title>Behavior strategy profiles</title>

<para>
</para>


<sect2 id="apiref.behav.behav">
<title>Behav (GCL only)</title>
<indexterm><primary>Behav (GCL function)</primary></indexterm>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
Behav[mixed->MIXED] =: BEHAV 
</synopsis>
</para>
</formalpara>

<para>
<function>Behav</function> converts <parameter>mixed</parameter>
to the equivalent behavior strategy profile on
the associated extensive form game using Kuhn's Theorem.  It is an
error if there is no extensive form game associated with the normal
form game of <function>profile</function>.  Note that this function assumes that the
associated extensive form game is a game of perfect recall.  If it is
not, then the resulting behavior profile is unpredictable, and may not
be a valid profile.
</para>

</sect2>


<sect2 id="apiref.behav.newbehav">
<title>Behav (GCL only)</title>
<indexterm><primary>Behav (GCL function)</primary></indexterm>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
Behav[support->EFSUPPORT] =: BEHAV
</synopsis>
</para>
</formalpara>

<para>
<function>Behav</function> returns a behavior strategy profile with equal
probabilities for all actions in <parameter>support</parameter>
in each same information set. 
</para>

</sect2>



<sect2 id="apiref.behav.getactionprob">
<title>GetActionProb</title>
<indexterm><primary>GetActionProb</primary></indexterm>
<indexterm><primary>ActionProb (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber BehavSolution::GetActionProb(gbtEfgAction p_action) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
ActionProb[profile->BEHAV, action->ACTION] =: NUMBER 
</synopsis>
</para>
</formalpara>

<para>
<function>GetActionProb</function>
(<function>ActionProb</function> in the GCL) returns the probability that
<parameter>action</parameter> is chosen at its information set when
all players are following <parameter>profile</parameter>.  If
<parameter>action</parameter> is a chance action, the probability of
chance selecting the action is returned.  If the probability is not
specified by the profile, the null value is returned.  It is an error
if <parameter>profile</parameter> and <parameter>action</parameter>
are not from the same extensive form game.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if the probability specified in the profile is rational.
</para>
</note>

</sect2>


<sect2 id="apiref.behav.getactionvalue">
<title>GetActionValue</title>
<indexterm><primary>GetActionValue</primary></indexterm>
<indexterm><primary>ActionValue (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber BehavSolution::GetActionValue(gbtEfgAction) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
ActionValue[profile->BEHAV, action->ACTION] =: NUMBER 
</synopsis>
</para>
</formalpara>

<para>
<function>GetActionValue</function> (<function>ActionValue</function>
in the GCL) returns the expected payoff to a player (who is in control
of the information set including <parameter>action</parameter>) of
choosing <parameter>action</parameter> when all players are following
<parameter>profile</parameter>.  If the value is not well-defined, the
null value is returned.  It is an error if
<parameter>profile</parameter> and <parameter>action</parameter> are
not from the same extensive form game, or if
<parameter>action</parameter> is an action at an information set owned
by the chance player.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>

<sect2 id="apiref.behav.getbelief">
<title>GetBelief</title>
<indexterm><primary>GetBelief</primary></indexterm>
<indexterm><primary>Belief (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber BehavSolution::GetBelief(gbtEfgNode) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
Belief[profile->BEHAV, node->NODE] =: NUMBER 
</synopsis>
</para>
</formalpara>

<para>
<function>GetBelief</function>
(<function>Belief</function> in the GCL) returns the probability of being at
<parameter>node</parameter>, conditional on the
player who chooses at <parameter>node</parameter> knowing she is in
<parameter>node</parameter>'s
information set, assuming all players follow <parameter>profile</parameter>.
The null
value is returned if the belief value is not well-defined, or if
<parameter>node</parameter> is terminal.
It is an error if <parameter>profile</parameter> and <parameter>node</parameter>
are not from the same extensive form game.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>

<sect2 id="apiref.behav.getcreator">
<title>GetCreator</title>
<indexterm><primary>GetCreator</primary></indexterm>
<indexterm><primary>Creator (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gText BehavSolution::GetCreator(void) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
Creator[profile->BEHAV] =: TEXT
</synopsis>
</para>
</formalpara>

<para>
<function>GetCreator</function> (<function>Creator</function> in the
GCL) returns a text string identifying the algorithm used to create
the profile.  The string includes an indication of whether the
extensive or normal form version of the algorithm was used.  Thus,
<literal>Liap[EFG]</literal> and <literal>Liap[NFG]</literal> are used
to identify the extensive and normal form versions of the
<function>LiapSolve</function> algorithm.  A profile created or modified 
by the user is identified by <literal>User</literal>.
</para>

</sect2>

<sect2 id="apiref.behav.getgame">
<title>GetGame</title>
<indexterm><primary>GetGame</primary></indexterm>
<indexterm><primary>Game (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtEfgGame BehavSolution::GetGame(void) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
Game[profile->BEHAV] =: EFG
</synopsis>
</para>
</formalpara>

<para>
<function>GetGame</function> (or <function>Game</function> in the GCL)
returns the extensive form game to which the profile belongs.
</para>

</sect2>


<sect2 id="apiref.behav.getinfosetprob">
<title>GetInfosetProb</title>
<indexterm><primary>GetInfosetProb</primary></indexterm>
<indexterm><primary>InfosetProb (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber BehavSolution::GetInfosetProb(gbtEfgInfoset) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
InfosetProb[profile->BEHAV, infoset->INFOSET*] =: NUMBER 
</synopsis>
</para>
</formalpara>

<para>
<function>GetInfosetProb</function> (<function>InfosetProb</function>
in the GCL) returns the probability of reaching
<parameter>infoset</parameter> when all players follow
<parameter>profile</parameter>.  The probability of reaching the null
information set is defined to be null.  It is an error if
<parameter>profile</parameter> and <parameter>infoset</parameter> are
not defined on the same extensive form game.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>

<sect2 id="apiref.behav.getinfosetvalue">
<title>GetInfosetValue</title>
<indexterm><primary>GetInfosetValue</primary></indexterm>
<indexterm><primary>InfosetValue (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber BehavSolution::GetInfosetValue(gbtEfgInfoset) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
InfosetValue[profile->BEHAV, infoset->INFOSET*] =: NUMBER 
</synopsis>
</para>
</formalpara>

<para>
<function>InfosetValue</function>
returns the value to the controlling player of reaching 
<parameter>infoset</parameter>
when all players follow <parameter>profile</parameter>.
It is an error if
<parameter>profile</parameter> and <parameter>infoset</parameter>
are not defined on the same
extensive form game.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>


<sect2 id="apiref.behav.getlabel">
<title>GetLabel</title>
<indexterm><primary>GetLabel</primary></indexterm>
<indexterm><primary>Name (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gText BehavSolution::GetLabel(void) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
This function is not available in the GCL.
</para>
</formalpara>

<para>
<function>GetLabel</function>
returns the text label of the profile.  
</para>

</sect2>


<sect2 id="apiref.behav.getliapvalue">
<title>GetLiapValue</title>
<indexterm><primary>GetLiapValue</primary></indexterm>
<indexterm><primary>LiapValue (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber BehavSolution::GetLiapValue(void) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
LiapValue[profile->BEHAV] =: NUMBER 
</synopsis>
</para>
</formalpara>

<para>
<function>GetLiapValue</function> (<function>LiapValue</function> in
the GCL) returns the Lyapunov function value for
<parameter>profile</parameter>.  This is a nonnegative value which is
zero exactly when the profile is a Nash equilibrium.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>

<sect2 id="apiref.behav.getnodevalue">
<title>GetNodeValue</title>
<indexterm><primary>GetNodeValue</primary></indexterm>
<indexterm><primary>NodeValue (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber BehavSolution::GetNodeValue(gbtEfgNode, gbtEfgPlayer) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
NodeValue[profile->BEHAV, player->EFPLAYER, node->NODE] =: NUMBER 
</synopsis>
</para>
</formalpara>

<para>
<function>GetNodeValue</function>
(<function>NodeValue</function> in the GCL)
returns the expected payoff to <parameter>player</parameter> at
<parameter>node</parameter>, given
that all players are following <parameter>profile</parameter>.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>

<sect2 id="apiref.behav.getpayoff">
<title>GetPayoff</title>
<indexterm><primary>GetPayoff</primary></indexterm>
<indexterm><primary>Payoff</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber BehavSolution::GetPayoff(gbtEfgPlayer p_player) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
Payoff[profile->BEHAV, player->EFPLAYER] =: NUMBER 
</synopsis>
</para>
</formalpara>

<para>
<function>GetPayoff</function> (<function>Payoff</function> in the
GCL) returns the expected payoff to player
<parameter>player</parameter>, when all players play according to
<parameter>profile</parameter>.  An error occurs if the parameters are
not from the same game.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>


<sect2 id="apiref.behav.getrealizprob">
<title>GetRealizProb</title>
<indexterm><primary>GetRealizProb</primary></indexterm>
<indexterm><primary>RealizProb (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber BehavSolution::GetRealizProb(gbtEfgNode) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
RealizProb[profile->BEHAV, node->NODE] =: NUMBER 
</synopsis>
</para>
</formalpara>

<para>
<function>GetRealizProb</function>
(<function>RealizProb</function> in the GCL)
returns the realization probability for <parameter>node</parameter>
given that all players
are following <parameter>profile</parameter>.  It is an error if
<parameter>profile</parameter> and
<parameter>node</parameter> are not from the same extensive form game.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>

<sect2 id="apiref.behav.getregret">
<title>GetRegret</title>
<indexterm><primary>GetRegret</primary></indexterm>
<indexterm><primary>Regret (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber BehavSolution::GetRegret(gbtEfgAction p_action) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
Regret[profile->BEHAV, action->ACTION] =: NUMBER 
</synopsis>
</para>
</formalpara>

<para>
<function>GetRegret</function> (<function>Regret</function> in the
GCL) returns the gain to a player for deviating to
<parameter>action</parameter> assuming all players are following
<parameter>profile</parameter>.  A strategy profile is a Nash
equilibrium if and only if the regrets of all actions or strategies
are zero.
</para>

<note>
<para>
The Python implementation always returns a floating-point number, even
if all the data of the game and profile are rational.
</para>
</note>

</sect2>


<sect2 id="apiref.behav.isnash">
<title>IsNash</title>
<indexterm><primary>IsNash</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gTriState BehavSolution::IsNash(void) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
IsNash[profile->BEHAV] =: BOOLEAN 
</synopsis>
</para>
</formalpara>

<para>
<function>IsNash</function>
returns <literal>True</literal> when <parameter>profile</parameter>
is known by Gambit to be a
Nash equilibrium of the corresponding game, and <literal>False</literal>
if <parameter>profile</parameter> is known to not be Nash.
Otherwise, the return value
is <literal>Unknown</literal>. 
If <parameter>profile</parameter> is complete (probabilities sum
to one for every player, and every information set), then there is a
definitive test for Nash equilibrium.  However if the profile is
incomplete (i. e., it does not specify actions at off the equilibrium
path information sets), then it is possible that a profile (or set of
all completions of the profile) may be Nash, but is not known by
Gambit to be Nash.
</para>

<note>
<para>
The Python implementation returns a value of <literal>1</literal> for
<literal>True</literal>, <literal>0</literal> for <literal>False</literal>,
and <literal>-1</literal> for <literal>Unknown</literal>.
</para>
</note>

</sect2>


<sect2 id="apiref.behav.issequential">
<title>IsSequential</title>
<indexterm><primary>IsSequential</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gTriState BehavSolution::IsSequential(void) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
IsSequential[profile->BEHAV] =: BOOLEAN 
</synopsis>
</para>
</formalpara>

<para>
<function>IsSequential</function>
returns <literal>True</literal> if <parameter>profile</parameter>
is known by Gambit to be an approximation to a
sequential Nash equilibrium, <literal>False</literal> if it is not,
and <literal>Unknown</literal> if the answer is not known.  There is
currently no definitive test in Gambit for whether an arbitrary
profile is sequential.  However any Nash equilibrium of an extensive
form game which is computed via the <function>LiapSolve</function> or
<function>QreSolve</function> algorithms is sequential.
</para>

<note>
<para>
The Python implementation returns a value of <literal>1</literal> for
<literal>True</literal>, <literal>0</literal> for <literal>False</literal>,
and <literal>-1</literal> for <literal>Unknown</literal>.
</para>
</note>

</sect2>


<sect2 id="apiref.behav.issubgameperfect">
<title>IsSubgamePerfect</title>
<indexterm><primary>IsSubgamePerfect</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gTriState BehavSolution::IsSequential(void) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
IsSubgamePerfect[profile->BEHAV] =: BOOLEAN 
</synopsis>
</para>
</formalpara>

<para>
<function>IsSubgamePerfect</function>
returns <literal>True</literal> if <parameter>profile</parameter>
is known by Gambit to be a subgame perfect Nash
equilibrium, <literal>False</literal> if it is known not to be a 
subgame perfect equilibrium, and <literal>Unknown</literal> otherwise.
There is currently no
definitive test in Gambit for whether an arbitrary profile is subgame
perfect.  However, any Nash equilibrium of an extensive form game which
is computed when all subgames are marked will only return a subgame
perfect equilibrium.  
</para>

<note>
<para>
The Python implementation returns a value of <literal>1</literal> for
<literal>True</literal>, <literal>0</literal> for <literal>False</literal>,
and <literal>-1</literal> for <literal>Unknown</literal>.
</para>
</note>

</sect2>

<sect2 id="apiref.behav.setactionprob">
<title>SetActionProb</title>
<indexterm><primary>SetActionProb</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void BehavSolution::SetStrategyProb(gbtEfgAction, gNumber)
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
SetActionProb[profile<->BEHAV, action->ACTION, value->NUMBER] =: BEHAV 
</synopsis>
</para>
</formalpara>

<para>
<function>SetActionProb</function> 
sets the component of <parameter>profile</parameter> for
<parameter>action</parameter> to be equal to <parameter>value</parameter>,
and returns <parameter>profile</parameter>.  It is an error if 
<parameter>profile</parameter> and <parameter>action</parameter>
are not from the same extensive form game. 
</para>

</sect2>

<sect2 id="apiref.behav.setactionprobs">
<title>SetActionProbs (GCL only)</title>
<indexterm><primary>SetActionProbs (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
This function is not available in C++ or Python.  Use
<function>SetActionProb</function> instead.
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
SetActionProbs[profile<->BEHAV, infoset->INFOSET, 
               value->LIST(NUMBER)] =: BEHAV 
</synopsis>
</para>
</formalpara>

<para>
<function>SetActionProbs</function> 
sets the components of <parameter>profile</parameter> for
information set <parameter>infoset</parameter> to be equal to 
<parameter>values</parameter>.
Returns <parameter>profile</parameter>. 
It is an error if <parameter>profile</parameter> and <parameter>infoset</parameter>
are not from the same extensive form game, or if the length of
<parameter>value</parameter> is not the same as the number of actions in 
<parameter>profile</parameter>'s
support at <parameter>infoset</parameter>.
</para>

</sect2>

<sect2 id="apiref.behav.setlabel">
<title>SetLabel</title>
<indexterm><primary>SetLabel</primary></indexterm>
<indexterm><primary>SetName (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void BehavSolution::SetLabel(const gText &amp;p_label)
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
This function is not available in the GCL.
</para>
</formalpara>

<para>
<function>SetLabel</function> sets the text label of the profile.
</para>

</sect2>


</sect1>

