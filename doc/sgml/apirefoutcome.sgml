<sect1 id="apiref.outcome">
<title>Outcomes</title>

<para>
</para>


<sect2 id="apiref.outcome.deleteoutcome">
<title>DeleteOutcome</title>
<indexterm><primary>DeleteOutcome</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtEfgOutcome::DeleteOutcome(void)
void gbtNfgOutcome::DeleteOutcome(void)
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
DeleteOutcome[outcome->EFOUTCOME] =: LIST(NODE) 
DeleteOutcome[outcome->NFOUTCOME] =: BOOLEAN 
</synopsis>
</para>
</formalpara>

<para>
<function>DeleteOutcome</function> removes
<parameter>outcome</parameter> from its game.  All nodes (for
extensive forms) or contingencies (for normal forms) with the
specified outcome attached are reset to having no outcome attached.
In the GCL,
the extensive form version returns the list of nodes to which the
outcome was attached; the normal form version returns
<literal>True</literal>.
</para>

</sect2>

<sect2 id="apiref.outcome.getgame">
<title>GetGame</title>
<indexterm><primary>GetGame</primary></indexterm>
<indexterm><primary>Game (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtEfgGame gbtEfgOutcome::GetGame(void) const
gbtNfgGame gbtNfgOutcome::GetGame(void) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
Game[player->EFOUTCOME] =: EFG
Game[player->NFOUTCOME] =: NFG
</synopsis>
</para>
</formalpara>

<para>
<function>GetGame</function> (or <function>Game</function> in the GCL)
returns the extensive or normal form game to which the outcome belongs.
</para>

</sect2>

<sect2 id="apiref.outcome.getlabel">
<title>GetLabel</title>
<indexterm><primary>GetLabel</primary></indexterm>
<indexterm><primary>Name (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gText gbtEfgOutcome::GetLabel(void) const
gText gbtNfgOutcome::GetLabel(void) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
Name[x->EFPLAYER*] =: TEXT
Name[x->NFPLAYER*] =: TEXT
</synopsis>
</para>
</formalpara>

<para>
<function>GetLabel</function> (<function>Name</function> in the GCL)
returns the text label of the outcome.
The empty string is returned if the outcome object is null.
</para>

</sect2>

<sect2 id="apiref.outcome.getpayoff">
<title>GetPayoff</title>
<indexterm><primary>GetPayoff</primary></indexterm>
<indexterm><primary>Payoff (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber gbtEfgOutcome::GetPayoff(gbtEfgPlayer) const
gNumber gbtNfgOutcome::GetPayoff(gbtNfgPlayer) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
Payoff[outcome->EFOUTCOME*, player->EFPLAYER] =: NUMBER 
Payoff[outcome->NFOUTCOME*, player->NFPLAYER] =: NUMBER 
</synopsis>
</para>
</formalpara>

<para>
<function>Payoff</function>
returns the value of the outcome <parameter>outcome</parameter> to the
player <parameter>player</parameter>.
An error occurs if the parameters are not from the
same game.
</para>

<note>
<para>
The Python implementation always returns a floating point number, even
if the value of the outcome is specified as a rational number in the game.
This will be improved in the near future (hopefully, because Guido approves
a rational number class for Python!)
</para>
</note>

</sect2>

<sect2 id="apiref.outcome.setlabel">
<title>SetLabel</title>
<indexterm><primary>SetLabel</primary></indexterm>
<indexterm><primary>SetName (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtEfgOutcome::SetLabel(const gText &amp;p_label)
void gbtNfgOutcome::SetLabel(const gText &amp;p_label)
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
SetName[x->EFOUTCOME, name->TEXT] =: EFOUTCOME
SetName[x->NFOUTCOME, name->TEXT] =: NFOUTCOME
</synopsis>
</para>
</formalpara>

<para>
<function>SetLabel</function> (<function>SetName</function> in the GCL) 
sets the text label of the outcome.  The GCL version returns the outcome.
</para>

</sect2>


<sect2 id="apiref.outcome.setpayoff">
<title>SetPayoff</title>
<indexterm><primary>SetPayoff</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtEfgOutcome::SetPayoff(gbtEfgPlayer, gNumber)
void gbtNfgOutcome::SetPayoff(gbtNfgPlayer, gNumber)
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
SetPayoff[outcome->EFOUTCOME, player->EFPLAYER,
          payoff->NUMBER] =: EFOUTCOME 
SetPayoff[outcome->NFOUTCOME, player->NFPLAYER, 
          payoff->NUMBER] =: NFOUTCOME 
</synopsis>
</para>
</formalpara>

<para>
<function>SetPayoff</function> sets the payoff of
<parameter>outcome</parameter> for <parameter>player</parameter> to
<parameter>payoff</parameter>.  It is an error if
<parameter>outcome</parameter> and <parameter>player</parameter> are
not from the same game.  Returns <parameter>outcome</parameter>.
</para>

<note>
<para>
The Python implementation results in a floating point number being
assigned as the payoff; there is no direct way to set a payoff to rational
precision.
This will be improved in the near future (hopefully, because Guido approves
a rational number class for Python!)
</para>
</note>

</sect2>


</sect1>

