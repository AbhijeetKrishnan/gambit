<sect1 id="apiref.outcome">
<title>Outcomes</title>

<para>
</para>


<sect2 id="apiref.outcome.deleteoutcome">
<title>DeleteOutcome</title>
<indexterm><primary>DeleteOutcome</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtEfgOutcome::DeleteOutcome(void)
void gbtNfgOutcome::DeleteOutcome(void)
</synopsis>
</para>
</formalpara>

<para>
<function>DeleteOutcome</function> removes
<parameter>outcome</parameter> from its game.  All nodes (for
extensive forms) or contingencies (for normal forms) with the
specified outcome attached are reset to having no outcome attached.
</para>

</sect2>

<sect2 id="apiref.outcome.getgame">
<title>GetGame</title>
<indexterm><primary>GetGame</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtEfgGame gbtEfgOutcome::GetGame(void) const
gbtNfgGame gbtNfgOutcome::GetGame(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetGame</function>
returns the extensive or normal form game to which the outcome belongs.
</para>

</sect2>

<sect2 id="apiref.outcome.getlabel">
<title>GetLabel</title>
<indexterm><primary>GetLabel</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gText gbtEfgOutcome::GetLabel(void) const
gText gbtNfgOutcome::GetLabel(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetLabel</function> 
returns the text label of the outcome.
The empty string is returned if the outcome object is null.
</para>

</sect2>

<sect2 id="apiref.outcome.getpayoff">
<title>GetPayoff</title>
<indexterm><primary>GetPayoff</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gNumber gbtEfgOutcome::GetPayoff(gbtEfgPlayer) const
gNumber gbtNfgOutcome::GetPayoff(gbtNfgPlayer) const
</synopsis>
</para>
</formalpara>


<para>
<function>Payoff</function>
returns the value of the outcome <parameter>outcome</parameter> to the
player <parameter>player</parameter>.
An error occurs if the parameters are not from the
same game.
</para>

<note>
<para>
The Python implementation always returns a floating point number, even
if the value of the outcome is specified as a rational number in the game.
This will be improved in the near future (hopefully, because Guido approves
a rational number class for Python!)
</para>
</note>

</sect2>

<sect2 id="apiref.outcome.setlabel">
<title>SetLabel</title>
<indexterm><primary>SetLabel</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtEfgOutcome::SetLabel(const gText &amp;p_label)
void gbtNfgOutcome::SetLabel(const gText &amp;p_label)
</synopsis>
</para>
</formalpara>

<para>
<function>SetLabel</function> sets the text label of the outcome.
</para>

</sect2>


<sect2 id="apiref.outcome.setpayoff">
<title>SetPayoff</title>
<indexterm><primary>SetPayoff</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtEfgOutcome::SetPayoff(gbtEfgPlayer, gNumber)
void gbtNfgOutcome::SetPayoff(gbtNfgPlayer, gNumber)
</synopsis>
</para>
</formalpara>

<para>
<function>SetPayoff</function> sets the payoff of
the outcome for <parameter>player</parameter> to
<parameter>payoff</parameter>.  It is an error if
the outcome and <parameter>player</parameter> are
not from the same game. 
</para>

<note>
<para>
The Python implementation results in a floating point number being
assigned as the payoff; there is no direct way to set a payoff to rational
precision.
This will be improved in the near future (hopefully, because Guido approves
a rational number class for Python!)
</para>
</note>

</sect2>


</sect1>

