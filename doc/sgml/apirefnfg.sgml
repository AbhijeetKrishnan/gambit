<sect1 id="apiref.nfg">
<title>Normal form games</title>

<para>
</para>

<sect2 id="apiref.nfg.compressnfg">
<title>CompressNfg (GCL only)</title>
<indexterm><primary>CompressNfg (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
This part of the interface is currently in flux in C++ and Python.
Consult the source code or the Gambit development team for information
if you require this function.
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
CompressNfg[support->NFSUPPORT] =: NFG 
</synopsis>
</para>
</formalpara>

<para>
<function>CompressNfg</function> creates a copy of the 
normal form game on which <parameter>support</parameter> is
defined, where all strategies not present in <parameter>support</parameter>
have been removed.
</para>

</sect2>

<sect2 id="apiref.nfg.getcomment">
<title>GetComment</title>
<indexterm><primary>GetComment</primary></indexterm>
<indexterm><primary>Comment (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gText gbtNfgGame::GetComment(void) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
Comment[nfg->NFG] =: TEXT
</synopsis>
</para>
</formalpara>

<para>
<function>GetComment</function> (<function>Comment</function> in the GCL)
returns the comment associated with the game
<parameter>nfg</parameter>.
</para>

</sect2>

<sect2 id="apiref.nfg.getlabel">
<title>GetLabel</title>
<indexterm><primary>GetLabel</primary></indexterm>
<indexterm><primary>Name (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gText gbtNfgGame::GetLabel(void) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
Name[x->NFG*] =: TEXT
</synopsis>
</para>
</formalpara>

<para>
<function>GetLabel</function> (<function>Name</function> in the GCL)
returns the text label of the game.  
The empty string is returned if the game object is null.
</para>

</sect2>


<sect2 id="apiref.nfg.getplayer">
<title>GetPlayer</title>
<indexterm><primary>GetPlayer</primary></indexterm>
<indexterm><primary>Players (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtNfgPlayer gbtNfgGame::GetPlayer(int p_index) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetPlayer</function> returns the player numbered
<parameter>p_index</parameter> from the list of players in the
game.  Each game's players are numbered sequentially beginning
at one.  An exception is thown if the index is out of range.
</para>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
Players[nfg->NFG] =: LIST(NFPLAYER) 
</synopsis>
</para>
</formalpara>

<para>
<function>Players</function>
returns the list of players defined on the game <parameter>nfg</parameter>.
</para>

</sect2>


<sect2 id="apiref.nfg.isconstsum">
<title>IsConstSum</title>
<indexterm><primary>IsConstSum</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
bool gbtNfgGame::IsConstSum(void) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
IsConstSum[nfg->NFG] =: BOOLEAN 
</synopsis>
</para>
</formalpara>

<para>
<function>IsConstSum</function>
returns <literal>True</literal> (nonzero) when the normal form game 
is constant sum and <literal>False</literal> (zero) otherwise.
</para>
</sect2>


<sect2 id="apiref.nfg.newnfg">
<title>NewNfg</title>
<indexterm><primary>NewNfg</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
This part of the interface is currently in flux in C++ and Python.
Consult the source code or the Gambit development team for information
if you require this function.
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
NewNfg[dim->LIST(INTEGER)] =: NFG 
</synopsis>
</para>
</formalpara>

<para>
<function>NewNfg</function>
creates a new normal form game with dimension <parameter>dim</parameter>.  No
initialization of the payoffs of the game is done.  Returns the newly
created game.  
</para>

</sect2>



<sect2 id="apiref.nfg.newoutcome">
<title>NewOutcome</title>
<indexterm><primary>NewOutcome</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtNfgOutcome gbtNfgGame::NewOutcome(void)
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
NewOutcome[nfg->NFG] =: NFOUTCOME 
</synopsis>
</para>
</formalpara>

<para>
<function>NewOutcome</function>
defines a new outcome in the normal form game <parameter>nfg</parameter>.
The new
outcome specifies payoffs of zero for all players.  Returns the newly
created outcome.
</para>
</sect2>


<sect2 id="apiref.nfg.numplayers">
<title>NumPlayers</title>
<indexterm><primary>NumPlayers</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
int gbtNfgGame::NumPlayers(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>NumPlayers</function> returns how many players are defined
on the game.
</para>

<formalpara>
<title>GCL usage</title>
<para>
<function>NumPlayers</function> can be written as a user-defined function
in the GCL as
<programlisting>
NewFunction[NumPlayers[nfg->NFG] =: INTEGER,
  Length[Players[nfg]]
];
</programlisting>
</para>
</formalpara>

</sect2>


<sect2 id="apiref.nfg.outcome">
<title>Outcome</title>
<indexterm><primary>Outcome</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
This part of the interface is currently in flux in C++ and Python.
Consult the source code or the Gambit development team for information
if you require this function.
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
Outcome[profile->LIST(STRATEGY)] =: NFOUTCOME 
</synopsis>
</para>
</formalpara>

<para>
<function>Outcome</function>
returns the outcome associated with the <parameter>node</parameter>,
or the contingency <parameter>profile</parameter>.  The outcome associated
with the null node is the null outcome.
</para>

</sect2>


<sect2 id="apiref.nfg.readnfg">
<title>ReadNfg</title>
<indexterm><primary>ReadNfg</primary></indexterm>
<indexterm><primary>LoadNfg (GCL function)</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
gbtNfgGame ::ReadNfg(gInput &amp;p_file)
</synopsis>
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
nfg = gambit.ReadNfg(filename)
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
LoadNfg[file->TEXT] =: NFG 
</synopsis>
</para>
</formalpara>

<para>
<function>ReadNfg</function> (<function>LoadNfg</function> in the GCL)
reads a normal form game from the file <parameter>file</parameter>.
C++ users should pass a stream represented by a <type>gInput</type> object;
Python and GCL users should pass the filename of the file to be read.
An error occurs if the file cannot be opened, or if the file does
not contain a valid normal form savefile.
</para>

</sect2>


<sect2 id="apiref.nfg.setcomment">
<title>SetComment</title>
<indexterm><primary>SetComment</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtNfgGame::SetComment(const gText &amp;p_comment)
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
SetComment[nfg->NFG, comment->TEXT] =: NFG
</synopsis>
</para>
</formalpara>

<para>
<function>SetComment</function> 
sets the comment associated with the game <parameter>nfg</parameter>.
</para>

</sect2>


<sect2 id="apiref.nfg.setlabel">
<title>SetLabel</title>
<indexterm><primary>SetLabel</primary></indexterm>
<indexterm><primary>SetName (GCL function)</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtNfgGame::SetLabel(const gText &amp;p_label)
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
SetName[x->NFG, name->TEXT] =: NFG
</synopsis>
</para>
</formalpara>

<para>
<function>SetLabel</function> (<function>SetName</function> in the GCL) 
sets the text label of the game.  The GCL version returns the game.
</para>

</sect2>


<sect2 id="apiref.nfg.setoutcome">
<title>SetOutcome</title>
<indexterm><primary>SetOutcome</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
This part of the interface is currently in flux in C++ and Python.
Consult the source code or the Gambit development team for information
if you require this function.
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
SetOutcome[profile->LIST(STRATEGY), outcome->NFOUTCOME] =: NFOUTCOME 
</synopsis>
</para>
</formalpara>

<para>
<function>SetOutcome</function>
attaches <parameter>outcome</parameter> to the cell in the normal form game
determined by the pure strategy profile defined by <parameter>profile</parameter>.
Returns the outcome attached.  It is an error if <parameter>profile</parameter> and
<parameter>outcome</parameter> are not from the same normal form game. Also,
<parameter>profile</parameter> must be a list of strategies consisting of one strategy
for each player in the game.  
</para>

</sect2>


<sect2 id="apiref.nfg.writenfg">
<title>WriteNfg</title>
<indexterm><primary>WriteNfg</primary></indexterm>
<indexterm><primary>SaveNfg (GCL function)</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
void gbtNfgGame::WriteNfg(gOutput &amp;p_file) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
nfg.WriteNfg(filename)
</synopsis>
</para>
</formalpara>

<formalpara>
<title>GCL usage</title>
<para>
<synopsis>
SaveNfg[nfg->EFG, file->TEXT] =: NFG 
</synopsis>
</para>
</formalpara>

<para>
<function>WriteNfg</function>
(<function>SaveNfg</function> in the GCL) writes a normal form
game to an external savefile.  In C, this file is given as a 
<type>gOutput</type> stream object; in Python and the GCL, the filename
to be written is passed.
The GCL version returns <parameter>nfg</parameter>.
</para>

</sect2>


</sect1>

