<sect1 id="apiref.node">
<title>Nodes</title>

<para>
</para>

<sect2 id="apiref.node.deletemove">
<title>DeleteMove</title>
<indexterm><primary>DeleteMove</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtEfgNode::DeleteMove(gbtEfgNode p_keep)
</synopsis>
</para>
</formalpara>

<para>
<function>DeleteMove</function>
deletes <parameter>node</parameter> from its extensive form game.  The
subtree rooted in node <parameter>keep</parameter>, which must be a child of
<parameter>node</parameter>, is kept, and <parameter>keep</parameter> takes
the place of <parameter>node</parameter> in
the tree.  All other subtrees descending from <parameter>node</parameter> 
are deleted.
It is an error if <parameter>keep</parameter>
is not a child of <parameter>node</parameter>, 
or if <parameter>keep</parameter> and <parameter>node</parameter> are not
from the same extensive form game.
</para>

</sect2>

<sect2 id="apiref.node.deletetree">
<title>DeleteTree</title>
<indexterm><primary>DeleteTree</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtEfgNode::DeleteTree(void)
</synopsis>
</para>
</formalpara>

<para>
<function>DeleteTree</function>
deletes the subtree rooted at <parameter>node</parameter>.  The
node then becomes a terminal node. 
</para>

</sect2>


<sect2 id="apiref.node.getchild">
<title>GetChild</title>
<indexterm><primary>GetChild</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtEfgNode gbtEfgNode::GetChild(int p_index) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetChild</function> 
returns the child numbered
<parameter>p_index</parameter> from the list of children for the node.
Each node's children, if any, are numbered sequentially beginning at one.
An exception is thrown if the index is out of range.
</para>

</sect2>


<sect2 id="apiref.node.getgame">
<title>GetGame</title>
<indexterm><primary>GetGame</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtEfgGame gbtEfgNode::GetGame(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetGame</function> returns the extensive form game to which
the node belongs.
</para>

</sect2>

<sect2 id="apiref.node.getinfoset">
<title>GetInfoset</title>
<indexterm><primary>GetInfoset</primary></indexterm>

<formalpara>
<title>C++/Python usage</title
<para>
<synopsis>
gbtEfgInfoset gbtEfgNode::GetInfoset(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetInfoset</function> returns the information set to which
the <parameter>node</parameter> belongs.  The null node belongs to the
null information set.
</para>

</sect2>


<sect2 id="apiref.node.getlabel">
<title>GetLabel</title>
<indexterm><primary>GetLabel</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gText gbtEfgNode::GetLabel(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetLabel</function> returns the text label of the node.  The
empty string is returned if the node object is null.
</para>

</sect2>


<sect2 id="apiref.node.getnextsibling">
<title>GetNextSibling</title>
<indexterm><primary>GetNextSibling</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtEfgNode gbtEfgNode::GetNextSibling(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetNextSibling</function> returns the next sibling of
<parameter>node</parameter>.  If <parameter>node</parameter> has no
next sibling, the null node is returned.
</para>

</sect2>

<sect2 id="apiref.node.getoutcome">
<title>GetOutcome</title>
<indexterm><primary>GetOutcome</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtEfgOutcome gbtEfgNode::GetOutcome(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetOutcome</function>
returns the outcome associated with the <parameter>node</parameter>.
The outcome associated
with the null node is the null outcome.
</para>

</sect2>


<sect2 id="apiref.node.getparent">
<title>GetParent</title>
<indexterm><primary>GetParent</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtEfgNode gbtEfgNode::GetParent(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetParent</function> 
returns the parent of <parameter>node</parameter>.
If <parameter>node</parameter> is the root node,
or if <parameter>node</parameter> is null, the null node is returned.
</para>

</sect2>

<sect2 id="apiref.node.getprioraction">
<title>GetPriorAction</title>
<indexterm><primary>GetPriorAction</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtEfgAction gbtEfgNode::GetPriorAction(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetPriorAction</function> returns the action corresponding
to the branch leading to <parameter>node</parameter>.  If
<parameter>node</parameter> is the root node, its prior action is the
null action.
</para>

</sect2>

<sect2 id="apiref.node.getpriorsibling">
<title>GetPriorSibling</title>
<indexterm><primary>GetPriorSibling</primary></indexterm>


<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtEfgNode gbtEfgNode::GetPriorSibling(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetPriorSibling</function>
returns the previous sibling of <parameter>node</parameter>. 
If <parameter>node</parameter> has no previous
sibling, the null node is returned.
</para>

</sect2>


<sect2 id="apiref.node.insertmove">
<title>InsertMove</title>
<indexterm><primary>InsertMove</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtEfgNode gbtEfgNode::InsertMove(gbtEfgInfoset)
</synopsis>
</para>
</formalpara>

<para>
<function>InsertMove</function>
inserts a new node in the tree at the location of <parameter>node</parameter>.
The
new node is made a member of <parameter>infoset</parameter>, and the
corresponding number of branches are created from the new node.
The node <parameter>node</parameter>
becomes the first child of the new node.  Returns the new node.
</para>

</sect2>

<sect2 id="apiref.node.ispredecessorof">
<title>IsPredecessorOf</title>
<indexterm><primary>IsPredecessorOf</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
bool gbtEfgNode::IsPredecessorOf(gbtEfgNode) const
</synopsis>
</para>
</formalpara>

<para>
<function>IsPredecessorOf</function>
returns <literal>True</literal> (nonzero) when <parameter>node</parameter>
is a predecessor
in the tree of the node <parameter>of</parameter>, and
<literal>False</literal> (zero) otherwise.
A node is considered its own predecessor.
</para>

</sect2>


<sect2 id="apiref.node.numchildren">
<title>NumChildren</title>
<indexterm><primary>NumChildren</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
int gbtEfgNode::NumChildren(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>NumChildren</function> returns the number of children
(direct descendants) of the node.
</para>

</sect2>


<sect2 id="apiref.node.setlabel"> 
<title>SetLabel</title>
<indexterm><primary>SetLabel</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtEfgNode::SetLabel(const gText &amp;p_label)
</synopsis>
</para>
</formalpara>

<para>
<function>SetLabel</function> sets the text label of the node.
</para>

</sect2>


<sect2 id="apiref.node.setoutcome">
<title>SetOutcome</title>
<indexterm><primary>SetOutcome</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtEfgNode::SetOutcome(gbtEfgOutcome)
</synopsis>
</para>
</formalpara>

<para>
<function>SetOutcome</function> 
attaches <parameter>outcome</parameter> to <parameter>node</parameter>.
Returns the outcome attached.
Note that nonterminal nodes may have outcomes attached; the interpretation
is that nonterminal outcomes represent incremental payoffs.  
It is an error if <parameter>node</parameter> and <parameter>outcome</parameter>
are not from the same
extensive form game.
</para>

</sect2>

</sect1>

