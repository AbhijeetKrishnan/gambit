<sect1 id="apiref.node">
<title>Nodes</title>

<para>
A node represents a (public) history in a game.  At nonterminal nodes, a
player (possibly the chance player) makes a move.
</para>

<sect2 id="apiref.node.copytree">
<title>CopyTree</title>
<indexterm><primary>CopyTree</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGameNode gbtGameNode::CopyTree(gbtGameNode p_src)
</synopsis>
</para>
</formalpara>

<para>
<function>CopyTree</function>
copies the subtree rooted at <parameter>p_src</parameter> to this node.
<parameter>p_src</parameter> may be a predecessor of the node.
A <errorname>gbtGameMismatchException</errorname> (mapped to
<errorname>RuntimeError</errorname> in Python) occurs if
<parameter>p_src</parameter> is from a different game, or if this node
is not a terminal node.
</para>

</sect2>


<sect2 id="apiref.node.deletemove">
<title>DeleteMove</title>
<indexterm><primary>DeleteMove</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtGameNode::DeleteMove(void)
</synopsis>
</para>
</formalpara>

<para>
<function>DeleteMove</function>
deletes the move prior to the node from its extensive form game. 
All other subtrees emanating from the parent move are deleted, and the
node assumes its parent's former place in the game tree.
If the node is the root node, no action is taken.
</para>

</sect2>

<sect2 id="apiref.node.deletetree">
<title>DeleteTree</title>
<indexterm><primary>DeleteTree</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtGameNode::DeleteTree(void)
</synopsis>
</para>
</formalpara>

<para>
<function>DeleteTree</function>
deletes the subtree rooted at the node.  The
node then becomes a terminal node. 
</para>

</sect2>


<sect2 id="apiref.node.getchild">
<title>GetChild</title>
<indexterm><primary>GetChild</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGameNode gbtGameNode::GetChild(int p_index) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetChild</function> 
returns the child numbered
<parameter>p_index</parameter> from the list of children for the node.
Each node's children, if any, are numbered sequentially beginning at one.
An exception is thrown (<errorname>gbtIndexException</errorname> in
C++, <errorname>IndexError</errorname> in Python) if the index is out
of range.
</para>

</sect2>

<sect2 id="apiref.node.getchildaction">
<title>GetChildAction</title>
<indexterm><primary>GetChildAction</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
gbtGameNode gbtGameNode::GetChild(const gbtAction &amp;p_action) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
node.GetChildAction(action)
</synopsis>
</para>
</formalpara>

<para>
<function>GetChild</function> (<function>GetChildAction</function> in
Python) returns the child node reached by following the branch leading
out of the node corresponding to the specified action.  If the action
does not belong to the same information set to which the node belongs,
a <errorname>gbtGameMismatchException</errorname> is thrown in C++,
which is mapped to a <errorname>RuntimeError</errorname> exception in
Python.  </para>

</sect2>


<sect2 id="apiref.node.getid">
<title>GetId</title>
<indexterm><primary>GetId</primary></indexterm>

<formalpara>
<title>C++/Python usage</title
<para>
<synopsis>
int gbtGameNode::GetId(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetId</function> returns the ID number of the node.
The ID is unique within a game, and is assigned in the order nodes
are encountered in a traversal of the tree.  Note that this implies the
&quot;same&quot; node may have different ID numbers as the tree is
edited, but that two independently built games that have equivalent
tree structures will be such that corresponding nodes will have the same
ID, no matter how the tree is built.
</para>

</sect2>

<sect2 id="apiref.node.getinfoset">
<title>GetInfoset</title>
<indexterm><primary>GetInfoset</primary></indexterm>

<formalpara>
<title>C++/Python usage</title
<para>
<synopsis>
gbtGameInfoset gbtGameNode::GetInfoset(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetInfoset</function> returns the information set to which
the node belongs.  Terminal nodes belong to the null information set.  
</para>

</sect2>


<sect2 id="apiref.node.getlabel">
<title>GetLabel</title>
<indexterm><primary>GetLabel</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
std::string gbtGameNode::GetLabel(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetLabel</function> returns the text label of the node.  
</para>

</sect2>

<sect2 id="apiref.node.getmemberid">
<title>GetMemberId</title>
<indexterm><primary>GetMemberId</primary></indexterm>

<formalpara>
<title>C++/Python usage</title
<para>
<synopsis>
int gbtGameNode::GetMemberId(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetMemberId</function> returns the ID number of the node in
its information set.
The ID is assigned in the order the nodes in the information set.
are encountered in a traversal of the tree. 
</para>

</sect2>

<sect2 id="apiref.node.getnextmember">
<title>GetNextMember</title>
<indexterm><primary>GetNextMember</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGameNode gbtGameNode::GetNextMember(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetNextMember</function> returns the next member of the information
set.  If there is no subsequent member, the null node is returned.
</para>

</sect2>

<sect2 id="apiref.node.getnextsibling">
<title>GetNextSibling</title>
<indexterm><primary>GetNextSibling</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGameNode gbtGameNode::GetNextSibling(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetNextSibling</function> returns the next sibling of the
node.  If the node has no next sibling, the null node is returned.
</para>

</sect2>

<sect2 id="apiref.node.getoutcome">
<title>GetOutcome</title>
<indexterm><primary>GetOutcome</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGameOutcome gbtGameNode::GetOutcome(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetOutcome</function> returns the outcome associated with
the node.
</para>

</sect2>


<sect2 id="apiref.node.getparent">
<title>GetParent</title>
<indexterm><primary>GetParent</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGameNode gbtGameNode::GetParent(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetParent</function> 
returns the parent of <parameter>node</parameter>.
If <parameter>node</parameter> is the root node, the null node is returned.
</para>

</sect2>

<sect2 id="apiref.node.getplayern">
<title>GetPlayer</title>
<indexterm><primary>GetPlayer</primary></indexterm>

<formalpara>
<title>C++/Python usage</title
<para>
<synopsis>
gbtGamePlayer gbtGameNode::GetPlayer(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetPlayer</function> returns the player who has the move at the
node.  If the node is terminal, the null player is returned.
</para>

</sect2>

<sect2 id="apiref.node.getprioraction">
<title>GetPriorAction</title>
<indexterm><primary>GetPriorAction</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGameAction gbtGameNode::GetPriorAction(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetPriorAction</function> returns the action corresponding
to the branch leading to the node.  If the node is the root node, its
prior action is the null action.  
</para>

</sect2>

<sect2 id="apiref.node.getpriormember">
<title>GetPriorMember</title>
<indexterm><primary>GetPriorMember</primary></indexterm>


<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGameNode gbtGameNode::GetPriorMember(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetPriorMember</function> returns the previous member in the
information set.  If there is no previous member, the null node is returned.
</para>

</sect2>

<sect2 id="apiref.node.getpriorsibling">
<title>GetPriorSibling</title>
<indexterm><primary>GetPriorSibling</primary></indexterm>


<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGameNode gbtGameNode::GetPriorSibling(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetPriorSibling</function> returns the previous sibling of
the node.  If the node has no previous sibling, the null node is
returned. 
</para>

</sect2>


<sect2 id="apiref.node.insertmove">
<title>InsertMove</title>
<indexterm><primary>InsertMove</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGameNode gbtGameNode::InsertMove(gbtGameInfoset)
</synopsis>
</para>
</formalpara>

<para>
<function>InsertMove</function>
inserts a new node in the tree at the location of the node.
The
new node is made a member of <parameter>infoset</parameter>, and the
corresponding number of branches are created from the new node.
The node becomes the first child of the new node.  Returns the new node.
A <errorname>gbtGameMismatchException</errorname> (mapped to
<errorname>RuntimeError</errorname> in Python) is thrown if the
information set does not belong to the same game as the node.
</para>

</sect2>

<sect2 id="apiref.node.isnonterminal">
<title>IsNonterminal</title>
<indexterm><primary>IsNonterminal</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
bool gbtGameNode::IsNonterminal(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>IsNonterminal</function>
returns <literal>True</literal> (nonzero) when the node
is not a terminal node (that is, the node has children).
</para>

</sect2>

<sect2 id="apiref.node.isnull">
<title>IsNull</title>
<indexterm><primary>IsNull</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
bool gbtGameNode::IsNull(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>IsNull</function>
returns <literal>True</literal> (nonzero) when the node
is the null node.
</para>

</sect2>


<sect2 id="apiref.node.ispredecessorof">
<title>IsPredecessorOf</title>
<indexterm><primary>IsPredecessorOf</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
bool gbtGameNode::IsPredecessorOf(gbtGameNode p_other) const
</synopsis>
</para>
</formalpara>

<para>
<function>IsPredecessorOf</function>
returns <literal>True</literal> (nonzero) when the node
is a predecessor
in the tree of the node <parameter>p_other</parameter>, and
<literal>False</literal> (zero) otherwise.
A node is considered its own predecessor.
</para>

</sect2>

<sect2 id="apiref.node.isterminal">
<title>IsTerminal</title>
<indexterm><primary>IsTerminal</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
bool gbtGameNode::IsTerminal(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>IsTerminal</function>
returns <literal>True</literal> (nonzero) when the node
is a terminal node (that is, the node has no children).
</para>

</sect2>

<sect2 id="apiref.node.joininfoset">
<title>JoinInfoset</title>
<indexterm><primary>JoinInfoset</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtGameNode::JoinInfoset(const gbtGameInfoset &amp;p_infoset)
</synopsis>
</para>
</formalpara>

<para>
<function>JoinInfoset</function> places the node into
<parameter>p_infoset</parameter>.
A <errorname>gbtGameMismatchException</errorname> (mapped to
<errorname>RuntimeError</errorname> in Python) is thrown if the
information set does not belong to the same game as the node, or if
the number of actions specified by the information set does not match
the number of actions at the node.
</para>

</sect2>

<sect2 id="apiref.node.leaveinfoset">
<title>LeaveInfoset</title>
<indexterm><primary>LeaveInfoset</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGameInfoset gbtGameNode::LeaveInfoset(void)
</synopsis>
</para>
</formalpara>

<para>
<function>LeaveInfoset</function> removes the node from its information
set and places it in a new information set.  No action is taken if the
node is already the only member of its information set, or if the node
is a terminal node.
</para>

</sect2>

<sect2 id="apiref.node.movetree">
<title>MoveTree</title>
<indexterm><primary>MoveTree</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGameNode gbtGameNode::MoveTree(gbtGameNode p_src)
</synopsis>
</para>
</formalpara>

<para>
<function>MoveTree</function>
moves the subtree rooted at <parameter>p_src</parameter> to this node.
A <errorname>gbtGameMismatchException</errorname> (mapped to
<errorname>RuntimeError</errorname> in Python) occurs if
<parameter>p_src</parameter> is from a different game, or if this node
is not a terminal node.
</para>

</sect2>

<sect2 id="apiref.node.numchildren">
<title>NumChildren</title>
<indexterm><primary>NumChildren</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
int gbtGameNode::NumChildren(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>NumChildren</function> returns the number of children
(direct descendants) of the node.
</para>

</sect2>


<sect2 id="apiref.node.setlabel"> 
<title>SetLabel</title>
<indexterm><primary>SetLabel</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtGameNode::SetLabel(const std::string &amp;p_label)
</synopsis>
</para>
</formalpara>

<para>
<function>SetLabel</function> sets the text label of the node.
</para>

</sect2>


<sect2 id="apiref.node.setoutcome">
<title>SetOutcome</title>
<indexterm><primary>SetOutcome</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtGameNode::SetOutcome(gbtGameOutcome)
</synopsis>
</para>
</formalpara>

<para>
<function>SetOutcome</function> 
attaches the outcome to the node.
Note that nonterminal nodes may have outcomes attached; the interpretation
is that nonterminal outcomes represent incremental payoffs.  
A <errorname>gbtGameMismatchException</errorname> (mapped to 
<errorname>RuntimeError</errorname> in Python) occurs if the outcome does
not belong to the same game as the node.
</para>

</sect2>

</sect1>
