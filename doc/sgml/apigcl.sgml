<sect1 id="api.gcl">
<title>GCL language description</title>

<warning>
<para>
Beginning with version 0.97.1.0 of Gambit, the Gambit Command Language
is officially deprecated.  For backwards compatibility, the GCL will
continue to be provided for the next few minor releases, but it will
be less actively tested and supported.  Users are encouraged to write
all new scripts using the new Python API, or directly using the C++
API.  Users interested in accessing Gambit in another language supported
by the SWIG tools should contact the Gambit development team to see if
this can be made possible.
</para>
</warning>

<para>
This section is an introduction to the Gambit Command Language (GCL).
The GCL provides a
method of directing the operation of Gambit that is analagous to that
of a high level general purpose programming language.
</para>
<para>
The purpose of the GCL is to provide a simple, but powerful and
flexible language by which one can perform complicated or repetitive
operations and procedures on games in extensive or normal form.  The
language has facilities for building and editing an extensive or
normal form game, converting back and forth between the extensive and
normal form representations, and solving the resulting games for
various equilibria of interest.  Standard arithmetic, logic, text and
input-output operations are provided, as well as vectorizable
functions which support many vector and matrix operations.  Flow
control statements allow for repetitive operations (such as
investigating games as one changes various parameters) or conditional
operations.  Thus the GCL is also suitable for certain types of
econometric analysis of games.
</para>


<sect2>
<title>Introduction to the command language</title>

<para>
When the GCL starts, it first looks for the initialization file
<filename>gclini.gcl</filename>
which is a file containing GCL functions, including
function to load the standard user defined functions that are
documented in this manual.  If the file cannot be found, a warning
will be issued.  Control is then turned over to you, and you will
receive the GCL prompt
<programlisting>
GCL1:= << 
</programlisting>
The interpreter is ready for your input.  Note that
your prompt may be different from the above depending on settings in
your <filename>gclini.gcl</filename> file.  
</para>

<sect3>
<title>Command line editing</title>
<para>
You can edit the command line by using the arrow keys. The left and
right arrow key move the cursor, the back space or delete key can be
used to delete characters, and the typing characters will enter the
characters in insert mode. The up and down arrow keys can be used to
recall previous lines.  
</para>
</sect3>

<sect3>
<title>Meaning of the prompt</title>
<para>
The GCL prompt is of the form <prompt>GCLnn:= &lt;&lt;</prompt>.
The prompt is
actually a valid part of a GCL expression, and can be deleted or modified by
the command line editor if so desired.  The <prompt>&lt;&lt;</prompt>
part of the
prompt is the short form of the <function>Print</function> function, which causes
its argument to be displayed.
Backspacing over this part of the command will suppress
output.  The <prompt>GCLnn:=</prompt> part of the prompt assigns
the evaluation of the expression
to the variable <prompt>GCLnn</prompt>.  Backspacing over
this will prevent saving of the output into a variable.
</para>

</sect3>

</sect2>

<sect2>
<title>Basic concepts</title>
<para>
The design motifs for GCL come from two principal families of
programming languages.  The first is traditional imperative
programming languages such as Pascal, C, and Modula-3.  In particular,
the GCL's concept of types draws heavily from these languages,
although the number of predefined types in GCL is much larger due to
the specialized nature of the language.  The second is more
specialized programming languages such as Mathematica, from which the
GCL's grammar is partially drawn.  Users with experience using any of
these languages should find the GCL easy to learn; however, no
programming experience is necessary to begin using the language
effectively.
</para>

<para>
The GCL is a language designed primarily for building, solving and
doing econometric analysis of non-cooperative games.  Because the GCL is a
specialized language, it has several features that are designed to
make computing as easy and flexible as possible in this kind of
environment.  Some of the main features of the GCL are:
<itemizedlist>
<listitem>
<para>
Specialized built-in data types with implicit typing:
The GCL has a number of specialized built-in data types to represent
various parts of games. For example for extensive form games, there
are built in data types to represent players, strategies, nodes in an
extensive form game tree, information sets, actions, outcomes,
behavior strategy profiles, and an entire extensive form game.
These data types are used internally by the GCL to organize
computation, and keep track of important features of the objects that
these data types represent.
</para>

<para>
Despite the large number of specialized data types, the GCL uses
implicit typing.  Implicit typing means that you never have to
explicitly declare what the data type of a variable is before you use
it.  Variables can thus be easily created in an interactive mode to
refer to any object that is a valid data type, and to save
intermediate steps of computations on these data structures.
</para>
</listitem>

<listitem>
<para>
Everything is a function:
Almost every statement in the GCL is built up from function calls.
Briefly, a function in the GCL is a procedure that takes objects of
specified data types, and uses them to construct and return an object
of a (possibly different) specified data type.  The GCL provides a set
of Built-In Functions (BIFs), which are documented in the
function reference section of this manual.  
</para>

<para>
The GCL provides functions that construct simple objects of any given
data type, and other functions that operate on objects of given data
types to modify them or create a new object that is guaranteed to be a
valid object of the given data type.  A GCL program typically consists
of using output from one function as input to a second, whose output
is then used as input to the next, and so on.  In this way, very
complicated objects, such as extensive form games, can be built, all
the while guaranteeing their internal consistency.  In this fashion,
one can construct any valid extensive form game, and (barring bugs) it
is impossible in the GCL to construct an invalid extensive form game.
</para>

<para>
In addition to the built-in functions, the GCL also allows you to
construct your own functions, which have exactly the same behavior as
any built-in function (listablity, recursion, optional arguments,
and accessible via online help)
</para>
</listitem>

<listitem>
<para>
Listability:
Many objects of interest in game theory are sets (the set of
players, of information sets for a player, of actions for an
information set, etc.)  All objects in the GCL (including lists) can
be put in lists.  Further, when a GCL function (with a few exceptions
noted in the Function reference section) is called with a list for
one of its arguments, the function is run &quot;listably&quot;.  This means
that the function is executed for each element of the list and
generates a list (or nested list) of the corresponding dimension as
output.  This makes it quite easy to generate objects of game
theoretic interest.  It also makes it easy to perform certain
repetitive operations usually performed by flow control statements.
</para>
</listitem>
</itemizedlist>
</para>

</sect2>

<sect2>
<title>Data types</title>
<para>
The built-in data types for the GCL are given in the following table.
The table is
divided into four sections. The data types in the first section are
standard data types that are supported in many languages.  The data
types in the next two sections are more specialized data types that
are used to represent elements of normal and extensive form games,
respectively.  The last section contains only one type, lists, which
play an important role in the GCL. 
</para>

<para>
The data types <type>INTEGER</type> and <type>EFBASIS</type> are subtypes
of another, parent type.  They are indicated in the table as the
indented entries following their parent type.  A subtype is a data
type which has all of the properties of its parent type, plus some
additional characteristics.  For example, an integer is a rational
number, with the additional restriction that its denominator is one.

<table>
<title>Data types in GCL</title>
<tgroup cols="2">
<thead>
<row><entry>Type name</entry><entry>Description</entry></row>
</thead>
<tbody>
<row><entry><type>BOOLEAN</type></entry><entry>a boolean value</entry></row>
<row>
<entry><type>NUMBER</type></entry>
<entry>a floating-point or rational number</entry>
</row>
<row><entry><type>INTEGER</type></entry><entry>an integer</entry></row>
<row>
<entry><type>TEXT</type></entry>
<entry>a string of arbitrary length</entry>
</row>
<row><entry><type>INPUT</type></entry><entry>input stream</entry></row>
<row><entry><type>OUTPUT</type></entry><entry>output stream</entry></row>
<row><entry><type>NFG</type></entry><entry>normal form game</entry></row>
<row>
<entry><type>NFPLAYER</type></entry>
<entry>a player in a normal form game</entry>
</row>
<row>
<entry><type>STRATEGY</type></entry>
<entry>a strategy in a normal form game</entry>
</row>
<row>
<entry><type>NFOUTCOME</type></entry>
<entry>an outcome in a normal form game</entry>
</row>
<row>
<entry><type>NFSUPPORT</type></entry>
<entry>a support of strategies in a normal form game</entry>
</row>
<row>
<entry><type>MIXED</type></entry>
<entry>a mixed strategy profile for a normal form game</entry>
</row>
<row>
<entry><type>EFG</type></entry>
<entry>an extensive form game</entry>
</row>
<row>
<entry><type>EFPLAYER</type></entry>
<entry>a player in an extensive form game</entry>
</row>
<row>
<entry><type>NODE</type></entry>
<entry>a node in an extensive form game</entry>
</row>
<row>
<entry><type>INFOSET</type></entry>
<entry>an information set in an extensive form game</entry>
</row>
<row>
<entry><type>ACTION</type></entry>
<entry>an action at an information set</entry>
</row>
<row>
<entry><type>EFOUTCOME</type></entry>
<entry>an outcome in an extensive form game</entry>
</row>
<row>
<entry><type>EFSUPPORT</type></entry>
<entry>a support of actions in an extensive form game</entry>
</row>
<row>
<entry><type>EFBASIS</type></entry>
<entry>an <type>EFSUPPORT</type> that is a basis for an assessment</entry>
</row>
<row>
<entry><type>BEHAV</type></entry>
<entry>a behavior strategy profile for an extensive form game</entry>
</row>
<row>
<entry><type>LIST(T)</type></entry>
<entry>a list of objects of type <type>T</type> (<type>T</type> is any
data type</entry>
</row>
</tbody>
</tgroup>
</table>
</para>

<para>
The remainder of this section details the rules concerning the
standard types <type>BOOLEAN</type>, <type>NUMBER</type>,
<type>TEXT</type>, <type>INPUT</type> and <type>OUTPUT</type>, as well as general
rules for typing.  The extensive form and normal form types, and their
related types, are detailed later in special sections.
</para>

<sect3>
<title>Boolean</title>
<para>
The <type>BOOLEAN</type> type is used to represent the boolean values.
The <type>BOOLEAN</type> type is implemented in tri-state logic,
and has the three values &quot;true&quot;, &quot;false&quot; and
&quot;unknown&quot;.  The
command language predefines three constants to represent these:
<literal>True</literal>, <literal>False</literal>, and 
<literal>Unknown</literal>.
</para>
</sect3>

<sect3>
<title>Numeric data types</title>
<para>
The GCL supports one basic numeric data type, <type>NUMBER</type>, with a 
subtype of <type>INTEGER</type>.

<itemizedlist>
<listitem>
<para>
Number:
The <type>NUMBER</type> type may contain numbers whose internal
representation is either floating point or rational.  The internal
representation of the number is referred to as the precision
of the number.  Whether the precision of the number is floating point
or rational depends on how the number is initially input.  It can be
input either as a floating point constant, or a rational constant.
</para>

<para>
Floating point numbers are implemented as the machine's
double-precision floating point type.  Computation with these numbers
is subject to rounding of least significant digits, and hence these
numbers can be imprecise; for example, operations usually associated
with being inverses of each other may not be with floating point
numbers. However, since arithmetic operations on floating point
numbers are implemented in hardware, use floating-point 
precision when speed is important.
</para>

<para>
Rational numbers are implemented as the ratios of two arbitrary-length
integers. Rational numbers are capable of precisely representing any
rational number, and arithmetic operations on rationals are exact.
However, arithmetic operations on rational numbers are implemented in
software.  Hence, computations with rational numbers can be slow, and
output from them may be unreadably large.
</para>

<para>
Floating point constants are represented in the GCL by any string of
digits (where a digit is an element of 
<literal>{0,1,2,3,4,5,6,7,8,9}</literal>)
containing exactly one decimal point (<literal>.</literal>).  Rational constants
are represented in the GCL by andy string of digits containing at most
one division sign (<literal>/</literal>).  Any <type>NUMBER</type> in the GCL is assumed
to be in base ten representation.
</para>
</listitem>

<listitem>
<para>
Integer:
The <type>INTEGER</type> type is a subtype of <type>NUMBER</type> consisting of
numbers of rational precision, whose denominator is one.  
</para>
</listitem>
</itemizedlist>
</para>

<para>
Since the GCL uses implicit data typing, the data type of a numeric
constant must be identifiable by the way it is written.  Hence, when
you write a numeric constant, keep the following in mind.  Floating
point constants must include exactly one <literal>.</literal>
in them.  Rational
constants must have at most one <literal>.</literal> in them, and integer
constants must have neither of the above. Thus, to represent the
number <literal>2</literal> as a floating point <type>NUMBER</type>, you would write
<literal>2.</literal>, and to represent it as a rational <type>NUMBER</type>, you would
use <literal>2</literal> or <literal>2/1</literal>, and to represent it as an integer
<type>NUMBER</type>, you would use <literal>2</literal>.
</para>
</sect3>

<sect3>
<title>Text</title>
<para>
The <type>TEXT</type> type is used to store text strings, typically labels
for parts of games.  It is generally encouraged to label various
elements of games in the command language for ease of identification;
however it is not required.  To specify a <type>TEXT</type> constant,
surround the text with double-quote characters (<literal>"</literal>).  Constants
may span more than one input line.  Also, line feeds can be explicitly
included in text constants using the C-style notation of
<literal>\n</literal>. 
</para>
</sect3>

<sect3>
<title>Input and output</title>
<para>
The <type>INPUT</type> type is a reference to an input stream, generally a
file on disk.  Its principal use is to read in external data.  The
constant <literal>StdIn</literal>,
is used to refer to the standard input stream
(generally the console).  New <type>INPUT</type> streams are created with
the function <function>Input</function>.
</para>

<para>
The <type>OUTPUT</type> type is a reference to an output stream, generally a
file on disk.  Its principal use is as a logging file for writing
formatted output from an extended command language job.  The
constants <literal>StdOut</literal> and <literal>NullOut</literal>
refer to the standard
output stream (generally the console) and the null output stream (the
garbage can), respectively.  New <type>OUTPUT</type> streams are created with the 
function <function>Output</function>.
</para>
</sect3>

<sect3>
<title>Normal form data types</title>
<para>
The data type <type>NFG</type> is used to represent a normal form game.  No
other normal form data type can exist independently of the normal form
game to which it belongs.  The <type>NFPLAYER</type> and <type>STRATEGY</type>
data types are used to represent players and strategies in a normal
form game.  A <type>NFOUTCOME</type> is an outcome for a normal form game,
and an <type>NFSUPPORT</type> represents a support for a normal form
game, which is a collection of sets of admissible strategies, one for
each player.  Finally a <type>MIXED</type> is a mixed strategy profile over
an arbitrary support.
</para>

<para>
There are no constants of any normal form data type.  Objects that are
of any of the normal form data types must be built up using functions
in the GCL.  Hence, a more detailed discussion of them is deferred
until later.  
</para>
</sect3>

<sect3>
<title>Extensive form data types</title>
<para>
The data type <type>EFG</type> is used to represent an extensive form
game.  As with normal form games, no other extensive form data type
can exist independently of the extensive form game to which it
belongs.  The <type>EFPLAYER</type> represents a player in an extensive
form game.  The types <type>NODE</type>, <type>ACTION</type>,
<type>INFOSET</type>, <type>EFOUTCOME</type> represent the corresponding parts
of the extensive form representation of the game.  A <type>BEHAV</type> is
a behavior strategy profile 
for an extensive form game. 
An <type>EFSUPPORT</type> represents a
support for a behavior strategy in an extensive form game, which is a
collection of sets of admissible actions (at least one for each
information set of each player).  An <type>EFBASIS</type> is a subtype of
<type>EFSUPPORT</type>, representing a support for an assessment in an
extensive form game. This is a collection of sets of admissible
actions together with a collection of sets of admissible members of
information sets (at least one member for each information set).
</para>

<para>
As with normal form games, there are no constants of any extensive form
data type.  Objects that are of any of extensive form data types must
be built up using functions in the GCL.  Hence, a more detailed
discussion of them is deferred until later.
</para>
</sect3>

<sect3>
<title>Lists</title>
<para>
The <type>LIST(T)</type> data type can be used to represent lists of any
data type <type>T</type> (including <type>T=LIST(R)</type>,
where <type>R</type> is any
data type).  Lists are represented in GCL statements by including
objects of a given data type in curly braces and separated by commas.
For example, the following is how to represent a list containing the
first five integers:
<literal>{ 1, 2, 3, 4, 5 }</literal>.
The data type <type>T</type> of a list is determined by the data type of its
first element.  All other elements of the list must be of the same
type as the first element.  The only exception to this rule is that
subsequent elements can be listed to a different depth than the first
element.  For example if <type>T</type> is a basic data type, then then the
second and subsequent elements of a <type>LIST(T)</type> can be of type
<type>LIST(T)</type> or <type>LIST(LIST(T))</type>, etc.  Similarly, the second
and subsequent elements of a <type>LIST(LIST(T))</type> can be of type
<type>T</type>.  
</para>

<para>
We refer to the elements at the bottom levels of a nested list as the
basic elements of the list.  Then lists can be of heterogeneous
depth.  However, lists must be of homogeneous type. In other words,
all basic elements of the list must be of the same type.  Hence,
<literal>{ 1, { 2, 3 }, 4 }</literal>
is a legal list of type <type>LIST(NUMBER)</type>, since all the basic
elements are of type <type>NUMBER</type>, and 
<literal>{ { 2.0, 3/2 }, 1, 4 }</literal>
is a legal list of type <type>LIST(LIST(NUMBER))</type>.  On the other
hand, 
<literal>{ 1, { 2, "3" }, 4 }</literal>
is not a legal list, since the second element of the nested list is
not a <type>NUMBER</type>.
</para>

<para>
Lists are distinct in type from each other and from their scalar
equivalents.  That is to say, <type>LIST(BOOLEAN)</type> is a distinct data
type from <type>LIST(NUMBER)</type>, and is also a distinct data type from
<type>BOOLEAN</type>.
</para>
</sect3>

<sect3>
<title>Conglomerate data types</title> 
<para>
In some of the function prototypes in the Function Reference section,
you will notice certain data types which are not listed as supported
data types in the section on GCL data types. These are referred to as
conglomerate data types. Conglomerate types are not actually
data types, but are names used in GCL function prototypes to represent
subsets of data types.  Following is a list of the conglomerate data
types along with the types they include:

<table>
<title>Conglomerate types in GCL</title>
<tgroup cols="2">
<thead>
<row><entry>Conglomerate type</entry><entry>Includes</entry></row>
</thead>
<tbody>
<row><entry><type>ANYTYPE</type></entry>
<entry>Any type except <type>LIST</type></entry></row>
<row><entry><type>NLIST(T)</type></entry>
<entry>Nested <type>LIST(T)</type> of any depth
(i.e., <type>LIST(LIST( ... LIST(T) ... ))</type></entry></row>
<row><entry><type>T*</type></entry>
<entry><type>T</type>, or a null value of <type>T</type>, for any
<type>T</type> except <type>LIST</type></entry></row>
</tbody>
</tgroup>
</table>
</para>

</sect3>

</sect2>

<sect2>
<title>Expressions</title>
<para>
A GCL program consists of a series of expressions.  An expression is
typically a GCL command built up out of function calls. 
Expressions can be
entered interactively, at the command prompt, or can be entered from
files, via the <literal>Include["filename"]</literal> directive (see the section
on including files).  
</para>

<para>
Expressions are terminated by an end-of-line character (the carriage
return) at a point where all brackets, braces, and quotes are matched
(cloed).  Expressions can be explicitly continued on additional lines
by using the continuation character, <literal>\</literal>.
</para>

<para>
Comments can be
included in GCL statements by preceeding the comments with the
characters <literal>//</literal>.  Anything after the <literal>//</literal>
and before a
linefeed is ignored by the GCL interpreter.
</para>

<para>
Some statements can lead to computations which may take a long time to
complete.  A control-C, typed at the console, is used to halt
execution of the GCL and return to the command prompt.  Note that the
effect of a control-C may not always be immediate, as the control-C is
only polled for at convenient stages during computation.
</para>
</sect2>

<sect2>
<title>Functions</title>
<para>
Functions in the GCL are rules for taking objects of specified data
types, and using them to construct and return an object of a (possibly
different) specified data type.  All statements in the GCL are built
up out of function calls.  In this section, we desribe the rules for
using functions in the GCL.
</para>

<para>
A function call consists of the name of a function followed (if the
function has parameters) by a list of parameters to the function,
enclosed in brackets.  Functions return a value, which may in turn
be used as a parameter to another function call, allowing more complex
computations to be expressed.
</para>

<para>
Functions in the GCL can be either built-in or user defined.  Also
functions can either require arguments or not.  This leads to four
combinations.  We label these as follows
<table>
<title>Function types</title>
<tgroup cols="3">
<thead>
<row><entry>Description</entry><entry>Built-in</entry><entry>Parameters</entry></row>
</thead>
<tbody>
<row><entry>Constant</entry><entry>Yes</entry><entry>No</entry></row>
<row><entry>Built-in Function</entry><entry>Yes</entry><entry>Yes</entry></row>
<row><entry>Variable</entry><entry>No</entry><entry>No</entry></row>
<row><entry>User-defined Function</entry><entry>No</entry><entry>Yes</entry></row> 
</tbody>
</tgroup>
</table>
</para>

<sect3>
<title>Constants</title>
<para>
The simplest type of a function in the GCL is a constant.  A constant
is a built-in function that has no arguments, and returns the same
value whenever it is called.  How to construct constants for the basic
data types is described in the section on data types.  Some examples
of constants follow:
<table>
<title>Constants</title>
<tgroup cols="2">
<thead>
<row><entry>Data type</entry><entry>Constant</entry></row>
</thead>
<tbody>
<row>
<entry><type>BOOLEAN</type></entry>
<entry>True, False</entry>
</row>
<row>
<entry><type>NUMBER</type> (rational precision)</entry>
<entry>1, -1234567/563</entry>
</row>
<row>
<entry><type>NUMBER</type> (float precision)</entry>
<entry>1., -1.234567</entry>
</row>
<row>
<entry><type>TEXT</type></entry>
<entry>"Hello, world!"</entry>
</row>
<row>
<entry><type>OUTPUT</type></entry>
<entry>StdOut, NullOut</entry>
</row>
<row>
<entry><type>INPUT</type></entry>
<entry>StdIn</entry>
</row>
</tbody>
</tgroup>
</table>
</para>

<para>
You typically don't think of a constant as a function, but it is.  It
is a function with no arguments, whose name is the constant itself.
You can &quot;execute&quot; a constant by simply typing its name.  When you do
so, it returns a value, corresponding to the object that the constant
represents.  
</para>

<para>
You are now ready to write your first GCL program:
<programlisting>
GCL1:= << "Hello, world!"
"Hello, world!"
</programlisting>
</para>

<para>
It is important to note that like all functions in the GCL, constants
have a data type, which is determined by the function name.  If
you try and use a <type>NUMBER</type> constant, say <literal>123</literal>, where a
<type>TEXT</type> or other data type is expected, you will get an error.
</para>
</sect3>

<sect3>
<title>Variables</title>
<para>
A variable is like a constant in that it has no arguments.  It stores
one object of a particular data type, and returns it when called. The
difference between a constant and a variable is that a variable must
be created before it can be used, and once it is created, it can be
deleted or redefined if you want.  To create a new variable, or to
redefine an existing variable, one can use the built-in function,
<function>Assign</function>, which has the prototype:
<programlisting>
Assign[name->TEXT, value<->T] =: T
</programlisting>
for any type <type>T</type>.  (How to read a function's prototype is
described in more detail in the section of function calls.  For now,
suffice it to say that <function>Assign</function> takes two parameters, the first of
which is the name of the variable, and the second of which is the
value to be assigned to the variable.)  The variable name can be any
string of alphanumeric characters (<literal>a-z</literal>, <literal>A-Z</literal>, or
<literal>0-9</literal>) beginning with a letter.  So, to create a variable with
name <literal>x</literal> which returns the <type>NUMBER</type> <literal>1</literal>, we can use
<function>Assign</function> as follows:
<programlisting>
GCL1:= << Assign["x",1]
1
</programlisting>
The <function>Assign</function> function also has an infix operator form, written
<literal>:=</literal>.  In this form, the quotes are not needed around the variable
name, and the function is not &quot;listable&quot; (see the section on Lists,
later in this chapter).  So, equivalently, and more compactly,
<programlisting>
GCL1:= << x := 1
1
</programlisting>
</para>

<para>
The <function>Assign</function> function can be used to either create a new variable or
modify an existing one.  However, it cannot be used to change the type
of a variable.  Consider the sequence
<programlisting>
y:=2
y:=3
y:="3"
</programlisting>
The first call creates a new variable <literal>y</literal> of type 
<type>NUMBER</type>, with value of <literal>2</literal>.
The second modifies <varname>y</varname> to
have value <literal>3</literal>.  Since the new assignment does not change the
type of <varname>y</varname>, this command is fine.  The third statement attempts
to change the data type of <varname>y</varname>.  This statement will result in an
error, since <function>Assign</function> cannot be used to change the type of a
variable.  To change the data type of a variable, it must first be
deleted, and then reassigned.  
</para>

<para>
An existing variable may be deleted by the use of the 
<function>UnAssign</function>
function, with the following prototype:
<programlisting>
UnAssign[name->TEXT] =: BOOLEAN
</programlisting>
After <function>UnAssign</function> is called on a variable, the variable
is no longer defined.  A subsequent call of <function>Assign</function>
may redefine
the variable to be of any type.  <function>UnAssign</function> has a short form of
<literal>:=</literal> followed immediately by a linefeed or semicolon.  Hence, if
<varname>y</varname> is a variable of type <type>BOOLEAN</type> you can change it to
<type>NUMBER</type> with value <literal>3.0</literal> in two steps as follows:
<programlisting>
y:=
y:= 3.0
</programlisting>
</para>

<sect4>
<title>Global and static variables</title>
<para>
Variables in the GCL are by default only visible in the the part of
the program in which they are defined.  In otherwords, a variable
defined outside of a function will not be visible inside a GCL
function (unless it is passed by reference), and a variable defined in
a function will not be visible from outside the function.  Secondly,
variables defined inside a function are deallocated when control
leaves the function.  Thus, when a function is called a second time,
variables defined within that function will not &quot;remember&quot; the
values they were assigned in the last call to the function.  
</para>

<para>
To modify the default scope and visibility of variables, the GCL uses
the prefix <literal>$</literal> in a variable name to represent a 
&quot;static&quot;
variable and the prefix <literal>$$</literal> to represent
a global variable.  A static variable
is only visible in the function in which it is defined, but remains
allocated after program control leaves the function, and retains its
last value when the function is called again.  A global variable
remains allocated and visible when control passes to any function.  The
following example illustrates the use of static variables:
<programlisting>
NewFunction[Foo[x->NUMBER]=:NUMBER,If[!IsDefined[$y],$y:=x];$y;];
GCL2:= << Foo[3]
3
GCL3:= << Foo[2]
3
</programlisting>
and the following illustrates the use of global variables:
<programlisting>
$$x:=5
NewFunction[Foo[],$$x;];
GCL1:= << Foo[]
5
</programlisting>
</para>

</sect4>

</sect3>

<sect3>
<title>Built-in functions</title>
<para>
Built-in functions in the GCL are just like the mathematical notion of
a function.  They are rules which associate with each point in the  
domain, a point in the range.  In the case of the GCL functions, each
function has a list of arguments.  Each argument must be of a specific
data type.  A point in the domain is specified by specifying a value
of the correct data type for each argument of the function.  
</para>

<para>
To execute a GCL function you write the function name, followed
(if the function is not a constant) by a comma separated list of the
arguments, enclosed in square brackets.  
</para>

<para>
All of the built-in functions in the GCL are listed in the Function
Reference section of the manual.  For each function, the function
prototype is listed.  The function prototype is a template that is
used to remind you of the correct syntax for each function.  
</para>

<para>
A function call consists of the name of a function, and a list of
parameters upon which the function is to operate.  Functions return a
value, which may in turn be used as a parameter to another function
call, allowing more complex computations to be expressed.
</para>

<para>
A simple example of a function call is
<programlisting>
Plus[x->1, y->2]
</programlisting>

This calls the function named <function>Plus</function>, 
with parameter <parameter>x</parameter> set
to the value 1 and <parameter>y</parameter> set to the value 2.
Since <function>Plus</function> is
the function for addition of two integers, the value returned would
be, as you might expect, 3.
</para>

<para>
In the addition example above, we called a function which is listed in
the function reference as
<programlisting>
Plus[x->NUMBER, y->NUMBER] =: NUMBER
</programlisting>
This listing of a function is called its prototype.  It contains the
function's name, its list of parameters, and its return value.  In
this case, the function <function>Plus</function> takes two
parameters, the first named <parameter>x</parameter> and taking a
value of type <type>NUMBER</type> and the second named
<parameter>y</parameter> and taking a value of type
<type>NUMBER</type>, and returns a value of type <type>NUMBER</type>.
</para>

<para>
Because the parameters have explicit names, it is possible to rearrange
the order in which parameters are listed when a function is called.
Thus, we could write out sample call equivalently as
<programlisting>
Plus[y->2, x->1]
</programlisting>
and achieve the same effect.
</para>

<para>
Explicitly specifying the formal names for parameters all the time
will prove tedious and can hinder readability.  For these reasons, it is
also legal to specify parameters without their associated formal names.
These are called passing &quot;anonymous&quot; parameters.  Our addition
example could thus also be written
<programlisting>
Plus[1, 2]
</programlisting>
</para>

<para>
When used without specifying the formal names, however, function
calls are restricted to specifying parameters in exactly the same
order as listed in the function prototype.  In our example, the GCL
interpreter would have no way of distinguishing whether we meant 1 to
be the value of <parameter>x</parameter> or the value of 
<parameter>y</parameter>, and vice versa.
While in the case of addition we may flip the values of the parameters
without having an effect on the result, in general this is not the
case.
</para>

<para>
It is permitted to mix the two styles of parameter specification,
subject to the following rules:
<itemizedlist>
<listitem>
<para>
All anonymous parameters must be specified before any named
parameters.
</para>
</listitem>
<listitem>
<para>
No parameters may be omitted in the anonymous parameter list.
If k parameters are specified anonymously, they must match
one-for-one the first k parameters in the function's prototype.
</para>
</listitem>
<listitem>
<para>
Once a named parameter has been specified, all succeeding
parameters must be named, even if the first named parameter appeared
in the same place in the parameter list as it does in the prototype.
</para>
</listitem>
</itemizedlist>
Therefore, it would be legal to write
<programlisting>
Plus[1, y->2]
</programlisting>
but
<programlisting>
Plus[x->1, 2]
</programlisting>
is illegal since it violates the third condition.
</para>

<para>
To be more precise, the function <function>Plus</function> comes in several different
variations listed in the function reference:

<programlisting>
Plus[x->NUMBER, y->NUMBER] =: NUMBER
Plus[x->TEXT, y->TEXT] =: TEXT
Plus[x->MIXED, y->MIXED] =: MIXED
Plus[x->BEHAV, y->BEHAV] =: BEHAV 
</programlisting>
This is an example of function &quot;overloading&quot;.  This
means that one function name may have several possible parameter
lists, sometimes called &quot;signatures&quot;.  The GCL interpreter is
capable of determining which version of the function to use by
analyzing the names and types of the parameters used.
</para>

<para>
Since a function may have multiple signatures, it is conceivable that
a function call might be ambiguous, in the sense that its parameters
match more than one signature for that function.  However, no function
call that is complete may be ambiguous from the way that signatures
have been chosen for the predefined functions.  Any function call
flagged by the interpreter as ambiguous must be missing at least one
parameter.
</para>

<para>
Some functions have parameters which are optional, in the sense that
they need not be specified in order to call the function.  These
parameters are indicated in the function's prototype by being
surrounded by curly braces.  (Note that these braces should not be
included in the function call when specifying an optional parameter.)
If an optional parameter is left unspecified in a function call, a
default value is assumed, as given in the function's documentation.
</para>

<para>
For a function, all required parameters always precede any optional
parameters.  Optional parameters may also be specified anonymously,
subject to the above rules on parameter specification.
</para>

<para>
All parameters so far have been passed by &quot;value&quot; that is, a copy
of the value of the parameter is given to the function to which it is
passed.  These parameters may not be modified by the function.  It is
also possible to have parameters to a function passed by 
&quot;reference&quot;.  This means that the function does not receive a copy of
the value, but rather the memory location of the value itself.  Thus,
the function may modify the value of a parameter passed by reference.
</para>

<para>
The symbol for passing a parameter by reference, both in a function's
prototype and in a function call, is <literal><-></literal>.  Constants may not be
passed by reference.  Reference parameters may be specified
anonymously just like a value parameter, subject to the usual rules.
It is a run-time error to attempt to pass a value to a reference
parameter, or vice versa.
</para>

<para>
In the case where functions have parameters which are subtypes, 
it is preferred to match to the subtype over the parent type.  For example,
suppose the following two signatures have been defined:

<programlisting>
Foo[x->INTEGER] =: INTEGER
Foo[x->NUMBER] =: NUMBER
</programlisting>

Then, a call of <literal>Foo[3]</literal> resolves to the first signature (since the
value passed is an integer), and <literal>Foo[3.5]</literal>
resolves to the second
(since it is a number, but not specifically an integer).
</para>

</sect3>

<sect3>
<title>User-defined functions</title>
<para>
As GCL programs become more and more complex, frequently there are
complicated operations which must be performed repeatedly.  The
command language therefore supports user-defined functions, which
allow for defining sections of code which may be called later.
</para>

<para>
A new function can be created using the function <function>NewFunction</function>.
For example, one might define a function to compute the absolute value
of an <type>NUMBER</type> 
as such:
<programlisting>
NewFunction[Abs[n->NUMBER],
  If[n > 0, n, If[n < 0, -n, 0]];
];
</programlisting>
After defining the <function>Abs</function> function, it may be called in
exactly the same way a system-supplied predefined function may.  The
return value of the function is the value of the last statement
executed.
</para>

<para>
Parameter type matching rules apply to user defined functions in
exactly the same way as to predefined functions.  From the function's
point of view, the parameter list is a list of variables on which
assignments are automatically done at the beginning of the function
execution.  So, taking the <function>Abs</function> example above, in executing the
call
<programlisting>
Abs[42]
</programlisting>

an assignment <literal>n := 42</literal> is implicitly performed before
the body of the function is executed.
</para>

<para>
It is also possible to pass variables by &quot;reference&quot; to a
user-defined function in the same way as a predefined function.  In
this case, the function's &quot;local&quot; variable is stored in the same
physical location in the computer, and modifying the value locally
also takes effect on the variable passed to the function.  For
example, it might be useful instead to define <function>Abs</function> as:
<programlisting>
NewFunction[Abs[n<->NUMBER],
		 If[n > 0, n, If[n < 0, n := -n, 0]]]
</programlisting>
in which case the function would still return the absolute
value of <parameter>n</parameter>, but also modify the variable passed to
<parameter>n</parameter> to
be the absolute value of the input <parameter>n</parameter>.  So,
<programlisting>
q := -37;
Abs[q]
</programlisting>
would result in the variable <varname>q</varname> containing the value
37 at the conclusion of execution.
</para>

</sect3>

<sect3>
<title>Aliases for function calls</title>
<para>
There are several functions which are so commonly used that special
&quot;short forms&quot; are defined for them.  We already saw one example with
the function <function>Assign</function>, which has the short form
<literal>:=</literal>.  Most
functions with short forms are the standard arithmetic and logic
operators, for which the usual binary infix or unary prefix notations
are supported.  The example of addition used in a previous section may
more familiarly be written
<programlisting>
1 + 2
</programlisting>
which expression is converted to the &quot;long form&quot; function
call by the interpreter.  Note that formal names may not be specified
in a &quot;short form&quot; call, and the order of parameters is therefore
significant.
</para>

<para>
Here is a list of the functions thus abbreviated, and their &quot;short
form&quot; equivalents:

<table>
<title>Operators in GCL</title>
<tgroup cols="2">
<thead>
<row><entry>Function</entry><entry>Operator(s)</entry></row>
</thead>
<tbody>
<row>
<entry><function>And[x,y]</function></entry>
<entry><literal>x && y</literal>, <literal>x AND y</literal></entry>
</row>
<row>
<entry><function>Assign[x,y]</function></entry>
<entry><literal>x := y</literal></entry>
</row>
<row>
<entry><function>Concat[x,y]</function></entry>
<entry><literal>x & y</literal></entry>
</row>
<row>
<entry><function>Divide[x,y]</function></entry>
<entry><literal>x / y</literal></entry>
</row>
<row>
<entry><function>Dot[x,y]</function></entry>
<entry><literal>x . y</literal></entry>
</row>
<row>
<entry><function>Equal[x,y]</function></entry>
<entry><literal>x = y</literal></entry>
</row>
<row>
<entry><function>Greater[x,y]</function></entry>
<entry><literal>x > y</literal></entry>
</row>
<row>
<entry><function>GreaterEqual[x,y]</function></entry>
<entry><literal>x >= y</literal></entry>
</row>
<row>
<entry><function>IntegerDivide[x,y]</function></entry>
<entry><literal>x DIV y</literal></entry>
</row>
<row>
<entry><function>Less[x,y]</function></entry>
<entry><literal>x < y</literal></entry>
</row>
<row>
<entry><function>LessEqual[x,y]</function></entry>
<entry><literal>x <= y</literal></entry>
</row>
<row>
<entry><function>Minus[x,y]</function></entry>
<entry><literal>x - y</literal></entry>
</row>
<row>
<entry><function>Modulus[x,y]</function></entry>
<entry><literal>x & y</literal>, <literal>x MOD y</literal></entry>
</row>
<row>
<entry><function>Not[x]</function></entry>
<entry><literal>NOT x</literal>, <literal>!x</literal></entry>
</row>
<row>
<entry><function>NotEqual[x,y]</function></entry>
<entry><literal>x != y</literal></entry>
</row>
<row>
<entry><function>NthChar[text,n]</function></entry>
<entry><literal>text[[n]]</literal>, <literal>text_n</literal></entry>
</row>
<row>
<entry><function>NthChild[node,n]</function></entry>
<entry><literal>node#n</literal></entry>
</row>
<row>
<entry><function>NthElement[list,n]</function></entry>
<entry><literal>list[[n]]</literal>, <literal>list_n</literal></entry>
</row>
<row>
<entry><function>Or[x,y]</function></entry>
<entry><literal>x || y</literal>, <literal>x OR y</literal></entry>
</row>
<row>
<entry><function>Parentheses[x]</function></entry>
<entry><literal>(x)</literal></entry>
</row>
<row>
<entry><function>Plus[x]</function></entry>
<entry><literal>x + y</literal></entry>
</row>
<row>
<entry><function>Power[x]</function></entry>
<entry><literal>x ^ y</literal></entry>
</row>
<row>
<entry><function>Print[x]</function></entry>
<entry><literal>&lt;&lt; x</literal></entry>
</row>
<row>
<entry><function>Read[in,x]</function></entry>
<entry><literal>in >> x</literal></entry>
</row>
<row>
<entry><function>Times[x,y]</function></entry>
<entry><literal>x * y</literal></entry>
</row>
<row>
<entry><function>UnAssign[x,y]</function></entry>
<entry><literal>x :=</literal></entry>
</row>
<row>
<entry><function>Write[out,x]</function></entry>
<entry><literal>out << x</literal></entry>
</row>
</tbody>
</tgroup>
</table>
</para>

<para>
When functions are written in their canonical forms, no ambiguity
arises in the order of evaluation: In order to evaluate a function,
all arguments must be evaluated first.  Arguments are evaluated from
left-to-right as specified in the function call.  This leads to a
recursive structure of evaluation, which stops only when an argument
being evaluated is a constant function (i. e., a function with no
arguments).
</para>

<para>
When short form forms are used, then ambiguity can arise in the
intended order of evaluation.  For example, the statement 
<literal>a + b * c</literal>, 
could be meant as <literal>Plus[a,Times[b,c]]</literal> or as
<literal>Times[Plus[a,b],c]</literal>. 
In order to resolve such ambiguities, all
functions that have a short form representation are given an order of
precedence.  When a statement is parsed by the GCL, it is first
scanned from left to right, replacing each short form expression at
the top level of precedence with its canonical form.  Then it is
scanned again replacing each short form expression at the second level
of precedence with its canonical form, and so on, until all short form
expressions have been eliminated.
</para>

<para>
The order of precedence for built-in functions is as follows:

<table>
<title>Order of precedence</title>
<tgroup cols="1">
<tbody>
<row><entry><literal>()</literal></entry></row>
<row><entry><literal>:=</literal></entry></row>
<row><entry><literal>&gt;&gt;</literal> <literal>&lt;&lt;</literal></entry></row>
<row><entry><literal>||</literal></entry></row>
<row><entry><literal>&amp;&amp;</literal></entry></row>
<row><entry><literal>NOT</literal></entry></row>
<row><entry><literal>=</literal> <literal>!=</literal>
            <literal>&lt;</literal> <literal>&lt;=</literal>
            <literal>&gt;</literal> <literal>&gt;=</literal></entry></row>    
<row><entry><literal>+</literal> <literal>-</literal> <literal>&amp;</literal></entry></row>
<row><entry><literal>*</literal> <literal>.</literal>
            <literal>/</literal> <literal>DIV</literal>
            <literal>MOD</literal> <literal>^</literal></entry></row>    
<row><entry>(unary) <literal>+</literal> <literal>-</literal></entry></row>
<row><entry><literal>[[ ]]</literal> <literal>_</literal></entry></row>
</tbody>
</tgroup>
</table>
Thus, the expression <literal>a + b * c</literal> would become 
<programlisting>
Plus[a,b*c]
Plus[a,Times[b,c]]
</programlisting>
On the other hand, the expression <literal>(a + b) * c</literal> would become 
<programlisting>
Parentheses[a+b]*c
Parentheses[Plus[a,b]]*c
Times[Parentheses[Plus[a,b]],c]
</programlisting>
which, since <function>Parentheses</function> is just the identity mapping, is
equivalent to
<programlisting>
Times[Plus[a,b],c]
</programlisting>
</para>

</sect3>

</sect2>

<sect2>
<title>Getting and suppressing console output</title>
<para>
The GCL will only print output at the console if you explicity ask for
it with the built-in function <function>Print</function>.  This
function has the prototype
<programlisting>
Print[x->T] =: T
</programlisting>
for any data type <type>T</type>, and has the short form
<literal>&lt;&lt; x</literal>.  You may have noticed that the GCL
prompt concludes with a <literal>&lt;&lt;</literal>.  In fact, this is
not part of the prompt, but rather is a &quot;pre-typed&quot; part of your GCL
command.
</para>

<para>
Once you have become accustomed to the GCL, you may prefer to supress
output from some or all commands typed at the GCL command line.  This
can be done for individual commands by using the backspace or delete
keys to erase the <literal>&lt;&lt;</literal> part of the prompt.  The
built-in function <function>SetVerbose</function> controls whether 
<literal>&lt;&lt;</literal> is
pretyped at every prompt.  The command
<programlisting>
SetVerbose[False]
</programlisting>
will
turn off this feature, so that your prompt will then look as
follows:
<programlisting>
GCL1:= 
</programlisting>
Now, the default is that no output is printed.  If you want to have
the output of specific commands printed, then you can start your
command with <literal>&lt;&lt;</literal>.  For example,
<programlisting>
GCL1:= 1+1
GCL2:= << 1+1
2
</programlisting>
Note that error messages will be reported at the console regardless of
the setting of the verbose mode.
</para>

</sect2>

<sect2>
<title>Lists</title>
<para></para>

<sect3>
<title>Building and modifying lists</title>
<para>
Lists play a special role in the GCL.  Variables can be created to
contain lists in the same fashion as for any other data type:  
<programlisting>
list:={1,{2,3},4}
</programlisting>
The built in function <function>List[x,n]</function> can be used to
create a list of length <parameter>n</parameter>
all of whose elements have the value
<parameter>x</parameter>.  For numeric data types, a third parameter for 
<function>List</function>
allows each successive entry to be incremented.
<programlisting>
GCL1:= << List["Help",3]
{ "Help", "Help", "Help" }
GCL2:= << List[List[0,3],3]
{ { 0, 0, 0 },
  { 0, 0, 0 },
  { 0, 0, 0 } }
GCL3:= << List[0/1, 5, 1/4]
{ 0, 1/4, 1/2, 3/4, 1 }
</programlisting>
Lists of any data type can be created with <function>List</function>.  So if
<parameter>n</parameter> is a normal form game, 
then <function>List[n,5]</function> is a list of five
copies of <parameter>n</parameter>.
</para>

<para>
The function <function>NthElement</function> can be used
to get <parameter>n</parameter>th element of the list,
<parameter>list</parameter>.  This function has
two short forms, <literal>list[[n]]</literal> and <literal>list_n</literal>.
Since the
function returns the <parameter>n</parameter>th element of the list,
it can be used
recursively to get the elements of nested lists.  So
<function>list_i_j</function>
returns the <parameter>j</parameter>th element of the 
<parameter>i</parameter>th element of
<parameter>list</parameter>.  Also, since <parameter>list</parameter>
is passed by reference, the
function can be used to modify the corresponding element of a list.
Thus, you can constuct your own 3-by-3 identity matrix as
follows:
<programlisting>
GCL1:= list:=List[List[0,3],3]
GCL2:= list_1_1:=list_2_2:=list_3_3:=1;
GCL3:= << list
{ { 1, 0, 0 },
  { 0, 1, 0 },
  { 0, 0, 1 } }
</programlisting>
</para>

</sect3>

</sect2>

<sect2>
<title>Listability of functions</title>
<para>
Almost all of the functions in the GCL are &quot;listable&quot;.  This means
that if there is a version of the function which takes a type <type>T</type>
as the data type for a parameter, then it can be called with
<type>LIST(T)</type> as well.  This results in the function generating a
list of the corresponding length and data type as its output.  For
example, consider a function
<programlisting>
Foo[x->T,y->S] =: R
</programlisting>
where <type>T</type>, <type>S</type>, and <type>R</type>
represent arbitrary data types.
Then if <varname>a</varname> is a <type>LIST(T)</type>, and 
<varname>b</varname> is of type
<type>S</type>, then <literal>c := Foo[a,b]</literal> generates 
<varname>c</varname> of type
<type>LIST(R)</type>, where the length of <varname>c</varname>
is equal to the length of
<varname>a</varname>, and where <literal>c[[i]] = Foo[a[[i]],b]</literal>.
</para>

<para>
If <function>Foo</function> is called with both 
<varname>a</varname> and <varname>b</varname> being lists
of the correct data type, then the GCL checks whether the length of
<varname>a</varname> and <varname>b</varname> is the same. 
If not, it generates a
dimensionality error. If they are of the same dimension, then 
<literal>c := Foo[a,b]</literal> generates 
<varname>c</varname> of type <type>LIST(R)</type>, where the
length of <varname>c</varname> is equal to the length of <varname>a</varname>,
and where
<literal>c[[i]] = Foo[a[[i]],b[[i]]]</literal>.
</para>

<para>
Note that the above rules implicitly define versions of <function>Foo</function>
of the following forms:
<programlisting>
Foo[x->LIST(T),y->S] =: LIST(R)
Foo[x->T,y->LIST(S)] =: LIST(R)
Foo[x->LIST(T),y->LIST(S)] =: LIST(R)
</programlisting>
</para>

<para>
The same rules apply recursively using these function prototypes as
well.  So if <varname>a</varname> is of type <type>LIST(LIST(T))</type>, 
and <varname>b</varname> is
of type <type>S</type>, the expression <literal>c := Foo[a, b]</literal>
results in a
listable call to <literal>Foo[x->LIST(T), y->S]</literal>.
Thus, <varname>c</varname> is of
type <type>LIST(LIST(R))</type>, where 
<literal>c[[i]] = Foo[a[[i]],b]</literal>.
Hence, <literal>c[[i]][[j]] = Foo[a[[i]][[j]],b]</literal>.
</para>

<para>
Note that many vector and matrix math operations follow directly as
listable calls to the basic arithmetic functions.  In this example,
listability of <function>Times</function> is used to provide scalar multiplication
of a scalar and a matrix, and listability of <function>Plus</function>
is used to
add two conformable matrices:  
<programlisting>
GCL1:= a:={{1,2},{3,4}};
GCL2:= << 2*a
{{2,4},{6,8}}
GCL3:= << a+Transpose[a]
{{2,5},{5,8}}
</programlisting>
</para>

<para>
Here listability of <function>Power</function> is used to create a list of the first
ten perfect squares:
<programlisting>
GCL4:= << List[1,10,1]^2
{ 1, 4, 9, 16, 25, 36, 49, 64, 81, 100 }
</programlisting>
</para>

<para>
While most functions in the GCL are listable, there are some
exceptions.  Built-in functions that are not listable are noted as
such in the Function Reference section of this document.
</para>

<para>
Listability of functions is a powerful tool of the GCL. Many GCL
programs using flow control statements can be written using listable
function calls instead.  It is encouraged to use listable functions as
much as possible because it typically leads to more concise, easier to
read GCL programs, and in addition the programs typically run
faster than they would if flow control satements were used instead.
This is because listable calls to functions are executed in compiled
code, while flow control statements are executed in interpreted code.
</para>

</sect2>

<sect2>
<title>Online documentation</title>
<para>
The functions <function>Help</function> and <function>Manual</function>
are used to obtain online
documentation of any function in the GCL, including user defined
functions that you created with the <function>NewFunction</function> command. 
</para>

<para>
If the <function>Help</function> function is called with a string that is an exact
match for a GCL function name, then it returns a list of function
prototypes for that function name (there can be more than one
prototype for a function name since GCL functions can be overloaded.)
For example,
<programlisting>
GCL1:= << Help["help"]
{ Help[x->TEXT, {udf->True}, {bif->True}] =: LIST(TEXT) }
</programlisting>
returns the function prototype for <function>Help</function>.
Note that <function>Help</function>
has two optional <type>BOOLEAN</type> parameters, 
<parameter>udf</parameter> and <parameter>bif</parameter>.
By default, both user defined functions and built-in functions are
included in the search.  To exclude one or the other of these, set the
corresponding parameter to <literal>False</literal>.
</para>

<para>
The required text parameter for <function>Help</function> can also contain the
regular-expression style wildcards <literal>*</literal> and <literal>?</literal>.  In this
case, if there is not an exact match, a list of function names
matching <parameter>x</parameter> is returned.  For example, The command 
<programlisting>
GCL1:= << Help["*efg"]
{ CompressEfg, LoadEfg, NewEfg, SaveEfg }
</programlisting>
returns a list of all function names ending with &quot;efg&quot;
Note that the function <function>Help</function> is listable (see section on
listability), so that we can do <literal>Help[Help["*efg"]]</literal>
to get a
list of function prototypes for all functions whose names end with
&quot;efg&quot;.  Similarly, <literal>Help["*"]</literal>
gives a list of all function
names in the GCL, and <literal>Help[Help["*"]]</literal> gives a list of all
function prototypes in the GCL.
</para>

<para>
The function <function>Manual</function> is used to obtain a more complete description
of a GCL function.  If <function>Manual</function> is called with an argument that
is an exact match for a GCL function name, it returns the manual entry
for that function.  For a built-in function a textual description of
the function and its parameters is returned. 
</para>

</sect2>

<sect2>
<title>Advanced topics</title>

<para></para>

<sect3>
<title>Including files</title>

<para>
The function <function>Include[file->TEXT]</function> is used to
insert the contents of the file given into the input stream, as if
they had been typed directly by the user.  This can be particularly
useful in conjunction with user defined functions, in that a library
of useful functions can be constructed and included into the program
asily.
</para>

<para>
<function>Include</function> may only appear at the &quot;top level&quot; of
the program.  That is to say, it cannot be used inside a loop,
function declaration, or expression.  However, files may be nested
arbitrarily deep using <function>Include</function>,
so you can include a file which
in turn includes other files.
</para>

<para>
When a file is included, the GCL looks for a file with that name in
the following locations, in order.  
<orderedlist>
<listitem>
<para>The current directory;</para>
</listitem>
<listitem>
<para>The directory specified by the <varname>HOME</varname> environment 
variable, if any;</para>
</listitem>
<listitem>
<para>The directory specified by the <varname>GCLLIB</varname>
environment variable, if any;</para>
</listitem>
<listitem>
<para>The directory where the executable is located.</para>
</listitem>
</orderedlist>
</para>

<para>
This search order applies also to the <filename>gclini.gcl</filename>
file that is
loaded whenever the GCL is started.  Hence, you can keep a standard
version of a file that is frequently included in the same directory as
the GCL executable, and then modify it for use on a particular project
by keeping a modified copy of it in the directory associated with that
project.  
</para>

<para>
It is good practice to have included files identify themselves when
they are included. This can be done by using the
<function>GetPath</function> function, which returns the full
pathname of the file from which the command is executed.  For example,
if the following line is placed as the first line in an included file
(say with filename <filename>path/myfile.gcl</filename>)
<programlisting>
StdOut << "Include[\""&amp;GetPath[]&amp;"\"]\n"
</programlisting>
(Note that the standard escape sequences <literal>\"</literal> and 
<literal>\n</literal> are
used within a text string to represent a quotation mark and a carriage
return, respectively.)  Then when the file is included, it will identify
itself by writing the following message to the standard output stream:
<programlisting>
Include["path/myfile.gcl"]
</programlisting>
</para>
</sect3>


<sect3>
<title>Flow control structures</title>

<para>
The GCL contains three functions which allow flow control within a
program.  These functions are &quot;special&quot; in that their parameters are
evaluated in a special way (since their parameters are expressions and
sequences of statements); they also have no &quot;formal&quot; names for their
parameters.
</para>

<sect4>
<title>Conditional execution with <function>If</function></title>

<para>
The function <function>If</function> allows execution of a sequence of statements
only under certain conditions.  The syntax of the function is
<programlisting>
If[boolean-expression, statement-list {, statement-list}]
</programlisting>
The function is interpreted as follows: If the
<parameter>boolean-expression</parameter> evaluates to <literal>True</literal>,
then the first
list of statements is executed.  If it evaluates to <literal>False</literal> and
the second (optional) list of statements is present, that list is
executed; if it is not present, the <function>If</function> expression evaluates to <literal>False</literal>.
For example, the statement
<programlisting>
If[i = 2, j := 1, j := 2]
</programlisting>
sets <varname>j</varname> to <literal>1</literal> if the value of 
<varname>i</varname> is
<literal>2</literal>, and sets <varname>j</varname> to <literal>2</literal>
if the value of <varname>i</varname> is
not <literal>2</literal>.  It would also be perfectly legitimate to write
<programlisting>
If[i = 2, j := 1]
</programlisting>
in which case <varname>j</varname> would be set to
<literal>1</literal> if <varname>i</varname> is equal to
<literal>2</literal>, but if <varname>i</varname> were not
<literal>2</literal>, the expression evaluates to
<literal>False</literal>.
</para>

<para>
This last example brings up an important note about conditional
execution.  Expressions which appear in the branch of an
<function>If</function> expression which is not taken are treated as
if they did not exist.  So, were this the first mention of
<varname>j</varname> in
this scope, the last example would leave <varname>j</varname> defined only if
<varname>i</varname> was equal to <literal>2</literal>.
However, <varname>j</varname> would
<emphasis>not</emphasis> be defined otherwise.  It is therefore
necessary to be careful in constructing <function>If</function>
expressions which result in the definition of new variables.
</para>

</sect4>

<sect4>
<title>Repetitive execution with <function>While</function></title>

<para>
Often in writing programs it is necessary to execute a block of
statements repeatedly, usually with different values for variables.
To this end the GCL provides a special function <function>While</function> as a
generalized looping construct.  The syntax of the function is
<programlisting>
While[boolean-expression, statement-list]
</programlisting>
The function is interpreted as follows: while
<parameter>boolean-expression</parameter> evalutes to <literal>True</literal>, execute the
statements in <parameter>statement-list</parameter>.  Note that the evaluation of the
boolean takes place at the beginning of the execution of a block, so
it is only important whether the value is <literal>True</literal> or
<literal>False</literal>
at the beginning of the block, and not at some point in the middle.
</para>

<para>
This simple loop creates a list of the first ten perfect squares: 
<programlisting>
i := 1;
list := { };
While[i <= 10, list := list & { i^2 }; i := i + 1;]
</programlisting>
</para>

<para>
As with <function>If</function>,
be wary of declaring a variable implicitly inside a
loop.  A variable is declared only when the corresponding statement is
executed; so, if the <parameter>boolean-expression</parameter> 
is <literal>False</literal> the
first time it is evaluated, the body of the loop never executes, and
no variables which appear in the loop are considered to be defined.
</para>

</sect4>

<sect4>
<title>Indexed looping with <function>For</function></title>

<para>
The function <function>For</function> is a specialized looping
construct, useful mostly in cases where some index variable is used to
iterate a list or some sequence.  The general syntax for
<function>For</function> is
<programlisting>
For[statement-list, boolean-expression, statement-list, statement-list]
</programlisting>
The call is interpreted as follows:
<orderedlist>
<listitem>
<para>
Execute the statements in the first <parameter>statement-list</parameter>
(initialization);
</para>
</listitem>
<listitem>
<para>
Evaluate the <parameter>boolean-expression</parameter> (or guard);
</para>
</listitem>
<listitem>
<para>
If the <parameter>boolean-expression</parameter> is <literal>False</literal>,
terminate the
loop and continue with the first statement after the loop.  If it is
<literal>True</literal>, execute the third 
<parameter>statement-list</parameter>, which is the body of the loop;
</para>
</listitem>
<listitem>
<para>
Execute the second <parameter>statement-list</parameter>, which is usually
used to increment a counter, and return to the evaluation of the guard
in step 2.
</para>
</listitem>
</orderedlist>
</para>

<para>
Returning to the example in the <function>While</function> section, here is another
way of writing the loop to create a list of the first ten squares:
<programlisting>
For[i:=1; list:={}, i<=10, i:=i+1, list:=list&{i^2}]
</programlisting>
The two methods are completely equivalent, but it is often
more convenient to use the structure afforded by the <function>For</function>
function.
</para>
</sect4>

</sect3>

<sect3>
<title>Input and output</title>

<para>
Data can be read from an input stream by the <function>Read</function>
function.
So if <varname>in</varname> is an input stream 
(i. e., of type <type>INPUT</type>) then
a successful call of <literal>Read[in,x]</literal>
will read the exposed data (see
function reference for definition of &quot;exposed data&quot;) from the input
stream, <varname>in</varname>, assign <varname>x</varname>
to have that type and value, and
position the file pointer at the end of the exposed data, to be ready
for the next call of <function>Read</function>. 
<literal>Read[in,x]</literal> has the short
form <literal>in &gt;&gt; x</literal>. 
Since the return value of <literal>Read[in,x]</literal> is
<varname>in</varname>, these calls can be chained.  In other words,
<programlisting>
in >> x >> y
</programlisting>
is equivalent to 
<programlisting>
Read[in,x]
Read[in,y]
</programlisting>
</para>

<para>
In the expression <literal>Read[in,x]</literal>,
if <varname>x</varname> is undefined, then its
data type is determined from the exposed data in the input stream.  On
the other hand if <varname>x</varname> is previously defined, then the
<function>Read</function> function will expect to find the corresponding data type
in the input stream, and a file read error will be generated if the
exposed data is of the wrong data type.  If <varname>x</varname> is previously
defined to be a <type>LIST(T)</type>, then <literal>Read[in,x]</literal> will
successively read elements into each element of the list.  If the
wrong data type is found for any element of the list, a file read
error will be returned.  Thus, if the file <filename>file.dat</filename> contains
the following data
<programlisting>
25 1/3 "This is a text string!" False 3.14159 
{{1, 0},{0, 1}}
1 2 3 4 5
</programlisting>
then the following GCL code
<programlisting>
in:=Input["file.dat"]
x:=List[0,5]
in >> i >> r >> t >> b >> f >> l >> x
</programlisting>
opens an input stream, consisting of the contents of <filename>file.dat</filename>, and
then reads data from the input stream into the corresponding
variables.  After the last expression is evaluated,
<itemizedlist>
<listitem>
<para>
<varname>i</varname> is a <type>NUMBER</type> with value <literal>25</literal>,
</para>
</listitem>
<listitem>
<para>
<varname>r</varname> is a <type>NUMBER</type> with value <literal>1/3</literal>, 
</para>
</listitem>
<listitem>
<para>
<varname>t</varname> is a <type>TEXT</type> with value
<literal>"This is a text string!"</literal>, 
</para>
</listitem>
<listitem>
<para>
<varname>b</varname> is a <type>BOOLEAN</type> with value 
<literal>False</literal>, 
</para>
</listitem>
<listitem>
<para>
<varname>f</varname> is a <type>NUMBER</type> with value
<literal>3.14159</literal>, 
</para>
</listitem>
<listitem>
<para>
<varname>l</varname> is a <type>LIST(LIST(NUMBER))</type>
with value <literal>{{1,0},{0,1}}</literal>, and 
</para>
</listitem>
<listitem>
<para>
<varname>x</varname> is a <type>LIST(NUMBER)</type> with value
<literal>{1,2,3,4,5}</literal>.  
</para>
</listitem>
</itemizedlist>
</para> 

<para>
Data can be written to an output stream by the use of the
<function>Write</function> function.  Thus, the following program
<programlisting>
out:=Output["file.out"]
x:=0/1;y:={0.0,0.0}
Write[out,x]
Write[out,y]
</programlisting>
creates an output stream, <varname>out</varname>, and then writes out a
<type>NUMBER</type>, followed by a list of two <type>NUMBER</type>s.
<literal>Write[out,x]</literal> has the short form 
<literal>out &lt;&lt; x</literal>.  Since the
return value of <function>Write</function> is <varname>out</varname>,
these calls can be
chained.  So the two lines writing out <varname>x</varname> and 
<varname>y</varname> in the
above example could be written instead
<programlisting>
out << x << y
</programlisting>
</para>

<para>
The <function>Format</function> and <function>ListFormat</function> functions
can be used to
control the formatting of data written to an output stream.  Note that
the <function>Read</function> and <function>Write</function> functions are not listable.
</para>

<para>
The <function>Read</function> and <function>Write</function>
 functions can only be used with
certain data types (see function documentation).  Reading and writing
of <type>EFG</type> and <type>NFG</type> from external files can be done with the
<function>LoadEfg</function>, <function>SaveEfg</function>,
<function>LoadNfg</function> and <function>SaveNfg</function> functions.
</para>

</sect3>

<sect3>
<title>Null values</title>

<para>
Certain function calls in the GCL result in either invalid or
undetermined values for the required data type. Examples would be
asking for the first child node of a terminal node, or the parent of
the root node, or an outcome attached to a node with no outcome.
Similar problems arise in the algorithmic and computational parts of
the code.  Here, for example, algorithms that do not compute
sequential equilibria do not return belief probabilities for unreached
information sets.  Other algorithms may action probabilities for off
the equilibrium path information sets undetermined.  
</para>

<para>
Under certain situations such as the above, when no valid value is
available for return, instead of returning an error, the GCL will
a Null value for the given type.  Returning a Null value instead of
terminating execuation with an error message is frequently desirable
in a setting where functions are being called listably, as it allows
for computation of elements of the list that have valid entries
without aborting the GCL because some elements have invalid entries.  
</para>

<para>
The situations in which Null values are returned are described in the
function reference section of the manual.  Most functions in the GCL,
when encountering a Null value as a parameter, will abort with an
error message.  Whether a function will accept Null values as valid
values for an argument is indicated in the function prototype with an
asterisk (<literal>*</literal>) after the relevant parameter.  For example, the
function prototype for <function>IsNull</function> is
<programlisting>
IsNull[x->T*]=:BOOLEAN
  for any data type, T
</programlisting>
Here, the <literal>*</literal> indicates that this function accepts Null values
for its argument.  If a built-in function accepts Null values for an
argument, it is documented in the function reference section what the
behavior of the function is when encountering a Null value.  
</para>

<para>
Note that user defined functions  will accept Null values for
arguments also, if the relevant parameter is designated with a
<literal>*</literal>, as above. 
</para>
</sect3>

<sect3>
<title>System information</title>

<para>
There are several commands in the GCL that allow you to get
information from or run processes on the host system.  
</para>

<para>
A series of functions, <function>StartWatch</function>,
<function>StopWatch</function>, and
<function>ElapsedTime</function>, provide information on the amount of cpu time
used by the GCL, and can be used to time computation.  
Another series of functions, <function>GetEnv</function>,
<function>SetEnv</function>,
<function>UnSetEnv</function>, <function>Platform</function>,
allow you to set and check
environment variables, or check the operating system that the GCL is
running on.
A third series of functions, <function>ExePath</function>,
<function>GetPath</function>, and <function>GambitExe</function> 
(included in <filename>stdudfs.gcl</filename>),
provide path and filenames to files being used
by or related to the GCL.
Finally, the <function>Shell</function>
command allows you to run a child process from
the GCL.  
</para>

<para>
The above system functions are also used in the user defined function
<function>Display</function>,
which allows you to start a child process that launches
up the Gambit graphical interface and loads an extensive or normal
form game. If <varname>game</varname> is a variable of type <type>NFG</type> or
<type>EFG</type>, then the call <function>Display[game]</function>
will load the 
<varname>game</varname> in the graphical interface.
<footnote>
<para>The user defined functions
<function>GambitExe</function> and <function>Display</function> assume that you used the default
directories and filenames when you installed Gambit.  If you deviated
from the standard installation, you may have to edit these functions
before they work correctly.
</para>
</footnote>
</para>

</sect3>

<sect3>
<title>Variables pointing to deleted objects</title>

<para>
In the GCL, you
can create variables to represent objects which may be deleted or
invalidated subsequently as side effects of some functions. For example, suppose
you define a variable to represent an element (node, information set,
outcome, etc.) of an extensive form game.  You may subsequently delete
the part of the tree that contains that element.  The object that the
variable originally referred to is no longer valid.  
In this case, the variable is automatically unassigned.
</para>

<para>
In the following example, a game is loaded, and the variable <varname>n</varname>
is defined to be the first child of the first child of the root node.
Now the part of the tree after the first branch is deleted, the
variable <varname>n</varname> is now undefined:
<programlisting>
GCL1:= e:=LoadEfg["poker.efg"]
GCL2:= r:=RootNode[e]
GCL3:= n:=r#1#1
GCL4:= DeleteTree[r#1]
GCL5:= << n
ERROR: Print[]: Undefined reference "n" passed for parameter #1
</programlisting>
Since the node is no longer present in the tree, the variable
<varname>n</varname> which
refers to it has been unassigned.  A similar situation occurs here, where
elements of a list are deleted via <function>DeleteTree</function>:
<programlisting>
GCL1:= e:=LoadEfg["poker.efg"]
GCL2:= t:=TerminalNodes[e]
GCL3:= DeleteTree[RootNode[e]#1]
GCL4:= << t
ERROR: Print[]: Undefined reference "t" passed for parameter #1
</programlisting>
In this case, a variable <varname>t</varname> is defined to refer to
the list of terminal nodes.  The function
<function>DeleteTree</function> deletes some of the terminal nodes.
Even though some of the nodes in the list <varname>t</varname>
are still valid, if
any element of a list is deleted, the entire list is unassigned.
</para>

<para>
Similar situations arise with mixed and behavior strategies if the
underlying game to which they refer change in a way to invalidate the
solutions.  In the following example, a solution to the game 
<varname>e</varname>
is saved as a variable <varname>b</varname> of type <type>BEHAV</type>:  
<programlisting>
GCL1:= e:=LoadEfg["poker.efg"]
GCL2:= << b:=EnumMixedSolve[e,asNfg->True]_1
(Behav) { { 1.000 0.000 }{ 0.333 0.667 } }{ { 0.667 0.333 } }
GCL3:= DeleteTree[RootNode[e]#1]
GCL4:= << b
ERROR: Print[]: Undefined reference "b" passed for parameter #1
</programlisting>
The game is subsequently edited, making the profile no longer valid
for the changed game; therefore, the variable containing it is
automatically unassigned.
</para>

</sect3>

<sect3>
<title>Errors</title>

<para>
Sometimes, programs contain errors.  The interpreter is able to detect
errors which violate rules of the language, and reports information
about the error so the user can correct it.  There are two main
classes of errors which may arise in GCL programs: parse errors and
run time errors.
</para>

<para>
A parse error occurs when the GCL interpreter cannot determine the
meaning of a statement, because it does not conform to the grammatical
rules of the language.  This most frequently occurs when braces,
brackets, or quotation marks fail to match up or when punctuation is
missing.  When it encounters a parse error, the GCL interpreter will
display an error message giving the filename and line number of the
error and the point at which it determined an error it occurred.
</para>

<para>
A run time error occurs when a statement which obeys the grammatical
rules of the language violates another rule of the language during its
execution.  Examples of this type of error include attempting to use a
variable name which is not defined, and using a value of one type
where another type was expected.  Also, builtin functions may generate
this type of error on invalid inputs.  A run time error will result in
termination of the GCL at the point where the error occurs, with a
message indicating the type of error encountered.
</para>

</sect3>

</sect2>






</sect1>









