<sect1 id="apiref.game">
<title>Games</title>

<para>
A game is the fundamental unit of analysis.  Games may be specified
in either extensive form, using a game tree, or normal form, using a table.
</para>

<para>
Games may be built and edited, but note that any strategy profiles or other
objects dependent upon them may become invalid if the underlying game is
changed.
</para>

<para>
Attempting to call functions that are not appropriate to the representation
of the game (such as trying to access the root node of a game specified
in normal form only) results in a <errorname>gbtGameUndefined</errorname>
exception being thrown in C++, and a <errorname>RuntimeError</errorname>
exception being thrown in Python.
</para>

<sect2 id="apiref.game.behaviorprofilelength">
<title>BehaviorProfileLength</title>
<indexterm><primary>BehaviorProfileLength</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
int gbtGame::BehaviorProfileLength(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>BehaviorProfileLength</function>
returns the number of probabilities that are specified in a behavior profile 
on the game.  This length is
the total number of actions at all information sets for all players.
</para>

</sect2>

<sect2 id="apiref.game.canonicalize">
<title>Canonicalize</title>
<indexterm><primary>Canonicalize</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtGame::Canonicalize(void)
</synopsis>
</para>
</formalpara>

<para>
<function>Canonicalize</function> renumbers the IDs of nodes and information
sets in a canonical ordering.  The canonical ordering numbers these
objects in the order in which they are encountered when traversing the
game tree.  Calling this function thus ensures that two games which are 
structurally identical will have the property that corresponding game
members will have the same ID numbers, regardless of the API calls
used to construct the game.
</para>

<note>
<para>
In versions prior to 0.97.1.3, this function was automatically called
every time a game was edited, ensuring the object IDs were always
canonicalized.  Starting with 0.97.1.3, the program should call this
function explicitly if the ordering of the ID numbers is significant
for the application.
</para>
</note>

</sect2>

<sect2 id="apiref.game.getchance">
<title>GetChance</title>
<indexterm><primary>GetChance</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGamePlayer gbtGame::GetChance(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetChance</function>
returns the chance, or nature, player 
defined on the extensive form.
Each extensive form has exactly one
chance player predefined, and it is not possible to define any additional
chance players.
</para>

</sect2>

<sect2 id="apiref.game.getcomment">
<title>GetComment</title>
<indexterm><primary>GetComment</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
std::string gbtGame::GetComment(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetComment</function> returns the comment associated with
the game.
</para>

</sect2>


<sect2 id="apiref.game.getlabel">
<title>GetLabel</title>
<indexterm><primary>GetLabel</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
std::string gbtGame::GetLabel(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetLabel</function> returns the text label of the game.  The
empty string is returned if the game object is null.
</para>

</sect2>

<sect2 id="apiref.game.getmaxpayoff">
<title>GetMaxPayoff</title>
<indexterm><primary>GetMaxPayoff</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtRational gbtGame::GetMaxPayoff(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetMaxPayoff</function> returns the largest payoff to any 
player in any outcome of the game.  If no outcomes are defined, the
function returns zero.
</para>

</sect2>

<sect2 id="apiref.game.getminpayoff">
<title>GetMinPayoff</title>
<indexterm><primary>GetMinPayoff</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtRational gbtGame::GetMinPayoff(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetMinPayoff</function> returns the smallest payoff to any 
player in any outcome of the game.  If no outcomes are defined, the
function returns zero.
</para>

</sect2>


<sect2 id="apiref.game.getoutcome">
<title>GetOutcome</title>
<indexterm><primary>GetOutcome</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGameOutcome gbtGame::GetOutcome(int p_index) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetOutcome</function> returns the outcome numbered
<parameter>p_index</parameter> from the list of outcomes for the game.
Each game's outcomes are numbered sequentially beginning at one.
An exception is thrown (<errorname>gbtIndexException</errorname> in
C++, <errorname>IndexError</errorname> in Python) if the index is out
of range.
</para>

</sect2>

<sect2 id="apiref.game.getplayer">
<title>GetPlayer</title>
<indexterm><primary>GetPlayer</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGamePlayer gbtGame::GetPlayer(int p_index) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetPlayer</function> returns the player numbered
<parameter>p_index</parameter> from the list of players in the game.
Each game's players are numbered sequentially beginning at one.  An
exception is thrown (<errorname>gbtIndexException</errorname> in
C++, <errorname>IndexError</errorname> in Python) if the index is
out of range. 
</para>

</sect2>

<sect2 id="apiref.game.getroot">
<title>GetRoot</title>
<indexterm><primary>GetRoot</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGameNode gbtGame::GetRoot(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetRoot</function> returns the root node of the game.
</para>

</sect2>

<sect2 id="apiref.game.hastree">
<title>HasTree</title>
<indexterm><primary>HasTree</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
bool gbtGame::HasTree(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>HasTree</function> returns <literal>True</literal> if the
game representation includes a game tree, and <literal>False</literal>
otherwise.
</para>

</sect2>


<sect2 id="apiref.game.isconstsum">
<title>IsConstSum</title>
<indexterm><primary>IsConstSum</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
bool gbtGame::IsConstSum(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>IsConstSum</function>
returns <literal>True</literal> (nonzero) when the game 
is constant sum and <literal>False</literal> (zero) otherwise.
</para>

</sect2>


<sect2 id="apiref.game.isperfectrecall">
<title>IsPerfectRecall</title>
<indexterm><primary>IsPerfectRecall</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
bool gbtGame::IsPerfectRecall(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>IsPerfectRecall</function>
returns <literal>True</literal> (nonzero) if the game is 
a game of perfect recall, and <literal>False</literal> (zero) otherwise.
</para>

</sect2>

<sect2 id="apiref.game.newbehavprofile">
<title>NewBehavProfile</title>
<indexterm><primary>NewBehavProfile</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
gbtBehavProfile&lt;double&gt; gbtGame::NewBehavProfile(double) const
gbtBehavProfile&lt;gbtRational&gt; gbtGame::NewBehavProfile(gbtRational) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
profile = game.NewBehavProfileDouble()
profile = game.NewBehavProfileRational()
</synopsis>
</para>
</formalpara>

<para>
<function>NewBehavProfile</function> creates a new mixed behavior
profile on the game.  Behavior profiles can store their probabilities
in double (machine floating point) precision, or using rational numbers.
The precision is indicated in C++ by the dummy parameter passed to the
overloaded member functions; the parameter is not used in the calculation
to create the profile object.
</para>

</sect2>

<sect2 id="apiref.game.newcontingency">
<title>NewContingency</title>
<indexterm><primary>NewContingency</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGameContingency gbtGame::NewContingency(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>NewContingency</function> creates a new contingency
(profile of strategies) on the game.
</para>

</sect2>

<sect2 id="apiref.game.newefg">
<title>NewEfg</title>
<indexterm><primary>NewEfg</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
gbtGame ::NewEfg(void)
</synopsis>
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
efg = gambit.NewEfg()
</synopsis>
</para>
</formalpara>

<para>
<function>NewEfg</function>
creates a new trivial extensive form game, consisting of only a root
node.  The default extensive form
game has no players (other than the chance player) defined on it.
Returns the newly created game.
</para>

</sect2>

<sect2 id="apiref.game.newmixedprofile">
<title>NewMixedProfile</title>
<indexterm><primary>NewMixedProfile</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
gbtMixedProfile&lt;double&gt; gbtGame::NewMixedProfile(double) const
gbtMixedProfile&lt;gbtRational&gt; gbtGame::NewMixedProfile(gbtRational) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
profile = game.NewMixedProfileDouble()
profile = game.NewMixedProfileRational()
</synopsis>
</para>
</formalpara>

<para>
<function>NewMixedProfile</function> creates a new mixed strategy
profile on the game.  Mixed strategy profiles can store their probabilities
in double (machine floating point) precision, or using rational numbers.
The precision is indicated in C++ by the dummy parameter passed to the
overloaded member functions; the parameter is not used in the calculation
to create the profile object.
</para>

</sect2>

<sect2 id="apiref.game.newnfg">
<title>NewNfg</title>
<indexterm><primary>NewNfg</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
gbtGame ::NewNfg(const gbtArray&lt;int&gt; &amp;p_dim)
</synopsis>
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
nfg = gambit.NewNfg(dim)
</synopsis>
</para>
</formalpara>

<para>
<function>NewNfg</function>
creates a new normal form game with the specified dimensions.
</para>

</sect2>

<sect2 id="apiref.game.newoutcome">
<title>NewOutcome</title>
<indexterm><primary>NewOutcome</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGameOutcome gbtGame::NewOutcome(void)
</synopsis>
</para>
</formalpara>

<para>
<function>NewOutcome</function> defines a new outcome in the 
game.  The new outcome specifies payoffs of zero for all players.
Returns the newly created outcome.
</para>

</sect2>


<sect2 id="apiref.game.newplayer">
<title>NewPlayer</title>
<indexterm><primary>NewPlayer</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGamePlayer gbtGame::NewPlayer(void)
</synopsis>
</para>
</formalpara>

<para>
<function>NewPlayer</function> defines a new player in the extensive
form game.  Returns the newly created player.
</para>

<note>
<para>
The normal form table implementation currently available does not support
adding players to the game after creation.
</para>
</note>

</sect2>

<sect2 id="apiref.game.numnodes">
<title>NumNodes</title>
<indexterm><primary>NumNodes</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
int gbtGame::NumNodes(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>NumNodes</function> returns the number of nodes present in
the game tree.
</para>

</sect2>

<sect2 id="apiref.game.numoutcomes">
<title>NumOutcomes</title>
<indexterm><primary>NumOutcomes</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
int gbtGame::NumOutcomes(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>NumOutcomes</function> returns how many outcomes are defined
on the game.
</para>

</sect2>

<sect2 id="apiref.game.numplayers">
<title>NumPlayers</title>
<indexterm><primary>NumPlayers</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
int gbtGame::NumPlayers(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>NumPlayers</function> returns how many players are defined
on the game.
</para>

</sect2>


<sect2 id="apiref.game.readefg">
<title>ReadEfg</title>
<indexterm><primary>ReadEfg</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
gbtGame ::ReadEfg(std::istream &amp;p_file)
</synopsis>
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
gambit.ReadEfg(filename)
</synopsis>
</para>
</formalpara>

<para>
<function>ReadEfg</function> reads an extensive form game from the
file <parameter>file</parameter>.  C++ users should pass a stream
represented by a <type>std::istream</type> object. Python users should
pass the filename of the file to be read; if the file cannot be opened
or read, a <errorname>IOError</errorname> exception occurs.
</para>

<para>
If the file does not contain a valid extensive form savefile, the
C++ function throws a <errorname>gbtEfgParserError</errorname> exception.
In Python, this is mapped to an <errorname>IOError</errorname> error.
</para>

</sect2>

<sect2 id="apiref.game.readnfg">
<title>ReadNfg</title>
<indexterm><primary>ReadNfg</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
gbtGame ::ReadNfg(std::istream &amp;p_file)
</synopsis>
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
gambit.ReadNfg(filename)
</synopsis>
</para>
</formalpara>

<para>
<function>ReadNfg</function> reads a normal form game from the file
<parameter>file</parameter>.  C++ users should pass a stream
represented by a <type>std::istream</type> object.  Python users
should pass the filename of the file to be read; if the file cannot be
opened or read, a <errorname>IOError</errorname> exception occurs.
</para>

<para>
If the file does not contain a valid normal form savefile, the
C++ function throws a <errorname>gbtEfgParserError</errorname> exception.
In Python, this is mapped to an <errorname>IOError</errorname> error.
</para>

</sect2>

<sect2 id="apiref.game.setcomment">
<title>SetComment</title>
<indexterm><primary>SetComment</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtGame::SetComment(const std::string &amp;p_comment)
</synopsis>
</para>
</formalpara>

<para>
<function>SetComment</function> 
sets the comment associated with the game.
</para>

</sect2>

<sect2 id="apiref.game.setlabel">
<title>SetLabel</title>
<indexterm><primary>SetLabel</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtGame::SetLabel(const std::string &amp;p_label)
</synopsis>
</para>
</formalpara>

<para>
<function>SetLabel</function> sets the text label of the game.
</para>

</sect2>

<sect2 id="apiref.game.strategyprofilelength">
<title>StrategyProfileLength</title>
<indexterm><primary>StrategyProfileLength</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
int gbtGame::StrategyProfileLength(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>StrategyProfileLength</function> returns the number of
probabilities that are specified in a strategy profile on the game.
This length is the total number of strategies for all players.
</para>

</sect2>

<sect2 id="apiref.game.writeefg">
<title>WriteEfg</title>
<indexterm><primary>WriteEfg</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
void gbtGame::WriteEfg(std::ostream &amp;p_file) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
game.WriteEfg(filename)
</synopsis>
</para>
</formalpara>

<para>
<function>WriteEfg</function> writes an extensive form game to an
external savefile.  In C++, this file is given as a
<type>std::ostream</type> stream object. In Python, the filename to be
written is passed; if this file cannot be opened or written, a
<errorname>IOError</errorname> exception occurs.
</para>

</sect2>

<sect2 id="apiref.game.writenfg">
<title>WriteNfg</title>
<indexterm><primary>WriteNfg</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
void gbtGame::WriteNfg(std::ostream &amp;p_file) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
game.WriteNfg(filename)
</synopsis>
</para>
</formalpara>

<para>
<function>WriteNfg</function>
writes the normal form of the game
to an external savefile.  In C++, this file is given as a 
<type>std::ostream</type> stream object. In Python, the filename to be
written is passed; if this file cannot be opened or written, a
<errorname>IOError</errorname> exception occurs.
</para>

</sect2>


</sect1>
