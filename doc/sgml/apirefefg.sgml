<sect1 id="apiref.efg">
<title>Extensive form games</title>

<para>
An extensive form game object represents a game tree.  Objects included
in an extensive form game include players, outcomes, nodes, information
sets, and actions.   
</para>

<para>
Extensive form games may be built and modified, though care should be
taken when modifying them if any supports or behavior strategy profiles
are already computed.  Note that many operations on extensive form games
are methods (in C++ and Python) defined on the component types listed
above; consult those sections of the documentation for more information.
</para>

<sect2 id="apiref.efg.getchance">
<title>GetChance</title>
<indexterm><primary>GetChance</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGamePlayer gbtGame::GetChance(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetChance</function>
returns the chance, or nature, player 
defined on the extensive form.
Each extensive form has exactly one
chance player predefined, and it is not possible to define any additional
chance players.
</para>

</sect2>

<sect2 id="apiref.efg.getcomment">
<title>GetComment</title>
<indexterm><primary>GetComment</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtText gbtGame::GetComment(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetComment</function> returns the comment associated with
the game <parameter>efg</parameter>.
</para>

</sect2>


<sect2 id="apiref.efg.getlabel">
<title>GetLabel</title>
<indexterm><primary>GetLabel</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtText gbtGame::GetLabel(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetLabel</function> returns the text label of the game.  The
empty string is returned if the game object is null.
</para>

</sect2>

<sect2 id="apiref.efg.getoutcome">
<title>GetOutcome</title>
<indexterm><primary>GetOutcome</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGameOutcome gbtGame::GetOutcome(int p_index) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetOutcome</function> returns the outcome numbered
<parameter>p_index</parameter> from the list of outcomes for the game.
Each game's outcomes are numbered sequentially beginning at one.
An exception is thrown if the index is out of range.
</para>

</sect2>

<sect2 id="apiref.efg.getplayer">
<title>GetPlayer</title>
<indexterm><primary>GetPlayer</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGamePlayer gbtGame::GetPlayer(int p_index) const
</synopsis>
</para>
</formalpara>

<para>
<function>GetPlayer</function> returns the player numbered
<parameter>p_index</parameter> from the list of players in the
game.  Each game's players are numbered sequentially beginning
at one.  An exception is thown if the index is out of range.
</para>

</sect2>


<sect2 id="apiref.efg.isconstsum">
<title>IsConstSum</title>
<indexterm><primary>IsConstSum</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
bool gbtGame::IsConstSum(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>IsConstSum</function>
returns <literal>True</literal> (nonzero) when the extensive form game 
is constant sum and <literal>False</literal> (zero) otherwise.
</para>

</sect2>


<sect2 id="apiref.efg.isperfectrecall">
<title>IsPerfectRecall</title>
<indexterm><primary>IsPerfectRecall</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
bool gbtGame::IsPerfectRecall(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>IsPerfectRecall</function>
returns <literal>True</literal> (nonzero) if <parameter>efg</parameter>
is a game of perfect recall, and
<literal>False</literal> (zero) otherwise.
</para>

</sect2>

<sect2 id="apiref.efg.newefg">
<title>NewEfg</title>
<indexterm><primary>NewEfg</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGame ::NewEfg(void)
</synopsis>
</para>
</formalpara>

<para>
<function>NewEfg</function>
creates a new trivial extensive form game, consisting of only a root
node.  The default extensive form
game has no players (other than the chance player) defined on it.
Returns the newly created game.
</para>

</sect2>

<sect2 id="apiref.efg.newoutcome">
<title>NewOutcome</title>
<indexterm><primary>NewOutcome</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGameOutcome gbtGame::NewOutcome(void)
</synopsis>
</para>
</formalpara>

<para>
<function>NewOutcome</function> defines a new outcome in the extensive
form game.  The new outcome specifies payoffs of zero for all players.
Returns the newly created outcome.
</para>

</sect2>


<sect2 id="apiref.efg.newplayer">
<title>NewPlayer</title>
<indexterm><primary>NewPlayer</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtGamePlayer gbtGame::NewPlayer(void)
</synopsis>
</para>
</formalpara>

<para>
<function>NewPlayer</function> defines a new player in the extensive
form game.  Returns the newly created player.
</para>

</sect2>


<sect2 id="apiref.efg.newsupport">
<title>NewSupport</title>
<indexterm><primary>NewSupport</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
gbtEfgSupport gbtGame::NewSupport(void)
</synopsis>
</para>
</formalpara>

<para>
<function>NewSupport</function> creates a new support object on the
extensive form game.  The support contains all actions at all
information sets for all players.
</para>

</sect2>

<sect2 id="apiref.efg.numoutcomes">
<title>NumOutcomes</title>
<indexterm><primary>NumOutcomes</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
int gbtGame::NumOutcomes(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>NumOutcomes</function> returns how many outcomes are defined
on the game.
</para>

</sect2>

<sect2 id="apiref.efg.numplayers">
<title>NumPlayers</title>
<indexterm><primary>NumPlayers</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
int gbtGame::NumPlayers(void) const
</synopsis>
</para>
</formalpara>

<para>
<function>NumPlayers</function> returns how many players are defined
on the game.
</para>

</sect2>


<sect2 id="apiref.efg.readefg">
<title>ReadEfg</title>
<indexterm><primary>ReadEfg</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
gbtGame ::ReadEfg(gbtInput &amp;p_file)
</synopsis>
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
efg = gambit.ReadEfg(filename)
</synopsis>
</para>
</formalpara>

<para>
<function>ReadEfg</function>
reads an extensive form game from the file <parameter>file</parameter>.
C++ users should pass a stream represented by a <type>gbtInput</type> object;
Python users should pass the filename of the file to be read.
An error occurs if the file cannot be opened, or if the file does
not contain a valid extensive form savefile.
</para>

</sect2>


<sect2 id="apiref.efg.setcomment">
<title>SetComment</title>
<indexterm><primary>SetComment</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtGame::SetComment(const gbtText &amp;p_comment)
</synopsis>
</para>
</formalpara>

<para>
<function>SetComment</function> 
sets the comment associated with the game <parameter>efg</parameter>.
</para>

</sect2>

<sect2 id="apiref.efg.setlabel">
<title>SetLabel</title>
<indexterm><primary>SetLabel</primary></indexterm>

<formalpara>
<title>C++/Python usage</title>
<para>
<synopsis>
void gbtGame::SetLabel(const gbtText &amp;p_label)
</synopsis>
</para>
</formalpara>

<para>
<function>SetLabel</function> sets the text label of the game.
</para>

</sect2>


<sect2 id="apiref.efg.writeefg">
<title>WriteEfg</title>
<indexterm><primary>WriteEfg</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
void gbtGame::WriteEfg(gbtOutput &amp;p_file) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
efg.WriteEfg(filename)
</synopsis>
</para>
</formalpara>

<para>
<function>WriteEfg</function> writes an extensive form game to an
external savefile.  In C++, this file is given as a
<type>gbtOutput</type> stream object; in Python, the filename to be
written is passed.
</para>

</sect2>

<sect2 id="apiref.efg.writenfg">
<title>WriteNfg</title>
<indexterm><primary>WriteNfg</primary></indexterm>

<formalpara>
<title>C++ usage</title>
<para>
<synopsis>
void gbtGame::WriteNfg(gbtOutput &amp;p_file) const
</synopsis>
</para>
</formalpara>

<formalpara>
<title>Python usage</title>
<para>
<synopsis>
efg.WriteNfg(filename)
</synopsis>
</para>
</formalpara>

<para>
<function>WriteNfg</function>
writes the reduced normal form of the extensive form game
to an external savefile.  In C++, this file is given as a 
<type>gbtOutput</type> stream object; in Python, the filename
to be written is passed.
</para>

</sect2>


</sect1>
