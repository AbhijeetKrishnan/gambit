//****************************************************************************
// PXI: This program is designed to primarily plot data that was generated by*
// the Gambit program.  However, it can also read other data files that      *
// conform to the file layout.  The data basically consists of columns of data
// each representing a y-value corresponding to a lambda value.  Lamda values
// are in a separate column.
// The format is as follows:
// Note: all the strings in [] should appear EXACTLY as shown, including the
// ':', excluding the []
// comments are in /* or // and should not be in the data file
// [Dimensionality:]
//  # of datasets, # of datapoints for each dataset
//  2 3 3 means 2 data sets w/ 3 datapoints each
// [Settings:]
// LambdaMin		// minimum value of 'x'
// LambdaMax		// maximum value of 'x'
// LambdaDel		// step in 'x' (assumed to be LambdaDel-1 for Log plots)
// DataMin			// minimum value the data values take
// DataMax			// maximum value the data values take
// DataType			// Can be either 1-Log or 0-Linear

// The following is optional, and might not be used in future versions
// [Game:]
// Order of coefficient reading
// Game matrix
// Only works for 2 dataset files
// [Extra:]
// Extra information about the algorithm that generated the file
// ReadExtra		// Set to 0 unless certain that PXI can use that data
// Merror				// Tolerance
// DelP					// P-step

// Required again
// [DataFormat:]
// # of columns
// column # for lambda values
// column # for objective function values (0 for none)
// Now, column # of datapoint #i for dataset #j, in order i=1..DataPoints[j],
// j=1..DataSets
// last entry can be 0 to indicate that it is obtained by 1-Sum[strategies[1..#strategies-1]]
// [Data:]
// The data, columns separated by white space.

#include "wx.h"
#include "wx_form.h"
#include "wx_mf.h"
#include "wx_clipb.h"
#include <math.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#pragma hdrstop
#include "wxmisc.h"
#include "gmisc.h"
#include "general.h"
#include "gambitio.h"
#include "gstring.h"
#include "arrays.h"
#include "equtrac.h"
#include "normequs.h"
#include "ncalcset.h"
#include "expdata.h"
#include "onedot.h"
#include "pxi.h"
#include "axis.h"

#include "new.h"


gOutput &operator<<(gOutput &op,const PxiCanvas::LABELSTRUCT &l) {op<<l.x<<' '<<l.y<<' '<<l.label<<'\n';return op;}

void mem_handler(void)
{wxFatalError("Memory Error");}

char tempstr[200];
// Declare the main frame, and a list of children
PxiFrame   *frame = NULL;
wxList 		my_children;

// This statement initialises the whole application
PxiApp     myApp;

// Must initialise these in OnInit, not statically
wxCursor	*arrow_cursor;
wxCursor	*wait_cursor;
wxColour	*game_color;
wxColour	*axis_text_color;
wxFont		*axis_font;
wxFont		*game_font;
wxBrush		*clear_brush;
wxBrush		*exp_data_brush;
// The `main program' equivalent, creating the windows and returning the
// main frame
wxFrame *PxiApp::OnInit(void)
{
	set_new_handler(mem_handler);
	// Create needed cursors
	arrow_cursor = new wxCursor(wxCURSOR_ARROW);
	wait_cursor = new wxCursor(wxCURSOR_WAIT);
	// Create the rest of the resources
	axis_font = new wxFont(8, wxSWISS, wxNORMAL, wxNORMAL);
	game_font = new wxFont(14,wxSWISS,wxNORMAL,wxNORMAL);
	game_color = new wxColour("BLACK");
	axis_text_color=new wxColour("BLUE");
	clear_brush = new wxBrush("BLACK",wxTRANSPARENT);
	exp_data_brush=new wxBrush("BLACK",wxSOLID);
	// Create the main frame window
	frame = new PxiFrame(NULL, "PXI",0,0,800,600,wxMDI_PARENT | wxDEFAULT_FRAME);
	// Give it an icon
	wxIcon *frame_icon;
	#ifdef wx_msw
		frame_icon = new wxIcon("pxi_icn");
	#else
		#include "pxi.xpm"
		frame_icon = new wxIcon(pxi_xpm);
	#endif
	frame->SetIcon(frame_icon);

	// Make a menubar for the main frame--shown when no windows are open
	wxMenu *file_menu = new wxMenu;
		file_menu->Append(PXI_LOAD_FILE, "&Load file");
		file_menu->Append(PXI_QUIT, "&Quit");
	wxMenu *data_menu = new wxMenu;
		data_menu->Append(PXI_DATA_GRID,"&GridSolver","Create a new file");
	wxMenu *help_menu = new wxMenu;
		help_menu->Append(PXI_ABOUT,"&About PlotX");

	wxMenuBar *menu_bar = new wxMenuBar;
		menu_bar->Append(file_menu, "&File");
		menu_bar->Append(data_menu, "&Data");
		menu_bar->Append(help_menu, "&Help");

	// Associate the menu bar with the frame
	frame->SetMenuBar(menu_bar);
	frame->SetCursor(arrow_cursor);
	frame->Show(TRUE);

	// Add support for command line parameters
	if (argc>1) frame->MakeChild(argv[1]);
	// Return the main frame window
	return frame;
}
// Define my frame constructor
PxiFrame::PxiFrame(wxFrame *frame, char *title, int x, int y, int w, int h, int type):
	wxFrame(frame, title, x, y, w, h, type)
{
}

PxiChild::PxiChild(wxFrame *frame, char *title, int x, int y, int w, int h, int type):
	wxFrame(frame, title, x, y, w, h, type)
{
my_children.Append(this);
Show(FALSE);
// Give it an icon (this is ignored in MDI mode: uses resources)
wxIcon *icon = new wxIcon("chrt_icn");
SetIcon(icon);

// Make a menubar
wxMenu *file_menu = new wxMenu;
	file_menu->Append(PXI_LOAD_FILE, "&Load file");
	file_menu->Append(PXI_CHILD_QUIT, "&Close");
	file_menu->Append(PXI_PRINT_EPS, "Print to &EPS file");
	#ifdef wx_msw
		file_menu->Append(PXI_PRINT, "&Print");
		file_menu->Append(PXI_COPY_MF, "&Copy MF");
		file_menu->Append(PXI_SAVE_MF, "&Save MF");
	#endif
	file_menu->AppendSeparator();
	file_menu->Append(PXI_QUIT, "&Quit");
wxMenu *data_menu= new wxMenu;
	data_menu->Append(PXI_DATA_GRID,"&GridSolver","Create a new file");
	data_menu->Append(PXI_DATA_OVERLAY_DATA, "&Overlay Data");
	data_menu->Append(PXI_DATA_OVERLAY_FILE, "&Overlay File");
	data_menu->Append(PXI_DATA_ONEDOT, "One&Dot");

wxMenu *help_menu = new wxMenu;
	help_menu->Append(PXI_ABOUT,"&About PlotX");
wxMenu *display_menu = new wxMenu;
	display_menu->Append(PXI_FILE_DETAIL,"File &Detail");
	display_menu->Append(PXI_DISPLAY_OPTIONS,"&Options...");
wxMenuBar *menu_bar = new wxMenuBar;
	menu_bar->Append(file_menu, "&File");
	menu_bar->Append(data_menu, "&Data");
	menu_bar->Append(display_menu, "&Display");
	menu_bar->Append(help_menu, "&Help");
// Associate the menu bar with the frame
SetMenuBar(menu_bar);
}

PxiChild::~PxiChild(void)
{
	my_children.DeleteObject(this);
}


// Intercept menu commands
void PxiFrame::OnMenuCommand(int id)
{
switch (id)
{
	case PXI_QUIT:	{Close();break;}
	case PXI_LOAD_FILE: {MakeChild();break;}
	case PXI_DATA_ONEDOT: {MakeOneDot();break;}
	case PXI_DATA_GRID:
	{
		char *data_file_name=MakeDataFile();
		if (data_file_name)	MakeChild(data_file_name);
		break;
	}
	case PXI_ABOUT:
	{
		(void)wxMessageBox("PlotX: n-Dimensional Data Plotter\nAuthor: Eugene Grayver"
											 " egrayver@cco.caltech.edu\n(c) Caltech EPS, 1995,1996\n"
											 "To register send $25 to\nEugene Grayver\n12030 Rochester #214"
											 "\nLos Angeles, CA 90025", "About PlotX");break;}
}
}

void PxiFrame::MakeChild(char *file_name)
{
// Make another frame, containing a canvas
if (!file_name)
{
	char *s=wxFileSelector("Load data file", NULL, NULL, NULL, "*.out;*.pxi");
	if (s)	file_name=copystring(s);
}
if (!wxFileExists(file_name))
{
	wxMessageBox("File could not be found or opened");
	return;
}
PxiChild *subframe = new PxiChild(frame,NULL,0,0,480,480,wxMDI_CHILD);
// Now build the canvas on top of the subframe
int width, height;
subframe->GetClientSize(&width, &height);
// save the canvas in subframe
subframe->canvas = new PxiCanvas(subframe, 0, 0, width, height,wxRETAINED,file_name);
subframe->Show(TRUE);
}



// Show details
void PxiCanvas::ShowDetail(void)
{
FileHeader header=headers[1];
gString message;
int		i1,i;
sprintf(tempstr,"Detail for: %s\n",FileNameFromPath(header.FileName()));
message+=tempstr;
sprintf(tempstr,"Error (lambda) step:  %4.4f\n",header.EStep());
message+=tempstr;
sprintf(tempstr,"Error (lambda) start: %4.4f\n",header.EStart());
message+=tempstr;
sprintf(tempstr,"Error (lambda) stop : %4.4f\n",header.EStop());
message+=tempstr;
sprintf(tempstr,"Minimum data value  : %4.4f\n",header.DataMin());
message+=tempstr;
sprintf(tempstr,"Maximum data value  : %4.4f\n",header.DataMax());
message+=tempstr;
sprintf(tempstr,"Data type:  %s\n",(header.DataType()==DATA_TYPE_ARITH) ? "Arithmetic" : "Logarithmic");
message+=tempstr;
message+="\n";
if (header.MError()>-.99)
{
	sprintf(tempstr,"Probability step :    %4.4f\n",header.QStep());
	message+=tempstr;
	sprintf(tempstr,"Margin of error:      %4.4f\n",header.MError());
	message+=tempstr;
}
if (header.Matrix())
{
	sprintf(tempstr,"Matrix dimensions:    %d x %d\n",header.Matrix()->DimX(),header.Matrix()->DimY());
	message+=tempstr;
	sprintf(tempstr,"_______MATRIX_______\n");
	for (i1=0;i1<header.Matrix()->DimY();i1++)
	{
		for (i=0;i<header.Matrix()->DimX();i++)
		{
			sprintf(tempstr,"%2.1lf,%2.1lf ",(*header.Matrix())(i1,i).row,(*header.Matrix())(i1,i).col);
			message+=tempstr;
		}
		message+='\n';
	}
}
wxMessageBox(message,"File Details",wxOK);
}

/*************************** Show Game *****************************/
// Show Game
void PxiCanvas::ShowGame(wxDC& dc,int cw,int ch,const FileHeader &header)
{
float		th,tw;
int			i1,i;
gString matrix_line;
if (header.Matrix())
{
	dc.SetFont(game_font);
	dc.SetTextForeground(game_color);
	for (i1=0;i1<header.Matrix()->DimX();i1++)
	{
		matrix_line="";
		for (i=0;i<header.Matrix()->DimY();i++)
		{
			sprintf(tempstr,"%2.1lf,%2.1lf ",(*header.Matrix())(i1,i).row,(*header.Matrix())(i1,i).col);
			matrix_line+=tempstr;
		}
		dc.GetTextExtent(matrix_line,&tw,&th);
		dc.DrawText(matrix_line,(cw-2*XOFF-tw)/2+XOFF,XOFF+th*i1*1.5);
  }
}
dc.SetPen(wxBLACK_PEN);
dc.SetBrush(clear_brush);
dc.DrawRoundedRectangle(XOFF/2+(cw-2*XOFF-tw)/2,XOFF/2,XOFF+tw,th*(header.Matrix()->DimY()-1)*1.5+XOFF*3/2);
}


void PxiCanvas::StopIt(void)
{
if (draw_settings->GetStopMax()==draw_settings->GetMaxL())
{
//	if (updating) draw_settings->SetStopMax(cur_e);
}
else
{
//	if (!updating)
	{
		draw_settings->ResetSetStop();
		OnPaint();
	}
}
}

#include "expdprm.h"
void PxiCanvas::MakeOverlayData(void)
{
if (exp_data) {delete exp_data;exp_data=NULL;}
ExpDataDialog D(headers[1].FileName(),frame);
if (D.Completed()==wxOK)
{
	ExpDataParams P;
	D.GetParams(P);
	exp_data=new ExpData(P);
	D.LoadNow();
}
}

void PxiCanvas::MakeOverlayFile(void)
{
char *s=copystring(wxFileSelector("Load Overlay",NULL,NULL,NULL,"*.out"));
if (s)
{
FileHeader temp_header(s);
if ( (temp_header.NumStrategies()!=headers[1].NumStrategies()) ||
		 (temp_header.NumInfosets()!=headers[1].NumInfosets()) )
	wxMessageBox("These data files do not\nhave the same structure!");
else
	headers.Append(temp_header);
}
}


void PxiFrame::MakeOneDot(char *in_filename,char *out_filename)
{
char *inname,*outname;
if (!in_filename)
{
	char *s=wxFileSelector("Enter Input File", NULL, NULL, NULL, "*.out");
	if (s) inname=copystring(s); else return;
}
else inname=copystring(in_filename);
if (!out_filename)
{
	char *s=wxFileSelector("Enter Output File", NULL, NULL, NULL, "*.out");
	if (s) outname=copystring(s); else return;
}
else outname=copystring(out_filename);
OneDot one_dot;
one_dot.Go(inname,outname);
delete [] outname;
delete [] inname;
}

void PxiCanvas::OnChar(wxKeyEvent &ev)
{
switch(ev.KeyCode())
{
	case PXI_KEY_STOP:
		StopIt();
		break;
	default:
		wxCanvas::OnChar(ev);
		break;
}
}

#define TEXT_MARGIN	.05
void PxiCanvas::OnEvent(wxMouseEvent &ev)
{
if (ev.ShiftDown() && ev.ButtonDown())	// use shift mouse click to add a label
{
	int w,h;
	GetClientSize(&w,&h);
	label_struct tmp_label;
	tmp_label.x=ev.x/w;tmp_label.y=ev.y/h;
	// Check if clicked on an already existing text
	int clicked_on=0;
	for (int i=1;i<=labels.Length();i++)
		if (labels[i].x+TEXT_MARGIN>tmp_label.x && labels[i].x-TEXT_MARGIN<tmp_label.x &&
				labels[i].y+TEXT_MARGIN>tmp_label.y && labels[i].y-TEXT_MARGIN<tmp_label.y)
					clicked_on=i;
	tmp_label.label=wxGetTextFromUser("Enter Label","Enter Label",
																		(clicked_on) ? (char *)labels[clicked_on].label : "");
	if (!clicked_on)
		labels.Append(tmp_label);
	else
	{
		tmp_label.x=labels[clicked_on].x;
		tmp_label.y=labels[clicked_on].y;
		labels[clicked_on]=tmp_label;
	}
	OnPaint();
}
}
// Define a constructor for my canvas
PxiCanvas::PxiCanvas(wxFrame *frame, int x, int y, int w, int h, int style,const char *file_name):
						wxCanvas(frame, x, y, w, h, style),exp_data(NULL),draw_settings(NULL),
						probs(file_name)
{
headers.Append(FileHeader(file_name));
draw_settings=new PxiDrawSettings(headers[1]);
frame->SetTitle(headers[1].FileName());
}

// Intercept menu commands
void PxiChild::OnMenuCommand(int id)
{
	switch (id)
	{
	case PXI_PRINT_EPS:         // To use the special wxWindows EPS driver
																 // under Windows 3.1, specify "PostScript"
	 {
		 wxPostScriptDC dc(NULL,TRUE);
		 if (dc.Ok())
		 {
				dc.StartDoc("Pxi printout");
				dc.StartPage();
				this->canvas->Update(dc,PXI_UPDATE_FILE);
				dc.EndPage();
				dc.EndDoc();
		}
		break;
		}
#ifdef wx_msw
	case PXI_PRINT:
		{
			wxPrinterDC dc(NULL, NULL, NULL);  // Defaults to EPS under UNIX,
																				// normal Windows printing under Win 3.1
			if (dc.Ok())
			{
				dc.StartDoc("PXI printout");
				dc.StartPage();
				this->canvas->Update(dc,PXI_UPDATE_PRINTER);
				dc.EndPage();
				dc.EndDoc();
			}
			this->canvas->Update(*(this->canvas->GetDC()),PXI_UPDATE_SCREEN);
			break;
		}
		case PXI_COPY_MF:
		{
			wxMetaFileDC dc;
			if (dc.Ok())
			{
				this->canvas->Update(dc,PXI_UPDATE_METAFILE);
				wxMetaFile *mf = dc.Close();
				if (mf)
				{
					mf->SetClipboard((int)(dc.MaxX()+10),(int)(dc.MaxY()+10));
					delete mf;
				}
			}
			this->canvas->Update(*(this->canvas->GetDC()),PXI_UPDATE_SCREEN);
			break;
		}
	case PXI_SAVE_MF:
	{
		char *s=copystring(wxFileSelector("Save Metafile",NULL,NULL,NULL,"*.wmf"));
		if (s)
		{
			wxMetaFileDC dc(s);
			if (dc.Ok())
	    {
				this->canvas->Update(dc,PXI_UPDATE_METAFILE);
        wxMetaFile *mf = dc.Close();
        if (mf)
        {
					delete mf;
					wxMakeMetaFilePlaceable(s,dc.MinX(),dc.MinY(),dc.MaxX(),dc.MaxY());
        }
			}
      delete [] s;
			this->canvas->Update(*(this->canvas->GetDC()),PXI_UPDATE_SCREEN);
			break;
		}
		}
#endif
		case PXI_CHILD_QUIT:	Close(); break;
	case PXI_FILE_DETAIL:		canvas->ShowDetail();	break;
	case PXI_DISPLAY_OPTIONS:
		canvas->DrawSettings()->SetOptions(this);
		this->canvas->Update(*(this->canvas->GetDC()),PXI_UPDATE_SCREEN);
		break;
	case PXI_DATA_OVERLAY_DATA:
		this->canvas->MakeOverlayData();
		this->canvas->Update(*(this->canvas->GetDC()),PXI_UPDATE_SCREEN);
		break;
	case PXI_DATA_OVERLAY_FILE:
		this->canvas->MakeOverlayFile();
		this->canvas->Update(*(this->canvas->GetDC()),PXI_UPDATE_SCREEN);
		break;
	default:
		frame->OnMenuCommand(id);
		break;
	}
}
//**************************************************************************
//********************* Create a new data file *****************************
//**************************************************************************
void solver_update_func1(int total=-1,wxProgressIndicator1 *_p=NULL)
{
static wxProgressIndicator1 *p;
if (total!=-1)	// initialization
{
	p=_p;
	p->SetMax(total);
}
else
	p->Update();
}

// solver update func--a function to periodically relinquish the control of the CPU
void solver_update_func(void)
{wxYield();solver_update_func1();}



// bench mark function--tests how long it takes this cpu to calculate one equ
double bench_mark(void)
{
double a=3.34343;
wxStartTimer();
// do 10000 tests for equ;
for (int i=0;i<10000;i++) {a=exp(a)*exp(a/a)*exp(a*a)*exp(a+1);a=3.34343;}
return (((double)wxGetElapsedTime())/10000.0);
}
// calc num steps.  this calculates the number of combinations possible with
// 'num' integers, 0..'max', such that their sum is <='max'  See any math book
// for explanation of this formula:
// total_num=( n+k-1 )
//           (  k-1  )
// (num+max-1)!/(max!(num-1)!)
unsigned long factorial(unsigned long num)
{
unsigned long temp=1;
for (unsigned long i=num;i>0;i--) temp*=i;
return temp;
}

unsigned long calc_num_steps(int dim,int steps)
{
unsigned long temp,temp1=1;
for (temp=steps+dim-1;temp>steps;temp--) temp1*=temp;
return (temp1/factorial(dim-1));
}

char *PxiFrame::MakeDataFile(void)
{
char *out_file_name=NULL;
// Create the settings dialog, get the settings
NormalCalcSettings *settings=new NormalCalcSettings;
// Create the normal form game calculator, and solve the game
if (settings->Completed()==wxOK)
{
	if (settings->GotMatrix())
  {
		NormalEquSolver *solver=new NormalEquSolver(settings->GetMatrix(),
		settings->GetLStart(),settings->GetLStop(),settings->GetLStep(),
		settings->GetPStep(),settings->GetMError(),settings->GetDataType(),
		settings->GetFileName());
		solver->SetUpdateFunc(solver_update_func);

		double bench=bench_mark();
		bench=0.00015;
		double l_steps;
		double num_steps;
		num_steps=(double)calc_num_steps(settings->GetMatrix().Dim(),(int)(1.0/settings->GetPStep()+0.03));
		if (settings->GetDataType()==DATA_TYPE_ARITH)
			l_steps=(settings->GetLStop()-settings->GetLStart())/settings->GetLStep();
		else
			l_steps=log(settings->GetLStop()/settings->GetLStart())/log(settings->GetLStep());
		long total_time=(long)(bench*(double)settings->GetMatrix().Dim()*l_steps*num_steps);
		long secs=total_time;
		sprintf(tempstr,"This will take approximately %02ld:%02ld",secs/60,secs%60);
		int go=wxMessageBox(tempstr,"Time projection",wxOK|wxCANCEL|wxCENTRE);
		if (go==wxOK)
    {
			wxProgressIndicator1 *progress=new wxProgressIndicator1();
			solver_update_func1((int)(l_steps+0.03),progress);
			solver->Go();
			delete progress;
			// Get the output file name and clean up
			out_file_name=copystring(solver->GetOutFileName());
			if (settings->OneDot())	MakeOneDot(out_file_name,out_file_name);
		}
		delete solver;
	}
	else
	{
		wxMessageBox("No game defined or entered","Error",wxOK | wxCENTRE);
	}
}
delete settings;
return (out_file_name);
}

// Define the repainting behaviour
void PxiCanvas::OnPaint(void)
{
	Update(*(GetDC()),PXI_UPDATE_SCREEN);
}
// Define the behaviour for the frame closing
// - must delete all frames except for the main one.
Bool PxiFrame::OnClose(void)
{
	// Must delete children
	wxNode *node = my_children.First();
	while (node)
	{
		PxiChild *child = (PxiChild *)node->Data();
		wxNode *next = node->Next();
		child->Close();
		node = next;
	}
	return TRUE;
}

Bool PxiChild::OnClose(void)
{return TRUE;}

//*************************************************************************
//************************* DRAW SETTINGS *********************************
//*************************************************************************
PxiDrawSettings::PxiDrawSettings(FileHeader &header)
{
int i,j;
overlay_font=new wxFont(8,wxSWISS,wxNORMAL,wxBOLD);
overlay_symbol=OVERLAY_NUMBER;
overlay_lines=FALSE;
overlay_token_size=DEF_TOKEN_SIZE;
color_mode=COLOR_EQU;
restart_overlay_colors=TRUE;
label_font=new wxFont(10,wxSWISS,wxNORMAL,wxNORMAL);
connect_dots=FALSE;
data_mode=header.DataType();
plot_mode=PXI_PLOT_X;show_game=FALSE;
l_start=header.EStart();l_stop=header.EStop();l_step=header.EStep();
stop_min=l_start;stop_max=l_stop;
data_min=header.DataMin();data_max=header.DataMax();

num_infosets=header.NumInfosets();
one_or_two=(header.NumInfosets()>1) ? 2 : 1;
// Create the 'what to display where' data structures
// Default is to show first 1/2 of the infosets with all their strategies
// on the top portion of the graph (in two graph mode) and the rest on the
// bottom.  In one graph mode, the default is to show just the first 1/2 of
// the infosets with all their strategies.
strategy_show=gBlock<show_player_strategies>(num_infosets);
for (i=1;i<=num_infosets;i++)
{
	strategy_show[i]=show_player_strategies(header.NumStrategies(i));
	for (j=1;j<=header.NumStrategies(i);j++) strategy_show[i][j]=TRUE;
}
plot_top=gBlock<int>(num_infosets/2);
for (i=1;i<=num_infosets/2;i++) plot_top[i]=i;
plot_bottom=gBlock<int>(num_infosets-num_infosets/2);
for (i=1+num_infosets/2;i<=num_infosets;i++) plot_bottom[i-num_infosets/2]=i;
// Default features are everything on
plot3_features=DRAW_AXIS|DRAW_LABELS;
plotx_features=DRAW_AXIS|DRAW_TICKS|DRAW_NUMS;
plot2_features=DRAW_AXIS|DRAW_TICKS|DRAW_NUMS|DRAW_SQUARE;
}

// Plot3 mode is now more flexible: it works great (by default) on 2 player
// games, each player having 3 strategies.  It has now been extended to work
// with N player games with 3+ strategies each
// In this case, the two desired strategies are selected in the dialog, and
// the third is calculated from 1-(first+second).  You can also plot more than
// one infoset per triangle now.
Bool PxiDrawSettings::CheckPlot3Mode(void)
{
int i;
// Check if there are 3 or over strategy_show for each player
int top, bottom;
for (top=1;top<=GetPlotTop();top++)
	if (strategy_show[GetPlotTop(top)].Length()<3)
	{
		wxMessageBox("Each player must have at least 3 strategies!");
		return FALSE;
	}
for (bottom=1;bottom<=GetPlotBottom();bottom++)
	if (strategy_show[GetPlotBottom(bottom)].Length()<3)
	{
		wxMessageBox("Each player must have at least 3 strategies!");
		return FALSE;
	}

// Check if only two strategies have been selected for each player (add all of them up)
int num_strategies=0;
for (top=1;top<=GetPlotTop();top++)
	for (i=1;i<=strategy_show[GetPlotTop(top)].Length();i++)
		num_strategies+=(GetStrategyShow(GetPlotTop(top),i)) ? 1 : 0;
for (bottom=1;bottom<=GetPlotBottom();bottom++)
	for (i=1;i<=strategy_show[GetPlotBottom(bottom)].Length();i++)
		num_strategies+=(GetStrategyShow(GetPlotBottom(bottom),i)) ? 1 : 0;
if (num_strategies>2*(GetPlotTop()+GetPlotBottom()))
{
	wxMessageBox("Only two strategies per player allowed!");
	return FALSE;
}
return TRUE;
}
// Check Plot_2 Mode:  Plot 2 mode plots a player's strategy against another
// strategy (the same or different player's).  Only one pair of strategies
// can be plotted at any one time.  Thus, only two of the checkboxes in the
// strategy selection section can be turned on.

Bool PxiDrawSettings::CheckPlot2Mode(void)
{
int i,j,num_strategies=0;
for (j=1;j<=strategy_show.Length();j++)
	for (i=1;i<=strategy_show[j].Length();i++)
		num_strategies+=(GetStrategyShow(j,i)) ? 1 : 0;
if (num_strategies>2)
{
	wxMessageBox("Only TWO strategies TOTAL can be checked\nin the strategy selection dialog");
	return FALSE;
}
return TRUE;
}
#define DELTA			1e-9
void PxiDrawSettings::SetOptions(wxFrame *parent)
{
Bool	enable_set_stop=TRUE;
Bool 	display_two,connectdots;
int 	i,iset;                       
MyDialogBox *display_dialog=new MyDialogBox(parent,"Draw Settings");
// Display Range
display_dialog->Form()->Add(wxMakeFormMessage("Display Range:"));
display_dialog->Form()->Add(wxMakeFormNewLine());
sprintf(tempstr,"From[%3.3f..%3.3f]:",l_start,l_stop);
display_dialog->Form()->Add(wxMakeFormFloat(tempstr, &stop_min, wxFORM_DEFAULT,
											 new wxList(wxMakeConstraintRange(l_start-DELTA,l_stop+DELTA), 0)));
sprintf(tempstr,"To[%3.3f..%3.3f]:",l_start,l_stop);
display_dialog->Form()->Add(wxMakeFormFloat(tempstr, &stop_max, wxFORM_DEFAULT,
											 new wxList(wxMakeConstraintRange(l_start-DELTA,l_stop+DELTA), 0)));
display_dialog->Form()->Add(wxMakeFormBool("Enable",&enable_set_stop));
display_dialog->Form()->Add(wxMakeFormNewLine());

display_dialog->Form()->Add(wxMakeFormFloat("DataMin", &data_min));
display_dialog->Form()->Add(wxMakeFormFloat("DataMax", &data_max));

// Display strategies.  If the game is small enough, put all the items right
// here.  Otherwise create a button to call up a new dialog
gBlock<Bool> plot_top_bool(num_infosets);
gBlock<Bool> plot_bottom_bool(num_infosets);
wxFormItem *display_button=0;
if (num_infosets<=5)
{
	display_dialog->Form()->Add(wxMakeFormNewLine());
	display_dialog->Form()->Add(wxMakeFormMessage("Display Data:"));
	display_dialog->Form()->Add(wxMakeFormNewLine());
	display_dialog->Form()->Add(wxMakeFormMessage("On Top"));
	for (i=1;i<=num_infosets;i++)
	{
		if (plot_top.Contains(i)) plot_top_bool[i]=TRUE; else plot_top_bool[i]=FALSE;
		sprintf(tempstr,"%d",i);
		display_dialog->Form()->Add(wxMakeFormBool(tempstr,&(plot_top_bool[i])));
	}
	display_dialog->Form()->Add(wxMakeFormMessage("On Bottom"));
	for (i=1;i<=num_infosets;i++)
	{
		if (plot_bottom.Contains(i)) plot_bottom_bool[i]=TRUE; else plot_bottom_bool[i]=FALSE;
		sprintf(tempstr,"%d",i);
		display_dialog->Form()->Add(wxMakeFormBool(tempstr,&(plot_bottom_bool[i])));
	}
	display_dialog->Form()->Add(wxMakeFormNewLine());
	for (iset=1;iset<=num_infosets;iset++)
	{
		char tmp[80];
		sprintf(tmp,"Infoset %d:     ",iset);
		display_dialog->Form()->Add(wxMakeFormMessage(tmp));
		for (i=1;i<=strategy_show[iset].Length();i++)
		{
			sprintf(tempstr,"%d",i);
			display_dialog->Form()->Add(wxMakeFormBool(tempstr,&(strategy_show[iset][i])));
		}
	display_dialog->Form()->Add(wxMakeFormNewLine());
	}
}
else
{
	display_dialog->Form()->Add(wxMakeFormNewLine());
	display_button=wxMakeFormButton("What to display",(wxFunction)PxiDrawSettings::disp_func);
	display_dialog->Form()->Add(display_button);
	display_dialog->Form()->Add(wxMakeFormNewLine());
}

// Display Mode--Xplot or 3plot
display_dialog->Form()->Add(wxMakeFormNewLine());
wxStringList *plot_mode_list=new wxStringList;
char				 *plot_mode_str=new char[20];
if (plot_mode==PXI_PLOT_X) strcpy(plot_mode_str,"Plot X");
if (plot_mode==PXI_PLOT_2) strcpy(plot_mode_str,"Plot 2");
if (plot_mode==PXI_PLOT_3) strcpy(plot_mode_str,"Plot 3");
plot_mode_list->Add("Plot X");plot_mode_list->Add("Plot 3");plot_mode_list->Add("Plot 2");
wxFormItem *plot_mode_item=wxMakeFormString("Plot Mode",&plot_mode_str,wxFORM_RADIOBOX,
			 new wxList(wxMakeConstraintStrings(plot_mode_list), 0),NULL,wxVERTICAL);
display_dialog->Form()->Add(plot_mode_item);
// Color Mode--Equ,Prob,None
wxStringList *color_mode_list=new wxStringList;
char				 *color_mode_str=new char[20];
if (color_mode==COLOR_EQU ) strcpy(color_mode_str,"Equ");
if (color_mode==COLOR_PROB) strcpy(color_mode_str,"Prob");
if (color_mode==COLOR_NONE) strcpy(color_mode_str,"None");
color_mode_list->Add("Equ");color_mode_list->Add("Prob");color_mode_list->Add("None");
wxFormItem *color_mode_item=wxMakeFormString("Color Mode",&color_mode_str,wxFORM_RADIOBOX,
			 new wxList(wxMakeConstraintStrings(color_mode_list), 0),NULL,wxVERTICAL);
display_dialog->Form()->Add(color_mode_item);
// Display matrix
display_dialog->Form()->Add(wxMakeFormNewLine());
display_dialog->Form()->Add(wxMakeFormBool("Display Matrix",&show_game));
if (one_or_two==2) display_two=TRUE; else display_two=FALSE;
connectdots=ConnectDots();
display_dialog->Form()->Add(wxMakeFormBool("Two Plots",&display_two));
display_dialog->Form()->Add(wxMakeFormBool("Connect Dots",&connectdots));
display_dialog->Form()->Add(wxMakeFormBool("Restart Colors",&restart_overlay_colors));
display_dialog->Form()->Add(wxMakeFormNewLine());
wxFormItem *overlay_button=wxMakeFormButton("Overlay Options",(wxFunction)PxiDrawSettings::overlay_func);
display_dialog->Form()->Add(overlay_button);
wxFormItem *label_font_button=wxMakeFormButton("Label Font",(wxFunction)PxiDrawSettings::label_font_func);
display_dialog->Form()->Add(label_font_button);
wxFormItem *plot_feat_button=wxMakeFormButton("Plot Options",(wxFunction)PxiDrawSettings::plot_features_func);
display_dialog->Form()->Add(plot_feat_button);
display_dialog->Form()->AssociatePanel(display_dialog);
((wxButton *)overlay_button->GetPanelItem())->SetClientData((char *)this);
((wxButton *)label_font_button->GetPanelItem())->SetClientData((char *)this);
((wxButton *)plot_feat_button->GetPanelItem())->SetClientData((char *)this);
if (display_button) ((wxButton *)display_button->GetPanelItem())->SetClientData((char *)this);
display_dialog->Go1();
if (display_dialog->Completed()==wxOK)
{
	one_or_two=(display_two) ? 2 : 1;
	connect_dots=connectdots;
	if (!enable_set_stop) ResetSetStop();
	if (num_infosets<=5)
	for (i=1;i<=num_infosets;i++)
	{
		if (plot_top_bool[i])
		{
			if (!plot_top.Contains(i)) plot_top.Append(i);
		}
		else
		{
			if (plot_top.Contains(i)) plot_top.Remove(plot_top.Find(i));
		}
		if (plot_bottom_bool[i])
		{
			if (!plot_bottom.Contains(i)) plot_bottom.Append(i);
		}
		else
		{
			if (plot_bottom.Contains(i)) plot_bottom.Remove(plot_bottom.Find(i));
		}
	}
	if (strcmp(plot_mode_str,"Plot X")==0)
		plot_mode=PXI_PLOT_X;
	if (strcmp(plot_mode_str,"Plot 3")==0)
		plot_mode=(CheckPlot3Mode()) ? PXI_PLOT_3 : PXI_PLOT_X;
	if (strcmp(plot_mode_str,"Plot 2")==0)
		plot_mode=(CheckPlot2Mode()) ? PXI_PLOT_2 : PXI_PLOT_X;
	if (strcmp(color_mode_str,"Equ")==0) color_mode=COLOR_EQU;
	if (strcmp(color_mode_str,"Prob")==0) color_mode=COLOR_PROB;
	if (strcmp(color_mode_str,"None")==0) color_mode=COLOR_NONE;
}
delete display_dialog;
delete [] plot_mode_str;
}

void PxiDrawSettings::overlay_func(wxButton &ob,wxEvent &)
{
PxiDrawSettings	*draw_settings=(PxiDrawSettings *)ob.GetClientData();
MyDialogBox *overlay_dialog=new MyDialogBox(NULL,"Overlay Options");
wxStringList *overlay_token_list=new wxStringList;
overlay_token_list->Add("Numbers");overlay_token_list->Add("Tokens");
char *overlay_token_str=new char[20];
if (draw_settings->GetOverlaySym()==OVERLAY_NUMBER)
	strcpy(overlay_token_str,"Numbers"); else strcpy(overlay_token_str,"Tokens");
overlay_dialog->Form()->Add(wxMakeFormString("Overlay Token",&overlay_token_str,wxFORM_RADIOBOX,
			 new wxList(wxMakeConstraintStrings(overlay_token_list), 0),NULL,wxVERTICAL));
overlay_dialog->Form()->Add(wxMakeFormNewLine());
Bool	overlay_connect=draw_settings->GetOverlayLines();
overlay_dialog->Form()->Add(wxMakeFormBool("Connect points",&overlay_connect));
overlay_dialog->Form()->Add(wxMakeFormNewLine());
wxFormItem	*overlay_font_button=wxMakeFormButton("Overlay Font",(wxFunction)PxiDrawSettings::overlay_font_func);
overlay_dialog->Form()->Add(overlay_font_button);
overlay_dialog->Form()->Add(wxMakeFormNewLine());
int token_size=draw_settings->GetTokenSize();
overlay_dialog->Form()->Add(wxMakeFormShort("Token Size",&token_size,wxFORM_SLIDER,
			 new wxList(wxMakeConstraintRange(MIN_TOKEN_SIZE,MAX_TOKEN_SIZE), 0)));

overlay_dialog->Form()->AssociatePanel(overlay_dialog);
((wxButton *)overlay_font_button->GetPanelItem())->SetClientData((char *)draw_settings);
overlay_dialog->Go1();
if (overlay_dialog->Completed()==wxOK)
{
	draw_settings->SetOverlayLines(overlay_connect);
	int overlay_token=wxListFindString(overlay_token_list,overlay_token_str);
	if (overlay_token==0)
		draw_settings->SetOverlaySym(OVERLAY_NUMBER);
	else
	{
		draw_settings->SetOverlaySym(OVERLAY_TOKEN);
		draw_settings->SetTokenSize(token_size);
	}

}
delete overlay_dialog;
}
void PxiDrawSettings::plot_features_func(wxButton &ob,wxEvent &)
{((PxiDrawSettings *)ob.GetClientData())->AskPlotFeatures();}


void PxiDrawSettings::AskPlotFeatures(void)
{
MyDialogBox *plot_feat_dialog;
unsigned int feat=PlotFeatures();
switch (plot_mode)
{
	case	PXI_PLOT_3:
	{
		plot_feat_dialog=new MyDialogBox(0,"Plot3 Options");
		Bool draw_axis=(feat&DRAW_AXIS) ? TRUE : FALSE;
		plot_feat_dialog->Form()->Add(wxMakeFormBool("Draw Axis",&draw_axis));
		Bool draw_labels=(feat&DRAW_LABELS) ? TRUE : FALSE;
		plot_feat_dialog->Form()->Add(wxMakeFormBool("Draw Labels",&draw_labels));
		plot_feat_dialog->Go();
		if (plot_feat_dialog->Completed()==wxOK)
		{
			feat=0;
			if (draw_axis) feat|=DRAW_AXIS;
			if (draw_labels) feat|=DRAW_LABELS;
		}
		break;
	}
	case	PXI_PLOT_X:
	{
		plot_feat_dialog=new MyDialogBox(0,"PlotX Options");
		Bool draw_axis=(feat&DRAW_AXIS) ? TRUE : FALSE;
		plot_feat_dialog->Form()->Add(wxMakeFormBool("Draw Axis",&draw_axis));
		Bool draw_ticks=(feat&DRAW_TICKS) ? TRUE : FALSE;
		plot_feat_dialog->Form()->Add(wxMakeFormBool("Draw Ticks",&draw_ticks));
		plot_feat_dialog->Form()->Add(wxMakeFormNewLine());
		Bool draw_nums=(feat&DRAW_NUMS) ? TRUE : FALSE;
		plot_feat_dialog->Form()->Add(wxMakeFormBool("Draw Nums",&draw_nums));
		plot_feat_dialog->Go();
		if (plot_feat_dialog->Completed()==wxOK)
		{
			feat=0;
			if (draw_axis) feat|=DRAW_AXIS;
			if (draw_ticks) feat|=DRAW_TICKS;
			if (draw_nums) feat|=DRAW_NUMS;
		}
		break;
	}
	case	PXI_PLOT_2:
	{
		plot_feat_dialog=new MyDialogBox(0,"Plot2 Options");
		Bool draw_axis=(feat&DRAW_AXIS) ? TRUE : FALSE;
		plot_feat_dialog->Form()->Add(wxMakeFormBool("Draw Axis",&draw_axis));
		Bool draw_ticks=(feat&DRAW_TICKS) ? TRUE : FALSE;
		plot_feat_dialog->Form()->Add(wxMakeFormBool("Draw Ticks",&draw_ticks));
		plot_feat_dialog->Form()->Add(wxMakeFormNewLine());
		Bool draw_nums=(feat&DRAW_NUMS) ? TRUE : FALSE;
		plot_feat_dialog->Form()->Add(wxMakeFormBool("Draw Nums",&draw_nums));
		Bool draw_square=(feat&DRAW_SQUARE) ? TRUE : FALSE;
		plot_feat_dialog->Form()->Add(wxMakeFormBool("Square Axis",&draw_square));
		plot_feat_dialog->Go();
		if (plot_feat_dialog->Completed()==wxOK)
		{
			feat=0;
			if (draw_axis) feat|=DRAW_AXIS;
			if (draw_ticks) feat|=DRAW_TICKS;
			if (draw_nums) feat|=DRAW_NUMS;
			if (draw_square) feat|=DRAW_SQUARE;
		}
		break;
	}
}
SetPlotFeatures(feat);
delete plot_feat_dialog;
}

void PxiDrawSettings::SetPlotFeatures(unsigned int feat)
{
switch (plot_mode)
{
	case	PXI_PLOT_3: plot3_features=feat;break;
	case	PXI_PLOT_X: plotx_features=feat;break;
	case	PXI_PLOT_2: plot2_features=feat;break;
}
}
unsigned int PxiDrawSettings::PlotFeatures(void)
{
switch (plot_mode)
{
	case	PXI_PLOT_3: return plot3_features;
	case	PXI_PLOT_X: return plotx_features;
	case	PXI_PLOT_2: return plot2_features;
}
}





void PxiDrawSettings::label_font_func(wxButton &ob,wxEvent &)
{
PxiDrawSettings	*draw_settings=(PxiDrawSettings *)ob.GetClientData();
FontDialogBox *f=new FontDialogBox(NULL,draw_settings->GetLabelFont());
if (f->Completed()==wxOK)
	draw_settings->SetLabelFont(f->MakeFont());
delete f;
}

// Dialog to select what isets and strategies will be displayed.  Take
// care of large games (so that the dialogs do not get too large)
void PxiDrawSettings::disp_func(wxButton &ob,wxEvent &)
{
PxiDrawSettings	*ds=(PxiDrawSettings *)ob.GetClientData();
MyDialogBox *display_dialog=new MyDialogBox(0,"What to Display");
display_dialog->Form()->Add(wxMakeFormNewLine());
display_dialog->Form()->Add(wxMakeFormMessage("Display Data:"));
display_dialog->Form()->Add(wxMakeFormNewLine());
display_dialog->Form()->Add(wxMakeFormMessage("On Top"));
int i,iset;
int num_infosets=ds->num_infosets;
gBlock<Bool> plot_top_bool(num_infosets);
gBlock<Bool> plot_bottom_bool(num_infosets);
gBlock<show_player_strategies>	&strategy_show=ds->strategy_show;
gBlock<int>		&plot_top=ds->plot_top,&plot_bottom=ds->plot_bottom;

for (i=1;i<=num_infosets;i++)
{
	if (plot_top.Contains(i)) plot_top_bool[i]=TRUE; else plot_top_bool[i]=FALSE;
	sprintf(tempstr,"%d",i);
	display_dialog->Form()->Add(wxMakeFormBool(tempstr,&(plot_top_bool[i])));
	if (i%8==0) display_dialog->Form()->Add(wxMakeFormNewLine());
}
if (i>8) display_dialog->Form()->Add(wxMakeFormNewLine());
display_dialog->Form()->Add(wxMakeFormMessage("On Bottom"));
for (i=1;i<=num_infosets;i++)
{
	if (plot_bottom.Contains(i)) plot_bottom_bool[i]=TRUE; else plot_bottom_bool[i]=FALSE;
	sprintf(tempstr,"%d",i);
	display_dialog->Form()->Add(wxMakeFormBool(tempstr,&(plot_bottom_bool[i])));
	if (i%8==0) display_dialog->Form()->Add(wxMakeFormNewLine());
}
display_dialog->Form()->Add(wxMakeFormNewLine());
// Now display all of the infoset startegies, at most 8 per dialog
for (iset=1;iset<=gmin(num_infosets,8);iset++)
{
	char tmp[80];
	sprintf(tmp,"Infoset %d:     ",iset);
	display_dialog->Form()->Add(wxMakeFormMessage(tmp));
	for (i=1;i<=strategy_show[iset].Length();i++)
	{
		sprintf(tempstr,"%d",i);
		display_dialog->Form()->Add(wxMakeFormBool(tempstr,&(strategy_show[iset][i])));
	}
display_dialog->Form()->Add(wxMakeFormNewLine());
}
display_dialog->Go();
if (display_dialog->Completed()==wxOK)
{
	for (i=1;i<=num_infosets;i++)
	{
		if (plot_top_bool[i])
		{
			if (!plot_top.Contains(i)) plot_top.Append(i);
		}
		else
		{
			if (plot_top.Contains(i)) plot_top.Remove(plot_top.Find(i));
		}
		if (plot_bottom_bool[i])
		{
			if (!plot_bottom.Contains(i)) plot_bottom.Append(i);
		}
		else
		{
			if (plot_bottom.Contains(i)) plot_bottom.Remove(plot_bottom.Find(i));
		}
	}
	delete display_dialog;
}
else
{
	delete display_dialog;
	return;
}

// Now display all of the infoset startegies, at most 8 per dialog
for (int iset_group=1;iset_group<=(num_infosets-1)/8;iset_group++)
{
	int start=iset_group*8+1;
	int end=start+gmin(num_infosets-start,8);
	display_dialog=new MyDialogBox(0,"What to Display");
	char tmp[80];
	sprintf(tmp,"Isets %d-%d",start,end);
	for (iset=start;iset<=end;iset++)
	{
		sprintf(tmp,"Infoset %d:     ",iset);
		display_dialog->Form()->Add(wxMakeFormMessage(tmp));
		for (i=1;i<=strategy_show[iset].Length();i++)
		{
			sprintf(tempstr,"%d",i);
			display_dialog->Form()->Add(wxMakeFormBool(tempstr,&(strategy_show[iset][i])));
		}
	display_dialog->Form()->Add(wxMakeFormNewLine());
	}
	display_dialog->Go();
	if (display_dialog->Completed()!=wxOK)
		{delete display_dialog;return;}
	else
		{delete display_dialog;}
}
}




void PxiDrawSettings::overlay_font_func(wxButton &ob,wxEvent &)
{
PxiDrawSettings	*draw_settings=(PxiDrawSettings *)ob.GetClientData();
FontDialogBox *f=new FontDialogBox(NULL,draw_settings->GetOverlayFont());
if (f->Completed()==wxOK)
	draw_settings->SetOverlayFont(f->MakeFont());
delete f;
}
