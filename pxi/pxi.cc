//
// File: pxi.cc -- implementation of main classes for PXI.  [Plot X V2.0]
//

//****************************************************************************
// PXI: This program is designed to primarily plot data that was generated by*
// the Gambit program.  However, it can also read other data files that      *
// conform to the file layout.  The data basically consists of columns of data
// each representing a y-value corresponding to a lambda value.  Lamda values
// are in a separate column.
// The format is as follows:
// Note: all the strings in [] should appear EXACTLY as shown, including the
// ':', excluding the []
// comments are in /* or // and should not be in the data file
// [Dimensionality:]
//  # of datasets, # of datapoints for each dataset
//  2 3 3 means 2 data sets w/ 3 datapoints each
// [Settings:]
// LambdaMin		// minimum value of 'x'
// LambdaMax		// maximum value of 'x'
// LambdaDel		// step in 'x' (assumed to be LambdaDel-1 for Log plots)
// DataMin		// minimum value the data values take
// DataMax		// maximum value the data values take
// DataType		// Can be either 1-Log or 0-Linear

// The following is optional, and might not be used in future versions
// [Game:]
// Order of coefficient reading
// Game matrix
// Only works for 2 dataset files
// [Extra:]
// Extra information about the algorithm that generated the file
// ReadExtra		// Set to 0 unless certain that PXI can use that data
// Merror		// Tolerance
// DelP			// P-step

// Required again
// [DataFormat:]
// # of columns
// column # for lambda values
// column # for objective function values (0 for none)
// Now, column # of datapoint #i for dataset #j, in order i=1..DataPoints[j],
// j=1..DataSets
// last entry can be 0 to indicate that it is obtained by 1-Sum[strategies[1..#strategies-1]]
// [Data:]
// The data, columns separated by white space.

#include <math.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#pragma hdrstop
#include "wxmisc.h"
#include "gmisc.h"
#include "arrays.h"
#include "expdata.h"
#include "dlgpxi.h"
#include "pxi.h"
#include "axis.h"

#include "new.h"
#include "wx/sizer.h"
#include "wx/fontdlg.h"
#include "wx/colordlg.h"

gOutput &operator<<(gOutput &op,const PxiCanvas::LABELSTRUCT &l) 
{op<<l.x<<' '<<l.y<<' '<<l.label<<'\n';return op;}

void mem_handler(void)
{wxFatalError("Memory Error");}

// The `main program' equivalent, creating the windows and returning the
// main frame
bool PxiApp::OnInit(void)
{
  wxConfig config("PXI");

  // Create the main frame window.
  PxiFrame *pxiFrame = new PxiFrame(0, "PXI", wxPoint(0, 0), wxSize(800, 600));
  // Set up the help system.
  wxString helpDir = wxGetWorkingDirectory();
  config.Read("Help-Directory", &helpDir);

  wxInitHelp(wxString(helpDir.c_str()) + "/gambit", 
	     "PXI(Plus or Minus), Version 0.97.3\n"
	     "Based on Eugene Grayver's PXI, version .94\n\n"
	     "Built with " wxVERSION_STRING "\n\n"
	     "Part of the Gambit Project\n"
	     "www.hss.caltech.edu/~gambit/Gambit.html\n"
	     "gambit@hss.caltech.edu\n\n"
	     "Copyright (C) 1999-2000\n"
	     "California Institute of Technology\n"
	     "Funding provided by the National Science Foundation");
  
  set_new_handler(mem_handler);

  pxiFrame->Show(true);
  if (argc>1) pxiFrame->LoadFile( (wxString) (argv[1]));
  return true;
}

IMPLEMENT_APP(PxiApp)

//=====================================================================
//                       class PxiToolbar
//=====================================================================

const int PXI_TOOLBAR_ID = 1101;

class PxiToolbar : public wxToolBar {
private:
  wxFrame *m_parent;

  // Event handlers
  void OnMouseEnter(wxCommandEvent &);
    
public:
  PxiToolbar(wxFrame *p_frame);
  virtual ~PxiToolbar() { }

  DECLARE_EVENT_TABLE()
};

BEGIN_EVENT_TABLE(PxiToolbar, wxToolBar)
  EVT_TOOL_ENTER(PXI_TOOLBAR_ID, PxiToolbar::OnMouseEnter)
END_EVENT_TABLE()

PxiToolbar::PxiToolbar(wxFrame *p_parent)
  : wxToolBar(p_parent, PXI_TOOLBAR_ID),
    m_parent(p_parent)
{
#ifdef __WXMSW__
  wxBitmap loadBitmap("OPEN_BITMAP");
  wxBitmap helpBitmap("HELP_BITMAP");
#else
#include "../sources/bitmaps/open.xpm"
#include "../sources/bitmaps/help.xpm"
  wxBitmap loadBitmap(open_xpm);
  wxBitmap helpBitmap(help_xpm);
#endif  // __WXMSW__
  
  SetMargins(2, 2);
#ifdef __WXMSW__
  SetToolBitmapSize(wxSize(33, 30));
#endif  // __WXMSW__
  AddTool(PXI_LOAD_FILE, loadBitmap);
  AddSeparator();
  AddTool(PXI_HELP_ABOUT, helpBitmap);

  Realize();
}

void PxiToolbar::OnMouseEnter(wxCommandEvent &p_event)
{
  if (p_event.GetSelection() > 0) {
    m_parent->SetStatusText(m_parent->GetMenuBar()->GetHelpString(p_event.GetSelection()));
  }
  else {
    m_parent->SetStatusText("");
  }
}

//=====================================================================
//                       class PxiFrame
//=====================================================================

PxiFrame::PxiFrame(wxFrame *p_parent, const wxString &p_title,
		   const wxPoint &p_position, const wxSize &p_size, long p_style) :
  wxFrame(p_parent, -1, p_title, p_position, p_size,p_style)
{
#ifdef __WXMSW__
  SetIcon(wxIcon("pxi_icn"));
#else
#include "pxi.xpm"
  SetIcon(wxIcon(pxi_xpm));
#endif
    
  wxMenu *file_menu = new wxMenu;
  wxMenu *help_menu = new wxMenu;
  file_menu->Append(PXI_LOAD_FILE, "&Load file", "Load file");
  file_menu->Append(PXI_QUIT, "&Quit", "Exit PXI");
  help_menu->Append(PXI_HELP_ABOUT,"&About", "About Plot X");
  help_menu->Append(PXI_HELP_CONTENTS,"&Contents", "Table of Contents");

  wxMenuBar *menu_bar = new wxMenuBar;
  menu_bar->Append(file_menu, "&File");
  menu_bar->Append(help_menu, "&Help");
  SetMenuBar(menu_bar);

  wxConfig config("PXI");
  m_fileHistory.Load(config);
  m_fileHistory.UseMenu(file_menu);
  m_fileHistory.AddFilesToMenu();

  CreateStatusBar();

  SetToolBar(new PxiToolbar(this));
}


PxiFrame::~PxiFrame()
{
  wxConfig config("PXI");
  m_fileHistory.Save(config);
}

BEGIN_EVENT_TABLE(PxiFrame, wxFrame)
  EVT_MENU(PXI_LOAD_FILE, PxiFrame::OnFileLoad) 
  EVT_MENU(PXI_QUIT, wxWindow::Close)
  EVT_MENU_RANGE(wxID_FILE1, wxID_FILE9, PxiFrame::OnMRUFile)
  EVT_MENU(PXI_HELP_ABOUT, PxiFrame::OnHelpAbout)
  EVT_MENU(PXI_HELP_CONTENTS, PxiFrame::OnHelpContents)
  EVT_CLOSE(PxiFrame::OnCloseWindow)
END_EVENT_TABLE()

void PxiFrame::OnFileLoad(wxCommandEvent &)
{
  Enable(false); // Don't allow anything while the dialog is up.

  wxString filename = wxFileSelector("Load data file", wxGetApp().CurrentDir(),
				  NULL, NULL, "*.pxi").c_str();
  Enable(true);

  if(filename == "") 
    return;

  wxGetApp().SetCurrentDir(wxPathOnly(filename));
  LoadFile(filename);
}

void PxiFrame::OnMRUFile(wxCommandEvent &p_event)
{
  LoadFile(m_fileHistory.GetHistoryFile(p_event.GetSelection() - wxID_FILE1).c_str());
}

void PxiFrame::OnHelpAbout(wxCommandEvent &)
{
  wxHelpAbout(); 
}

void PxiFrame::OnHelpContents(wxCommandEvent &)
{
  wxHelpContents(PXI_GUI_HELP);
}

void PxiFrame::LoadFile(const wxString &p_filename)
{    
  wxString filename(wxFileNameFromPath(p_filename));
  filename = filename.MakeLower();

  if (filename.Contains(".pxi")) {
    if (!wxFileExists(p_filename)) {
      wxMessageBox("File could not be found or opened");
      return;
    }
    else {
      m_fileHistory.AddFileToHistory(p_filename);
    }
    PxiChild *subframe = new PxiChild(this,p_filename);
  }
  else
    wxMessageBox("Unknown file type");
}

BEGIN_EVENT_TABLE(PxiChild, wxFrame)
  //  EVT_MENU(PXI_LOAD_FILE, PxiChild::On)
  EVT_MENU(PXI_OUTPUT, PxiChild::OnFileOutput)
  EVT_MENU(PXI_CHILD_CLOSE, PxiChild::Close)
  EVT_MENU(PXI_CHILD_QUIT, PxiChild::OnQuit)
  EVT_MENU(PXI_DATA_OVERLAY_DATA, PxiChild::OnOverlayData)
  EVT_MENU(PXI_DATA_OVERLAY_FILE, PxiChild::OnOverlayFile)
  EVT_MENU(PXI_FILE_DETAIL, PxiChild::OnFileDetail)
  EVT_MENU(PXI_DISPLAY_OPTIONS, PxiChild::OnDisplayOptions)
  EVT_MENU(PXI_PREFS_FONT_AXIS, PxiChild::OnPrefsFontAxis)
  EVT_MENU(PXI_PREFS_FONT_LABEL, PxiChild::OnPrefsFontLabel)
  EVT_MENU(PXI_PREFS_FONT_OVERLAY, PxiChild::OnPrefsFontOverlay)
  EVT_MENU(PXI_PREFS_COLORS, PxiChild::OnPrefsColors)
  EVT_MENU(PXI_HELP_ABOUT, PxiChild::OnHelpAbout)
  EVT_MENU(PXI_HELP_CONTENTS, PxiChild::OnHelpContents)
  EVT_SIZE(PxiChild::OnSize)
  EVT_CLOSE(PxiChild::OnCloseWindow)
END_EVENT_TABLE()

void PxiChild::OnQuit(wxCommandEvent &)
{
  GetParent()->Close();
}

void PxiChild::OnOverlayData(wxCommandEvent &)
{
  dialogOverlayData dialog(this, canvas);
  wxClientDC dc(this);
  canvas->Update(dc,PXI_UPDATE_SCREEN);
}

void PxiChild::OnOverlayFile(wxCommandEvent &)
{
  char *s=copystring(wxFileSelector("Load Overlay",NULL,NULL,NULL,"*.out"));
  if (s) {
    FileHeader temp_header(s);
    if ( (temp_header.NumStrategies()!=(canvas->Header(1)).NumStrategies()) ||
	 (temp_header.NumInfosets()!=(canvas->Header(1)).NumInfosets()) )
      wxMessageBox("These data files do not\nhave the same structure!");
    else
      canvas->AppendHeader(temp_header);
  }
  wxClientDC dc(this);
  canvas->Update(dc,PXI_UPDATE_SCREEN);
}

void PxiChild::OnFileDetail(wxCommandEvent &)
{
  canvas->ShowDetail();
}

void PxiChild::OnFileOutput(wxCommandEvent &)
{
  wxOutputDialogBox dialog(0,this);
  if (dialog.ShowModal() == wxID_OK) 
    switch (dialog.GetMedia()) {
    case wxMEDIA_PRINTER: print(dialog.GetOption()); break;
    case wxMEDIA_PS:print_eps(dialog.GetOption()); break;
    case wxMEDIA_CLIPBOARD:print_mf(dialog.GetOption()); break;
    case wxMEDIA_METAFILE: print_mf(dialog.GetOption(), true); break;
    case wxMEDIA_PREVIEW: print(dialog.GetOption(), true); break;
    default:
      // We'll ignore this silently
      break;
    }
}

void PxiChild::OnPrefsColors(wxCommandEvent &)
{
  wxColourData data;
  wxColourDialog dialog(this, &data);
 
  if (dialog.ShowModal() == wxID_OK) {
    // dialog.GetColourData().GetColour();
  }
}

void PxiChild::OnPrefsFontLabel(wxCommandEvent &)
{
  wxFontData data;
  wxFontDialog dialog(this, &data);
  
  if (dialog.ShowModal() == wxID_OK) {
    canvas->draw_settings->SetLabelFont(dialog.GetFontData().GetChosenFont());
  }
}

void PxiChild::OnPrefsFontAxis(wxCommandEvent &)
{
  wxFontData data;
  wxFontDialog dialog(this, &data);
  
  if (dialog.ShowModal() == wxID_OK) {
    canvas->draw_settings->SetAxisFont(dialog.GetFontData().GetChosenFont());
  }
}

void PxiChild::OnPrefsFontOverlay(wxCommandEvent &)
{
  wxFontData data;
  wxFontDialog dialog(this, &data);
  
  if (dialog.ShowModal() == wxID_OK) {
    canvas->draw_settings->SetOverlayFont(dialog.GetFontData().GetChosenFont());
  }
}

void PxiChild::OnHelpAbout(wxCommandEvent &)
{
  wxHelpAbout();
}

void PxiChild::OnHelpContents(wxCommandEvent &)
{
  wxHelpContents(PXI_GUI_HELP);
}

void PxiChild::OnDisplayOptions(wxCommandEvent &)
{
  canvas->DrawSettings()->SetOptions(this);
  wxClientDC dc(this);
  this->canvas->Update(dc,PXI_UPDATE_SCREEN);
}

PxiChild::PxiChild(PxiFrame *p_parent, const wxString &p_filename) :
  wxFrame(p_parent, -1, p_filename, wxPoint(0,0),wxSize(480,480), 
	  wxDEFAULT_FRAME_STYLE | wxFRAME_FLOAT_ON_PARENT), parent(p_parent)
{
  SetSizeHints(300, 300);

  // Give the frame an icon
#ifdef __WXMSW__
  SetIcon(wxIcon("pxi_icn"));
#else
#include "pxi.xpm"
  SetIcon(wxIcon(pxi_xpm));
#endif

  CreateStatusBar();
  MakeMenus();

  //  m_toolbar = new PxiChildToolbar(this, this);

  int width, height;
  GetClientSize(&width, &height);
    // save the canvas in subframe
  canvas = new PxiCanvas(this, wxPoint(0, 0), wxSize(width, height),wxRETAINED,p_filename);
  Show(true);
}

PxiChild::~PxiChild(void)
{ }

void PxiChild::MakeMenus(void)
{
  wxMenu *file_menu = new wxMenu;
  file_menu->Append(PXI_LOAD_FILE, "&Load file", "Load new data file");
  file_menu->Append(PXI_CHILD_CLOSE, "&Close", "Close child window");
  file_menu->Append(PXI_OUTPUT, "Output", "Output to file or printer");
  file_menu->AppendSeparator();
  file_menu->Append(PXI_CHILD_QUIT, "&Quit", "Quit Program");
  wxMenu *data_menu= new wxMenu;
  data_menu->Append(PXI_DATA_OVERLAY_DATA, "&Overlay Data", "Overlay experiment data on plot");
  data_menu->Append(PXI_DATA_OVERLAY_FILE, "&Overlay File", "Overlay another pxi file");
  
  wxMenu *prefs_menu = new wxMenu;
  wxMenu *prefs_font_menu = new wxMenu;

  prefs_font_menu->Append(PXI_PREFS_FONT_AXIS,"&Axes", "Change Axes Font");
  prefs_font_menu->Append(PXI_PREFS_FONT_LABEL,"&Label", "Change Lable Font");
  prefs_font_menu->Append(PXI_PREFS_FONT_OVERLAY,"&Overlay", "Change Overlay Font");
  prefs_menu->Append(PXI_PREFS_FONTS, "&Fonts", prefs_font_menu,
		     "Set display fonts");

  prefs_menu->Append(PXI_PREFS_COLORS,"&Colors", "Change Colors");
  wxMenu *help_menu = new wxMenu;
  help_menu->Append(PXI_HELP_ABOUT,"&About", "About Plot X");
  help_menu->Append(PXI_HELP_CONTENTS,"&Contents", "Table of Contents");
  wxMenu *display_menu = new wxMenu;
  display_menu->Append(PXI_FILE_DETAIL,"&Details", "File Details");
  display_menu->Append(PXI_DISPLAY_OPTIONS,"&Options...", "Change plot options");
  wxMenuBar *menu_bar = new wxMenuBar;
  menu_bar->Append(file_menu, "&File");
  menu_bar->Append(data_menu, "&Data");
  menu_bar->Append(display_menu, "&Display");
  menu_bar->Append(prefs_menu, "&Prefs");
  menu_bar->Append(help_menu, "&Help");

  // Associate the menu bar with the frame
  SetMenuBar(menu_bar);
}


// Show details

void PxiCanvas::ShowDetail(void)
{
  char tempstr[200];
  FileHeader header=headers[1];
  wxString message;
  int		i1,i;
  sprintf(tempstr,"Detail for: %s\n",(const char *)FileNameFromPath(header.FileName()));
  message+=tempstr;
  sprintf(tempstr,"Error (lambda) step:  %4.4f\n",header.EStep());
  message+=tempstr;
  sprintf(tempstr,"Error (lambda) start: %4.4f\n",header.EStart());
  message+=tempstr;
  sprintf(tempstr,"Error (lambda) stop : %4.4f\n",header.EStop());
  message+=tempstr;
  sprintf(tempstr,"Minimum data value  : %4.4f\n",header.DataMin());
  message+=tempstr;
  sprintf(tempstr,"Maximum data value  : %4.4f\n",header.DataMax());
  message+=tempstr;
  sprintf(tempstr,"Data type:  %s\n",(header.DataType()==DATA_TYPE_ARITH) ? "Arithmetic" : "Logarithmic");
  message+=tempstr;
  message+="\n";
  if (header.MError()>-.99) {
    sprintf(tempstr,"Probability step :    %4.4f\n",header.QStep());
    message+=tempstr;
    sprintf(tempstr,"Margin of error:      %4.4f\n",header.MError());
    message+=tempstr;
  }
  wxMessageBox(message,"File Details",wxOK);
}

void PxiCanvas::StopIt(void)
{
  if (draw_settings->GetStopMax()==draw_settings->GetMaxL()) {
    //	if (updating) draw_settings->SetStopMax(cur_e);
  }
  else {
    //	if (!updating)
    {
      draw_settings->ResetSetStop();
      wxPaintEvent event;
      OnPaint(event);
    }
  }
}

void PxiCanvas::NewExpData(ExpDataParams &P) 
{ 
  if(exp_data) delete exp_data;
  exp_data = NULL;
  exp_data = new ExpData(P); 
}

void PxiCanvas::OnChar(wxKeyEvent &ev)
{
  switch(ev.KeyCode()) {
  case PXI_KEY_STOP:
    StopIt();
    break;
  default:
    wxScrolledWindow::OnChar(ev);
    break;
  }
}

void PxiCanvas::OnEvent(wxMouseEvent &ev)
{
  if (ev.ShiftDown() && ev.ButtonDown()) {  // use shift mouse click to add a label
    int w,h;
    GetClientSize(&w,&h);
    label_struct tmp_label;
    //    tmp_label.x=ev.x/w;tmp_label.y=ev.y/h;
    tmp_label.x=ev.GetX()/w;tmp_label.y=ev.GetY()/h;
    // Check if clicked on an already existing text
    int clicked_on=0;
    for (int i=1;i<=labels.Length();i++)
      if (labels[i].x+TEXT_MARGIN>tmp_label.x && labels[i].x-TEXT_MARGIN<tmp_label.x &&
	  labels[i].y+TEXT_MARGIN>tmp_label.y && labels[i].y-TEXT_MARGIN<tmp_label.y)
	clicked_on=i;
    const char * junk = (clicked_on) ? (const char *)labels[clicked_on].label : "";
    tmp_label.label=wxGetTextFromUser("Enter Label","Enter Label", (char *)junk);
    //					  (clicked_on) ? (char *)labels[clicked_on].label : "");
    if (!clicked_on)
      labels.Append(tmp_label);
    else {
      tmp_label.x=labels[clicked_on].x;
      tmp_label.y=labels[clicked_on].y;
      labels[clicked_on]=tmp_label;
    }
    wxPaintEvent event;
    OnPaint(event);
  }
}

BEGIN_EVENT_TABLE(PxiCanvas, wxScrolledWindow)
  EVT_PAINT(PxiCanvas::OnPaint)
END_EVENT_TABLE()

// Define a constructor for my canvas
PxiCanvas::PxiCanvas(wxFrame *frame, const wxPoint &p_position,
		     const wxSize &p_size, int style,const char *file_name):
  wxScrolledWindow(frame, -1, p_position, p_size, style),
  exp_data(NULL),draw_settings(NULL), probs(file_name), painting(false)
{
  headers.Append(FileHeader(file_name));
  draw_settings=new PxiDrawSettings(headers[1]);
  frame->SetTitle(headers[1].FileName());
  Show(true);
}

#ifdef wx_msw
void PxiChild::print(wxOutputOption fit, bool preview)
{
  wxPrinterDC dc(NULL, NULL, NULL);  // Defaults to EPS under UNIX,
  // normal Windows printing under Win 3.1
  if (dc.Ok()) {
    dc.StartDoc("PXI printout");
    dc.StartPage();
    this->canvas->Update(dc,PXI_UPDATE_PRINTER);
    dc.EndPage();
    dc.EndDoc();
  }
  this->canvas->Update(*(this->canvas->GetDC()),PXI_UPDATE_SCREEN);
}
#else
void PxiChild::print(wxOutputOption /*fit*/, bool preview)
{
  if (!preview)
    wxMessageBox("Printing not supported under X");
  else
    wxMessageBox("Print Preview is not supported under X");
}
#endif



void PxiChild::print_eps(wxOutputOption fit)
{
#ifdef __WXMSW__
#else
  wxPostScriptDC dc("junk.pxi",true, this);
  if (dc.Ok()) {
    dc.StartDoc("Pxi printout");
    dc.StartPage();
    this->canvas->Update(dc,PXI_UPDATE_FILE);
    dc.EndPage();
    dc.EndDoc();
  }
#endif // __WXMSW__
}

#ifdef __WXMSW__
void PxiChild::print_mf(wxOutputOption fit, bool save_mf)
{
  wxMetaFileDC dc;
  if (dc.Ok()) {
    this->canvas->Update(dc,PXI_UPDATE_METAFILE);
    wxMetaFile *mf = dc.Close();
    if (mf) {
      mf->SetClipboard((int)(dc.MaxX()+10),(int)(dc.MaxY()+10));
      delete mf;
    }
  }
  this->canvas->Update(*(this->canvas->GetDC()),PXI_UPDATE_SCREEN);
}
#else
void PxiChild::print_mf(wxOutputOption /*fit*/, bool /*save_mf*/)
{
  wxMessageBox("Metafiles are not supported under X");
}
#endif __WXMSW__

#ifdef __WXMSW__
void PxiChild::save_mf(wxOutputOption fit, bool save_mf)
{
  char *s=copystring(wxFileSelector("Save Metafile",NULL,NULL,NULL,"*.wmf"));
  if (s) {
    wxMetaFileDC dc(s);
    if (dc.Ok()) {
      this->canvas->Update(dc,PXI_UPDATE_METAFILE);
      wxMetaFile *mf = dc.Close();
      if (mf) {
	delete mf;
	wxMakeMetaFilePlaceable(s,dc.MinX(),dc.MinY(),dc.MaxX(),dc.MaxY());
      }
    }
    delete [] s;
    this->canvas->Update(*(this->canvas->GetDC()),PXI_UPDATE_SCREEN);
  }
}
#else
void PxiChild::save_mf(wxOutputOption /*fit*/, bool /*save_mf*/)
{
  wxMessageBox("Metafiles are not supported under X");
}
#endif // __WXMSW__

void PxiFrame::OnCloseWindow(wxCloseEvent &)
{
  wxKillHelp();
  Destroy();
}

// Define the repainting behaviour
void PxiCanvas::OnPaint(wxPaintEvent &)
{
  if (painting) 
    return; // prevent re-entry
  painting = true;
  wxPaintDC dc(this);
  Update(dc,PXI_UPDATE_SCREEN);
  painting = false;
}

// Define the behaviour for the frame closing
// - must delete all frames except for the main one.

//*************************************************************************
//************************* DRAW SETTINGS *********************************
//*************************************************************************

PxiDrawSettings::PxiDrawSettings(FileHeader &header)
  : overlay_font(8,wxSWISS,wxNORMAL,wxBOLD),
    label_font(8,wxSWISS,wxNORMAL,wxBOLD), 
    axis_font(8,wxSWISS,wxNORMAL,wxBOLD),
    clear_brush("BLACK",wxTRANSPARENT),
    exp_data_brush("BLACK",wxSOLID), 
    axis_text_color("BLUE")
{
  int i,j;
  overlay_symbol=OVERLAY_NUMBER;
  overlay_lines=FALSE;
  overlay_token_size=DEF_TOKEN_SIZE;
  color_mode=COLOR_EQU;
  restart_overlay_colors=TRUE;
  connect_dots=FALSE;
  data_mode=header.DataType();
  plot_mode=PXI_PLOT_X;
  l_start=header.EStart();l_stop=header.EStop();l_step=header.EStep();
  stop_min=l_start;stop_max=l_stop;
  data_min=header.DataMin();data_max=header.DataMax();
  
  num_infosets=header.NumInfosets();
  one_or_two=(header.NumInfosets()>1) ? 2 : 1;
  // Create the 'what to display where' data structures
  // Default is to show first 1/2 of the infosets with all their strategies
  // on the top portion of the graph (in two graph mode) and the rest on the
  // bottom.  In one graph mode, the default is to show just the first 1/2 of
  // the infosets with all their strategies.
  strategy_show=gBlock<show_player_strategies>(num_infosets);
  for (i=1;i<=num_infosets;i++) {
    strategy_show[i]=show_player_strategies(header.NumStrategies(i));
    for (j=1;j<=header.NumStrategies(i);j++) strategy_show[i][j]=TRUE;
  }
  plot_top=gBlock<int>(num_infosets/2);
  for (i=1;i<=num_infosets/2;i++) plot_top[i]=i;
  plot_bottom=gBlock<int>(num_infosets-num_infosets/2);
  for (i=1+num_infosets/2;i<=num_infosets;i++) plot_bottom[i-num_infosets/2]=i;
  // Default features are everything on
  plot3_features=DRAW_AXIS|DRAW_LABELS;
  plotx_features=DRAW_AXIS|DRAW_TICKS|DRAW_NUMS;
  plot2_features=DRAW_AXIS|DRAW_TICKS|DRAW_NUMS|DRAW_SQUARE;
}

// Plot3 mode is now more flexible: it works great (by default) on 2d player
// games, each player having 3 strategies.  It has now been extended to work
// with N player games with 3+ strategies each
// In this case, the two desired strategies are selected in the dialog, and
// the third is calculated from 1-(first+second).  You can also plot more than
// one infoset per triangle now.

Bool PxiDrawSettings::CheckPlot3Mode(void)
{
  int i;
  // Check if there are 3 or over strategy_show for each player
  int top, bottom;
  for (top=1;top<=GetPlotTop();top++)
    if (strategy_show[GetPlotTop(top)].Length()<3) {
      wxMessageBox("Each player must have at least 3 strategies!");
      return FALSE;
    }
  for (bottom=1;bottom<=GetPlotBottom();bottom++)
    if (strategy_show[GetPlotBottom(bottom)].Length()<3) {
      wxMessageBox("Each player must have at least 3 strategies!");
      return FALSE;
    }
  
  // Check if only two strategies have been selected for each player (add all of them up)
  int num_strategies=0;
  for (top=1;top<=GetPlotTop();top++)
    for (i=1;i<=strategy_show[GetPlotTop(top)].Length();i++)
      num_strategies+=(GetStrategyShow(GetPlotTop(top),i)) ? 1 : 0;
  for (bottom=1;bottom<=GetPlotBottom();bottom++)
    for (i=1;i<=strategy_show[GetPlotBottom(bottom)].Length();i++)
      num_strategies+=(GetStrategyShow(GetPlotBottom(bottom),i)) ? 1 : 0;
  if (num_strategies>2*(GetPlotTop()+GetPlotBottom())) {
    wxMessageBox("Only two strategies per player allowed!");
    return FALSE;
  }
  return TRUE;
}

// Check Plot_2 Mode:  Plot 2 mode plots a player's strategy against another
// strategy (the same or different player's).  Only one pair of strategies
// can be plotted at any one time.  Thus, only two of the checkboxes in the
// strategy selection section can be turned on.

Bool PxiDrawSettings::CheckPlot2Mode(void)
{
  int i,j,num_strategies=0;
  for (j=1;j<=strategy_show.Length();j++)
    for (i=1;i<=strategy_show[j].Length();i++)
      num_strategies+=(GetStrategyShow(j,i)) ? 1 : 0;
  if (num_strategies>2) {
    wxMessageBox("Only TWO strategies TOTAL can be checked\nin the strategy selection dialog");
    return FALSE;
  }
  return TRUE;
}

void PxiDrawSettings::SetOptions(wxWindow *parent)
{
  dialogDrawSettings dialog(parent, *this);
}

void PxiDrawSettings::SetPlotFeatures(unsigned int feat)
{
  switch (plot_mode) {
  case PXI_PLOT_3: plot3_features=feat;break;
  case PXI_PLOT_X: plotx_features=feat;break;
  case PXI_PLOT_2: plot2_features=feat;break;
  }
}

unsigned int PxiDrawSettings::PlotFeatures(void)
{
  switch (plot_mode) {
  case	PXI_PLOT_3: return plot3_features;
  case	PXI_PLOT_X: return plotx_features;
  case	PXI_PLOT_2: return plot2_features;
  }
}

//
// A general-purpose dialog box to display the description of the exception
//

void pxiExceptionDialog(const wxString &p_message, wxWindow *p_parent,
            long p_style /*= wxOK | wxCENTRE*/)
{
  wxString message = "An internal error occurred in PXI:\n" + p_message;
  wxMessageBox(message, "PXI Error", p_style, p_parent);
}


