//****************************************************************************
// PXI: This program is designed to primarily plot data that was generated by*
// the Gambit program.  However, it can also read other data files that      *
// conform to the file layout.  The data basically consists of columns of data
// each representing a y-value corresponding to a lambda value.  Lamda values
// are in a separate column.
// The format is as follows:
// Note: all the strings in [] should appear EXACTLY as shown, including the
// ':', excluding the []
// comments are in /* or // and should not be in the data file
// [Dimensionality:]
//  # of datasets, # of datapoints for each dataset
//  2 3 3 means 2 data sets w/ 3 datapoints each
// [Settings:]
// LambdaMin		// minimum value of 'x'
// LambdaMax		// maximum value of 'x'
// LambdaDel		// step in 'x' (assumed to be LambdaDel-1 for Log plots)
// DataMin		// minimum value the data values take
// DataMax		// maximum value the data values take
// DataType		// Can be either 1-Log or 0-Linear

// The following is optional, and might not be used in future versions
// [Game:]
// Order of coefficient reading
// Game matrix
// Only works for 2 dataset files
// [Extra:]
// Extra information about the algorithm that generated the file
// ReadExtra		// Set to 0 unless certain that PXI can use that data
// Merror		// Tolerance
// DelP			// P-step

// Required again
// [DataFormat:]
// # of columns
// column # for lambda values
// column # for objective function values (0 for none)
// Now, column # of datapoint #i for dataset #j, in order i=1..DataPoints[j],
// j=1..DataSets
// last entry can be 0 to indicate that it is obtained by 1-Sum[strategies[1..#strategies-1]]
// [Data:]
// The data, columns separated by white space.

#include <math.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#pragma hdrstop
#include "wxmisc.h"
#include "gmisc.h"
#include "general.h"
#include "gambitio.h"
#include "arrays.h"
#include "equtrac.h"
#include "normequs.h"
#include "expdata.h"
#include "onedot.h"
#include "pxi.h"
#include "axis.h"

#include "new.h"
#include "wx/sizer.h"

gOutput &operator<<(gOutput &op,const PxiCanvas::LABELSTRUCT &l) 
{op<<l.x<<' '<<l.y<<' '<<l.label<<'\n';return op;}

void mem_handler(void)
{wxFatalError("Memory Error");}

char tempstr[200];

// Must initialise these in OnInit, not statically
wxCursor	*arrow_cursor;
wxCursor	*wait_cursor;
wxColour	*axis_text_color;
wxFont		*axis_font;
wxBrush		*clear_brush;
wxBrush		*exp_data_brush;

// The `main program' equivalent, creating the windows and returning the
// main frame
bool PxiApp::OnInit(void)
{
  wxConfig config("PXI");

  // Create the main frame window.
  PxiFrame *pxiFrame = new PxiFrame(0, "PXI", wxPoint(0, 0), wxSize(800, 600));
  // Set up the help system.
  wxString helpDir = wxGetWorkingDirectory();
  config.Read("Help-Directory", &helpDir);

  wxInitHelp(wxString(helpDir.c_str()) + "/gambit", 
	     "PXI, Version 0.97.3\n"
	     "Built with " wxVERSION_STRING "\n\n"
	     "Part of the Gambit Project\n"
	     "www.hss.caltech.edu/~gambit/Gambit.html\n"
	     "gambit@hss.caltech.edu\n\n"
	     "Copyright (C) 1999-2000\n"
	     "California Institute of Technology\n"
	     "Funding provided by the National Science Foundation");
  
  set_new_handler(mem_handler);
  // Create needed cursors
  arrow_cursor = new wxCursor(wxCURSOR_ARROW);
  wait_cursor = new wxCursor(wxCURSOR_WAIT);
  // Create the rest of the resources
  axis_font = new wxFont(8, wxSWISS, wxNORMAL, wxNORMAL);
  axis_text_color=new wxColour("BLUE");
  clear_brush = new wxBrush("BLACK",wxTRANSPARENT);
  exp_data_brush=new wxBrush("BLACK",wxSOLID);

  // pxiFrame->SetCursor(arrow_cursor);

  pxiFrame->Show(true);
  if (argc>1) pxiFrame->LoadFile( (wxString) (argv[1]));
  return true;
}

IMPLEMENT_APP(PxiApp)

//=====================================================================
//                       class PxiToolbar
//=====================================================================

const int PXI_TOOLBAR_ID = 1101;

class PxiToolbar : public wxToolBar {
private:
  wxFrame *m_parent;

  // Event handlers
  void OnMouseEnter(wxCommandEvent &);
    
public:
  PxiToolbar(wxFrame *, const wxPoint &, const wxSize &);
  virtual ~PxiToolbar() { }

  DECLARE_EVENT_TABLE()
};

BEGIN_EVENT_TABLE(PxiToolbar, wxToolBar)
  EVT_TOOL_ENTER(PXI_TOOLBAR_ID, PxiToolbar::OnMouseEnter)
END_EVENT_TABLE()

PxiToolbar::PxiToolbar(wxFrame *p_parent, const wxPoint &p_position,
			     const wxSize &p_size)
  : wxToolBar(p_parent, PXI_TOOLBAR_ID, p_position, p_size),
    m_parent(p_parent)
{
#ifdef __WXMSW__
  wxBitmap loadBitmap("OPEN_BITMAP");
  wxBitmap helpBitmap("HELP_BITMAP");
#else
#include "../sources/bitmaps/open.xpm"
#include "../sources/bitmaps/help.xpm"
  wxBitmap loadBitmap(open_xpm);
  wxBitmap helpBitmap(help_xpm);
#endif  // __WXMSW__
  
  SetMargins(2, 2);
#ifdef __WXMSW__
  SetToolBitmapSize(wxSize(33, 30));
#endif  // __WXMSW__
  AddTool(PXI_LOAD_FILE, loadBitmap);
  AddSeparator();
  AddTool(PXI_ABOUT, helpBitmap);

  Realize();
}

void PxiToolbar::OnMouseEnter(wxCommandEvent &p_event)
{
  if (p_event.GetSelection() > 0) {
    m_parent->SetStatusText(m_parent->GetMenuBar()->GetHelpString(p_event.GetSelection()));
  }
  else {
    m_parent->SetStatusText("");
  }
}

//=====================================================================
//                       class PxiFrame
//=====================================================================

PxiFrame::PxiFrame(wxFrame *p_parent, const wxString &p_title,
		   const wxPoint &p_position, const wxSize &p_size, long p_style) :
  wxFrame(p_parent, -1, p_title, p_position, p_size,p_style)
{
#ifdef __WXMSW__
  SetIcon(wxIcon("pxi_icn"));
#else
#include "pxi.xpm"
  SetIcon(wxIcon(pxi_xpm));
#endif
    
  wxMenu *file_menu = new wxMenu;
  wxMenu *data_menu = new wxMenu;
  wxMenu *help_menu = new wxMenu;
  file_menu->Append(PXI_LOAD_FILE, "&Load file", "Load file");
  file_menu->Append(PXI_QUIT, "&Quit", "Exit PXI");
  data_menu->Append(PXI_DATA_GRID,"&GridSolver","Create a new file");
  help_menu->Append(PXI_ABOUT,"&About PlotX");

  wxMenuBar *menu_bar = new wxMenuBar;
  menu_bar->Append(file_menu, "&File");
  menu_bar->Append(data_menu, "&Data");
  menu_bar->Append(help_menu, "&Help");
  SetMenuBar(menu_bar);

  wxConfig config("PXI");
  m_fileHistory.Load(config);
  m_fileHistory.UseMenu(file_menu);
  m_fileHistory.AddFilesToMenu();

  CreateStatusBar();

  (void) new PxiToolbar(this, wxPoint(0, 0), wxSize(200, 40));
}

PxiFrame::~PxiFrame()
{
  wxConfig config("PXI");
  m_fileHistory.Save(config);
}

BEGIN_EVENT_TABLE(PxiFrame, wxFrame)
  EVT_MENU(PXI_LOAD_FILE, PxiFrame::OnFileLoad) 
  EVT_MENU(PXI_QUIT, wxWindow::Close)
  EVT_MENU_RANGE(wxID_FILE1, wxID_FILE9, PxiFrame::OnMRUFile)
  EVT_MENU(PXI_DATA_GRID, PxiFrame::OnDataGridSolve)
  EVT_MENU(PXI_ABOUT, PxiFrame::OnHelpAbout)
  EVT_CLOSE(PxiFrame::OnCloseWindow)
END_EVENT_TABLE()

void PxiFrame::OnFileLoad(wxCommandEvent &)
{
  Enable(false); // Don't allow anything while the dialog is up.

  wxString filename = wxFileSelector("Load data file", wxGetApp().CurrentDir(),
				  NULL, NULL, "*.pxi").c_str();
  Enable(true);

  if(filename == "") 
    return;

  wxGetApp().SetCurrentDir(wxPathOnly(filename));
  LoadFile(filename);
}

void PxiFrame::OnDataGridSolve(wxCommandEvent &)
{
}

void PxiFrame::OnMRUFile(wxCommandEvent &p_event)
{
  LoadFile(m_fileHistory.GetHistoryFile(p_event.GetSelection() - wxID_FILE1).c_str());
}

void PxiFrame::OnHelpAbout(wxCommandEvent &)
{
  wxHelpAbout(); 
}

void PxiFrame::LoadFile(const wxString &p_filename)
{    
  wxString filename(wxFileNameFromPath(p_filename));
  filename = filename.MakeLower();

  if (filename.Contains(".pxi")) {
    if (!wxFileExists(p_filename)) {
      wxMessageBox("File could not be found or opened");
      return;
    }
    else {
      m_fileHistory.AddFileToHistory(p_filename);
    }
    PxiChild *subframe = new PxiChild(this,p_filename);
  }
  else
    wxMessageBox("Unknown file type");
}

BEGIN_EVENT_TABLE(PxiChild, wxFrame)
  //  EVT_MENU(PXI_LOAD_FILE, PxiChild::On)
  EVT_MENU(PXI_OUTPUT, PxiChild::OnFileOutput)
  EVT_MENU(PXI_CHILD_QUIT, PxiChild::Close)
  EVT_MENU(PXI_QUIT, PxiChild::Close)
  EVT_MENU(PXI_DATA_GRID, PxiChild::OnGrid)
  EVT_MENU(PXI_DATA_OVERLAY_DATA, PxiChild::OnOverlayData)
  EVT_MENU(PXI_DATA_OVERLAY_FILE, PxiChild::OnOverlayFile)
  EVT_MENU(PXI_DATA_ONEDOT, PxiChild::OnOneDot)
  EVT_MENU(PXI_FILE_DETAIL, PxiChild::OnFileDetail)
  EVT_MENU(PXI_DISPLAY_OPTIONS, PxiChild::OnDisplayOptions)
  EVT_MENU(PXI_ABOUT, PxiChild::OnHelpAbout)
  EVT_SIZE(PxiChild::OnSize)
  EVT_CLOSE(PxiChild::OnCloseWindow)
END_EVENT_TABLE()

void PxiChild::OnGrid(wxCommandEvent &)
{
}

void PxiChild::OnOverlayData(wxCommandEvent &)
{
  canvas->MakeOverlayData();
  wxClientDC dc(this);
  canvas->Update(dc,PXI_UPDATE_SCREEN);
}

void PxiChild::OnOverlayFile(wxCommandEvent &)
{
  canvas->MakeOverlayFile();
  wxClientDC dc(this);
  canvas->Update(dc,PXI_UPDATE_SCREEN);
}

void PxiChild::OnOneDot(wxCommandEvent &)
{
}

void PxiChild::OnFileDetail(wxCommandEvent &)
{
  canvas->ShowDetail();
}

void PxiChild::OnFileOutput(wxCommandEvent &)
{
  wxOutputDialogBox dialog(0,this);
  if (dialog.ShowModal() == wxID_OK) 
    switch (dialog.GetMedia()) {
    case wxMEDIA_PRINTER: print(dialog.GetOption()); break;
    case wxMEDIA_PS:print_eps(dialog.GetOption()); break;
    case wxMEDIA_CLIPBOARD:print_mf(dialog.GetOption()); break;
    case wxMEDIA_METAFILE: print_mf(dialog.GetOption(), true); break;
    case wxMEDIA_PREVIEW: print(dialog.GetOption(), true); break;
    default:
      // We'll ignore this silently
      break;
    }
}

void PxiChild::OnHelpAbout(wxCommandEvent &)
{
  wxHelpAbout();
}

void PxiChild::OnDisplayOptions(wxCommandEvent &)
{
  canvas->DrawSettings()->SetOptions(this);
  wxClientDC dc(this);
  this->canvas->Update(dc,PXI_UPDATE_SCREEN);
}

PxiChild::PxiChild(wxFrame *p_parent, const wxString &p_filename) :
  wxFrame(p_parent, -1, p_filename, wxPoint(0,0),wxSize(480,480)), parent(p_parent)
{
  SetSizeHints(300, 300);

  // Give the frame an icon
#ifdef __WXMSW__
  SetIcon(wxIcon("pxi_icn"));
#else
#include "pxi.xpm"
  SetIcon(wxIcon(pxi_xpm));
#endif

  CreateStatusBar();
  MakeMenus();

  //  m_toolbar = new PxiChildToolbar(this, this);

  int width, height;
  GetClientSize(&width, &height);
    // save the canvas in subframe
  canvas = new PxiCanvas(this, wxPoint(0, 0), wxSize(width, height),wxRETAINED,p_filename);
  Show(true);
}

PxiChild::~PxiChild(void)
{ }

void PxiChild::MakeMenus(void)
{
  wxMenu *file_menu = new wxMenu;
  file_menu->Append(PXI_LOAD_FILE, "&Load file");
  file_menu->Append(PXI_CHILD_QUIT, "&Close");
  file_menu->Append(PXI_OUTPUT, "Output");
  file_menu->AppendSeparator();
  file_menu->Append(PXI_QUIT, "&Quit");
  wxMenu *data_menu= new wxMenu;
  data_menu->Append(PXI_DATA_GRID,"&GridSolver","Create a new file");
  data_menu->Append(PXI_DATA_OVERLAY_DATA, "&Overlay Data");
  data_menu->Append(PXI_DATA_OVERLAY_FILE, "&Overlay File");
  data_menu->Append(PXI_DATA_ONEDOT, "One&Dot");
  
  wxMenu *help_menu = new wxMenu;
  help_menu->Append(PXI_ABOUT,"&About PlotX");
  wxMenu *display_menu = new wxMenu;
  display_menu->Append(PXI_FILE_DETAIL,"File &Detail");
  display_menu->Append(PXI_DISPLAY_OPTIONS,"&Options...");
  wxMenuBar *menu_bar = new wxMenuBar;
  menu_bar->Append(file_menu, "&File");
  menu_bar->Append(data_menu, "&Data");
  menu_bar->Append(display_menu, "&Display");
  menu_bar->Append(help_menu, "&Help");

  // Associate the menu bar with the frame
  SetMenuBar(menu_bar);
}


#ifdef UNUSED
// Intercept menu commands
void PxiFrame::OnMenuCommand(int id)
{
  switch (id) {
  case PXI_QUIT:	{Close();break;}
  case PXI_LOAD_FILE: {MakeChild();break;}
  case PXI_DATA_ONEDOT: {MakeOneDot();break;}
  case PXI_DATA_GRID: {
    char *data_file_name=MakeDataFile();
    if (data_file_name)	MakeChild(data_file_name);
    break;
  }
  case PXI_ABOUT: {
    (void)wxMessageBox("PlotX: n-Dimensional Data Plotter\nAuthor: Eugene Grayver"
		       " egrayver@cco.caltech.edu\n(c) Caltech EPS, 1995,1996\n"
		       "To register send $25 to\nEugene Grayver\n12030 Rochester #214"
		       "\nLos Angeles, CA 90025", "About PlotX");break;}
  }
}
#endif //UNUSED

// Show details
void PxiCanvas::ShowDetail(void)
{
  FileHeader header=headers[1];
  wxString message;
  int		i1,i;
  sprintf(tempstr,"Detail for: %s\n",(const char *)FileNameFromPath(header.FileName()));
  message+=tempstr;
  sprintf(tempstr,"Error (lambda) step:  %4.4f\n",header.EStep());
  message+=tempstr;
  sprintf(tempstr,"Error (lambda) start: %4.4f\n",header.EStart());
  message+=tempstr;
  sprintf(tempstr,"Error (lambda) stop : %4.4f\n",header.EStop());
  message+=tempstr;
  sprintf(tempstr,"Minimum data value  : %4.4f\n",header.DataMin());
  message+=tempstr;
  sprintf(tempstr,"Maximum data value  : %4.4f\n",header.DataMax());
  message+=tempstr;
  sprintf(tempstr,"Data type:  %s\n",(header.DataType()==DATA_TYPE_ARITH) ? "Arithmetic" : "Logarithmic");
  message+=tempstr;
  message+="\n";
  if (header.MError()>-.99) {
    sprintf(tempstr,"Probability step :    %4.4f\n",header.QStep());
    message+=tempstr;
    sprintf(tempstr,"Margin of error:      %4.4f\n",header.MError());
    message+=tempstr;
  }
  if (header.Matrix()) {
    sprintf(tempstr,"Matrix dimensions:    %d x %d\n",header.Matrix()->DimX(),header.Matrix()->DimY());
    message+=tempstr;
    sprintf(tempstr,"_______MATRIX_______\n");
    for (i1=0;i1<header.Matrix()->DimY();i1++) {
      for (i=0;i<header.Matrix()->DimX();i++) {
	sprintf(tempstr,"%2.1lf,%2.1lf ",(*header.Matrix())(i1,i).row,(*header.Matrix())(i1,i).col);
	message+=tempstr;
      }
      message+='\n';
    }
  }
  wxMessageBox(message,"File Details",wxOK);
}

void PxiCanvas::StopIt(void)
{
  if (draw_settings->GetStopMax()==draw_settings->GetMaxL()) {
    //	if (updating) draw_settings->SetStopMax(cur_e);
  }
  else {
    //	if (!updating)
    {
      draw_settings->ResetSetStop();
      wxPaintEvent event;
      OnPaint(event);
    }
  }
}

#include "expdprm.h"
void PxiCanvas::MakeOverlayData(void)
{
  if (exp_data) {delete exp_data;exp_data=NULL;}
  dialogExpData dialog(headers[1].FileName(),(PxiFrame *)this->GetParent());
  if (dialog.ShowModal() == wxID_OK) {
    ExpDataParams P;
    dialog.GetParams(P);
    exp_data=new ExpData(P);
    dialog.LoadNow();
  }
}

void PxiCanvas::MakeOverlayFile(void)
{
  char *s=copystring(wxFileSelector("Load Overlay",NULL,NULL,NULL,"*.out"));
  if (s) {
    FileHeader temp_header(s);
    if ( (temp_header.NumStrategies()!=headers[1].NumStrategies()) ||
	 (temp_header.NumInfosets()!=headers[1].NumInfosets()) )
      wxMessageBox("These data files do not\nhave the same structure!");
    else
      headers.Append(temp_header);
  }
}

void PxiFrame::MakeOneDot(char *in_filename,char *out_filename)
{
  char *inname,*outname;
  if (!in_filename) {
    const char *s=wxFileSelector("Enter Input File", NULL, NULL, NULL, "*.out");
    if (s) inname=copystring(s); else return;
  }
  else inname=copystring(in_filename);
  if (!out_filename) {
    const char *s=wxFileSelector("Enter Output File", NULL, NULL, NULL, "*.out");
    if (s) outname=copystring(s); else return;
  }
  else outname=copystring(out_filename);
  OneDot one_dot;
  one_dot.Go(inname,outname);
  delete [] outname;
  delete [] inname;
}

void PxiCanvas::OnChar(wxKeyEvent &ev)
{
  switch(ev.KeyCode()) {
  case PXI_KEY_STOP:
    StopIt();
    break;
  default:
    wxScrolledWindow::OnChar(ev);
    break;
  }
}

#define TEXT_MARGIN	.05

void PxiCanvas::OnEvent(wxMouseEvent &ev)
{
  if (ev.ShiftDown() && ev.ButtonDown()) {  // use shift mouse click to add a label
    int w,h;
    GetClientSize(&w,&h);
    label_struct tmp_label;
    //    tmp_label.x=ev.x/w;tmp_label.y=ev.y/h;
    tmp_label.x=ev.GetX()/w;tmp_label.y=ev.GetY()/h;
    // Check if clicked on an already existing text
    int clicked_on=0;
    for (int i=1;i<=labels.Length();i++)
      if (labels[i].x+TEXT_MARGIN>tmp_label.x && labels[i].x-TEXT_MARGIN<tmp_label.x &&
	  labels[i].y+TEXT_MARGIN>tmp_label.y && labels[i].y-TEXT_MARGIN<tmp_label.y)
	clicked_on=i;
    const char * junk = (clicked_on) ? (const char *)labels[clicked_on].label : "";
    tmp_label.label=wxGetTextFromUser("Enter Label","Enter Label", (char *)junk);
    //					  (clicked_on) ? (char *)labels[clicked_on].label : "");
    if (!clicked_on)
      labels.Append(tmp_label);
    else {
      tmp_label.x=labels[clicked_on].x;
      tmp_label.y=labels[clicked_on].y;
      labels[clicked_on]=tmp_label;
    }
    wxPaintEvent event;
    OnPaint(event);
  }
}

BEGIN_EVENT_TABLE(PxiCanvas, wxScrolledWindow)
  EVT_PAINT(PxiCanvas::OnPaint)
END_EVENT_TABLE()

// Define a constructor for my canvas
PxiCanvas::PxiCanvas(wxFrame *frame, const wxPoint &p_position,
		     const wxSize &p_size, int style,const char *file_name):
  wxScrolledWindow(frame, -1, p_position, p_size, style),
  exp_data(NULL),draw_settings(NULL), probs(file_name), painting(false)
{
  headers.Append(FileHeader(file_name));
  draw_settings=new PxiDrawSettings(headers[1]);
  frame->SetTitle(headers[1].FileName());
  Show(true);
}

#ifdef wx_msw
void PxiChild::print(wxOutputOption fit, bool preview)
{
  wxPrinterDC dc(NULL, NULL, NULL);  // Defaults to EPS under UNIX,
  // normal Windows printing under Win 3.1
  if (dc.Ok()) {
    dc.StartDoc("PXI printout");
    dc.StartPage();
    this->canvas->Update(dc,PXI_UPDATE_PRINTER);
    dc.EndPage();
    dc.EndDoc();
  }
  this->canvas->Update(*(this->canvas->GetDC()),PXI_UPDATE_SCREEN);
}
#else
void PxiChild::print(wxOutputOption /*fit*/, bool preview)
{
  if (!preview)
    wxMessageBox("Printing not supported under X");
  else
    wxMessageBox("Print Preview is not supported under X");
}
#endif



void PxiChild::print_eps(wxOutputOption fit)
{
  wxPostScriptDC dc("junk.pxi",true, this);
  if (dc.Ok()) {
    dc.StartDoc("Pxi printout");
    dc.StartPage();
    this->canvas->Update(dc,PXI_UPDATE_FILE);
    dc.EndPage();
    dc.EndDoc();
  }
}

#ifdef wx_msw
void PxiChild::print_mf(wxOutputOption fit, bool save_mf)
{
  wxMetaFileDC dc;
  if (dc.Ok()) {
    this->canvas->Update(dc,PXI_UPDATE_METAFILE);
    wxMetaFile *mf = dc.Close();
    if (mf) {
      mf->SetClipboard((int)(dc.MaxX()+10),(int)(dc.MaxY()+10));
      delete mf;
    }
  }
  this->canvas->Update(*(this->canvas->GetDC()),PXI_UPDATE_SCREEN);
}
#else
void PxiChild::print_mf(wxOutputOption /*fit*/, bool /*save_mf*/)
{
  wxMessageBox("Metafiles are not supported under X");
}
#endif

#ifdef wx_msw
void PxiChild::save_mf(wxOutputOption fit, bool save_mf)
{
  char *s=copystring(wxFileSelector("Save Metafile",NULL,NULL,NULL,"*.wmf"));
  if (s) {
    wxMetaFileDC dc(s);
    if (dc.Ok()) {
      this->canvas->Update(dc,PXI_UPDATE_METAFILE);
      wxMetaFile *mf = dc.Close();
      if (mf) {
	delete mf;
	wxMakeMetaFilePlaceable(s,dc.MinX(),dc.MinY(),dc.MaxX(),dc.MaxY());
      }
    }
    delete [] s;
    this->canvas->Update(*(this->canvas->GetDC()),PXI_UPDATE_SCREEN);
  }
}
#else
void PxiChild::save_mf(wxOutputOption /*fit*/, bool /*save_mf*/)
{
  wxMessageBox("Metafiles are not supported under X");
}
#endif

#ifdef UNUSED
// Intercept menu commands
void PxiChild::OnMenuCommand(int id)
{
  switch (id) {
  case PXI_PRINT_EPS:         // To use the special wxWindows EPS driver
    // under Windows 3.1, specify "PostScript"
    {
      wxPostScriptDC dc(NULL,TRUE);
      if (dc.Ok()) {
	dc.StartDoc("Pxi printout");
	dc.StartPage();
	this->canvas->Update(dc,PXI_UPDATE_FILE);
	dc.EndPage();
	dc.EndDoc();
      }
      break;
    }
#ifdef wx_msw
  case PXI_PRINT: {
    wxPrinterDC dc(NULL, NULL, NULL);  // Defaults to EPS under UNIX,
    // normal Windows printing under Win 3.1
    if (dc.Ok()) {
      dc.StartDoc("PXI printout");
      dc.StartPage();
      this->canvas->Update(dc,PXI_UPDATE_PRINTER);
      dc.EndPage();
      dc.EndDoc();
    }
    this->canvas->Update(*(this->canvas->GetDC()),PXI_UPDATE_SCREEN);
    break;
  }
  case PXI_COPY_MF: {
    wxMetaFileDC dc;
    if (dc.Ok()) {
      this->canvas->Update(dc,PXI_UPDATE_METAFILE);
      wxMetaFile *mf = dc.Close();
      if (mf) {
	mf->SetClipboard((int)(dc.MaxX()+10),(int)(dc.MaxY()+10));
	delete mf;
      }
    }
    this->canvas->Update(*(this->canvas->GetDC()),PXI_UPDATE_SCREEN);
    break;
  }
  case PXI_SAVE_MF: {
    char *s=copystring(wxFileSelector("Save Metafile",NULL,NULL,NULL,"*.wmf"));
    if (s) {
      wxMetaFileDC dc(s);
      if (dc.Ok()) {
	this->canvas->Update(dc,PXI_UPDATE_METAFILE);
        wxMetaFile *mf = dc.Close();
        if (mf) {
	  delete mf;
	  wxMakeMetaFilePlaceable(s,dc.MinX(),dc.MinY(),dc.MaxX(),dc.MaxY());
        }
      }
      delete [] s;
      this->canvas->Update(*(this->canvas->GetDC()),PXI_UPDATE_SCREEN);
      break;
    }
  }
#endif
  case PXI_CHILD_QUIT:	Close(); break;
  case PXI_FILE_DETAIL:		canvas->ShowDetail();	break;
  case PXI_DISPLAY_OPTIONS:
    canvas->DrawSettings()->SetOptions(this);
    this->canvas->Update(*(this->canvas->GetDC()),PXI_UPDATE_SCREEN);
    break;
  case PXI_DATA_OVERLAY_DATA:
    this->canvas->MakeOverlayData();
    this->canvas->Update(*(this->canvas->GetDC()),PXI_UPDATE_SCREEN);
    break;
  case PXI_DATA_OVERLAY_FILE:
    this->canvas->MakeOverlayFile();
    this->canvas->Update(*(this->canvas->GetDC()),PXI_UPDATE_SCREEN);
    break;
  default:
    frame->OnMenuCommand(id);
    break;
  }
}
#endif // UNUSED


#ifdef NOT_IMPLEMENTED
void solver_update_func1(int total=-1,wxProgressIndicator1 *_p=NULL)
{
  static wxProgressIndicator1 *p;
  if (total!=-1) {	// initialization
    p=_p;
    p->SetMax(total);
  }
  else
    p->Update();
}

// solver update func--a function to periodically relinquish the control of the CPU
void solver_update_func(void)
{wxYield();solver_update_func1();}
#endif // NOT_IMPLEMENTED

// bench mark function--tests how long it takes this cpu to calculate one equ
double bench_mark(void)
{
  double a=3.34343;
  wxStartTimer();
  // do 10000 tests for equ;
  for (int i=0;i<10000;i++) {a=exp(a)*exp(a/a)*exp(a*a)*exp(a+1);a=3.34343;}
  return (((double)wxGetElapsedTime())/10000.0);
}

// calc num steps.  this calculates the number of combinations possible with
// 'num' integers, 0..'max', such that their sum is <='max'  See any math book
// for explanation of this formula:
// total_num=( n+k-1 )
//           (  k-1  )
// (num+max-1)!/(max!(num-1)!)
unsigned long factorial(unsigned long num)
{
  unsigned long temp=1;
  for (unsigned long i=num;i>0;i--) temp*=i;
  return temp;
}

unsigned long calc_num_steps(int dim,int steps)
{
  unsigned long temp,temp1=1;
  for (temp=steps+dim-1;temp>steps;temp--) temp1*=temp;
  return (temp1/factorial(dim-1));
}

#ifdef UNUSED
char *PxiFrame::MakeDataFile(void)
{
  char *out_file_name=NULL;
  // Create the settings dialog, get the settings
  NormalCalcSettings *settings=new NormalCalcSettings;
  // Create the normal form game calculator, and solve the game
  if (settings->Completed()==wxOK) {
    if (settings->GotMatrix()) {
      NormalEquSolver *solver=new NormalEquSolver(settings->GetMatrix(),
						  settings->GetLStart(),settings->GetLStop(),settings->GetLStep(),
						  settings->GetPStep(),settings->GetMError(),settings->GetDataType(),
						  settings->GetFileName());
      solver->SetUpdateFunc(solver_update_func);
      
      double bench=bench_mark();
      bench=0.00015;
      double l_steps;
      double num_steps;
      num_steps=(double)calc_num_steps(settings->GetMatrix()->Dim(),(int)(1.0/settings->GetPStep()+0.03));
      if (settings->GetDataType()==DATA_TYPE_ARITH)
	l_steps=(settings->GetLStop()-settings->GetLStart())/settings->GetLStep();
      else
	l_steps=log(settings->GetLStop()/settings->GetLStart())/log(settings->GetLStep());
      long total_time=(long)(bench*(double)settings->GetMatrix()->Dim()*l_steps*num_steps);
      long secs=total_time;
      sprintf(tempstr,"This will take approximately %02ld:%02ld",secs/60,secs%60);
      int go=wxMessageBox(tempstr,"Time projection",wxOK|wxCANCEL|wxCENTRE);
      if (go==wxOK) {
	wxProgressIndicator1 *progress=new wxProgressIndicator1();
	solver_update_func1((int)(l_steps+0.03),progress);
	solver->Go();
	delete progress;
	// Get the output file name and clean up
	out_file_name=copystring(solver->GetOutFileName());
	if (settings->OneDot())	MakeOneDot(out_file_name,out_file_name);
      }
      delete solver;
    }
    else {
      wxMessageBox("No game defined or entered","Error",wxOK | wxCENTRE);
    }
  }
  delete settings;
  return (out_file_name);
}
#endif // UNUSED

void PxiFrame::OnCloseWindow(wxCloseEvent &)
{
  wxKillHelp();
  Destroy();
}

// Define the repainting behaviour
void PxiCanvas::OnPaint(wxPaintEvent &)
{
  if (painting) 
    return; // prevent re-entry
  painting = true;
  wxPaintDC dc(this);
  Update(dc,PXI_UPDATE_SCREEN);
  painting = false;
}

// Define the behaviour for the frame closing
// - must delete all frames except for the main one.

//*************************************************************************
//************************* DRAW SETTINGS *********************************
//*************************************************************************
PxiDrawSettings::PxiDrawSettings(FileHeader &header)
{
  int i,j;
  overlay_font=new wxFont(8,wxSWISS,wxNORMAL,wxBOLD);
  overlay_symbol=OVERLAY_NUMBER;
  overlay_lines=FALSE;
  overlay_token_size=DEF_TOKEN_SIZE;
  color_mode=COLOR_EQU;
  restart_overlay_colors=TRUE;
  label_font=new wxFont(10,wxSWISS,wxNORMAL,wxNORMAL);
  connect_dots=FALSE;
  data_mode=header.DataType();
  plot_mode=PXI_PLOT_X;
  l_start=header.EStart();l_stop=header.EStop();l_step=header.EStep();
  stop_min=l_start;stop_max=l_stop;
  data_min=header.DataMin();data_max=header.DataMax();
  
  num_infosets=header.NumInfosets();
  one_or_two=(header.NumInfosets()>1) ? 2 : 1;
  // Create the 'what to display where' data structures
  // Default is to show first 1/2 of the infosets with all their strategies
  // on the top portion of the graph (in two graph mode) and the rest on the
  // bottom.  In one graph mode, the default is to show just the first 1/2 of
  // the infosets with all their strategies.
  strategy_show=gBlock<show_player_strategies>(num_infosets);
  for (i=1;i<=num_infosets;i++) {
    strategy_show[i]=show_player_strategies(header.NumStrategies(i));
    for (j=1;j<=header.NumStrategies(i);j++) strategy_show[i][j]=TRUE;
  }
  plot_top=gBlock<int>(num_infosets/2);
  for (i=1;i<=num_infosets/2;i++) plot_top[i]=i;
  plot_bottom=gBlock<int>(num_infosets-num_infosets/2);
  for (i=1+num_infosets/2;i<=num_infosets;i++) plot_bottom[i-num_infosets/2]=i;
  // Default features are everything on
  plot3_features=DRAW_AXIS|DRAW_LABELS;
  plotx_features=DRAW_AXIS|DRAW_TICKS|DRAW_NUMS;
  plot2_features=DRAW_AXIS|DRAW_TICKS|DRAW_NUMS|DRAW_SQUARE;
}

// Plot3 mode is now more flexible: it works great (by default) on 2d player
// games, each player having 3 strategies.  It has now been extended to work
// with N player games with 3+ strategies each
// In this case, the two desired strategies are selected in the dialog, and
// the third is calculated from 1-(first+second).  You can also plot more than
// one infoset per triangle now.

Bool PxiDrawSettings::CheckPlot3Mode(void)
{
  int i;
  // Check if there are 3 or over strategy_show for each player
  int top, bottom;
  for (top=1;top<=GetPlotTop();top++)
    if (strategy_show[GetPlotTop(top)].Length()<3) {
      wxMessageBox("Each player must have at least 3 strategies!");
      return FALSE;
    }
  for (bottom=1;bottom<=GetPlotBottom();bottom++)
    if (strategy_show[GetPlotBottom(bottom)].Length()<3) {
      wxMessageBox("Each player must have at least 3 strategies!");
      return FALSE;
    }
  
  // Check if only two strategies have been selected for each player (add all of them up)
  int num_strategies=0;
  for (top=1;top<=GetPlotTop();top++)
    for (i=1;i<=strategy_show[GetPlotTop(top)].Length();i++)
      num_strategies+=(GetStrategyShow(GetPlotTop(top),i)) ? 1 : 0;
  for (bottom=1;bottom<=GetPlotBottom();bottom++)
    for (i=1;i<=strategy_show[GetPlotBottom(bottom)].Length();i++)
      num_strategies+=(GetStrategyShow(GetPlotBottom(bottom),i)) ? 1 : 0;
  if (num_strategies>2*(GetPlotTop()+GetPlotBottom())) {
    wxMessageBox("Only two strategies per player allowed!");
    return FALSE;
  }
  return TRUE;
}

// Check Plot_2 Mode:  Plot 2 mode plots a player's strategy against another
// strategy (the same or different player's).  Only one pair of strategies
// can be plotted at any one time.  Thus, only two of the checkboxes in the
// strategy selection section can be turned on.

Bool PxiDrawSettings::CheckPlot2Mode(void)
{
  int i,j,num_strategies=0;
  for (j=1;j<=strategy_show.Length();j++)
    for (i=1;i<=strategy_show[j].Length();i++)
      num_strategies+=(GetStrategyShow(j,i)) ? 1 : 0;
  if (num_strategies>2) {
    wxMessageBox("Only TWO strategies TOTAL can be checked\nin the strategy selection dialog");
    return FALSE;
  }
  return TRUE;
}

#define DELTA			1e-9

void PxiDrawSettings::SetOptions(wxWindow *parent)
{
  dialogDrawSettings dialog(parent, *this);
  if(dialog.ShowModal() == wxID_OK){ 
    stop_min = strtod(dialog.GetMinLam(),NULL);
    stop_max = strtod(dialog.GetMaxLam(),NULL);
    data_min = strtod(dialog.GetMinY(),NULL);
    data_max = strtod(dialog.GetMaxY(),NULL);

    int mode = dialog.GetPlotMode();
    if(mode==0)plot_mode=PXI_PLOT_X;
    if(mode==1)plot_mode=PXI_PLOT_2;
    if(mode==2)plot_mode=PXI_PLOT_3;

    mode = dialog.GetColorMode();
    if(mode==0)color_mode=COLOR_EQU;
    if(mode==1)color_mode=COLOR_PROB;
    if(mode==2)color_mode=COLOR_NONE;

    one_or_two=1;
    if(dialog.GetTwoPlots()) one_or_two = 2;
    connect_dots = dialog.GetConnectDots();
    restart_overlay_colors = dialog.GetRestartColors();
  };
}

void PxiDrawSettings::overlay_func(wxButton &ob,wxEvent &)
{
#ifdef NOT_IMPLEMENTED
  PxiDrawSettings	*draw_settings=(PxiDrawSettings *)ob.GetClientData();
  MyDialogBox *overlay_dialog=new MyDialogBox(NULL,"Overlay Options");
  wxStringList *overlay_token_list=new wxStringList;
  overlay_token_list->Add("Numbers");overlay_token_list->Add("Tokens");
  char *overlay_token_str=new char[20];
  if (draw_settings->GetOverlaySym()==OVERLAY_NUMBER)
    strcpy(overlay_token_str,"Numbers"); else strcpy(overlay_token_str,"Tokens");
  overlay_dialog->Form()->Add(wxMakeFormString("Overlay Token",&overlay_token_str,wxFORM_RADIOBOX,
					       new wxList(wxMakeConstraintStrings(overlay_token_list), 0),NULL,wxVERTICAL));
  overlay_dialog->Form()->Add(wxMakeFormNewLine());
  Bool	overlay_connect=draw_settings->GetOverlayLines();
  overlay_dialog->Form()->Add(wxMakeFormBool("Connect points",&overlay_connect));
  overlay_dialog->Form()->Add(wxMakeFormNewLine());
  wxFormItem	*overlay_font_button=wxMakeFormButton("Overlay Font",(wxFunction)PxiDrawSettings::overlay_font_func);
  overlay_dialog->Form()->Add(overlay_font_button);
  overlay_dialog->Form()->Add(wxMakeFormNewLine());
  int token_size=draw_settings->GetTokenSize();
  overlay_dialog->Form()->Add(wxMakeFormShort("Token Size",&token_size,wxFORM_SLIDER,
					      new wxList(wxMakeConstraintRange(MIN_TOKEN_SIZE,MAX_TOKEN_SIZE), 0)));
  
  overlay_dialog->Form()->AssociatePanel(overlay_dialog);
  ((wxButton *)overlay_font_button->GetPanelItem())->SetClientData((char *)draw_settings);
  overlay_dialog->Go1();
  if (overlay_dialog->Completed()==wxOK) {
    draw_settings->SetOverlayLines(overlay_connect);
    int overlay_token=wxListFindString(overlay_token_list,overlay_token_str);
    if (overlay_token==0)
      draw_settings->SetOverlaySym(OVERLAY_NUMBER);
    else {
      draw_settings->SetOverlaySym(OVERLAY_TOKEN);
      draw_settings->SetTokenSize(token_size);
    }
    
  }
  delete overlay_dialog;
#endif // NOT_IMPLEMENTED
}
void PxiDrawSettings::plot_features_func(wxButton &ob,wxEvent &)
{((PxiDrawSettings *)ob.GetClientData())->AskPlotFeatures();}


void PxiDrawSettings::AskPlotFeatures(void)
{
#ifdef NOT_IMPLEMENTED
  MyDialogBox *plot_feat_dialog;
  unsigned int feat=PlotFeatures();
  switch (plot_mode) {
  case	PXI_PLOT_3: {
    plot_feat_dialog=new MyDialogBox(0,"Plot3 Options");
    Bool draw_axis=(feat&DRAW_AXIS) ? TRUE : FALSE;
    plot_feat_dialog->Form()->Add(wxMakeFormBool("Draw Axis",&draw_axis));
    Bool draw_labels=(feat&DRAW_LABELS) ? TRUE : FALSE;
    plot_feat_dialog->Form()->Add(wxMakeFormBool("Draw Labels",&draw_labels));
    plot_feat_dialog->Go();
    if (plot_feat_dialog->Completed()==wxOK) {
      feat=0;
      if (draw_axis) feat|=DRAW_AXIS;
      if (draw_labels) feat|=DRAW_LABELS;
    }
    break;
  }
  case	PXI_PLOT_X: {
    plot_feat_dialog=new MyDialogBox(0,"PlotX Options");
    Bool draw_axis=(feat&DRAW_AXIS) ? TRUE : FALSE;
    plot_feat_dialog->Form()->Add(wxMakeFormBool("Draw Axis",&draw_axis));
    Bool draw_ticks=(feat&DRAW_TICKS) ? TRUE : FALSE;
    plot_feat_dialog->Form()->Add(wxMakeFormBool("Draw Ticks",&draw_ticks));
    plot_feat_dialog->Form()->Add(wxMakeFormNewLine());
    Bool draw_nums=(feat&DRAW_NUMS) ? TRUE : FALSE;
    plot_feat_dialog->Form()->Add(wxMakeFormBool("Draw Nums",&draw_nums));
    plot_feat_dialog->Go();
    if (plot_feat_dialog->Completed()==wxOK) {
      feat=0;
      if (draw_axis) feat|=DRAW_AXIS;
      if (draw_ticks) feat|=DRAW_TICKS;
      if (draw_nums) feat|=DRAW_NUMS;
    }
    break;
  }
  case	PXI_PLOT_2: {
    plot_feat_dialog=new MyDialogBox(0,"Plot2 Options");
    Bool draw_axis=(feat&DRAW_AXIS) ? TRUE : FALSE;
    plot_feat_dialog->Form()->Add(wxMakeFormBool("Draw Axis",&draw_axis));
    Bool draw_ticks=(feat&DRAW_TICKS) ? TRUE : FALSE;
    plot_feat_dialog->Form()->Add(wxMakeFormBool("Draw Ticks",&draw_ticks));
    plot_feat_dialog->Form()->Add(wxMakeFormNewLine());
    Bool draw_nums=(feat&DRAW_NUMS) ? TRUE : FALSE;
    plot_feat_dialog->Form()->Add(wxMakeFormBool("Draw Nums",&draw_nums));
    Bool draw_square=(feat&DRAW_SQUARE) ? TRUE : FALSE;
    plot_feat_dialog->Form()->Add(wxMakeFormBool("Square Axis",&draw_square));
    plot_feat_dialog->Go();
    if (plot_feat_dialog->Completed()==wxOK) {
      feat=0;
      if (draw_axis) feat|=DRAW_AXIS;
      if (draw_ticks) feat|=DRAW_TICKS;
      if (draw_nums) feat|=DRAW_NUMS;
      if (draw_square) feat|=DRAW_SQUARE;
    }
    break;
  }
  }
  SetPlotFeatures(feat);
  delete plot_feat_dialog;
#endif // NOT_IMPLEMENTED
}

unsigned int PxiDrawSettings::PlotFeatures(void)
{
  switch (plot_mode) {
  case	PXI_PLOT_3: return plot3_features;
  case	PXI_PLOT_X: return plotx_features;
  case	PXI_PLOT_2: return plot2_features;
  }
}

void PxiDrawSettings::label_font_func(wxButton &ob,wxEvent &)
{
#ifdef NOT_IMPLEMENTED
  PxiDrawSettings	*draw_settings=(PxiDrawSettings *)ob.GetClientData();
  FontDialogBox *f=new FontDialogBox(NULL,draw_settings->GetLabelFont());
  if (f->Completed()==wxOK)
    draw_settings->SetLabelFont(f->MakeFont());
  delete f;
#endif // NOT_IMPLEMENTED
}

void PxiDrawSettings::overlay_font_func(wxButton &ob,wxEvent &)
{
#ifdef NOT_IMPLEMENTED
  PxiDrawSettings	*draw_settings=(PxiDrawSettings *)ob.GetClientData();
  FontDialogBox *f=new FontDialogBox(NULL,draw_settings->GetOverlayFont());
  if (f->Completed()==wxOK)
    draw_settings->SetOverlayFont(f->MakeFont());
  delete f;
#endif // NOT_IMPLEMENTED
}
//
// A general-purpose dialog box to display the description of the exception
//

void pxiExceptionDialog(const wxString &p_message, wxWindow *p_parent,
            long p_style /*= wxOK | wxCENTRE*/)
{
  wxString message = "An internal error occurred in PXI:\n" + p_message;
  wxMessageBox(message, "PXI Error", p_style, p_parent);
}

const int idSETTINGS_WHICH_PLOT_LISTBOX = 2018;
const int idSETTINGS_WHICH_INFOSET_LISTBOX = 2019;
const int idSETTINGS_INFOSET_LISTBOX = 2020;
const int idSETTINGS_ACTION_LISTBOX = 2021;
const int idSETTINGS_OVERLAY_BUTTON = 2022;
const int idSETTINGS_FONT_BUTTON = 2023;
const int idSETTINGS_PLOT_BUTTON = 2024;

BEGIN_EVENT_TABLE(dialogDrawSettings, guiAutoDialog)
  EVT_LISTBOX(idSETTINGS_WHICH_PLOT_LISTBOX, dialogDrawSettings::OnWhichPlot)
  EVT_LISTBOX(idSETTINGS_WHICH_INFOSET_LISTBOX, dialogDrawSettings::OnWhichInfoset)
  EVT_LISTBOX(idSETTINGS_INFOSET_LISTBOX, dialogDrawSettings::OnInfoset)
  EVT_LISTBOX(idSETTINGS_ACTION_LISTBOX, dialogDrawSettings::OnAction)
  EVT_BUTTON(idSETTINGS_OVERLAY_BUTTON, dialogDrawSettings::OnOverlay)
  EVT_BUTTON(idSETTINGS_FONT_BUTTON, dialogDrawSettings::OnFont)
  EVT_BUTTON(idSETTINGS_PLOT_BUTTON, dialogDrawSettings::OnPlot)
END_EVENT_TABLE()

dialogDrawSettings::dialogDrawSettings(wxWindow *p_parent, PxiDrawSettings &s)
  : guiAutoDialog(p_parent, "Draw Settings"), 
    draw_settings(s)
{
  int num_plots = 1;
  if(draw_settings.one_or_two==2) num_plots = 2;
  
  m_whichPlotItem = new wxListBox(this, idSETTINGS_WHICH_PLOT_LISTBOX);
  for (int i = 1; i <= num_plots; i++) {
    char tmp[80];
    sprintf(tmp, "Plot %d", i);
    m_whichPlotItem->Append(tmp);
  }
  m_whichPlotItem->SetSelection(0);
  
  m_whichIsetItem = new wxListBox(this, idSETTINGS_WHICH_INFOSET_LISTBOX, 
				  wxDefaultPosition, wxDefaultSize,0,0,
#ifdef __WXGTK__  // the wxGTK multiple-selection listbox is flaky (2.1.11)
				  wxLB_EXTENDED
#else
				  wxLB_MULTIPLE
#endif // __WXGTK__
				  );
  wxCommandEvent event;
  OnWhichPlot(event);
  
  m_infosetItem = new wxListBox(this, idSETTINGS_INFOSET_LISTBOX);
  for (int iset = 1; iset <= draw_settings.num_infosets; iset++) {
    char tmp[80];
    sprintf(tmp, "Infoset %d", iset);
    m_infosetItem->Append(tmp);
  }
  m_infosetItem->SetSelection(0);
  
  m_actionItem = new wxListBox(this, idSETTINGS_ACTION_LISTBOX, 
			       wxDefaultPosition, wxDefaultSize,0,0,
#ifdef __WXGTK__  // the wxGTK multiple-selection listbox is flaky (2.1.11)
			       wxLB_EXTENDED
#else
                               wxLB_MULTIPLE
#endif // __WXGTK__
			       );
  OnInfoset(event);
  
  char tmp[80];
  sprintf(tmp, "%f", draw_settings.stop_min);
  m_minLam = new wxNumberItem(this, "minLam", tmp);
  sprintf(tmp, "%f", draw_settings.stop_max);
  m_maxLam = new wxNumberItem(this, "maxLam", tmp);
  sprintf(tmp, "%f", draw_settings.data_min);
  m_minY = new wxNumberItem(this, "minLam", tmp);
  sprintf(tmp, "%f", draw_settings.data_max);
  m_maxY = new wxNumberItem(this, "maxLam", tmp);
  
  wxBoxSizer *lambdaSizer = new wxBoxSizer(wxHORIZONTAL);
  lambdaSizer->Add(new wxStaticText(this, -1, "X Min"),
		   0, wxALL | wxCENTER, 5);
  lambdaSizer->Add(m_minLam, 0, wxALL, 5);
  lambdaSizer->Add(new wxStaticText(this, -1, "X Max"),
		   0, wxALL | wxCENTER, 5);
  lambdaSizer->Add(m_maxLam, 0, wxALL, 5);
  
  wxBoxSizer *dataSizer = new wxBoxSizer(wxHORIZONTAL);
  dataSizer->Add(new wxStaticText(this, -1, "Y Min"),
		   0, wxALL | wxCENTER, 5);
  dataSizer->Add(m_minY, 0, wxALL, 5);
  dataSizer->Add(new wxStaticText(this, -1, "Y Max"),
		   0, wxALL | wxCENTER, 5);
  dataSizer->Add(m_maxY, 0, wxALL, 5);
  
  wxBoxSizer *plotSizer = new wxBoxSizer(wxHORIZONTAL);
  plotSizer->Add(m_whichPlotItem, 0, wxCENTRE | wxALL, 5);
  plotSizer->Add(m_whichIsetItem, 0, wxCENTRE | wxALL, 5);
  
  wxBoxSizer *selectSizer = new wxBoxSizer(wxHORIZONTAL);
  selectSizer->Add(m_infosetItem, 0, wxCENTRE | wxALL, 5);
  selectSizer->Add(m_actionItem, 0, wxCENTRE | wxALL, 5);
  
  wxString plotModeChoices[] = { "Plot X", "Plot 2", "Plot 3" };
  m_plotMode = new wxRadioBox(this, -1, "Plot Mode",
			      wxDefaultPosition, wxDefaultSize,
			      3, plotModeChoices, 0, wxRA_SPECIFY_ROWS);
  
  if (draw_settings.plot_mode == PXI_PLOT_X) 
    m_plotMode->SetSelection(0);
  else if (draw_settings.plot_mode == PXI_PLOT_2) 
    m_plotMode->SetSelection(1);
  else if (draw_settings.plot_mode == PXI_PLOT_3) 
    m_plotMode->SetSelection(2);
  
  wxString colorModeChoices[] = { "Equ", "Prob", "None" };
  m_colorMode = new wxRadioBox(this, -1, "Color Mode",
			       wxDefaultPosition, wxDefaultSize,
			       3, colorModeChoices, 0, wxRA_SPECIFY_ROWS);
  
  if (draw_settings.color_mode == PXI_PLOT_X) 
    m_colorMode->SetSelection(0);
  else if (draw_settings.color_mode == PXI_PLOT_2) 
    m_colorMode->SetSelection(1);
  else if (draw_settings.color_mode == PXI_PLOT_3) 
    m_colorMode->SetSelection(2);
  
  wxBoxSizer *modeSizer = new wxBoxSizer(wxHORIZONTAL);
  modeSizer->Add(m_plotMode, 0, wxALL, 5);
  modeSizer->Add(m_colorMode, 0, wxALL, 5);
  
  m_overlayButton = new wxButton(this, idSETTINGS_OVERLAY_BUTTON, "Overlay");
  m_fontButton = new wxButton(this, idSETTINGS_FONT_BUTTON, "Font");
  m_plotButton = new wxButton(this, idSETTINGS_PLOT_BUTTON, "Plot");
  
  m_twoPlots = new wxCheckBox(this, -1, "Two Plots");
  if(draw_settings.one_or_two==2)
    m_twoPlots->SetValue(true);
  else
    m_twoPlots->SetValue(false);

  m_connectDots = new wxCheckBox(this, -1, "Connect Dots");
  m_connectDots->SetValue(draw_settings.ConnectDots());

  m_restartColors = new wxCheckBox(this, -1, "Restart Colors");
  m_restartColors->SetValue(draw_settings.restart_overlay_colors);

  wxBoxSizer *miscSizer = new wxBoxSizer(wxHORIZONTAL);
  miscSizer->Add(m_twoPlots, 0, wxALL, 5);
  miscSizer->Add(m_connectDots, 0, wxALL, 5);
  miscSizer->Add(m_restartColors, 0, wxALL, 5);

  wxBoxSizer *botSizer = new wxBoxSizer(wxHORIZONTAL);
  botSizer->Add(m_overlayButton, 0, wxALL, 5);
  botSizer->Add(m_fontButton, 0, wxALL, 5);
  botSizer->Add(m_plotButton, 0, wxALL, 5);

  wxBoxSizer *allSizer = new wxBoxSizer(wxVERTICAL);
  allSizer->Add(new wxStaticText(this, -1, "Display Range:"), 0, wxCENTRE | wxALL, 5);
  allSizer->Add(lambdaSizer, 0, wxCENTRE | wxALL, 5);
  allSizer->Add(dataSizer, 0, wxCENTRE | wxALL, 5);
  allSizer->Add(plotSizer, 0, wxCENTRE | wxALL, 5);
  allSizer->Add(selectSizer, 0, wxCENTRE | wxALL, 5);
  allSizer->Add(modeSizer, 0, wxCENTRE | wxALL, 5);
  allSizer->Add(miscSizer, 0, wxCENTRE | wxALL, 5);
  allSizer->Add(botSizer, 0, wxCENTRE | wxALL, 5);
  allSizer->Add(m_buttonSizer, 0, wxCENTRE | wxALL, 5);
  
  SetSizer(allSizer); 
  allSizer->Fit(this);
  allSizer->SetSizeHints(this); 
  Layout();
}

dialogDrawSettings::~dialogDrawSettings()
{ }

void dialogDrawSettings::OnWhichPlot(wxCommandEvent &)
{
  int i = m_whichPlotItem->GetSelection()+1; 

  m_whichIsetItem->Clear();
  for (int iset = 1; iset <= draw_settings.num_infosets; iset++) {
    char tmp[80];
    sprintf(tmp, "Infoset %d", iset);
    m_whichIsetItem->Append(tmp);
  }
  if(i==1)
    for (int iset = 1; iset <= draw_settings.num_infosets; iset++) {
      if (draw_settings.plot_top.Contains(iset)) 
	m_whichIsetItem->SetSelection(iset-1, true);
    }
  else
    for (int iset = 1; iset <= draw_settings.num_infosets; iset++) {
      if (draw_settings.plot_bottom.Contains(iset)) 
	m_whichIsetItem->SetSelection(iset-1, true);
    }
}

void dialogDrawSettings::OnWhichInfoset(wxCommandEvent &)
{
  int i = m_whichPlotItem->GetSelection()+1; 

  if(i==1)
    for (int iset = 1; iset <= draw_settings.num_infosets; iset++) {
      bool flag = m_whichIsetItem->Selected(iset-1);
      bool member = draw_settings.plot_top.Contains(iset);
      if (flag && !member) 
	draw_settings.plot_top.Append(iset);
      else if (!flag && member) 
	draw_settings.plot_top.Remove(draw_settings.plot_top.Find(iset));
    }
  else 
    for (int iset = 1; iset <= draw_settings.num_infosets; iset++) {
      bool flag = m_whichIsetItem->Selected(iset-1);
      bool member = draw_settings.plot_bottom.Contains(iset);
      if (flag && !member) 
	draw_settings.plot_bottom.Append(iset);
      else if(!flag && member)
	draw_settings.plot_bottom.Remove(draw_settings.plot_bottom.Find(iset));
    }
}

void dialogDrawSettings::OnInfoset(wxCommandEvent &)
{
  int iset = m_infosetItem->GetSelection()+1; 

  m_actionItem->Clear();
  for (int act = 1; act <= draw_settings.strategy_show[iset].Length(); act++) {
    char tmp[80];
    sprintf(tmp, "Action %d", act);
    m_actionItem->Append(tmp);
  }
  for (int act = 1; act <= draw_settings.strategy_show[iset].Length(); act++) {
    if(draw_settings.strategy_show[iset][act])
      m_actionItem->SetSelection(act - 1, true);
  }
  m_actionItem->Enable(true);
}

void dialogDrawSettings::OnAction(wxCommandEvent &)
{ 
  int iset = m_infosetItem->GetSelection()+1; 

  for (int act = 1; act <= draw_settings.strategy_show[iset].Length(); act++) 
    draw_settings.strategy_show[iset][act] = m_actionItem->Selected(act-1);
  
}

void dialogDrawSettings::OnOverlay(wxCommandEvent &)
{
  //  draw_settings.overlay_func();
}

void dialogDrawSettings::OnFont(wxCommandEvent &)
{ 
  //  draw_settings.label_font_func();
}

void dialogDrawSettings::OnPlot(wxCommandEvent &)
{ 
  //  draw_settings.plot_features_func();
}

