%
% FILE: gclman.tex -- source for GCL manual
%
% $Id$
%
\documentstyle[widetext,chicagob]{article}
\renewcommand{\baselinestretch}{.9}
\newcommand{\bd}{\begin{description}}
\newcommand{\ed}{\end{description}}
\begin{document}

\title{GAMBIT COMMAND LANGUAGE\thanks{This is part of the Gambit
Project, which was funded in part by National Science Foundation
grants SBR-9308637 to the California Institute of Technology and
SBR-9308862 to the University of Minnesota.  We are grateful to Rob
Weber for help in compiling this manual and testing parts of the
language.}}

\author{Richard D. McKelvey\\California Institute of
Technology
\and
Andrew McLennan\\University of
Minnesota
\and 
Theodore Turocy\\California Institute of Technology
}

\date{\today\\ \jobname.tex}

\maketitle

\tableofcontents

\section{Introduction}

This document describes the GAMBIT Command Language (GCL).  GAMBIT is
a computer program that allows one to build, manipulate, and solve
finite extensive and normal form games. The GCL provides a method of
directing the operation of GAMBIT that is analagous to that of a high
level general purpose programming language.

The general purpose of the GCL is to provide a simple, but powerful
and flexible language by which one can perform complicated or
repetitive operations and procedures on games in extensive or normal
form.  The language has facilities for building and editing an
extensive or normal form game, converting back and forth between the
extensive and normal form representations, and then solving the
resulting game for various equilibria of interest. Flow
control statements allow for repetitive operations (such as
investigating games as one changes various parameters) or conditional
operations.

\section{Installation}

\section{Basic concepts}

The design motifs for GCL come from two principal families of programming
languages.  The first is traditional imperative programming languages
such as Pascal, C, and Modula-3.  In particular, the GCL's concept of
types draws heavily from these languages, although the number of
predefined types in GCL is much larger due to the specialized nature of
the language.  The second is more specialized programming languages such
as Mathematica.  


\subsection{Types}

The built-in data types for the GCL are the following:  

\medskip

\begin{tabular} {|l||l|} \hline
Type name	& Description \\ \hline
{\tt BOOL} 	& boolean \\
{\tt INTEGER} 	& integer \\ 
{\tt FLOAT} 	& floating-point number \\
{\tt RATIONAL} 	& rational number with arbitrary precision \\
{\tt TEXT}	& string of arbitrary length \\
{\tt OUTPUT}	& output stream \\ \hline
{\tt EFG}	& extensive form game \\
{\tt EFPLAYER}	& a player in an extensive form game \\
{\tt NODE}	& a node in an extensive form game \\ 
{\tt INFOSET}	& an information set in an extensive form game \\
{\tt ACTION}	& an action at an information set \\
{\tt OUTCOME}	& an outcome in an extensive form game \\
{\tt BEHAV}	& a behavioral strategy profile for an extensive form game \\ \hline
{\tt NFG}	& normal form game \\
{\tt NFPLAYER}	& a player in a normal form game \\
{\tt STRATEGY}	& a strategy in a normal form game \\
{\tt NFSUPPORT}	& a support of strategies in a normal form game \\
{\tt MIXED}	& a mixed strategy profile for a normal form game \\ \hline
\end{tabular}

\medskip

The remainder of this section details the rules concerning the types
{\tt BOOL}, {\tt INTEGER}, {\tt FLOAT}, {\tt RATIONAL}, {\tt TEXT}, and
{\tt OUTPUT}, as well as general rules for typing.  The extensive form
and normal form types, and their related types, are detailed later in
special sections.

\subsubsection{Booleans}

The {\tt BOOL} type represents boolean values, that is to say, ``true'' and
``false''.  The command language predefines two constant values to
represent these, {\tt True} and {\tt False}.

\subsubsection{Integers}

The {\tt INTEGER} type may contain integer values.  It is implemented
as the machine's long integer type, which is typically at least 32
bits in modern machines.  Thus, there is a danger, however small, of
overflow or underflow in computations involving these numbers.

\subsubsection{Floats}

The {\tt FLOAT} type may contain floating point values.  It is implemented
as the machine's double-precision floating point type.  These numbers
are imprecise; for example, operations usually associated with being inverses
of each other may not be with floating point numbers.  For more precise
computations, the {\tt RATIONAL} type is available, although these may
sometimes be bulky and slow.

\subsubsection{Rationals}

The {\tt RATIONAL} type is an arbitrary-length ratio of two integers.
This is capable of precisely representing any rational number.  However,
they are slow, and output from them may be unreadably large.  Rational
numbers are formed from two integers using the {\tt /} operator, 
described below.

\subsubsection{Text}

The {\tt TEXT} type is used to store text strings, typically labels
for parts of games.  It is generally encouraged to label various elements
of games in the command language for ease of identification; however it
is not required.  To specify a {\tt TEXT} constant, surround the
text with double-quote characters ({\tt "}).  Constants may not span
more than one input line.

\subsubsection{Output}

The {\tt OUTPUT} type is a reference to an output stream, generally a file
on disk.  Its principal use is as a logging file for formatting output
from an extended command language job.

\subsection{Variables}

\subsection{Lists}

Additionally, variables of any type can be contained in lists of arbitrary
length.
Variables of type {\tt LIST} are defined similarly to the above variables,
except that the expression to the right of the {\tt ":="} symbol
contains a vector of variables of the same type enclosed in curly braces
and separated by commas.  For example, the following is a list containing
the first five integers:

\begin{verbatim}
{ 1, 2, 3, 4, 5 }
\end{verbatim}

\noindent In the same manner, lists of any type may be created and manipulated.
Lists may be nested to any depth; however, the type of all the elements
of the list and any sublists must always be the same.  Hence

\begin{verbatim}
{ 3, { 4, 6 }, 23 }
\end{verbatim}

\noindent is a legal list, since all the elements are of type 
{\tt INTEGER}, but

\begin{verbatim}
{ 3, { 4.2, 5.7 }, 23 }
\end{verbatim}

\noindent is not, since the second element is a {\tt LIST(FLOAT)}.

Lists are distinct in type from each other and from their scalar equivalents.

\subsection{Errors}

\section{Writing simple programs}

\subsection{Statements}

\subsection{Function calls}

A function call consists of the name of a function, and a list of parameters
upon which the function is to operate.  Functions return a value, which
may in turn be used as a parameter to another function call, allowing more
complex computations to be expressed.

A simple example of a function call is

\begin{verbatim}
Plus[x->1, y->2]
\end{verbatim}

This calls the function named {\tt Plus}, with parameter \verb+x+ set to
the value 1 and \verb+y+ set to the value 2.  Since {\tt Plus} is the function
for addition of two integers, the value returned would be, as you might
expect, 3.

In the addition example above, we called a function which is listed in
the function reference as

\begin{verbatim}
Plus[x->INTEGER, y->INTEGER] =: INTEGER
\end{verbatim}

\noindent This listing of a function is called its {\it prototype}.  
It contains the function's name, its list of parameters, and its return
value.  In this case, the function {\tt Plus} takes two parameters, the
first named \verb+x+ and taking a value of type {\tt INTEGER} and the
second named \verb+y+ and taking a value of type {\tt INTEGER}, and
returns a value of type {\tt INTEGER}.

Because the parameters have explicit names, it is possible to rearrange
the order in which parameters are listed when a function is called.
Thus, we could write out sample call equivalently as

\begin{verbatim}
Plus[y->2, x->1]
\end{verbatim}

\noindent and achieve the same effect.

Explicitly specifying the formal names for parameters all the time
will prove tedious and can hinder readability.  For these reasons, it is
also legal to specify parameters without their associated formal names.
These are called passing {\it anonymous} parameters.  Our addition
example could thus also be written

\begin{verbatim}
Plus[1, 2]
\end{verbatim}

In not specifying the formal names, however, function calls are restricted
to specifying parameters in exactly the same order as listed in the function
prototype.  In our example, the GCL interpreter would have no way of
distinguishing whether we meant 1 to be the value of \verb+x+ or the
value of \verb+y+, and vice versa.  While in the case of addition we may
flip the values of the parameters without having an effect on the result,
in general this is not the case.

It is permitted to mix the two styles of parameter specification, subject
to the following rules:

\begin{itemize}
\item All anonymous parameters must be specified before any named parameters
\item No parameters may be omitted in the anonymous parameter list.  If
$k$ parameters are specified anonymously, they must match one-for-one the
first $k$ parameters in the function's prototype.
\item Once a named parameter has been specified, all succeeding parameters
must be named, even if the first named parameter appeared in the same
place in the parameter list as it does in the prototype.
\end{itemize}

\noindent Therefore, it would be legal to write

\begin{verbatim}
Plus[1, y->2]
\end{verbatim}

\noindent but

\begin{verbatim}
Plus[x->1, 2]
\end{verbatim}

\noindent is illegal since it violates the third condition.

To be more precise, the function {\tt Plus} comes in several different
variations listed in the function reference:

\begin{verbatim}
Plus[x->INTEGER, y->INTEGER] =: INTEGER
Plus[x->FLOAT, y->FLOAT] =: FLOAT
Plus[x->RATIONAL, y->RATIONAL] =: RATIONAL
Plus[x->TEXT, y->TEXT] =: TEXT
Plus[x->LIST(T), y->LIST(T) =: LIST(T)
\end{verbatim}

\noindent In fact, not all the versions of {\tt Plus} implement addition;
for example, the {\tt TEXT} version concatenates two strings.  This is a
good example of function {\it overloading}.  This means that one function
name may have several possible parameter lists, sometimes called
{\it signatures}.  The GCL interpreter is capable of determining which
version of the function to use by analyzing the names and types of the
parameters used.

Since a function may have multiple signatures, it is conceivable that
a function call might be ambiguous, in the sense that its parameters match
more than one signature for that function.  However, no function call that
is complete may be ambiguous from the way that signatures have been
chosen for the predefined functions.  Any function call flagged by the
interpreter as ambiguous must be missing at least one parameter.

Some functions have parameters which are optional, in the sense that they
need not be specified in order to call the function.  These parameters
are indicated in the function's prototype by being surrounded by curly
braces.  (Note that these braces should not be included in the function
call when specifying an optional parameter.)  If an optional parameter
is left unspecified in a function call, a default value is assumed, as
given in the function's documentation.

For a function, all required parameters always precede any optional
parameters.  Optional parameters may also be specified anonymously,
subject to the above rules on parameter specification.

All parameters so far have been passed by {\it value}, that is, a copy
of the value of the parameter is given to the function to which it is passed.
These parameters may not be modified by the function.  It is also possible
to have parameters to a function passed by {\it reference}.  This means
that the function does not receive a copy of the value, but rather the
memory location of the value itself.  Thus, the function may modify
the value of a parameter passed by reference.

The symbol for passing a parameter by reference, both in a function's
prototype and in a function call, is {\tt <->}.  Constants may not be
passed by reference.  Reference parameters may be specified anonymously
just like a value parameter, subject to the usual rules.  It is a run-time
error to attempt to pass a value to a reference parameter, or vice versa.

\subsection{Aliases for function calls}

There are several functions which are so commonly used that special
``short'' forms are defined for them.  Most of these are the
standard arithmetic and logic operators, for which the usual binary
infix or unary prefix notations are supported.  Our addition example
may more familiarly be written

\begin{verbatim}
1 + 2
\end{verbatim}

\noindent which expression is converted to the ``long form'' function
call by the interpreter.  Note that formal names may not be specified
in a ``short form'' call, and the order of parameters is therefore
significant.

Here is a list of the functions thus abbreviated, and their ``short form''
equivalents:

\medskip

{\tt
\begin{tabular}{lp{4in}}
And[x, y]		& x \&\& y, x AND y \\
Assign[x, y]		& x := y \\
Divide[x, y]		& x / y or x DIV y \\
Equal[x, y]		& x = y \\
Greater[x, y]		& x > y \\
GreaterEqual[x, y]	& x >= y \\
Less[x, y]		& x < y \\
LessEqual[x, y]		& x <= y \\
Minus[x, y]		& x - y \\
Modulus[x, y]		& x \% y, x MOD y \\
Not[x]			& NOT x, !x \\
NotEqual[x, y]		& x != y \\
NthChar[text, n]	& text[[n]] \\
NthChild[node, n]	& node\#n \\ 
NthElement[list, n]	& list[[n]] \\
Or[x, y]		& x || y, x OR y \\
Paren[x]		& (x) \\ 
Plus[x, y]		& x + y \\
Times[x, y]		& x * y \\
\end{tabular}
}

When functions are written in their canonical forms, no ambiguity
arises in the order of evaluation: In order to evaluate a function,
all arguments must be evaluated first.  Arguments are evaluated from
left-to-right as specified in the function call.
This leads to a recursive structure of evaluation,
which stops only when an argument being evaluated is a constant
function (i. e., a function with no arguments).

When short form forms are used, then ambiguity can arise in the
intended order of evaluation.  For example, the statement \verb&a + b * c&,
could be meant as \verb+Plus[a,Times[b,c]]+ or as
\verb+Times[Plus[a,b],c]+.  In order to resolve such ambiguities, all
functions that have a short form representation are given an order of
precedence.  When a statement is parsed by the GCL, it is first
scanned from left to right, replacing each short form expression at the
top level of precedence with its canonical form.  Then it is scanned
again replacing each short form expression at the second level of
precedence with its canonical form, and so on, until all short form
expressions have been eliminated.  

The order of precedence for built-in functions is as follows:
\bd
\item
\verb+()+
\item
\verb+:=+
\item
\verb+||+
\item
\verb+&&+
\item
\verb+NOT+
\item
\verb+= != < <= > >=+
\item
\verb&+ -&
\item
\verb+* / DIV MOD+
\item
\verb&(unary) + -&
\item
\verb+[[ ]]+
\ed

Thus, the statement \verb&a + b * c& would become 
\begin{verbatim}
Plus[a,b*c]
Plus[a,Times[b,c]]
\end{verbatim}

\noindent
On the other hand, the statement \verb&( a + b ) * c& would become 
\begin{verbatim}
Paren[a+b]*c
Paren[Plus[a,b]]*c
Times[Paren[Plus[a,b]],c]
\end{verbatim}

\noindent
which, since \verb+Paren+ is just the identity mapping, is equivalent to
\begin{verbatim}
Times[Plus[a,b],c]
\end{verbatim}

\medskip

\subsection{Flow control structures}

The GCL contains three functions which allow flow control within a
program.  Flow control functions differ from other functions in that
when they are evaluated, the list of visible functions does not
change.

\medskip

\begin{tabular}{lp{4in}}
If[BOOL, & \\
\{series of commands\}] & Evaluates the BOOL expression
once. If it evaluates to True, the series of commands are performed.
Each command must be followed by a semi-colon or carriage return.  If
the BOOL evaluates to FALSE, none of the commands are performed.\\
If[BOOL, & \\
\{series of commands\}, & \\
\{series of commands\}] & Evaluates the BOOL expression
once. If it evaluates to True, the first series of commands are
performed.  Each command must be followed by a semi- colon or carriage
return.  If the BOOL evaluates to FALSE, the second series of
commands are performed. \\
While[BOOL, &\\
\{series of commands\}] & Evaluates the BOOL
expression or variable.  As long as it evaluates to True, the series
of commands are performed.  Each command must be followed by a
semi-colon or carriage return.  If the BOOL evaluates to FALSE, the
loop ends without performing the commands.\\
NOTE: & The While command functions as a
loop.  That is, it continues to perform the series of commands as long
as the expression evaluates to True.  The If statement, however, only
performs the series of commands once if the expression evaluates to
True.\\
For[\{expressions\}, & \\
\{expression\}, & \\
\{expressions\}, & \\
\{statements\}] & Evaluates the first set of expressions as initialization;
afterwards, so long as the second parameter (which must evaluate to a 
BOOL value) remains True, executes the statement body followed by the
third parameter expressions in a fashion similar to the While command.
\end{tabular}

\section{Advanced topics}

\subsection{Including files}

\subsection{User defined functions}

As GCL programs become more and more complex, frequently there are complicated
operations which must be performed repeatedly.  The command language therefore
supports user-defined functions, which allow for defining sections of code
which may be called later.

A new function can be created using the function
\verb+NewFunction+.  For example, one might define a function to compute
the absolute value of an {\tt INTEGER} as such:

\begin{verbatim}
NewFunction[Abs[n->INTEGER],
                 If[n > 0, n, If[n < 0, -n, 0]]]
\end{verbatim}

\noindent After defining the \verb+Abs+ function, it may be called in exactly
the same way a system-supplied predefined function may.  The return value
of the function is the value of the last statement executed. 

Parameter type matching rules apply to user defined functions in exactly the
same way as to predefined functions.  From the function's point of view,
the parameter list is a list of variables on which assignments are
automatically done at the beginning of the function execution.  So, taking
the \verb+Abs+ example above, in executing the call

\begin{verbatim}
Abs[42]
\end{verbatim}

\noindent an assignment \verb+n := 42+ is implicitly performed before the
body of the function is executed.

It is also possible to pass variables by ``reference'' to a user-defined
function in the same way as a predefined function.  In this case, the
function's ``local'' variable is stored in the same physical location in the
computer, and modifying the value locally also takes effect on the variable
passed to the function.  For example, it might
be useful instead to define \verb+Abs+ as:

\begin{verbatim}
NewFunction[Abs[n<->INTEGER],
		 If[n > 0, n, If[n < 0, n := -n, 0]]]
\end{verbatim}

\noindent in which case the function would still return the absolute value
of \verb+n+, but also modify the variable passed to \verb+n+ to be the
absolute value of the input \verb+n+.  So,

\begin{verbatim}
q := -37;
Abs[q]
\end{verbatim}

\noindent would result in the variable \verb+q+ containing the value 37
at the conclusion of execution.

Each function has its own ``scope'', or set of variables.  Within a function
body, the only variables which are visible are those which are declared
in the parameter list of the function (this is \verb+n+ in the \verb+Abs+
example above), and those which are created during the function's execution.
That is, no ``global'' or outside variables may be accessed directly by the
function.  For example, if the user typed in the following:

\begin{verbatim}
i := 4;
NewFunction[FooFunc[x->INTEGER], x * i]
\end{verbatim}

\noindent later execution of the \verb+FooFunc+ would yield an ``undefined
variable i'' error message, since \verb+i+ is never defined within the
function.  If instead \verb+FooFunc+ had been defined as follows:

\begin{verbatim}
NewFunction[FooFunc[x->INTEGER], i := 13, x * i]
\end{verbatim}

\noindent \verb+FooFunc+ would always return 13 times the value of the
parameter \verb+x+, since the value of \verb+i+ inside \verb+FooFunc+ is
always 13, regardless of the value of \verb+i+ outside of the function.


\subsection{Extensive forms}

\subsubsection{Creating a new extensive form}

\subsubsection{Modifying an extensive form}

\subsubsection{Saving and loading extensive forms}

\subsection{Normal forms}

\subsubsection{Creating a new normal form}

\subsubsection{Modifying a normal form}

\subsubsection{Saving and loading normal forms}

\section{Function Reference, by Category}

This section contains a list of functions, organized by
category.  For a description of each function, and the arguments,
refer to the following, alphabetically organized, section.

\begin{verbatim}
Assign[x<->T, y->T] =: T
Include[file->TEXT]
NewFunction[name[argument-list], body]
Quit
UnAssign[x<->T] =: T
\end{verbatim}

\subsection{Flow Control}

\begin{verbatim}
For[start, test, incr, body]
If[condition, t, f]
While[test, statements]
\end{verbatim}

\subsection{Lists}

\begin{verbatim}
Contains[list->LIST(T), x->T] =: BOOL
Length[list->LIST(T)] =: INTEGER
NthElement[list->LIST(T),n->INTEGER] =: T 
Plus[x->LIST(T), y->LIST(T)] =: LIST(T)
Remove[list->LIST(T), n->INTEGER] =: LIST(T)
\end{verbatim}

\subsection{String Functions}

\begin{verbatim}
Greater[x->TEXT, y->TEXT] =: BOOL
GreaterEqual[x->TEXT, y->TEXT] =: BOOL
Length[text->TEXT] =: INTEGER
Less[x->TEXT, y->TEXT] =: BOOL
LessEqual[x->TEXT, y->TEXT] =: BOOL
NthChar[text->TEXT, n->INTEGER] =: TEXT
Plus[x->TEXT, y->TEXT] =: TEXT
\end{verbatim}


\subsection{Input and Output}

\begin{verbatim}
LoadEfg[file->TEXT] =: EFG
LoadNfg[file->TEXT] =: NFG
Output[file->TEXT] =: OUTPUT
SaveEfg[file->TEXT] =: BOOL
SaveNfg[file->TEXT] =: BOOL
SetFormat[output->OUTPUT, width->INTEGER, precis->INTEGER] =: OUTPUT
Write[output->OUTPUT, x->BEHAV] =: OUTPUT
Write[output->OUTPUT, x->BOOL] =: OUTPUT 
Write[output->OUTPUT, x<->EFG] =: OUTPUT
Write[output->OUTPUT, x->FLOAT] =: OUTPUT
Write[output->OUTPUT, x->INTEGER] =: OUTPUT
Write[output->OUTPUT, x->MIXED] =: OUTPUT
Write[output->OUTPUT, x<->NFG] =: OUTPUT
Write[output->OUTPUT, x->RATIONAL] =: OUTPUT
Write[output->OUTPUT, x->TEXT, {quoted->BOOL}] =: OUTPUT
\end{verbatim}

\subsection{Logic}

\begin{verbatim}
And[x->BOOL, y->BOOL] =: BOOL
Equal[x->T, y->T] =: BOOL
Not[x->BOOL] =: BOOL
NotEqual[x->T, y->T] =: BOOL
Or[x->BOOL, y->BOOL] =: BOOL
\end{verbatim}

\subsection{Arithmetic}

\begin{verbatim}
Divide[x->FLOAT, y->FLOAT] =: FLOAT
Divide[x->INTEGER, y->INTEGER] =: INTEGER
Divide[x->RATIONAL, y->RATIONAL] =: RATIONAL
Exp[x->FLOAT] =: FLOAT
Greater[x->FLOAT, y->FLOAT] =: BOOL
Greater[x->INTEGER, y->INTEGER] =: BOOL
Greater[x->RATIONAL, y->RATIONAL] =: BOOL
GreaterEqual[x->FLOAT, y->FLOAT] =: BOOL
GreaterEqual[x->INTEGER, y->INTEGER] =: BOOL
GreaterEqual[x->RATIONAL, y->RATIONAL] =: BOOL
Less[x->FLOAT, y->FLOAT] =: BOOL
Less[x->INTEGER, y->INTEGER] =: BOOL
Less[x->RATIONAL, y->RATIONAL] =: BOOL
LessEqual[x->FLOAT, y->FLOAT] =: BOOL
LessEqual[x->INTEGER, y->INTEGER] =: BOOL
LessEqual[x->RATIONAL, y->RATIONAL] =: BOOL
Log[x->FLOAT] =: FLOAT
Minus[x->FLOAT, y->FLOAT] =: FLOAT
Minus[x->INTEGER, y->INTEGER] =: INTEGER
Minus[x->RATIONAL, y->RATIONAL] =: RATIONAL
Modulus[x->INTEGER, y->INTEGER] =: INTEGER
Paren[x->T] =: T
Plus[x->FLOAT, y->FLOAT] =: FLOAT
Plus[x->INTEGER, y->INTEGER] =: INTEGER
Plus[x->RATIONAL, y->RATIONAL] =: RATIONAL
Times[x->FLOAT, y->FLOAT] =: FLOAT
Times[x->INTEGER, y->INTEGER] =: INTEGER
Times[x->RATIONAL, y->RATIONAL] =: RATIONAL
\end{verbatim}

\subsection{Extensive Form Manipulation}

\begin{verbatim}
AppendAction[infoset->INFOSET] =: ACTION
AppendNode[node->NODE, infoset->INFOSET] =: NODE
AttachOutcome[node->NODE, outcome->OUTCOME] =: OUTCOME
CopyTree[from->NODE, to->NODE] =: NODE
DeleteAction[infoset->INFOSET, action->ACTION] =: ACTION
DeleteNode[node->NODE, keep->NODE] =: NODE
DeleteOutcome[outc->OUTCOME] =: BOOL
DeleteTree[node->NODE] =: NODE
DetachOutcome[node->NODE] =: NODE
InsertAction[infoset->INFOSET, at->ACTION] =: ACTION
InsertNode[node->NODE, infoset->INFOSET] =: NODE
JoinInfoset[node->NODE, infoset->INFOSET] =: NODE
LeaveInfoset[node->NODE] =: INFOSET
MergeInfosets[infoset1->INFOSET,
               infoset2->INFOSET] =: INFOSET
MoveTree[from->NODE, to->NODE] =: NODE
NewEfg[{rational->BOOL}, {players->LIST(TEXT)}] =: EFG
NewInfoset[player->EFPLAYER, actions->LIST(TEXT),
           {name->TEXT}] =: INFOSET
NewInfoset[player->EFPLAYER, actions->INTEGER,
           {name->TEXT}] =: INFOSET
NewOutcome[efg<->EFG, {name->TEXT}] =: OUTCOME
NewPlayer[efg<->EFG, {name->TEXT}] =: EFPLAYER 
RandomEfg[efg<->EFG, {seed->INTEGER}] =: EFG
Reveal[infoset->INFOSET, who->LIST(EFPLAYER)),
       {what->LIST(ACTIONS)}] =: INFOSET
SetChanceProbs[infoset->INFOSET, probs->LIST(FLOAT)] =: INFOSET
SetChanceProbs[infoset->INFOSET, probs->LIST(RATIONAL)] =: INFOSET
SetName[x->ACTION, name->TEXT] =: ACTION
SetName[x<->EFG, name->TEXT] =: EFG
SetName[x->INFOSET, name->TEXT] =: INFOSET
SetName[x->NODE, name->TEXT] =: NODE
SetName[x->OUTCOME, name->TEXT] =: OUTCOME
SetName[x->PLAYER, name->TEXT] =: PLAYER
SetPayoff[outcome->OUTCOME, payoff->LIST(FLOAT)] =: OUTCOME
SetPayoff[outcome->OUTCOME, payoff->LIST(RATIONAL)] =: OUTCOME
\end{verbatim}

\subsection{Normal Form Manipulation}

\begin{verbatim}
AddStrategy[support->SUPPORT, strategy->STRATEGY] =: SUPPORT
CompressNfg[nfg<->NFG, support->SUPPORT] =: NFG
NewNfg[dim->LIST(INTEGER), {rational->BOOL}] =: NFG
NewSupport[nfg<->NFG] =: SUPPORT
RandomNfg[nfg<->NFG, {seed->INTEGER}] =: NFG
RemoveStrategy[support->SUPPORT, strategy->STRATEGY] =: SUPPORT
SetName[x<->NFG, name->TEXT] =: NFG
SetPayoff[list->LIST(INTEGER), payoffs->LIST(FLOAT)] =: LIST(INTEGER)
SetPayoff[list->LIST(INTEGER), payoffs->LIST(RATIONAL)] =: LIST(INTEGER)
\end{verbatim}

\subsection{Conversions}

\begin{verbatim}
Float[x->INTEGER] =: FLOAT
Float[x->FLOAT] =: FLOAT
Float[x->RATIONAL] =: FLOAT
Nfg[efg<->EFG, {time<->FLOAT}] =: NFG
Rational[x->INTEGER] =: RATIONAL
Rational[x->FLOAT] =: RATIONAL
Rational[x->RATIONAL] =: RATIONAL
Text[x->INTEGER] =: TEXT
Text[x->FLOAT] =: TEXT
Text[x->RATIONAL] =: TEXT
Text[x->TEXT] =: TEXT
\end{verbatim}

\subsection{Solving and analyzing games}

\begin{verbatim}
Behav[mixed->MIXED] =: BEHAV
ElimDom[start->SUPPORT, {strong->BOOL}, {time<->FLOAT}] =: SUPPORT 
EnumMixedSolve[nfg<->NFG, {stopAfter->INTEGER},
               {nPivots<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
EnumPureSolve[nfg<->NFG, {stopAfter->INTEGER}, 
              {time<->FLOAT}] =: LIST(MIXED) 
GobitSolve[efg<->EFG(FLOAT),
          {pxifile->OUTPUT}, {time<->FLOAT},
          {nEvals<->INTEGER}, {nIters<->INTEGER},
          {fullGraph->BOOL},
          {minLam->FLOAT}, {maxLam->FLOAT}, 
          {delLam->FLOAT}, {powLam->INTEGER}, 
          {start->BEHAV}] =: LIST(BEHAV)
GobitSolve[nfg<->NFG(FLOAT),
          {pxifile->OUTPUT}, {time<->FLOAT},
          {nEvals<->INTEGER}, {nIters<->INTEGER},
          {fullGraph->BOOL},
          {minLam->FLOAT}, {maxLam->FLOAT}, 
          {delLam->FLOAT}, {powLam->INTEGER}, 
          {start->MIXED}] =: LIST(MIXED)
LCPSolve[efg<->EFG, {stopAfter->INTEGER},
          {nPivots<->INTEGER}, {time<->FLOAT}] =: LIST(BEHAV)
LCPSolve[nfg<->NFG, {stopAfter->INTEGER},
          {nPivots<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
LiapSolve[efg<->EFG, {time<->FLOAT}, {nEvals<->INTEGER},
         {stopAfter->INTEGER}, {nTries->INTEGER}] =: LIST(BEHAV)
LiapSolve[nfg<->NFG, {time<->FLOAT}, {nEvals<->INTEGER},
         {stopAfter->INTEGER}, {nTries->INTEGER}] =: LIST(MIXED)
LPSolve[nfg<->NFG, {nPivots<->INTEGER},
          {time<->FLOAT}] =: LIST(MIXED)
LqreGridSolve[nfg<->NFG, {pxifile->OUTPUT},
           {minLam->T}, {maxLam->T}, 
           {delLam->T}, {powLam->INTEGER}, 
           {delp->T}, {tol->T},
           {nEvals<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
SetOptions[alg->TEXT, param->TEXT, value->T] =: T
SimpDivSolve[nfg<->NFG,{stopAfter->INTEGER}, 
         {nRestarts->INTEGER}, {leashLength->INTEGER},
         {nEvals<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
\end{verbatim}

\subsection{Getting Information}

\begin{verbatim}
Actions[infoset->INFOSET] =: LIST(ACTION)
Centroid[efg->EFG] =: BEHAV
Centroid[nfg->NFG,support->SUPPORT] =: MIXED
Chance[efg->EFG] =: EFPLAYER
ChanceProbs[infoset->INFOSET] =: LIST(T)
Infoset[node->NODE] =: INFOSET
Infosets[player->EFPLAYER] =: LIST(INFOSET)
IsPredecessor[node->NODE, of->NODE] =: BOOL
IsRoot[node->NODE] =: BOOL
IsSuccessor[node->NODE, from->NODE] =: BOOL
LastAction[node->NODE] =: ACTION
Members[infoset->INFOSET] =: LIST(NODE)
Name[x->ACTION] =: TEXT
Name[x<->EFG] =: TEXT
Name[x->EFPLAYER] =: TEXT
Name[x->INFOSET] =: TEXT
Name[x<->NFG] =: TEXT
Name[x->NFPLAYER] =: TEXT
Name[x->NODE] =: TEXT
Name[x->OUTCOME] =: TEXT
Name[x->STRATEGY] =: TEXT
NextSibling[node->NODE] =: NODE
Nodes[efg<->EFG] =: LIST(NODE)
NonterminalNodes[efg<->EFG] =: LIST(NODE)
NthChild[node->NODE, n->INTEGER] =: NODE
NumActions[infoset->INFOSET] =: INTEGER
NumChildren[node->NODE] := INTEGER
NumInfosets[player->EFPLAYER] =: INTEGER
NumMembers[infoset->INFOSET] =: INTEGER
NumNodes[efg<->EFG] =: INTEGER
NumOutcomes[efg<->EFG] =: INTEGER
NumPlayers[efg<->EFG] =: INTEGER
NumPlayers[nfg<->NFG] =: INTEGER
NumStrats[player->NFPLAYER, {support->SUPPORT}] =: INTEGER
Outcome[node->NODE] =: OUTCOME
Outcomes[efg<->EFG] =: LIST(OUTCOME)
Parent[node->NODE] =: NODE
Payoff[outcome->OUTCOME] =: LIST(T)
Payoff[strategy->BEHAV] =: LIST(T)
Payoff[strategy->MIXED] =: LIST(T)
Player[infoset->INFOSET] =: EFPLAYER
Player[node->NODE] =: EFPLAYER
Players[efg<->EFG] =: LIST(EFPLAYER)
Players[nfg<->NFG] =: LIST(NFPLAYER)
PriorSibling[node->NODE] =: NODE
RealizProbs[strategy->BEHAV] =: LIST(T)
RootNode[efg<->EFG] =: NODE
TerminalNodes[efg<->EFG] =: LIST(NODE)
\end{verbatim}

\subsection{Timing}

\begin{verbatim}
ElapsedTime[] =: FLOAT
IsWatchRunning[] =: BOOL
StartWatch[] =: FLOAT
StopWatch[] =: FLOAT
\end{verbatim}


\section{Function Reference, Alphabetical}

The following is a list of procedures with the operations that they
perform in the Gambit Command Language:

Variable types in all capital letters indicate the type of the
required parameter or return value of the procedure.

The symbol {\tt "=:"} to the right of a procedure specifies the type
of the return value (if any exists) produced by the procedure.

Paremeters enclosed in brackets {\tt "\{ \}"} represent optional
parameters which are not necessary for the procedure to function.

\begin{itemize}

%--A--

\item
\protect \large \begin{verbatim} 
Actions[infoset->INFOSET] =: LIST(ACTION)
\end{verbatim}\normalsize

\bd
Returns the list of actions available at the information set
\verb+infoset+.
\item
[See also:] {\tt AppendAction}, {\tt DeleteAction}, {\tt InsertAction},
{\tt NumActions}.
\ed

\item
\protect \large \begin{verbatim}
ActionValues[strategy->BEHAV, infoset->INFOSET] =: LIST(FLOAT)
ActionValues[strategy->BEHAV, infoset->INFOSET] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns the list of values at information set \verb+infoset+ for each
action for the player making the decision at \verb+infoset+, assuming that
all players obey the behavioral strategy profile \verb+strategy+.
\item
[See also:] {\tt Beliefs}, {\tt InfosetProbs}, {\tt NodeValues},
{\tt RealizProbs}.
\ed

\item
\protect \large \begin{verbatim}
AddStrategy[support->SUPPORT, strategy->STRATEGY] =: SUPPORT
\end{verbatim}\normalsize

\bd
Adds the strategy \verb+strategy+ to the
strategies in the support \verb+support+.  If \verb+strategy+ is already in the
support, no action is taken.  The modified support is returned.
\item
[See also:] {\tt NewSupport}, {\tt RemoveStrategy}.
\ed

\item 
\protect \large \begin{verbatim}
And[x->BOOL, y->BOOL] =: BOOL
\end{verbatim} \normalsize

\bd
Computes the logical conjunction of \verb+x+ and \verb+y+.
\item
[Short forms:] \verb+x && y+, \verb+x AND y+.
\ed


\item
\protect \large \begin{verbatim}
AppendAction[infoset->INFOSET] =: ACTION
\end{verbatim}\normalsize

\bd
Adds an action into the information set \verb+infoset+,
as the last action.  Returns the newly created action.
\item
[See also:] {\tt Actions}, {\tt DeleteAction}, {\tt InsertAction},
{\tt NumActions}.
\ed


\item
\protect \large \begin{verbatim} 
AppendNode[node->NODE, infoset->INFOSET] =: NODE
\end{verbatim}\normalsize

\bd
Places \verb+node+ into the information set
\verb+infoset+.  The result is \verb+node+ becomes a decision node,
with number of branches equal to the number of actions in \verb+infoset+.
Returns the first child of \verb+node+.
\item
[See also:] {\tt InsertNode}, {\tt NewInfoset}.
\ed

\item 
\protect \large \begin{verbatim}
Assign[x<->T, y->T] =: T
\end{verbatim} \normalsize

\bd
Assigns the value \verb+y+ to the variable referred to by
\verb+x+.  Returns the value assigned.
\item
[Short form:] \verb+x := y+
\item
[See also:] {\tt UnAssign}.
\ed

\item
\protect \large \begin{verbatim} 
AttachOutcome[node->NODE, outcome->OUTCOME] =: OUTCOME
\end{verbatim}\normalsize

\bd
Attaches the outcome \verb+outcome+ to the node \verb+node+.
Returns the outcome attached.  Note that nonterminal nodes may have
attached outcomes.
\item
[See also:] {\tt DetachOutcome}, {\tt HasOutcome}, {\tt Outcome}.
\ed

%--B--

\item
\protect \large \begin{verbatim}
Behav[mixed->MIXED] =: BEHAV
\end{verbatim}\normalsize

\bd
Converts the mixed profile \verb+mixed+ to the equivalent
behavioral profile on the associated extensive form game.  In order to use
this function the normal form to which \verb+mixed+ belongs must have
been created from an extensive form game currently stored in a variable
in the command language.
\ed

\item
\protect \large \begin{verbatim}
Beliefs[strategy->BEHAV] =: LIST(FLOAT)
Beliefs[strategy->BEHAV] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns a list of the conditional probabilities of
being at a node given that a player knows he is in that node's information
set, if all players are playing the behavioral strategy profile
\verb+strategy+.  The list is ordered according to the prefix-traversal
order of the game tree, the same order in which the list of nodes is
returned by {\tt Nodes}.
\ed


%--C--

\item
\protect \large \begin{verbatim} 
Centroid[efg<->EFG] =: BEHAV
\end{verbatim}\normalsize

\bd
Returns a behavioral profile for the extensive form
game \verb+efg+ initialized to the centroid, that is, the behavioral
profile in which all actions at each information set are equally
likely to be chosen.
\ed

\item
\protect \large \begin{verbatim}
Centroid[nfg<->NFG] =: MIXED
\end{verbatim}\normalsize

\bd
Returns a mixed profile for the normal form game \verb+nfg+
initialized to the centroid, that is, the mixed profile in which all
strategies for each player are equally likely to be choen.
\ed

\item
\protect \large \begin{verbatim}
Centroid[support->SUPPORT] =: MIXED
\end{verbatim}\normalsize

\bd
Returns a mixed profile over the support \verb+support+
initialized to the centroid, that is, the mixed profile in which 
all strategies in the support for each player are equally likely to be
chosen, and all strategies not in the support are chosen with probability
zero.
\ed

\item
\protect \large \begin{verbatim}
Chance[efg<->EFG] =: EFPLAYER
\end{verbatim}\normalsize

\bd
Returns the chance, or nature, player defined on the
extensive form game \verb+efg+.  Each extensive form has exactly one
chance player predefined, and it is not possible to define any additional
chance players.
\ed

\item
\protect \large \begin{verbatim}
ChanceProbs[infoset->INFOSET] =: LIST(FLOAT)
ChanceProbs[infoset->INFOSET] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns the vector of probabilities over the actions at
information set \verb+infoset+ as a list.  A run-time error results if
the given information set does not belong to the chance player.
\ed

\item
\protect \large \begin{verbatim}
CompressNfg[nfg<->NFG, support->SUPPORT] =: NFG
\end{verbatim}\normalsize

\bd
Returns a new normal form game with the strategies present
in the support \verb+support+ and values for each contingency equivalent
to the values for the corresponding contingencies in the game \verb+nfg+.
\ed

\item
\protect \large \begin{verbatim}
Contains[list->LIST(T), x->T] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the value \verb+x+ is contained in the list
\verb+list+.
\item
[See also:] {\tt Length}, {\tt Subscript}.
\ed

\item
\protect \large \begin{verbatim}
CopyTree[from->NODE, to->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Copies the subtree rooted at \verb+from+ to the terminal
node \verb+to+ in the same extensive form game.  The nodes in the
copied subtree belong to the same information sets as their counterparts in
the original subtree.  Returns the node \verb+to+.
\item
[See also:] {\tt MoveTree}, {\tt Reveal}.
\ed

%--D--

\item
\protect \large \begin{verbatim}
DeleteAction[infoset->INFOSET, action->ACTION] =: INFOSET
\end{verbatim}\normalsize

\bd
Deletes the action \verb+action+ from the information set
\verb+infoset+.  As a consequence, the corresponding subtrees associated
with the action from each member of the information set are deleted.
Returns the information set.
\item
[See also:] {\tt Actions}, {\tt AppendAction}, {\tt InsertAction},
{\tt NumActions}.
\ed

\item
\protect \large \begin{verbatim}
DeleteNode[node->NODE, keep->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Deletes the node \verb+node+ from the tree.  The
subtree rooted in node \verb+keep+, which must be a child of
\verb+node+, is kept, and \verb+keep+ takes the place of \verb+node+ in
the tree.  All other subtrees descending from \verb+node+ are deleted.
The kept node \verb+keep+ is returned.
\item
[See also:] {\tt DeleteTree}, {\tt InsertNode}.
\ed

\item
\protect \large \begin{verbatim}
DeleteOutcome[outcome->OUTCOME] =: BOOL
\end{verbatim}\normalsize

\bd
Removes the outcome \verb+outcome+ from its extensive
form game.  All nodes with the specified outcome attached are reset to
having no outcome attached; this is equivalent to an implicit call to
{\tt DetachOutcome} on these nodes.  Returns \verb+True+ on success.
\item
[See also:] {\tt NewOutcome}.
\ed

\item
\protect \large \begin{verbatim}
DeleteTree[node->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Deletes the subtree rooted at the node \verb+node+.  The
node then becomes a terminal node, which is returned.
\item
[See also:] {\tt DeleteNode}.
\ed

\item
\protect \large \begin{verbatim}
DetachOutcome[node->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Sets the outcome associated with \verb+node+ to be the
null outcome.  If there is no outcome associated with \verb+node+ no
action is taken.  Returns \verb+node+.
\item
[See also:] {\tt AttachOutcome}, {\tt Outcome}.
\ed

\item 
\protect \large \begin{verbatim}
Divide[x->FLOAT, y->FLOAT] =: FLOAT
Divide[x->RATIONAL, y->RATIONAL] =: RATIONAL
\end{verbatim} \normalsize

\bd
Returns the quotient $x / y$. 
\item
[Short form:] \verb+x / y+
\ed

\item 
\protect \large \begin{verbatim}
Divide[x->INTEGER, y->INTEGER] =: INTEGER
\end{verbatim} \normalsize

\bd
Returns the quotient $x / y$, rounded to the next integer
towards zero.
\item
[Short form:] \verb%x DIV y%
\item
[See also:] \verb+Modulus+.
\ed

%--E--

\item
\protect \large \begin{verbatim}
ElapsedTime[] =: FLOAT
\end{verbatim}\normalsize

\bd
If the system stopwatch is currently running, returns the
time elapsed since the stopwatch was started.  If the system stopwatch
is not runnign, returns the time elapsed during the last period during which
the stopwatch was running.
\item
[See also:] {\tt IsWatchRunning}, {\tt StartWatch}, {\tt StopWatch}.
\ed

\item
\protect \large \begin{verbatim}
ElimDom[start->SUPPORT, {strong->BOOL}, {time<->FLOAT} =: SUPPORT
\end{verbatim} \normalsize

\bd
Finds dominated strategies in the normal form game \verb+nfg+.
The process is controlled by the following parameters:

\bd
\item
[start:] The initial support.  If unspecified, it defaults to the full
strategy set for each player in the game.  
\item
[strong:] Determines the type of dominance used.  The default value is
False, which signifies that weak dominance is used.  If `strong` is
specified to be True, strong dominance is used.
\item
[mixed:] Determines if mixed strategies are used in determining if a
given pure strategy is dominated.  The default value is False, meaning
that only pure strategies are used. If \verb+strong+ is specified to
be True, mixed strategies are used.
\item
[players:] A list of players for whom dominant strategies are
computed.  Default is all players in the game.  
\item
[time:] Returns the elapsed time for the operation.
\ed
\ed

\item
\protect \large \begin{verbatim}
EnumMixedSolve[nfg<->NFG, {stopAfter->INTEGER},
               {nPivots<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
\end{verbatim}\normalsize

\bd
Returns all Nash equilibria (pure and mixed) for a two
person normal form game \verb+nfg+.  More precisely, it finds the set
of extreme points of the components of the set of Nash equilibria.
The procedure is to enumerate the set of complementary basic feasible
solutions. (See, eg \cite[1964]{Man:64}.)  The following optional
parameters are permitted: 
\bd
\item
[stopAfter:] Specifies the maximum number of equilibria to find.  If
not specified, the default value is zero, which means that all
equilibria are found.
\item
[nPivots:] Upon completion, contains the number of pivots done.
\item
[time:] Upon completion, contains the elapsed time for the computation.
\ed
\item
[See also:] {\tt EnumPureSolve}.
\ed

\item
\protect \large \begin{verbatim}
EnumPureSolve[nfg<->NFG, {stopAfter->INTEGER}, 
              {time<->FLOAT}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd
Returns all pure strategy Nash equilibria in the
normal form game \verb+nfg+.  The following optional parameters are
permitted:
\bd
\item
[stopAfter:] The function finds only up to \verb+stopAfter+ equilibria,then returns.  If unspecified, finds all equilibria.
\item
[time:] Upon completion, contains the elapsed time for the computation.
\ed
\item
[See also:] {\tt EnumMixedSolve}.
\ed

\item
\protect \large \begin{verbatim}
Equal[x->T, y->T] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the two objects \verb+x+ and \verb+y+ are
equal.
\item
[Short form:] \verb+x = y+.
\item
[See also:] {\tt NotEqual}.
\ed

\item
\protect \large \begin{verbatim}
Exp[x->FLOAT] =: FLOAT
\end{verbatim} \normalsize

\bd
Returns the value of the function ${\rm e}^{x}$ for the
value \verb+x+.
\item
[See also:] {\tt Log}.
\ed


%--F--

\item
\protect \large \begin{verbatim}
Float[x->INTEGER] =: FLOAT
Float[x->FLOAT] =: FLOAT
Float[x->RATIONAL] =: FLOAT
\end{verbatim} \normalsize

\bd
Returns the value \verb+x+ as a value of type {\tt FLOAT}.
In the case where \verb+x+ is {\tt RATIONAL}, this may result in a loss
of precision.
\item
[See also:] {\tt Rational}.
\ed

\item
\protect \large \begin{verbatim}
For[start, test, incr, body]
\end{verbatim}\normalsize

\bd
Executes $start$, then repeatedly evaluates $body$ and $incr$
until $test$ fails to give $True$.
\item
[See also:] \verb+While+.
\ed

%--G--

\item
\protect \large \begin{verbatim}
GobitSolve[efg<->EFG(FLOAT),
           {pxifile->OUTPUT}, {time<->FLOAT},
           {nEvals<->INTEGER}, {nIters<->INTEGER},
           {fullGraph->BOOL},
           {minLam->FLOAT}, {maxLam->FLOAT}, 
           {delLam->FLOAT}, {powLam->INTEGER}, 
           {start->BEHAV}] =: LIST(BEHAV)
\end{verbatim}\normalsize

\protect \large \begin{verbatim}
GobitSolve[nfg<->NFG(FLOAT),
           {pxifile->OUTPUT}, {time<->FLOAT},
           {nEvals<->INTEGER}, {nIters<->INTEGER},
           {fullGraph->BOOL},
           {minLam->FLOAT}, {maxLam->FLOAT}, 
           {delLam->FLOAT}, {powLam->INTEGER}, 
           {start->MIXED}] =: LIST(MIXED)
\end{verbatim}\normalsize

\bd
\item
Computes a branch of the logistic quantal response
equilibrium correspondence (as described in \cite[1995]{McKPal:95a}
for normal form games, and in \cite[1995b]{McKPal:95b} for extensive
form games.  The branch is computed for values of $\lambda$ between
$\underline{\lambda}$ and $\bar{\lambda}.$ The algorithm starts at
$\lambda_0 = \underline{\lambda}$ if $\delta>0,$ or $\lambda_0 =
\bar{\lambda}$ if $\delta<0$. It then increments according to the
formula 
$$
\lambda_{t+1} = \lambda_t +\delta \lambda_t^a,
$$ where $\underline\lambda,$ $\bar\lambda,$ $\delta,$ and $a$ are
parameters described below. In the computation for the first value of
$\lambda_0$, the algorithm begins its search for a solution at the
starting point determined by the parameter ''start.''  At each
successive value of $\lambda_t,$ the algorithm begins it's search at
the point found in step $t - 1.$ 

The {\em principal branch} of the logistic quantal response
equilibrium mapping is the branch that is connected to the centroid of
the game at $\lambda = 0$.  This branch can be computed by setting
$\lambda_0$ sufficiently small.  As discussed in McKelvey and Palfrey,
for generic normal form games, the principal branch of the quantal
response equilibrium correspondence converges to a unique selection
from the set of Nash equilibria as $\lambda$ goes to infinity.
Similarly, for generic extensive form games, the principal branch of
the quantal response mapping converges to a unique selection from the
set of sequential equilibria as $\lambda$ goes to infinity.  Hence, in
extensive form games, this algorithm can be used to compute an
approximation to a sequential equilibrium.
\item
[Return value:] The List of Mixed (or Behavior) profiles found -- one
profile for each value of $\lambda_t$.  If \verb+fullGraph+ is
\verb+False+, then only the last value is returned.  
\item 
[Required parameters:]\hfil\null Exactly one of the following

\bd
\item
[nfg:] The game in normal form for which the quantal response
equilibrium solution is to be
found.
\item	
[efg:] The game in extensive form for which the quantal response
equilibrium solution is to be found.
\ed

\item
[Optional parameters:]\hfil\null

\bd
\item
[pxifile:] Can be used to generate an output file compatible for input
to pxi, a program for graphical viewing and display of the output.  
\item
[time:] Returns the elapsed time for the operation.
\item
[nEvals:] Number of function evaluations.
\item
[nIters:] Number of iterations of the the function minimization.
\item
[minLam:] Sets $\underline\lambda,$ the minimum value of $\lambda.$
Default is $\underline\lambda = 0.01$.
\item
[maxLam:] Sets $\bar\lambda,$ the maximum value of $\lambda.$  Default is
$\bar\lambda = 30.0.$
\item
[delLam:]  Constant, $\delta,$ used in incrementing.   Default is
$\delta = .01.$
\item
[powLam:] Exponent, $a,$ used in incrementing $\lambda.$  Setting $a = 0$
corresponds to linear incrementing, and $a = 1$ results in geometric
incrementing.  Default is $a = 1$.
\item
[start:] Sets the starting point of the search for the initial value of
$\lambda.$  Default is the centroid, where all strategies are chosen
with equal probability.  
\item
[maxitsN:] Sets the maximum number of iterations to the
n-dimensional optimization routine.  Default is 200.
\item
[maxits1:] Sets the maximum number of iterations in the
1-dimensional line search.  Default is 100.
\item
[tolN:] Sets the tolerance for the n-dimensional optimization
routine.  Default is 1.0e-10.
\item
[tol1:] Sets the tolerance for the 1-dimensional line search.
Default is 2.0e-10.
\item
\ed
\ed

\item
\protect \large \begin{verbatim}
Greater[x->INTEGER, y->INTEGER] =: BOOL
Greater[x->FLOAT, y->FLOAT] =: BOOL
Greater[x->RATIONAL, y->RATIONAL] =: BOOL
Greater[x->TEXT, y->TEXT] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the value of \verb+x+ is greater than
that of \verb+y+.  For text comparisons, a lexicographic comparison using the
native character set of the machine is performed.
\item
[Short form:] \verb+x > y+
\item
[See also:] {\tt GreaterThan}, {\tt Less}, {\tt LessEqual}.
\ed

\item
\protect \large \begin{verbatim}
GreaterEqual[x->INTEGER, y->INTEGER] =: BOOL
GreaterEqual[x->FLOAT, y->FLOAT] =: BOOL
GreaterEqual[x->RATIONAL, y->RATIONAL] =: BOOL
GreaterEqual[x->TEXT, y->TEXT] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the value of \verb+x+ is at least that of
\verb+y+.  For text comparisons, a lexicographic comparison using the
native character set of the machine is performed.
\item
[Short form:] \verb+x >= y+
\item
[See also:] {\tt Greater}, {\tt Less}, {\tt LessEqual}.
\ed

%--H--

\item
\protect \large \begin{verbatim}
HasOutcome[node->NODE] =: BOOL
\end{verbatim} \normalsize

\bd
Returns whether the node \verb+node+ currently has an outcome associated
with it.
\item
[See also:] {\tt AttachOutcome}, {\tt DetachOutcome}, {\tt Outcome}.
\ed

%--I--

\item 
\protect \large \begin{verbatim}
If[condition, t, f]
\end{verbatim} \normalsize
  
\bd
If antecedent is True, evaluates $t$.  If
antecedent is false, evaluates $f$. 
\ed


\item
\protect \large \begin{verbatim}
Include[file->TEXT]
\end{verbatim}\normalsize

\bd
Includes the commands in the specified file as commands
in the running GCL program.  The program treats the command as if it
were replaced by the contents of the file.  \verb+Include+ may only be used
at the ``top level'', that is, it cannot be used inside of \verb+NewFunction+
or flow control structures.
\ed

\item
\protect \large \begin{verbatim}
Infoset[node->NODE] =: INFOSET
\end{verbatim}\normalsize

\bd
Returns the information set to which the node \verb+node+
belongs.  All nonterminal nodes belong to an information set.  Terminal
nodes belong to an information set, and a call to this function using
a terminal node will result in a run-time error.
\ed

\item
\protect \large \begin{verbatim}
InfosetProbs[strategy->BEHAV] =: LIST(FLOAT)
InfosetProbs[strategy->BEHAV] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns a (nested) list of the probabilities of reaching all information
sets in an extensive form game, given that all players obey the
behavioral strategy profile \verb+strategy+.  The $i$th element
in the list returned is a list of the probabilities for the information
sets owned by player $i$.
\item
[See also:] {\tt ActionValues}, {\tt Beliefs}, {\tt NodeValues},
{\tt RealizProbs}.
\ed

\item
\protect \large \begin{verbatim}
Infosets[player->EFPLAYER] =: LIST(INFOSET)
\end{verbatim}\normalsize

\bd
Returns the list of information sets at which player
\verb+player+ has the decision.
\ed

\item
\protect \large \begin{verbatim}
InsertAction[infoset->INFOSET, at->ACTION] =: ACTION
\end{verbatim}\normalsize

\bd
Inserts a new action into the information set \verb+infoset+
before the action \verb+at+.  The corresponding new branch is created for
each node belonging to the information set.  Returns the newly created action.
\item
[See also:] {\tt Actions}, {\tt AppendAction}, {\tt DeleteAction},
{\tt NumActions}.
\ed

\item
\protect \large \begin{verbatim}
InsertNode[node->NODE, infoset->INFOSET] =: NODE
\end{verbatim}\normalsize

\bd
Inserts a new node in the tree at the location of
node \verb+node+.  The
new node is placed in the information set \verb+infoset+, and the
corresponding number of branches are created from the new node.  \verb+node+
becomes the first child of the new node.  Returns the new node.
\item
[See also:] {\tt AppendNode}, {\tt NewInfoset}.
\ed

\item
\protect \large \begin{verbatim}
IsPredecessor[node->NODE, of->NODE] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the node \verb+node+ is a predecessor
in the tree of the node \verb+of+.  For the purposes of this function,
a node is considered its own predecessor.
\item
[See also:] {\tt IsSuccessor}.
\ed

\item
\protect \large \begin{verbatim}
IsRoot[node->NODE] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the node \verb+node+ is the root node of its
extensive form.
\item
[See also:] {\tt Parent}.
\ed

\item
\protect \large \begin{verbatim}
IsSuccessor[node->NODE, from->NODE] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the node \verb+node+ is a successor
in the tree of the node \verb+from+.  For the purposes of this function,
a node is considered its own successor.
\item
[See also:] {\tt IsPredecessor}.
\ed

\item
\protect \large \begin{verbatim}
IsWatchRunning[] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the system stopwatch is currently running.
\item
[See also:] {\tt ElapsedTime}, {\tt StartWatch}, {\tt StopWatch}.
\ed

%--J--

\item
\protect \large \begin{verbatim}
JoinInfoset[node->NODE, infoset->INFOSET] =: NODE
\end{verbatim}\normalsize

\bd
Makes the node \verb+node+ a member of the information set
\verb+infoset+.  If the previous information set of \verb+node+ was
a singleton (i.e., it contained only \verb+node+), it is removed from the
extensive form.  It is a run-time error if the number of actions at the
information set does not match the number of branches at the node.
Returns the node \verb+node+.
\item
[See also:] {\tt LeaveInfoset}, {\tt MergeInfosets}.
\ed

%--K--

%--L--

\item
\protect \large \begin{verbatim} 
LastAction[node->NODE] =: ACTION
\end{verbatim}\normalsize

\bd
Returns the action corresponding to the branch leading to
the node \verb+node+.  It is a run-time error if the node \verb+node+ is
the root node of the tree and thus has no such action.
\ed

\item
\protect \large \begin{verbatim}
LCPSolve[efg<->EFG, {stopAfter->INTEGER},
         {nPivots<->INTEGER}, {time<->FLOAT}] =: LIST(BEHAV)
LCPSolve[nfg<->NFG, {stopAfter->INTEGER},
         {nPivots<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
\end{verbatim}\normalsize

\bd
For a normal form game, the game is set up as a linear
complementarity problem, and solved via the Lemke-Howson Algorithm.
(See, eg., Searches for equilibria of the specified normal form game
specified using the Lemke-Howson algorithm (see
\cite[1964]{LemHow:64}) using lexicographic rule for insuring
termination, as developed in \cite[1971]{Eav:71}.

For an extensive form game, this algorithm implements Koller, Megiddo
and von Stengel's {\em sequence form} (\cite[1994]{KolMegSte:94}. The
sequence form is a formulation of the set of Nash equilibria as the
solution to a non linear complementarity problem in variables that
correspond to ``sequences'' in the extensive form, which they show can
be solved by Lemke's algorithm for Linear complementarity problems.
The method has nice properties in terms of its computational
complexity, as it only grows linearly in the size of the extensive
form game.  

\item
[Required parameters:]\hfil\null

\bd
\item
[nfg:] The game in normal form for which the solution is to be
searched.
\item
[efg:] The game in normal form for which the solution is to be
searched.
\ed

\item
[Optional parameters:]\hfil\null

\bd
\item
[stopAfter:] Specifies the maximum number of equilibria to find.  If
not specified, the default value is zero, which means that all
equilibria reachable by the algorithm are to be found.
\item
[nPivots:] The total number of pivots. 
\item
[time:] Returns the elapsed time for the operation.
\ed
\ed

\item
\protect \large \begin{verbatim}
LeaveInfoset[node->NODE] =: INFOSET
\end{verbatim}\normalsize

\bd
Removes the node \verb+node+ from the information set to
which it currently belongs and places it in a newly created
singleton information set belonging to the same player.  If \verb+node+
is already the only member of its information set, no action is taken.
Returns information set to which \verb+node+ belongs upon completion.
\item
[See also:] {\tt JoinInfoset}, {\tt MergeInfosets}.
\ed

\item
\protect \large \begin{verbatim}
Length[text->TEXT] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of characters in the text string
\verb+text+.
\item
[See also:] {\tt NthChar}.
\ed

\item
\protect \large \begin{verbatim}
Length[list->LIST(T)] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of elements in the list \verb+list+.
\item
[See also:] {\tt NthElement}.
\ed

\item
\protect \large \begin{verbatim}
Less[x->INTEGER, y->INTEGER] =: BOOL
Less[x->FLOAT, y->FLOAT] =: BOOL
Less[x->RATIONAL, y->RATIONAL] =: BOOL
Less[x->TEXT, y->TEXT] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whehter the value of \verb+x+ is less than that of
\verb+y+.  For text comparisons, a lexicographic comparison using the
native character set of the machine is performed.
\item
[Short form:] \verb+x < y+
\item
[See also:] {\tt Greater}, {\tt GreaterEqual}, {\tt LessEqual}.
\ed

\item
\protect \large \begin{verbatim}
LessEqual[x->INTEGER, y->INTEGER] =: BOOL
LessEqual[x->FLOAT, y->FLOAT] =: BOOL
LessEqual[x->RATIONAL, y->RATIONAL] =: BOOL
LessEqual[x->TEXT, y->TEXT] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the value of \verb+x+ is no more than that
of \verb+y+.  For text comparisons, a lexicographic comparison using the
native character set of the machine is performed.
\item
[Short form:] \verb+x <= y+
\item
[See also:] {\tt Greater}, {\tt GreaterEqual}, {\tt Less}.
\ed

\item
\protect \large \begin{verbatim}
LiapSolve[efg<->EFG, {time<->FLOAT},
          {nEvals<->INTEGER}, {stopAfter->INTEGER}, {nTries->INTEGER},
          {start->BEHAV}] =: LIST(BEHAV)
\end{verbatim}\normalsize

\protect \large \begin{verbatim}
LiapSolve[nfg<->NFG, {time<->FLOAT}, {nEvals<->INTEGER},
          {stopAfter->INTEGER}, {nTries->INTEGER},
	  {start->MIXED}] =: LIST(MIXED)
\end{verbatim}\normalsize


\bd
\item
[] Finds Nash equilibria via the Lyapunov function method
described in \cite[1991]{McK:91}.  Works on either the
extensive or normal form.  This algorithm casts the problem as a
function minimization problem by use of a Lyapunov function for Nash
equilibria.  This is a continuously differentiable non negative
function whose zeros coincide with the set of Nash equilibria of the
game.  A standard descent algorithm is used to find a constrained
local minimum of the function from any given starting location.  Since
a local minimum need not be a global minimum (with value 0,) the
algorithm is not guaranteed to find a Nash equilibrium from any fixed
starting point.  The algorithm thus incorporates the capability of
restarting.  The algorithm starts from the initial starting point
determined by the parameter 'start'.  If a Nash equilibrium is not
found, it will keep searching from new randomly chosen starting points
until a Nash equilibrium has been found or the maximum number of tries
(parameter 'ntries') is exceeded, whichever comes first.
\item
[Return value:] Returns the list of solutions found.
\item
[Required parameters:] Exactly one of the following \hfil\null

\bd
\item
[nfg:] The game in normal form for which the Liapunov solution is to
be found.
\item
[efg:] The game in extensive form for which the Liapunov solution is
to be found.
\ed

\item
[Optional parameters:]\hfil\null

\bd
\item
[start:] Sets the starting profile for the descent algorithm.  The
default is the centroid.
\item
[ntries:] Sets the maximum number of attempts at finding each
equilibrium. Default is 10
\item
[stopAfter:] Sets the number of equilibria to find.  Has a default
value of 1.  [maxitsOpt:] Sets the maximum number of iterations to the
n-dimensional optimization routine.  Default is 200.
\item
[maxits1D:] Sets the maximum number of iterations in the
1-dimensional line search.  Default is 100.
\item
[maxitsND:] Sets the maximum number of iterations in the
n-dimensional optimization.  
\item
[tolND:] Sets the tolerance for the n-dimensional optimization
routine.  Default is 1.0e-10.
\item
[tol1D:] Sets the tolerance for the 1-dimensional line search.
Default is 2.0e-10.
\item
[time:] Returns the elapsed time for the operation.
\ed
\ed

\item
\protect \large \begin{verbatim}
LoadEfg[file->TEXT] =: EFG
\end{verbatim}\normalsize

\bd
Loads an extensive form game from an external savefile
and returns the game.
\item
[See also:] {\tt SaveEfg}.
\ed

\item
\protect \large \begin{verbatim}
LoadNfg[file->TEXT] =: NFG
\end{verbatim}\normalsize

\bd
Loads a normal form game from an external savefile
and returns the game.  
\item
[See also:] {\tt SaveNfg}.
\ed

\item
\protect \large \begin{verbatim}
Log[x->FLOAT] =: FLOAT
\end{verbatim} \normalsize

\bd
Computes the natural logarithm of \verb+x+.
\item
[See also:] {\tt Exp}.
\ed

\item
\protect \large \begin{verbatim}
LPSolve[nfg<->NFG, {nPivots<->INTEGER},
        {time<->FLOAT}] =: LIST(MIXED)
\end{verbatim}\normalsize

\bd
Finds the minmimax solution (a Nash equilibrium) for a
two person constant-sum game, by solving it as a Linear Program.
\item
[Required parameters:]
\bd
\item
[nfg:] The game in normal form for which the solutions are to be found.  
\ed

\item
[Optional parameters:]\hfil\null

\bd
\item[nPivots:] Number of pivots. 
\item[time:] Elapsed time for the operation.
\ed
\ed

\item
\protect \large \begin{verbatim}
LqreGridSolve[nfg<->NFG, {pxifile->OUTPUT},
              {minLam->FLOAT}, {maxLam->FLOAT}, 
              {delLam->FLOAT}, {powLam->INTEGER}, 
              {delp->FLOAT}, {tol->FLOAT},
              {nEvals<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)

LqreGridSolve[nfg<->NFG, {pxifile->OUTPUT},
              {minLam->RATIONAL}, {maxLam->RATIONAL}, 
              {delLam->RATIONAL}, {powLam->INTEGER}, 
              {delp->RATIONAL}, {tol->RATIONAL},
              {nEvals<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
\end{verbatim}\normalsize

\bd
Performs a grid search to compute the complete logistic
quantal response correspondence for a (small) two-person normal form
game.  The correspondence is computed for values of $\lambda$ between
$\underline{\lambda}$ and $\bar{\lambda}.$ Points are evaluated in
terms of the value of an objective function, that measures the
distance between the original point, and the best response to the best
response (under the logistic best response function.)  Points that are
close (within 'tol') to being fixed points are kept, others are
discarded.  Values of the probabilities are evaluated on a grid of
mesh 'delp.'

\item
[Return value:] The List of Mixed (or Behavior) profiles found -- one
profile for each value of $\lambda_t$. 

\item
[Required parameters:]\hfil\null
	
\bd
\item  
[nfg:] The two person game in normal form which is to be operated on.
\ed

\item
[Optional parameters:]  See LqreSolve[] for additional parameters.

\bd
\item
[delp:] Grid size for search over probability space.  Default is XXXX .
\item
[tol:] The tolerance on the objective function.  Values of $p$ for
which the objective function is less this value are kept.  
\ed
\ed

%--M--

\item
\protect \large \begin{verbatim}
Members[infoset->INFOSET] =: LIST(NODE)
\end{verbatim}\normalsize

\bd
Returns the list of nodes which are members of the information
set \verb+infoset+.
\ed

\item
\protect \large \begin{verbatim}
MergeInfosets[infoset1->INFOSET,
              infoset2->INFOSET] =: INFOSET
\end{verbatim}\normalsize

\bd
Moves all the nodes from \verb+infoset2+ into \verb+infoset1+.
It is a run-time error if the number of actions is not the same at the
two information sets.  \verb+infoset2+ is deleted from the extensive form,
and \verb+infoset1+ is returned.
\ed

\item 
\protect \large \begin{verbatim}
Minus[x->INTEGER, y->INTEGER] =: INTEGER
Minus[x->FLOAT, y->FLOAT] =: FLOAT
Minus[x->RATIONAL, y->RATIONAL] =: RATIONAL
\end{verbatim} \normalsize

\bd
Returns the difference $x - y$.
\item
[Short form:] \verb+x - y+
\ed

\item
\protect \large \begin{verbatim}
Modulus[x->INTEGER, y->INTEGER] =: INTEGER
\end{verbatim}\normalsize

\bd
Computes the remainder from dividing \verb+y+ into \verb+x+.
\item
[Short form:] \verb+x MOD y+
\item
[See also:] {\tt Divide}.
\ed


\item
\protect \large \begin{verbatim}
MoveTree[from->NODE, to->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Moves the subtree rooted at \verb+from+ to
the terminal node \verb+to+.  \verb+from+ becomes a terminal node.
Returns \verb+to+.
\item
[See also:] {\tt CopyTree}.
\ed

%--N--

\item
\protect \large \begin{verbatim}
Name[x->ACTION] =: TEXT
Name[x<->EFG] =: TEXT
Name[x->EFPLAYER] =: TEXT
Name[x->INFOSET] =: TEXT
Name[x<->NFG] =: TEXT
Name[x->NFPLAYER] =: TEXT
Name[x->NODE] =: TEXT
Name[x->OUTCOME] =: TEXT
Name[x->STRATEGY] =: TEXT
\end{verbatim}\normalsize

\bd
Returns the name of the object \verb+x+.
\item
[See also:] {\tt SetName}.
\ed

\item
\protect \large \begin{verbatim} 
NewEfg[{rational->BOOL}, {players->LIST(TEXT)}] =: EFG
\end{verbatim}\normalsize

\bd
Creates a new extensive form game.  By default, the
outcomes and probabilities associated with the game will be stored as
{\tt FLOAT}.  If the \verb+rational+ parameter is specified and is \verb+True+,
these values will be stored as {\tt RATIONAL}.  The default extensive form
game has no players (other than the chance player) defined on it; the
optional parameter \verb+players+ specifies a list of players to be
created and the names to be assigned to them.  Returns the newly created
game.
\ed

\item   
\protect \large \begin{verbatim}
NewFunction[name[argument-list], body]
\end{verbatim}\normalsize

\bd
Creates a new function.  The function may be called exactly
as if it were a predefined function of the command language.  See the
section on user-defined functions for more detailed information.
\ed

\item
\protect \large \begin{verbatim} 
NewInfoset[player->EFPLAYER, actions->LIST(TEXT),
            {name->TEXT}] =: INFOSET
NewInfoset[player->EFPLAYER, actions->INTEGER,
            {name->TEXT}] =: INFOSET
\end{verbatim}\normalsize

\bd
Creates a new information set belonging to \verb+player+.
If the integer version of \verb+actions+ is used, the information set
will contain that number of actions, each named with the empty string.
Alternatively, the list version of \verb+actions+ causes the information
set to have the same number of actions as the list has elements, with
the actions named by the corresponding element in the list.  (In either
case, the number of actions specified must be positive.)  The optional
parameter \verb+name+ allows a name to be specified for the information
set; by default it is labeled by the empty string.  The newly created
information set is returned.
\ed

\item
\protect \large \begin{verbatim}
NewNfg[dim->LIST(INTEGER), {rational->BOOL}] =: NFG
\end{verbatim}\normalsize

\bd
Creates a new normal form game with dimensionality \verb+dim+.
By default, the payoffs and probabilities associated with the game will
be stored as {\tt FLOAT}.  If the \verb+rational+ parameter is specified
and is \verb+True+, these values will be stored as {\tt RATIONAL}.
No initialization of the payoffs of the game is done.
Returns the newly created game.
\ed

\item
\protect \large \begin{verbatim} 
NewOutcome[efg<->EFG, {name->TEXT}] =: OUTCOME
\end{verbatim}\normalsize

\bd
Defines a new outcome in the extensive form game \verb+efg+.
By default the outcome is named with the empty string; the optional parameter
\verb+name+, if specified, gives the name of the new outcome.  Returns the
newly created outcome.
\item
[See also:] {\tt DeleteOutcome}.
\ed

\item
\protect \large \begin{verbatim}
NewPlayer[efg<->EFG, {name->TEXT}] =: EFPLAYER 
\end{verbatim}\normalsize

\bd
Defines a new player in the extensive form game \verb+efg+.
By default the player is named with the empty string; the optional parameter
\verb+name+, if specified, gives the name of the new player.  Returns the
newly created player.
\ed

\item
\protect \large \begin{verbatim}
NewSupport[nfg<->NFG] =: SUPPORT
\end{verbatim}\normalsize

\bd
Creates and returns a new support on the normal form
game \verb+nfg+.  The support contains all strategies for all players.
\item
[See also:] {\tt AddStrategy}, {\tt RemoveStrategy}.
\ed

\item
\protect \large \begin{verbatim}
NextSibling[node->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Returns the next sibling of the node \verb+node+.
\item
[See also:] {\tt PriorSibling}.
\ed

\item
\protect \large \begin{verbatim}
Nfg[efg<->EFG, {time<->FLOAT}] =: NFG
\end{verbatim}\normalsize

\bd
Creates and returns the reduced normal form game equivalent
to the extensive form game \verb+efg+.  The optional parameter \verb+time+,
if specified, contains upon completion the amount of time consumed by
the transformation.
\ed

\item
\protect \large \begin{verbatim} 
Nodes[efg<->EFG] =: LIST(NODE)
\end{verbatim}\normalsize

\bd
Returns the list of nodes in the extensive form game
\verb+efg+ in prefix-traversal order of the tree.
\item
[See also:] {\tt NonterminalNodes}, {\tt NumNodes}, {\tt TerminalNodes}.
\ed

\item
\protect \large \begin{verbatim}
NodeValues[strategy->BEHAV, player->EFPLAYER] =: LIST(FLOAT)
NodeValues[strategy->BEHAV, player->EFPLAYER] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns a list containing the expected payoff to the player \verb+player+
at each node in an extensive form game, given that all players are obeying
the behavioral strategy profile \verb+strategy+.  The list is ordered
in the prefix traversal order of the tree, the same order as returned
by the function {\tt Nodes}.
\item
[See also:] {\tt ActionValues}, {\tt Beliefs}, {\tt InfosetProbs},
{\tt RealizProbs}.
\ed

\item
\protect \large \begin{verbatim} 
NonterminalNodes[efg<->EFG] =: LIST(NODE)
\end{verbatim}\normalsize

\bd
Returns the list of nonterminal nodes in the extensive form
game \verb+efg+ in prefix-traversal order of the tree.
\item
[See also:] {\tt Nodes}, {\tt NumNodes}, {\tt TerminalNodes}.
\ed

\item
\protect \large \begin{verbatim}
Not[x->BOOL] =: BOOL
\end{verbatim}\normalsize

\bd
Returns the boolean inverse of \verb+x+.
\item
[Short forms:] \verb+NOT x+, \verb+!x+.
\ed

\item
\protect \large \begin{verbatim}
NotEqual[x->T, y->T] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the values of \verb+x+ and \verb+y+ are
not equal.
\item
[Short form:] \verb+x != y+.
\item
[See also:] {\tt Equal}.
\ed

\item
\protect \large \begin{verbatim}
NthChar[text->TEXT, n->INTEGER] =: TEXT
\end{verbatim}\normalsize

\bd
Returns a text string of length 1 containing the \verb+n+th
character from the string \verb+text+.  By convention, the first character
in a string is indexed by 1.
\item
[Short form:] \verb+text[[n]]+.
\item
[See also:] {\tt Length}.
\ed

\item
\protect \large \begin{verbatim} 
NthChild[node->NODE, n->INTEGER] =: NODE
\end{verbatim}\normalsize

\bd
Returns the \verb+n+th child of the node \verb+node+.
By convention, the first child of a node is indexed by 1.
\item
[Short form:] \verb+node#n+.
\item
[See also:] {\tt NumChildren}.
\ed

\item
\protect \large \begin{verbatim}
NthElement[list->LIST(T), n->INTEGER] =: T 
\end{verbatim}\normalsize

\bd
Returns the \verb+n+th element of the list \verb+list+.
By convention, the first element of a list is indexed by 1.
\item
[Short form:] \verb+list[[n]]+.
\item
[See also:] {\tt Length}.
\ed

\item
\protect \large \begin{verbatim}
NumActions[infoset->INFOSET] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of actions defined at the information
set \verb+infoset+.
\item
[See also:] {\tt Actions}.
\ed

\item
\protect \large \begin{verbatim}
NumChildren[node->NODE] := INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of children of the node \verb+node+.
\item
[See also:] {\tt NthChild}.
\ed

\item
\protect \large \begin{verbatim}
NumInfosets[player->EFPLAYER] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of information sets belonging to the
player \verb+player+.
\item
[See also:] {\tt Infosets}.
\ed

\item
\protect \large \begin{verbatim}
NumMembers[infoset->INFOSET] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of nodes belonging to the information
set \verb+infoset+.
\item
[See also:] {\tt Members}.
\ed

\item
\protect \large \begin{verbatim}
NumNodes[efg<->EFG] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of nodes in the tree of the extensive form
game \verb+efg+.
\item
[See also:] {\tt Nodes}.
\ed

\item
\protect \large \begin{verbatim}
NumOutcomes[efg<->EFG] =: INTEGER
\end{verbatim} \normalsize

\bd
Returns the number of outcomes defined on the extensive from
game \verb+efg+.
\item
[See also:] {\tt Outcomes}.
\ed

\item
\protect \large \begin{verbatim}
NumPlayers[efg<->EFG] =: INTEGER
\end{verbatim} \normalsize

\bd
Returns the number of players defined on the extensive form
game \verb+efg+.
\item
[See also:] {\tt Players}.
\ed

\item
\protect \large \begin{verbatim}
NumPlayers[nfg<->NFG] =: INTEGER
\end{verbatim} \normalsize

\bd
Returns the number of players defined on the normal form
game \verb+nfg+.
\item
[See also:] {\tt Players}.
\ed

\item
\protect \large \begin{verbatim}
NumStrats[player->NFPLAYER, {support->SUPPORT}] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of strategies for the player \verb+player+
in a normal form game.  By default, the total number of strategies is
returned; if \verb+support+ is specified, the number of strategies
for \verb+player+ in that support is returned instead.
\ed

%--O--

\item 
\protect \large \begin{verbatim}
Or[x->BOOL, y->BOOL] =: BOOL
\end{verbatim} \normalsize
  
\bd
Returns the disjunction of \verb+x+ and \verb+y+.
\item
[Short form:] \verb+x || y+, \verb+x OR y+.
\ed

\item
\protect \large \begin{verbatim}
Outcome[node->NODE] =: OUTCOME
\end{verbatim}\normalsize

\bd
Returns the outcome attached to the node \verb+node+.
\item
[See also:] {\tt AttachOutcome}, {\tt DetachOutcome}.
\ed

\item
\protect \large \begin{verbatim}
Outcomes[efg<->EFG] =: LIST(OUTCOME)
\end{verbatim}\normalsize

\bd
Returns the list of outcomes defined on the extensive form
game \verb+efg+.
\item
[See also:] {\tt DeleteOutcome}, {\tt NewOutcome}, {\tt NumOutcomes}.
\ed

\item
\protect \large \begin{verbatim}
Output[file->TEXT] =: OUTPUT
\end{verbatim}\normalsize

\bd
Opens a new output stream for writing to the file \verb+text+.
\item
[See also:] {\tt SetFormat}, {\tt Write}.
\ed

%--P--

\item
\protect \large \begin{verbatim}
Paren[x->T] =: T
\end{verbatim}\normalsize

\bd
Returns the value passed in \verb+x+.  This is used to control
the order of evaluation of expressions.
\item
[Short form:] \verb+(x)+
\ed

\item
\protect \large \begin{verbatim}
Parent[node->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Returns the parent node of \verb+node+.
\item
[See also:] {\tt IsRoot}.
\ed

\item
\protect \large \begin{verbatim}
Payoff[outcome->OUTCOME] =: LIST(FLOAT)
Payoff[outcome->OUTCOME] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns the payoffs associated with outcome \verb+outcome+
as a list.
\item
[See also:] {\tt SetPayoff}.
\ed

\item
\protect \large \begin{verbatim}
Payoff[nfg<->NFG, list->LIST(INTEGER)] =: LIST(FLOAT)
Payoff[nfg<->NFG, list->LIST(INTEGER)] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns the list of payoffs to all players in the normal form game
\verb+nfg+ in the contingency specified by \verb+list+.
\item
[See also:] {\tt SetPayoff}.
\ed

\item
\protect \large \begin{verbatim}
Payoff[strategy->BEHAV] =: LIST(FLOAT)
Payoff[strategy->BEHAV] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns the payoffs to each player in an extensive form game
if players follow the behavioral strategy profile \verb+strategy+.
\ed

\item
\protect \large \begin{verbatim}
Payoff[strategy->MIXED] =: LIST(FLOAT)
Payoff[strategy->MIXED] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns the payoffs to each player in a normal form game
if players follow the mixed strategy profile \verb+strategy+.
\ed

\item
\protect \large \begin{verbatim}
Player[infoset->INFOSET] =: EFPLAYER
\end{verbatim}\normalsize

\bd
Returns the player who makes the decision at the information
set \verb+infoset+.
\ed

\item
\protect \large \begin{verbatim}
Player[node->NODE] =: EFPLAYER
\end{verbatim}\normalsize

\bd
Returns the player who makes the decision at the node
\verb+node+.
\ed

\item
\protect \large \begin{verbatim}
Players[efg<->EFG] =: LIST(EFPLAYER)
\end{verbatim} \normalsize

\bd
Returns the list of players defined on the extensive form
game \verb+efg+.
\item
[See also:] {\tt NumPlayers}.
\ed

\item
\protect \large \begin{verbatim}
Players[nfg<->NFG] =: LIST(NFPLAYER)
\end{verbatim} \normalsize

\bd
Returns the list of players defined on the normal form
game \verb+nfg+.
\item
[See also:] {\tt NumPlayers}.
\ed

\item 
\protect \large \begin{verbatim}
Plus[x->INTEGER, y->INTEGER] =: INTEGER
Plus[x->FLOAT, y->FLOAT] =: FLOAT
Plus[x->RATIONAL, y->RATIONAL] =: RATIONAL
\end{verbatim} \normalsize

\bd
Returns the sum of \verb+x+ and \verb+y+.
\item
[Short form:] \verb%x + y%
\ed

\item
\protect \large \begin{verbatim}
Plus[x->LIST(T), y->LIST(T)] =: LIST(T)
\end{verbatim}\normalsize

\bd
Returns the concatenation of the lists \verb+x+ and \verb+y+.
\item
[Short form:] \verb%x + y%
\ed

\item 
\protect \large \begin{verbatim}
Plus[x->TEXT, y->TEXT] =: TEXT
\end{verbatim} \normalsize

\bd
Returns the concatenation of the text strings \verb+x+
and \verb+y+.
\item
[Short form:] \verb%x + y%
\ed

\item
\protect \large \begin{verbatim}
PriorSibling[node->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Returns the prior sibling of the node \verb+node+ in its
game tree.
\item
[See also:] {\tt NextSibling}.
\ed


%--Q--


\item
\protect \large \begin{verbatim}
Quit
\end{verbatim}\normalsize

\bd
Exits the command language.
\ed

%--R--

\item
\protect \large \begin{verbatim}
RandomEfg[efg<->EFG, {seed->INTEGER}] =: EFG
\end{verbatim}\normalsize

\bd
Assigns a payoff for each outcome for each player in the
extensive form \verb+efg+ randomly chosen from the uniform distribution
between 0 and 1.  The optional parameter \verb+seed+ may be used to
set the seed of the pseudo-random number generator.  The identical game
randomized with the same seed on the same machine will always produce
the same results.
\ed

\item
\protect \large \begin{verbatim}
RandomNfg[nfg<->NFG, {seed->INTEGER}] =: NFG
\end{verbatim}\normalsize

\bd
Assigns a payoff for each contingency for each player in
the normal form \verb+nfg+ randomly chosen from the uniform distribution
between 0 and 1.  The optional parameter \verb+seed+ may be used to
set hte seed of the pseudo-random number generator.  The identical game
randomized with the same seed on the same machine will always produce
the same results.
\ed

\item
\protect \large \begin{verbatim}
Rational[x->INTEGER] =: RATIONAL
Rational[x->FLOAT] =: RATIONAL
Rational[x->RATIONAL] =: RATIONAL
\end{verbatim} \normalsize

\bd
Converts the value \verb+x+ to the equivalent value of
type {\tt RATIONAL}.
\item
[See also:] {\tt Float}.
\ed

\item
\protect \large \begin{verbatim}
RealizProbs[strategy->BEHAV] =: LIST(FLOAT)
RealizProbs[strategy->BEHAV] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns the list of realization probabilities for the
nodes in an extensive form given that the players are using the behavioral
strategy profile \verb+strategy+.  The list is ordered in the prefix-traversal
of the nodes in the tree, the same order in which the {\tt Nodes} function
returns the nodes in the tree.
\ed

\item
\protect \large \begin{verbatim}
Remove[list->LIST(T), n->INTEGER] =: LIST(T)
\end{verbatim}\normalsize

\bd
Returns a new list consisting of the elements of list
\verb+list+ with the \verb+n+th element removed.  {\tt Remove} does not
modify the input list \verb+list+.
\ed

\item
\protect \large \begin{verbatim}
RemoveStrategy[support->SUPPORT, strategy->STRATEGY] =: SUPPORT
\end{verbatim}\normalsize

\bd
Removes the strategy \verb+strategy+ from the
support \verb+support+.  If \verb+strategy+ is not in the support,
no action is taken.  Returns the modified support.
\item
[See also:] {\tt AddStrategy}, {\tt NewSupport}.
\ed

\item
\protect \large \begin{verbatim}
Reveal[infoset->INFOSET, who->LIST(EFPLAYER), 
       {what->LIST(ACTIONS)}] =: INFOSET
\end{verbatim}\normalsize

\bd
Reveals the list of actions at the given information
set to the indicated players, refining their information partitions at
all information sets in the extensive form game accordingly.  The list
of actions is considered as a set Thus, it is indicated to the
spceified players whether the set of actions in \verb+what+ or its
complement has occurred.  If \verb+what+ is not specified, then all of
the actions in the information set are individually revealed to
the players specified.  
\ed


\item
\protect \large \begin{verbatim}
RootNode[efg<->EFG] =: NODE
\end{verbatim}\normalsize

\bd
Returns the root node of the extensive form game \verb+efg+.
\item
[See also:] {\tt IsRoot}.
\ed

%--S--

\item
\protect \large \begin{verbatim}
SaveEfg[efg<->EFG, file->TEXT] =: BOOL
\end{verbatim}\normalsize

\bd
Writes the extensive form game \verb+efg+ to an external
save file.  Returns the success of the operation.
\item
[See also:] {\tt LoadEfg}.
\ed

\item
\protect \large \begin{verbatim}
SaveNfg[nfg<->NFG, file->TEXT] =: BOOL
\end{verbatim}\normalsize

\bd
Writes the normal form game \verb+nfg+ to an external
save file.  Returns the success of the operation.
\item
[See also:] {\tt LoadNfg}.
\ed

\item
\protect \large \begin{verbatim} 
SetChanceProbs[infoset->INFOSET, probs->LIST(FLOAT)] =: INFOSET
SetChanceProbs[infoset->INFOSET, probs->LIST(RATIONAL)] =: INFOSET
\end{verbatim}\normalsize

\bd
Sets the action probabilities for the information set
\verb+infoset+ to the values given in \verb+probs+.  This is only
meaninful for nodes in information sets belonging to the chance
player.  Returns \verb+infoset+. 
\item
[See also:] {\tt ChanceProbs}.
\ed

\item
\protect \large \begin{verbatim}
SetFormat[output->OUTPUT, width->INTEGER, precis->INTEGER] =: OUTPUT
\end{verbatim}\normalsize

\bd
Sets the formatting style for output on the stream
\verb+output+.  \verb+width+ sets the width of the field for floating
point numbers, and \verb+precis+ sets the number of decimal places shown
for floating point numbers.
\item
[See also:] {\tt Write}.
\ed

\item
\protect \large \begin{verbatim}
SetName[x->ACTION, name->TEXT] =: ACTION
SetName[x<->EFG, name->TEXT] =: EFG
SetName[x->EFPLAYER, name->TEXT] =: EFPLAYER
SetName[x->INFOSET, name->TEXT] =: INFOSET
SetName[x<->NFG, name->TEXT] =: NFG
SetName[x->NFPLAYER, name->TEXT] =: NFPLAYER
SetName[x->NODE, name->TEXT] =: NODE
SetName[x->OUTCOME, name->TEXT] =: OUTCOME
SetName[x->STRATEGY, name->TEXT] =: STRATEGY
\end{verbatim}\normalsize

\bd
Sets the name of the object \verb+x+ to \verb+name+.
Returns the object \verb+x+.
\item
[See also:] {\tt Name}.
\ed

\item
\protect \large \begin{verbatim}
SetOptions[alg->TEXT, param->TEXT, value->T] =: T
\end{verbatim}\normalsize

\item
\protect \large \begin{verbatim}
SetPayoff[outcome->OUTCOME, payoff->LIST(FLOAT)] =: OUTCOME
SetPayoff[outcome->OUTCOME, payoff->LIST(RATIONAL)] =: OUTCOME
\end{verbatim}\normalsize

\bd
Sets the payoffs of the outcome \verb+outcome+ to the
values specified by \verb+payoff+.  It is a run-time error if the type
of the list \verb+payoff+ does not match the type of the game in which
\verb+outcome+ is defined.  Returns \verb+outcome+.
\item
[See also:] {\tt Payoff}.
\ed

\item
\protect \large \begin{verbatim}
SetPayoff[nfg<->NFG, list->LIST(INTEGER),
          payoff->LIST(FLOAT)] =: LIST(STRATEGY)
SetPayoff[nfg<->NFG, list->LIST(INTEGER), 
          payoff->LIST(RATIONAL)] =: LIST(STRATEGY)
\end{verbatim}\normalsize

\bd
Sets the payoffs in the normal form game \verb+nfg+ of the
contingency specified by \verb+list+ to the values specified by
\verb+payoff+.  It is a run-time error if the type of the list
\verb+payoff+ does not match the type of the game in which the
strategies in \verb+list+ are defined.  Returns \verb+list+.
\item
[See also:] {\tt Payoff}.  
\ed

\item
\protect \large \begin{verbatim}
SimpDivSolve[nfg<->NFG,{stopAfter->INTEGER}, 
             {nRestarts->INTEGER}, {leashLength->INTEGER},
             {nEvals<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
\end{verbatim}\normalsize

\bd
Computes a Nash equilibrium to a normal form game based
on a simplicial subdivision algorithm.  The algorithm implemented is
that of \cite{VTH:1987}.  The 
algorithm is a simplicial subdivision algorithm which can start at any
point in the simplex.  The algorithm starts with a given grid size,
follows a path of almost completely labeled subsimplexes, and
converges to a completely labeled sub-simplex that approximates the
solution.  Additional accuracy is obtained by refining the grid size
and restarting from the previously found point.  The idea is that by
restarting at a close approximation to the solution, each successive
increase in accuracy will yield a short path, and hence be quick.

In its pure form, the algorithm is guaranteed to find at least one
mixed strategy equilibrium to any n-person game.  Experience shows
that the algorithm works well, and is acceptably fast for many
moderate size problems.  But in some examples it can be quite slow.
The reason for this is that sometimes after restarting with a refined
grid size, even though the starting point is a good approximation to
the solution, the algorithm will go to the boundary of the simplex
before converging back to a point that is close to the original
starting point.  When this occurs, each halving of the grid size will
take twice as long to converge as the previous grid size.  If a high
degree of accuracy is required, or if the normal form is large, this
can result in the algorithm taking a long time to converge.

In order to combat the above difficulty, a parameter 'leash' has been
added to the algorithm which places a limit on the distance which the
algorithm can wander from the restart point. (Setting this parameter
to 0 results in no limit, and gives the pure form of the algorithm.)
With this parameter set to a non trivial value, the algorithm is no
longer guaranteed to converge, and setting small values of the
parameter will sometimes yield lack of convergence.  However,
experience shows that values of the parameter on the order of 10
generally do not destroy convergence, and yield much faster
convergence.

\item
[Return value:] The list of equilibria found.
\item
[Required parameters:]\hfil\null

\bd
\item
[nfg:] The game in normal form on which the operation will be
performed.
\ed

\item
[Optional parameters:]\hfil\null
	
\bd
\item
[stopAfter:] Maximum number of equilibria to find. Default is 1.  
\item 
[nRestarts:] Number of restarts.  At each restart the mesh of the
triangulation is halved.  So this parameter determines the final mesh
by the formula ${1/2}^{ndivs}$.
\item
[leashLength:] Sets the leashlength. Default is 0, which results in no
constraint, or no leash.  
\item
[time:] Returns the elapsed time for the operation.
\ed
\ed

\item
\protect \large \begin{verbatim}
StartWatch[] =: FLOAT
\end{verbatim}\normalsize

\bd
Starts the system stopwatch running.  If the stopwatch
is already running, {\tt StartWatch} has no effect.  Returns the amount
of time since the stopwatch was started.
\item
[See also:] {\tt ElapsedTime}, {\tt IsWatchRunning}, {\tt StopWatch}.
\ed

\item
\protect \large \begin{verbatim}
Strategies[player->NFPLAYER, {support->SUPPORT}] =: LIST(STRATEGY)
\end{verbatim}\normalsize

\bd
Returns the list of strategies from which player \verb+player+ may choose
in a normal form game.  If \verb+support+ is unspecified, returns the
player's full complement of strategies; else returns the list of strategies
in the support for the player.
\ed

\item
\protect \large \begin{verbatim}
StopWatch[] =: FLOAT
\end{verbatim}\normalsize

\bd
Stops the system stopwatch.  If the stopwatch was not
running, {\tt StopWatch} has no effect.  Returns the amount of time
on the stopwatch.
\item
[See also:] {\tt ElapsedTime}, {\tt IsWatchRunning}, {\tt StartWatch}.
\ed

%--T--

\item
\protect \large \begin{verbatim} 
TerminalNodes[efg<->EFG] =: LIST(NODE)
\end{verbatim}\normalsize

\bd
Returns the list of terminal nodes in the extensive form
game \verb+efg+ in prefix-traversal order.
\item
[See also:] {\tt Nodes}, {\tt NonterminalNodes}.
\ed

\item
\protect \large \begin{verbatim}
Text[x->INTEGER] =: TEXT
Text[x->FLOAT] =: TEXT
Text[x->RATIONAL] =: TEXT
Text[x->TEXT] =: TEXT
\end{verbatim} \normalsize

\bd
Converts the object \verb+x+ into the equivalent text object.
\item
[See also:] {\tt Float}, {\tt Rational}.
\ed

\item 
\protect \large \begin{verbatim}
Times[x->FLOAT, y->FLOAT] =: FLOAT
Times[x->INTEGER, y->INTEGER] =: INTEGER
Times[x->RATIONAL, y->RATIONAL] =: RATIONAL
\end{verbatim} \normalsize
  
\bd
Computes the product of \verb+x+ and \verb+y+.
\item
[Short form:] \verb+x * y+
\ed

%--U--

\item
\protect \large \begin{verbatim}
UnAssign[x<->T] =: T
\end{verbatim}\normalsize

\bd
Undefines the variable referenced by \verb+x+.  Returns the
last value of the variable.
\item
[See also:] {\tt Assign}.
\ed

%--V--

%--W--

\item 
\protect \large \begin{verbatim}
While[test, statements]
\end{verbatim} \normalsize
  
\bd
If test is True, evaluates the statement list consisting of
\verb+do+ followed by itself.  If test fails, evaluates the empty
statement list.
\item
[See also:] \verb+For+.
\ed

\item
\protect \large \begin{verbatim}
Write[output->OUTPUT, x->BEHAV] =: OUTPUT 
Write[output->OUTPUT, x->BOOL] =: OUTPUT 
Write[output->OUTPUT, x<->EFG] =: OUTPUT
Write[output->OUTPUT, x->FLOAT] =: OUTPUT
Write[output->OUTPUT, x->INTEGER] =: OUTPUT
Write[output->OUTPUT, x->MIXED] =: OUTPUT
Write[output->OUTPUT, x<->NFG] =: OUTPUT
Write[output->OUTPUT, x->RATIONAL] =: OUTPUT
Write[output->OUTPUT, x->TEXT, {quoted->BOOL}] =: OUTPUT
\end{verbatim}\normalsize

\bd
Does a formatted write of the object \verb+x+ to the
output stream \verb+output+.  The optional parameter \verb+quoted+ to
the {\tt TEXT} version, if specified as \verb+True+, controls whether
the text string is surronded by explicit double-quotes in the output
file; the default is \verb+False+.
\item
[See also:] {\tt Output}, {\tt SetFormat}
\ed

%--X--

%--Y--

%--Z--

\end{itemize}
\bibliographystyle{chicagob}
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{gambit}
\end{document}
