Gambit Command Language


General Overview

The general purpose of the language is to allow the user to perform a series of
operations and procedures on games in extensive or normal form through a set of
commands.  The games can be randomly generated by a procedure within the
program, read into the program from external files, or created in extensive
form using the language.  Games created or contained in the extensive form can
be transformed into the normal form using a procedure within the program.

The language consists of a series of statements, each ending in a semi-colon
or carriage return.  A carriage return will not be interpreted as the end of a
statement, however, if there are unmatched parentheses or brackets.  For
example, the following two lines are interpreted as one statement:

	Output[1,
	2]

If both lines are followed by a carriage return, the statement will generate
the line of output: 

	1, 2

The user has the option of creating a text file containing a series of commands
which can then be run together, as a program, by the language.  The output of 
such a program can be directed either to the screen or to a file specified by 
the user.  A text file can be read by the language as a program by placing an 
input file command "<" followed by the name of the file, following the command 
which enters the command language.  By using an output file command ">" 
followed by the name of a previously non-existent file, the user can direct the
output of the command language to an external text file.  For example:

	> gcl_sun < input.gcl > output.out


Output

Output can be produced by a program or command using the following command:

	Output[{expression1}, {expression2}, . . . ];

The command produces a line of output containing the values or strings 
specified by the expressions.  An expression can be a variable of any type or 
can evaluate to any value or string which can be contained in a variable.  The 
brackets "{ }" are not a part of the language and are used only to enclose
expressions which are also not a part of the language.


Variables

Variables can be defined and given a value using the ":=" symbol where the name
of the variable is to the left of the symbol and to the right there is an
expression which evaluates to a value of the type desired for the variable.
A variable can be of the following types:

	BOOLEAN		Boolean (evaluates to constants:  True or False)
	INTEGER		Evaluates to an integer of arbitrary size
	RATIONAL	Evaluates to a rational number of arbitrary precision
	TEXT		String of arbitrary length enclosed in quotation marks
	EXTFORM		Game in extensive form (created or read)
	NORFORM		Game in normal form (created or read)
	NODE		A node (may only be a subvariable of an extensive form
			problem)
	DATATYPE	Defines precision (constants:  Float or Rational)

Additionally, variables of type BOOLEAN, INTEGER, RATIONAL, and TEXT can be 
contained in lists of arbitrary length.  Lists are defined similarly to the 
above variables, except that the expression to the right of the ":=" symbol
contains a vector of variables of the same type enclosed in brackets and
separated by commas.  For example:

	BOOLLIST := { BOOLEAN1, BOOLEAN2, . . . . , BOOLEANn }

The elements of a list are indexed sequentially.  Therefore, the ith element of
a list is defined as:

	BOOLLIST[[i]]	which evaluates to a single variable of type BOOLEAN

In the same manner, list variables of type INTLIST, RATLIST, and TEXTLIST can
be created and accessed for variables of type INTEGER, RATIONAL, and TEXT, 
respectively.


Flow Control

Gambit Command Language also contains mechanisms which allow flow control 
within a program in one of three manners.

While[BOOLEAN, {series of commands}];	Evaluates the BOOLEAN expression or
					variable.  As long as it evaluates to
					TRUE, the series of commands are 
					performed.  Each command must be 
					followed by a semi-colon.  If the
					BOOLEAN evaluates to FALSE, the loop
					ends without performing the commands.

If[BOOLEAN, {series of commands}];	Evaluates the BOOLEAN expression once.
					If it evaluates to TRUE, the series of
					commands are performed.  Each command
					must be followed by a semi-colon.  If
					the BOOLEAN evaluates to FALSE, none
					of the commands are performed.

	NOTE:	The While command functions as a loop.  That is, it continues
		to perform the series of commands as long as the expression
		evaluates to TRUE.  The If statement, however, only performs
		the series of commands once if the expression evaluates to
		TRUE.


Procedures

The following is a list of procedures with the operations that they perform
in the Gambit Command Language:

Variable types in all capital letters indicate the type of the required
parameter or return value of the procedure.

The symbol "=:" to the right of a procedure specifies the type of the return
value (if any exists) produced by the procedure.

Paremeters enclosed in brackets "{ }" represent optional parameters which
are not necessary for the procedure to function.

----------

AllLemke[N->NORFORM] =: NORFORM

   -	Description:  Searches for all solutions of the specified normal form
	problem using the Lemke-Howson algorithm.
   -	Return value:  Returns the same problem in normal form.
   -	Required parameters:
	  *  N:  The problem normal form for which solutions are to be found.
   -	Optional parameters:  None.

----------

AppendNode[n->NODE, pl->INTEGER, br->INTEGER] =: NODE

   -	Description:  Appends the number of branches specified to the indicated
	terminal node and places the node in a new information set for the
	given player.
   -	Return value:  Returns the node to which new branches have been 
	appended.
   -	Required parameters:
	  *  n:  The terminal node to which branches are to be added.
	  *  pl:  The player whose information set the node will now belong to.
	     If the player specified is not already defined in the game, the 
	     player is created automatically. 
	  *  br:  The number of branches to be appended to the node.
   -	Optional parameters:  None.

----------

AttachOutcome[n->NODE, outc->INTEGER] =: NODE

   -	Description:  Attaches the indicated outcome to the specified node.  
   -	Return value:  Returns the node to which the outcome is attached.
   -	Required parameters:
	  *  n:  The node to which the outcome is to be attached.  Note that
	     the node need not be terminal in order to have an outcome 
	     attached.
	  *  outc:  The number of the outcome to be attached.  If no outcome 
	     with the indicated number exists, no action is taken.  
   -	Optional parameters:  None.

----------

Car[l->BOOLLIST] =: BOOLEAN
Car[l->INTLIST] =: INTEGER
Car[l->RATLIST] =: RATIONAL
Car[l->TEXTLIST] =: TEXT

   -	Description:  Finds the first element of the specified list.
   -	Return value:  The first element of the list.
   -	Required parameters:
	  *  l:  The list on which the procedure is to be performed.
   -	Optional parameters:  None.

----------

Cdr[l->BOOLLIST] =: BOOLLIST
Cdr[l->INTLIST] =: INTLIST
Cdr[l->RATLIST] =: RATLIST
Cdr[l->TEXTLIST] =: TEXTLIST

   -	Description:  Deletes the first element of the specified list.
   -	Return value:  The list minus the first element.
   -	Required parameters:
	  *  l:  The list on which the procedure is to be performed.
   -	Optional parameters:  None.

----------

Contains[e->BOOLEAN, l->BOOLLIST] =: BOOLEAN
Contains[e->INTEGER, l->INTLIST] =: BOOLEAN
Contains[e->RATIONAL, l->RATLIST] =: BOOLEAN
Contains[e->TEXT, l->TEXTLIST] =: BOOLEAN

   -	Description:  Finds whether the specified value is contained in the 
	indicated list.
   -	Return value:  True when the specified value is contained in the list.
   -	Required parameters:
	  *  e:  The value to be searched for.
	  *  l:  The list which is to be searched in.
   -	Optional parameters:  None.

----------

CopyTree[n->NODE, to->NODE] =: NODE

   -	Description:  Copies the subtree rooted at the specified node to the 
	indicated node.
   -	Return value:  XXXX.
   -	Required parameters:
	  *  n:  The node at which the subtree to be copied is rooted.
	  *  to:  The node to which the subtree is to be copied.
   -	Optional parameters:  None.

----------

DeleteAction[n->NODE, br->INTEGER] =: NODE

   -	Description:  Deletes the indicated action number from the information
	set containing the specified node.
   -	Return value:  The given node.
   -	Required parameters:
	  *  n:  The node belonging to the information set from which the 
	     action is to be deleted.
	  *  br:  The number of the branch to be deleted.
   -	Optional parameters:  None.

----------

DeleteNode[n->NODE, keep->INTEGER] =: NODE

   -	Description:  Deletes the indicated node from the tree.  The specified
	child of the deleted node is kept and replaces the node in its spot in
	the tree.  The subtrees associated with all other children of the 
	deleted node are deleted.
   -	Return value:  The node which replaces the deleted node.
   -	Required parameters:
	  *  n:  The node to be deleted.
	  *  keep:  The child of the deleted node which is to be kept.
   -	Optional parameters:  None.

----------

DeleteTree[n->NODE] =: NODE

   -	Description:  Deletes the subtree rooted at the specified node.  This 
	node then becomes a terminal node.
   -	Return value:  The indicated node which is now a terminal node.
   -	Required parameters:
	  *  n:  The node where the subtree to be deleted is rooted.
   -	Optional parameters:  None.

----------

DetachOutcome[n->NODE] =: NODE

   -	Description:  Sets the outcome attached to the specified node to the 
	null outcome.
   -	Return value:  The indicated node.
   -	Required parameters:
	  *  n:  The node whose outcome is to be detached.
   -	Optional parameters:  None.

----------

ElimAllDom[N->NORFORM, {strong->BOOLEAN}, {time<->RATIONAL}, {output->TEXT}] 
	=: INTEGER

   -	Description:  Iteratively eliminates dominated strategies for all 
	players.
   -	Return value:  The number of the new strategy set.  The original full
	strategy set is numbered 1.  Each iteration creates a new strategy set
	with an integer value one greater than that of the previous strategy 
	set.  Therefore, if no dominated strategies are found, the return value
	is equal to 1.
   -	Required parameters:
	  *  N:  The problem in normal form for which dominated strategies are
	     to be eliminated.
   -	Optional parameters:
	  *  strong:  Determines the type of dominance used.  The default value
	     is False, which signifies that weak dominance is used.  If 
	     `strong` is specified to be True, strong dominance is used.  
	  *  time:  Returns the elapsed time for the operation.
	  *  output:  Redirects the output of the procedure to a specified 
	     file.  Directing output to ``/dev/null'' under Unix turns output
	     off.  By default, it directs output to the screen.

----------

ElimDom[N->NORFORM, {pl->INTLIST}, {strong->BOOLEAN}, {time<->RATIONAL},
	{output->TEXT}] =: INTEGER

   -	Description:  Performs one iteration of eliminating dominated 
	strategies for the list of players specified.  
   -	Return value:  The number of the new strategy set.  The original full
	strategy set is numbered 1.  Each iteration creates a new strategy set
	with an integer value one greater than that of the previous strategy 
	set.  Therefore, if no dominated strategies are found, the return value
	is equal to 1.
   -	Required paremeters:
	  *  N:  The problem in normal form for which dominated strategies are
	     to be eliminated.
   -	Optional parameters:
	  *  pl:  Specifies the list of players for which the procedure is to
	     be performed.  If unspecified, it defaults to all players. 
 	  *  strong:  Determines the type of dominance used.  The default value
	     is False, which signifies that weak dominance is used.  If 
	     `strong` is specified to be True, strong dominance is used.  
	  *  time:  Returns the elapsed time for the operation.
	  *  output:  Redirects the output of the procedure to a specified 
	     file.  Directing output to ``/dev/null'' under Unix turns output
	     off.  By default, it directs output to the screen.

----------

EfgToNfg[E->EXTFORM, {time<->RATIONAL}] =: NORFORM

   -	Description:  Converts a problem in extensive form to the same problem
	as a normal form game.
   -	Return value:  The new normal form game.  
   -	Required parameters:
	  *  E:  The problem in extensive form to be converted to extensive 
	     form.
   -	Optional parameters:
	  *  time:  Returns the elapsed time for the operation.

----------

GetActionName[n->NODE, br->INTEGER] =: TEXT

   -	Description:  Finds the name assigned to the action corresponding to 
	the indicated branch of the specified node.
   -	Return value:  The name of the action.
   -	Required parameters:
	  *  n:  The node at which the action to be found exists.
	  *  br:  The branch which corresponds to the action to be found.
   -	Optional parameters:  None.

----------

GetInfosetName[n->NODE] =: TEXT

   -	Description:  Finds the name of the information set to which the 
	specified node belongs.
   -	Return value:  The name of the information set.
   -	Required parameters:
	  *  n:  The node which belongs to the information set to be found.
   -	Optional parameters:  None.

----------

GetNextSibling[n->NODE] =: NODE

   -	Description:  Finds the next sibling of the specified node.
   -	Return value:  The node which is the next sibling of the specified 
	node.
   -	Required parameters:
	  *  n:  The node for which the next sibling is to be found.
   -	Optional parameters:  None.

----------

GetOutcome[E->EXTFORM, outc->INTEGER] =: RATLIST

   -	Description:  Finds the vector of payoffs to the players for the 
	outcome with the indicated number in the specified problem in extensive
	form.
   -	Return value:  The vector of payoffs corresponding to the specified 
	outcome.  If the outcome is not defined, the procedure returns the 
	empty list.
   -	Required parameters:
	  *  E:  The problem in extensive form for which the outcome is to be
	     found.
	  *  outc:  The number assigned to the outcome for which the payoff 
	     vector will be returned.
   -	Optional paramteters:  None.

---------

GetOutcomeName[E->EXTFORM, outc->INTEGER] =: TEXT

   -	Description:  Finds the name of the specified outcome in the indicated
	problem in extensive form.  If the outcome is not defined, an error is
	given.
   -	Return value:  The name assigned to the indicated outcome.  By default,
	the name of an outcome is the empty string.
   -	Required parameters:
	  *  E:  The problem in extensive form for which the outcome name is to
	     be found.
	  *  outc:  The number assigned to the outcome whose name will be 
	     returned.
   -	Optional parameters:  None.

----------

GetPlayerName[E->EXTFORM, pl->INTEGER] =: TEXT

   -	Description:  Finds the name of the indicated player in the given 
	problem in extensive form.
   -	Return value:  The name assigned to the indicated player.  If the 
	indicated player has not been assigned a name or does not exist, the
	procedure returns the empty string.
   -	Required parameters:
	  *  E:  The problem in extensive form for which the player name is to
	     be found.
	  *  pl:  The number assigned to the player whose name will be 
	     returned.
   -	Optional parameters:  None.

----------

GetPriorSibling[n->NODE] =: NODE

   -	Description:  Finds the prior sibling of the specified node.
   -	Return value:  The node which is the prior sibling of the specified 
	node.
   -	Required parameters:
	  *  n:  The node for which the prior sibling is to be found.
   -	Optional parameters:  None.

----------

GetTitle[E->EXTFORM] =: TEXT

   -	Description:  Finds the title of the indicated problem in extensive 
	form.
   -	Return value:  The title of the indicated extensive form problem.  If
	the title has not been assigned, the empty string is returned.
   -	Required parameters:
	  *  E:  The problem in extensive form whose title is to be found.
   -	Optional parameters:  None.

----------

Gobit[N->NORFORM, {nequilib->INTEGER}, {type->INTEGER},
	{maxitsDFP->INTEGER}, {maxitsBrent->INTEGER}, {minLam->RATIONAL},
	{maxLam->RATIONAL}, {delLam->RATIONAL}, {tolDFP->RATIONAL},
	{tolBrent}->RATIONAL}, {time<->RATIONAL}, {output->TEXT}] =: INTEGER

   -	Description:  Computes the Gobit solution for the specified problem in
	normal form.  
   -	Return value:  XXXX.
   -	Required parameters
	  *  N:  The problem in normal form for which the Gobit solution is to
	     be found.
   -	Optional parameters:
	  *  nequilib:  Sets the number of equilibria to find.  Has a default 
	     value of 1.  
	  *  type:   XXXX.  
	  *  maxitsDFP:  XXXX.
	  *  maxitsBrent:  Sets the maximum number of iterations in Brent and 
	     has a default value of XXXX.  
	  *  minLam:  Sets the minimum value of Lambda.  Has a default value of
	     0.01.
	  *  maxLam:  Sets the maximum value of Lambda.  Has a default value of
	     30.
	  *  delLam:  Specifies the rate at which the value of Lambda changes.
	     Has a default value of 1.01.
	  *  tolDFP:  XXXX .  Has a default value of 1.0E-10.  
	  *  tolBrent:  XXXX .
	  *  time:  Returns the elapsed time for the operation.
	  *  output:  Can be used to redirect the output of this procedure to a
	     file.  Directing output to ``/dev/null'' under Unix turns output 
	     off.  By default, output is directed to the screen.

----------

HasOutcome[E->EXTFORM, outc->INTEGER] =: BOOLEAN

   -	Description:  Finds whether or not the specified problem in extensive 
	form contains an outcome with the given number.  
   -	Return value:  True only when there exists an outcome with the given 
	number in the specified problem.  Returns False otherwise.
   -	Required parameters:
	  *  E:  The problem in extensive form which is to be searched for the
	     outcome.
	  *  outc:  The number of the outcome which is to be searched for.
   -	Optional parameters:  None.

----------

IsWatchRunning[] =: BOOLEAN

   -	Description:  Finds whether or not the system stopwatch is currently
	running.
   -	Return value:  True only if the system stopwatch is currently running.
	Returns False otherwise.
   -	Required parameters:  None.
   -	Optional parameters:  None.

----------

Lemke[N->NORFORM] =: NORFORM

   -	Descprition:  Searches for one solution of the specified normal form 
	game specified using the Lemke-Howson algorithm.  
   -	Return value:  The same problem in normal form.	
   -	Required parameters:
	  *  N:  The problem in normal form for which the solution is to be 
	     searched.
   -	Optional parameters:  None.

----------

Length[l->BOOLLIST] =: INTEGER
Length[l->INTLIST] =: INTEGER
Length[l->RATLIST] =: INTEGER
Length[l->TEXTLIST] =: INTEGER

   -	Description:  Finds the number of elements in the specified list.
   -	Return value:  The number of elements found in the list.
   -	Required parameters:
	  *  l:  The list for which the number of elements is to be found.
   -	Optional parameters:  None.

----------

MergeInfosets[n->NODE, to->NODE] =: NODE

   -	Description:  Moves all the nodes contained in the information set 
	which contains the node first specified to the information to which the
	second node indicated belongs.
   -	Return value:  XXXX .
   -	Required parameters:
	  *  n:  The node which belongs to the information set whose nodes are
	     to be moved to the second information set.
	  *  to:  The node which belongs to the information set to which all
	     the nodes from the first information set are to be moved.
   -	Optional parameters:  None.

----------

NewEfg[] =: EXTFORM

   -	Description:  Allocates and returns a new extensive form game.
   -	Return value:  The newly allocated problem in extensive form.
   -	Required parameters:  None.
   -	Optional parameters:  None.

----------

NewOutcome[E->EXTFORM, {outc->INTEGER}] =: INTEGER

   -	Description:  Creates and assigns a number to a new outcome within the
	specified problem in extensive form.  
   -	Return value:  The number of the newly created outcome.  The optional 
	parameter 'outc' allows the user to specify the number given to the new
	outcome created.  If 'outc' is not specified, the new outcome is 
	assigned the lowest positive number for which no outcome is defined.  
	If the number specified by 'outc' already exists as an outcome, no 
	action is taken and the procedure returns a value of zero.
   -	Required parameters:
	  *  E:  The problem in extensive form for which a new outcome is to
	     be created.
   -	Optional parameters:
	  *  outc:  Allows the user to specify the number given to the new 
	     outcome created.  If not specified, the new outcome is assigned
	     the lowest positive number for which no otcome is defined.  If the
	     number specified already exists as an outcome, no action is taken
	     and the procedure returns a value of zero.

----------

PureNash[N->NORFORM, {num->INTEGER}, {time<->RATIONAL}, {output->TEXT}]
	 =: INTEGER

   -	Description:  Finds the weak pure strategy Nash equilibria in the 
	specified normal form game.  
   -	Return value:  The number of equilibria found.  The optional parameter 
	'num' allows the user to set the maximum number of Nash equilibria to 
	find and has a default value of 1.
   -	Required parameters:
	  *  N:  The problem in normal form for which the weak pure strategy
	     Nash equilibria are to be found.
   -	Optional parameters:
	  *  num:  Allows the user to set the maximum number of Nash equilibria
	     to find.  Has a default value of 1.
	  *  time:  Returns the elapsed time for the operation.
	  *  output:  Can be used to redirect the output of this procedure to a
	     file.  Directing output to ``/dev/null'' under Unix turns output 
	     off.  By default, output is directed to the screen.  

----------

Quit

   -	Description:  Exits the command language.
   -	Return value:  None.
   -	Required parameters:  None.
   -	Optional parameters:  None.

----------

RandomNfg[dim->INTLIST, {seed->INTEGER}] =: NORFORM

	Constructs a new problem in normal form of the specified
dimensionality.  If a value is specified for the optional parameter 'seed',
the random number generator is reseeded with the given integer.

----------

ReadEfgFile[file->TEXT] =: EXTFORM

	Creates a new problem whose contents are the extensive form game
stored in the given file.

----------

ReadNfgFile[file->TEXT, {type->DATATYPE}] =: NORFORM

	Creates a new problem whose contents are the normal form game stored
in the given file.  The file is read as a floating-point normal form unless
otherwise specified by the user.

----------

RootNode[E->EXTFORM, {game->INTEGER}] =: NODE

	Returns, as a variable of type NODE, the root node of game number 
`game` in the specified problem.  If 'game' is not specified, the first game is
used by default.

----------

Run[TEXT]

	Includes the commands in the file specified by the string TEXT as
commands in the running GCL program.  TEXT may be any legal expression
evaluating to type TEXT.  The program treats the command as if it were
replaced by the contents of the file.

----------

SetActionName[n->NODE, br->INTEGER, name->TEXT] =: NODE

	Sets the name of the branch number specified by 'br' of the indicated 
node to the name given.

----------

SetInfosetName[n->NODE, name->TEXT] =: NODE

	Assigns the name given by 'name' to the information set to which the 
node indicated by 'n' belongs.

----------

SetOutcome[E->EXTFORM, outc->INTEGER, value->INTLIST] =: EXTFORM
SetOutcome[E->EXTFORM, outc->INTEGER, value->RATLIST] =: EXTFORM

	Sets the value of the outcome indicated by `outc` in the give problem 
in extensive form, to the vector specified by the parameter 'value'.  The 
length of `value` must match the number of players defined in the problem.  If
no outcome with the given number exists, then it is created.  Returns the 
modified problem in extensive form.


SetOutcome[E->EXTFORM, outc->INTEGER, pl->INTEGER, value->INTEGER] =: EXTFORM
SetOutcome[E->EXTFORM, outc->INTEGER, pl->INTEGER, value->RATIONAL] =: EXTFORM

	Sets the payoff to the player indicated by 'pl' of the outcome whose 
number is indicated by `outc` in the given problem in extensive form to the
given value.  If no outcome with the given number exists, no action is 
performed. 

----------

SetOutcomeName[E->EXTFORM, outc->INTEGER, name->TEXT] =: EXTFORM

	Assigns the outcome with the specified number the title given by 
'name'.  Returns the original extensive form problem with the outcome name 
assigned.

----------

SetPlayerName[E->EXTFORM, pl->INTEGER, name->TEXT] =: EXTFORM

	Assigns the player with the specified number the namer given by 'name'.
Returns the original extensive form problem with the player name assigned.

----------

SetTitle[E->EXTFORM, title->TEXT] =: EXTFORM

	Assigns the title specified by `title` to the problem in extensive form
given by 'E'.  Returns the problem with the title assigned.

----------

StartWatch[] =: INTEGER

	Starts the system stopwatch.  The return value is uninteresting.

----------

StopWatch[] =: INTEGER

	Stops the system stopwatch.  The return value is uninteresting.

----------

WriteEfgFile[E->EXTFORM, file->TEXT] =: EXTFORM

	Writes the given extensive form to the specified file.  Returns the
same extensive form.

----------

WriteNfgFile[N->NORFORM, file->TEXT] =: NORFORM

	Writes the given normal form to the specified file.  Returns the
same normal form.

----------





























