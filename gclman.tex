Gambit Command Language


General Overview

The general purpose of the language is to allow the user to perform a series of
operations and procedures on games in extensive or normal form through a set of
commands.  The games can be randomly generated by a procedure within the
program, read into the program from external files, or created in extensive
form using the language.  Games created or contained in the extensive form can
be transformed into the normal form using a procedure within the program.

The language consists of a series of statements, each ending in a semi-colon.
The user has the option of creating a text file containing a series of
commands which can then be run together, as a program, by the language.  The
output of such a program can be directed either to the screen or to a file
specified by the user.  A text file can be read by the language as a program
by placing an input file command "<" followed by the name of the file, 
following the command which enters the command language.  By using an output
file command ">" followed by the name of a previously non-existent file, the
user can direct the output of the command language to an external text file.
For example:

> gcl_sun < input.gcl > output.out


Output

Output can be produced by a program or command using the following command:

	Output[{expression1}, {expression2}, . . . ];

The command produces a line of output containing the values or strings 
specified by the expressions.  An expression can be a variable of any type or 
can evaluate to any value or string which can be contained in a variable.  The 
brackets "{ }" are not a part of the language and are used only to enclose
expressions which are also not a part of the language.


Variables

Variables can be defined and given a value using the ":=" symbol where the name
of the variable is to the left of the symbol and to the right there is an
expression which evaluates to a value of the type desired for the variable.
A variable can be of the following types:

	BOOLEAN		Boolean (evaluates to constants:  True or False)
	INTEGER		Evaluates to an integer of arbitrary size
	RATIONAL	Evaluates to a rational number of arbitrary precision
	TEXT		String of arbitrary length enclosed in quotation marks
	EXTFORM		Game in extensive form (created or read)
	NORFORM		Game in normal form (created or read)
	NODE		A node (may only be a subvariable of an extensive form
			problem)
	DATATYPE	Defines precision (constants:  Float or Rational)

Additionally, variables of type BOOLEAN, INTEGER, RATIONAL, and TEXT can be 
contained in lists of arbitrary length.  Lists are defined similarly to the 
above variables, except that the expression to the right of the ":=" symbol
contains a vector of variables of the same type enclosed in brackets and
separated by commas.  For example:

	BOOLLIST := { BOOLEAN1, BOOLEAN2, . . . . , BOOLEANn }

The elements of a list are indexed sequentially.  Therefore, the ith element of
a list is defined as:

	BOOLLIST[[i]]	which evaluates to a single variable of type BOOLEAN

In the same manner, list variables of type INTLIST, RATLIST, and TEXTLIST can
be created and accessed for variables of type INTEGER, RATIONAL, and TEXT, 
respectively.


Flow Control

Gambit Command Language also contains mechanisms which allow flow control 
within a program in one of three manners.

While[BOOLEAN, {series of commands}];	Evaluates the BOOLEAN expression or
					variable.  As long as it evaluates to
					TRUE, the series of commands are 
					performed.  Each command must be 
					followed by a semi-colon.  If the
					BOOLEAN evaluates to FALSE, the loop
					ends without performing the commands.

If[BOOLEAN, {series of commands}];	Evaluates the BOOLEAN expression once.
					If it evaluates to TRUE, the series of
					commands are performed.  Each command
					must be followed by a semi-colon.  If
					the BOOLEAN evaluates to FALSE, none
					of the commands are performed.

	NOTE:	The While command functions as a loop.  That is, it continues
		to perform the series of commands as long as the expression
		evaluates to TRUE.  The If statement, however, only performs
		the series of commands once if the expression evaluates to
		TRUE.


The following is a list of procedures with the operations that they perform
in the Gambit Command Language:

Variable types in all capital letters indicate the type of the required
parameter or return value of the procedure.

The symbol "=:" to the right of a procedure specifies the type of the return
value (if any exists) produced by the procedure.

Paremeters enclosed in brackets "{ }" represent optional parameters which
are not necessary for the procedure to function.


ElimAllDom[N->NORFORM, {strong->BOOLEAN}, {time<->RATIONAL}] =: INTEGER
	Iteratively eliminates dominated strategies for all players.  The 
optional `strong` parameter determines the type or dominance used.  The
default value is False, which signifies that weak dominance is used.  If 
`strong` is specified to be True, strong dominance is used.  Returns the
number of the new strategy set.  (The original full strategy set is 
numbered 1.  Each iteration creates a new strategy set with an integer value
one greater than that of the previous strategy set.  Therefore, if no
dominated strategies are found, ElimAllDom returns a value of 1.)  The
optional parameter 'time' returns the elapsed time for the operation.

----------

ElimDom[N->NORFORM, {pl->INTLIST}, {strong->BOOLEAN}, {time<->RATIONAL}] 
	=: INTEGER

	Performs one iteration of eliminating dominated strategies for the
list of players specified.  If unspecified, the optional parameter 'pl'
defaults to all players.  The optional `strong` parameter determines the 
type of dominance used.  The default value is False, which signifies that 
weak dominance is used.  If `strong` is specified to be True, strong
dominance is used.  Returns the number of the new strategy set.  (The
original full strategy set is numbered 1.  Each iteration creates a new
strategy set with an integer value one greater than that of the previous 
strategy set.  Therefore, if no dominated strategies are found, ElimDom 
returns a  value of 1.)  The optional parameter 'time' returns the elapsed
time for the operation.

----------

EfgToNfg[E->EXTFORM, {time<->RATIONAL}] =: NORFORM

	Converts a problem in extensive form to the same problem as a normal
form game and returns the normal form game.  The optional parameter 'time'
returns the elapsed time for the operation.

----------

Gobit[N->NORFORM, {nequilib->INTEGER}, {type->INTEGER},
	{maxitsDFP->INTEGER}, {maxitsBrent->INTEGER}, {minLam->RATIONAL},
	{maxLam->RATIONAL}, {delLam->RATIONAL}, {tolDFP->RATIONAL},
	{tolBrent}->RATIONAL}, {time<->RATIONAL}] =: INTEGER

	Computes the Gobit solution for the specified normal form game.  The
optional parameter `nequilib` . . . .


----------

IsWatchRunning[] =: BOOLEAN

	Returns "True" if the system stopwatch is currently running.

----------

PureNash[N->NORFORM, {num->INTEGER}, {time<->RATIONAL}] =: INTEGER

	Finds the pure strategy Nash equilibria in the specified normal form
game.  Returns the number of equilibria found.  The optional parameter 'num'
allows the user to set the maximum number of Nash equilibria to find and has
a default value of 1.  The optional parameter 'time' returns the elapsed 
time for the operation.

----------

Quit

	Exits the command language.

----------

RandomNfg[dim->INTLIST, {seed->INTEGER}] =: NORFORM

	Constructs a new problem in normal form of the specified
dimensionality.  If a value is specified for the optional parameter 'seed',
the random number generator is reseeded with the given integer.

----------

ReadEfgFile[file->TEXT] =: EXTFORM

	Creates a new problem whose contents are the extensive form game
stored in the given file.

----------

ReadNfgFile[file->TEXT, {type->DATATYPE}] =: NORFORM

	Creates a new problem whose contents are the normal form game stored
in the given file.  The file is read as a floating-point normal form unless
otherwise specified by the user.

----------

StartWatch[] =: INTEGER

	Starts the system stopwatch.  The return value is uninteresting.

----------

StopWatch[] =: INTEGER

	Stops the system stopwatch.  The return value is uninteresting.

----------

WriteEfgFile[E->EXTFORM, file->TEXT] =: EXTFORM

	Writes the given extensive form to the specified file.  Returns the
same extensive form.

----------

WriteNfgFile[N->NORFORM, file->TEXT] =: NORFORM

	Writes the given normal form to the specified file.  Returns the
same normal form.

----------





























