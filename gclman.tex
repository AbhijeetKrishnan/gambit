\documentstyle[12pt,widetext]{manual}
\begin{document}

\title{Gambit Command Language}

\section*{General Overview}

The general purpose of the language is to allow the user to perform a series of
operations and procedures on games in extensive or normal form through a set of
commands.  The games can be randomly generated by a procedure within the
program, read into the program from external files, or created in extensive
form using the language.  Games created or contained in the extensive form can
be transformed into the normal form using a procedure within the program.

The language consists of a series of statements, each ending in a semi-colon
or carriage return.  A carriage return will not be interpreted as the end of a
statement, however, if there are unmatched parentheses or brackets.  For
example, the following two lines are interpreted as one statement:

\begin{verbatim}
	Output[1, 2]
\end{verbatim}

If both lines are followed by a carriage return, the statement will generate
the line of output: 

\begin{verbatim}
	1, 2
\end{verbatim}

The user has the option of creating a text file containing a series of commands
which can then be run together, as a program, by the language.  The output of 
such a program can be directed either to the screen or to a file specified by 
the user.  A text file can be read by the language as a program by placing an 
input file command {\tt "<"} followed by the name of the file, following the 
command which enters the command language.  By using an output file command 
{\tt ">"} followed by the name of a file, the user can direct the output of 
the command language to an external text file.  For example:

\begin{verbatim}
	> gcl_sun < input.gcl > output.out
\end{verbatim}

\subsection*{Output}

Output can be produced by a program or command using the following command:

\begin{verbatim}
	Output[{expression1}, {expression2}, . . . ]
\end{verbatim}

The command produces a line of output containing the values or strings 
specified by the expressions.  An expression can be a variable of any type or 
can evaluate to any value or string which can be contained in a variable.  The 
brackets {\tt "{ }"} are not a part of the language and are used only to 
enclose expressions which are also not a part of the language.

\subsection*{Variables}

Variables can be defined and given a value using the {\tt ":="} symbol 
where the name of the variable is to the left of the symbol and to the right 
there is an expression which evaluates to a value of the type desired for 
the variable. A variable can be of the following types:

\medskip

\begin{tabular}{lp}{3in}
BOOLEAN & Boolean (evaluates to constants:  True or False)\\
INTEGER & Evaluates to an integer of arbitrary size \\
RATIONA & Evaluates to a rational number of arbitrary precision\\
TEXT	& String of arbitrary length enclosed in quotation marks\\
EFG	& Game in extensive form (created or read)\\
NFG	& Game in normal form (created or read)\\
NODE	& A node (may only be a subvariable of an extensive form
problem) \\
DATATYPE & Defines precision (constants:  Float or Rational) \\
MIXED	& {Profile of mixed strategies.  Can only be a subvariable of a
normal form problem.  That is, if n is a problem in normal form, a
variable of type MIXED can only be assigned to a subvariable of the
form n.x.}\\
BEHAV	& Profile of behavioral strategies.  Can only be a subvariable
of an extensive form problem.  That is, if e is a problem in extensive
form, a variable of type BEHAV can only be assigned to a subvariable
of the form e.x. \\
\end{tabular}

\medskip

\noindent
Additionally, variables of type  BEHAV, BOOLEAN, INTEGER, MIXED, RATIONAL, and 
TEXT can be contained in lists of arbitrary length.  Variables of type LIST are
defined similarly to the above variables, except that the expression to the 
right of the {\tt ":="} symbol contains a vector of variables of the same 
type enclosed in brackets and separated by commas.  For example:

\begin{verbatim}
	LIST(BOOLEAN) := { BOOLEAN1, BOOLEAN2, . . . . , BOOLEANn }
\end{verbatim}

The elements of a list are indexed sequentially.  Therefore, the ith element of
a list is defined as:

\begin{verbatim}
	LIST(BOOLEAN)[[i]]	which evaluates to a single variable of type 
				BOOLEAN.
\end{verbatim}

\noindent
In the same manner, list variables of type LIST(BEHAV), LIST(INTEGER), 
LIST(MIXED), LIST(RATIONAL), and LIST(TEXT) can be created and accessed for 
variables of type BEHAV, INTEGER, MIXED, RATIONAL, and TEXT, respectively.

\subsection*{Flow Control}

Gambit Command Language also contains mechanisms which allow flow control 
within a program in one of three manners.

\medskip

\begin{tabular}{lp}{3in}
While [BOOLEAN, \{series of commands\}] & Evaluates the BOOLEAN
expression or variable.  As long as it evaluates to TRUE, the series
of commands are performed.  Each command must be followed by a
semi-colon or carriage return.  If the BOOLEAN evaluates to FALSE, the
loop ends without performing the commands.\\
If [BOOLEAN, \{series of commands\}] & Evaluates the BOOLEAN expression
once. If it evaluates to TRUE, the series of commands are performed.
Each command must be followed by a semi-colon or carriage return.  If
the BOOLEAN evaluates to FALSE, none of the commands are performed.\\
If [BOOLEAN, \{series of commands\}], & Evaluates the BOOLEAN expression
once. If it evaluates to TRUE, the first series of commands are
performed.  Each command must be followed by a semi-
colon or carriage return.  If the BOOLEAN evaluates to FALSE, the second
series of commands are performed. \\
\end{tabular}	

\begin{tabular}{lp}{3in}
NOTE: & The While command functions as a loop.  That is, it continues
to perform the series of commands as long as the expression
evaluates to TRUE.  The If statement, however, only performs the
series of commands once if the expression evaluates to TRUE.\\
\end{tabular}

\section*{Procedures}

The following is a list of procedures with the operations that they perform
in the Gambit Command Language:

Variable types in all capital letters indicate the type of the required
parameter or return value of the procedure.

The symbol {\tt "=:"} to the right of a procedure specifies the type of the 
return value (if any exists) produced by the procedure.

Paremeters enclosed in brackets {\tt "{ }"} represent optional parameters which
are not necessary for the procedure to function.

\begin{itemize}

\item
\begin{verbatim}

AppendNode[n->NODE, pl->INTEGER, br->INTEGER] =: NODE

\end{verbatim}

\begin{description}
\item
- Description:  Appends the number of branches specified to the
indicated terminal node and places the node in a new information set
for the given player.
\item
- Return value: Returns the node to which new branches have been appended.
\item
- Required parameters:
\begin{description}
\item
*  n:  The terminal node to which branches are to be added.
\item
*  pl:  The player whose information set the node will now belong to.
If the player specified is not already defined in the game, the player
is created automatically. 
\item
*  br:  The number of branches to be appended to the node.
\end{description}
\item
- Optional parameters:  None.
\end{description}

\item
\begin{verbatim}
AttachOutcome[n->NODE, outc->INTEGER] =: NODE
\end{verbatim}
\begin{description}
\item
- Description:  Attaches the indicated outcome to the specified node.
\item
- Return value:  Returns the node to which the outcome is attached.
\item
- Required parameters:
\begin{description}
\item
*  n:  The node to which the outcome is to be attached.  Note that the
node need not be terminal in order to have an outcome attached.
\item
*  outc:  The number of the outcome to be attached.  If no outcome
with the indicated number exists, no action is taken.  
\end{description}
\item
- Optional parameters:  None.
\end{description}

\end{itemize}

Car[l->LIST(T)] =: T	\\


	For T = BEHAV, BOOLEAN, INTEGER, MIXED, RATIONAL, or TEXT

   -	Description:  Finds the first element of the specified list of type T.
   -	Return value:  Returns a value of type T which is the first element of 
	the list.
   -	Required parameters:
	  *  l:  The list of type T on which the procedure is to be performed.
   -	Optional parameters:  None.

----------

Cdr[l->LIST(T)] =: LIST(T)

	For T = BEHAV, BOOLEAN, INTEGER, MIXED, RATIONAL, or TEXT

   -	Description:  Deletes the first element of the specified list of type 
	T.
   -	Return value:  A list of type T which is the specified list minus its
	first element.
   -	Required parameters:
	  *  l:  The list of type T on which the procedure is to be performed.
   -	Optional parameters:  None.

----------

Cons[l1->LIST(T), l2->LIST(T)] =: LIST(T)

	For T = BEHAV, BOOLEAN, INTEGER, MIXED, RATIONAL, or TEXT

   -	Description:  Concatenates the two lists, placing the second list given
	at the end of the first list.  Note the two lists must be of the same
	type.
   -	Return value:  Returns a new list (of the same type), which is a 
	combination of the two given lists.
   -	Required parameters:
	  *  l1:  The list of type T which is to be placed in front of the
		second list.
	  *  l2:  The list of type T which is to be placed at the end of the
		first list.
   -	Optional parameters:  None.

----------

Contains[e->T, l->LIST(T)] =: BOOLEAN

	For T = BEHAV, BOOLEAN, INTEGER, MIXTRAT, RATIONAL, or TEXT

   -	Description:  Finds whether the specified value of type T is contained 
	in the indicated list of type T.
   -	Return value:  True when the specified value is contained in the list.
   -	Required parameters:
	  *  e:  The value of type T to be searched for.
	  *  l:  The list of type T which is to be searched in.
   -	Optional parameters:  None.

----------

CopyTree[n->NODE, to->NODE] =: NODE

   -	Description:  Copies the subtree rooted at the specified node to the 
	indicated node.
   -	Return value:  XXXX.
   -	Required parameters:
	  *  n:  The node at which the subtree to be copied is rooted.
	  *  to:  The node to which the subtree is to be copied.
   -	Optional parameters:  None.

----------

CrunchNfg[N->NFG] =: NFG

   -	Description:  Creates a new problem in normal form for which the 
	strategies are those of the smallest strategy set of the specified 
	normal form problem and which contains only those payoff elements
	corresponding to those strategies.
   -	Return value:  Returns the new normal form problem.
   -	Required parameters:
	  *  N:  The problem in normal form from which the new normal form 
		problem is to be created.
   -	Optional parameters:  None.

----------

DeleteAction[n->NODE, br->INTEGER] =: NODE

   -	Description:  Deletes the indicated action number from the information
	set containing the specified node.
   -	Return value:  The given node.
   -	Required parameters:
	  *  n:  The node belonging to the information set from which the 
		action is to be deleted.
	  *  br:  The number of the branch to be deleted.
   -	Optional parameters:  None.

----------

DeleteNode[n->NODE, keep->INTEGER] =: NODE

   -	Description:  Deletes the indicated node from the tree.  The specified
	child of the deleted node is kept and replaces the node in its spot in
	the tree.  The subtrees associated with all other children of the 
	deleted node are deleted.
   -	Return value:  The node which replaces the deleted node.
   -	Required parameters:
	  *  n:  The node to be deleted.
	  *  keep:  The child of the deleted node which is to be kept.
   -	Optional parameters:  None.

----------

DeleteTree[n->NODE] =: NODE

   -	Description:  Deletes the subtree rooted at the specified node.  This 
	node then becomes a terminal node.
   -	Return value:  The indicated node which is now a terminal node.
   -	Required parameters:
	  *  n:  The node where the subtree to be deleted is rooted.
   -	Optional parameters:  None.

----------

DetachOutcome[n->NODE] =: NODE

   -	Description:  Sets the outcome attached to the specified node to the 
	null outcome.
   -	Return value:  The indicated node.
   -	Required parameters:
	  *  n:  The node whose outcome is to be detached.
   -	Optional parameters:  None.

----------

DisplayEfg[E->EFG]

   -	Description:  Prints the game tree of the specified extensive form
	problem in outline form.
   -	Return value:  None.
   -	Required parameters:
	  *  E:  The problem in extensive form which is to be displayed.
   -	Optional parameters:  None.

----------

DisplayNfg[N->NFG, {sset->INTEGER}]

   -	Description:  Prints the specified normal form problem as a list of
	contingencies and corresponding payoff vectors.  Uses the last strategy
	set unless otherwise specified.
   -	Return value:  None.
   -	Required parameters:
	  *  N:  The problem in normal form which is to be displayed.
   -	Optional parameters:
	  *  SSET:  The number of the strategy set of the specified normal form
		problem which is to be used in displaying the problem.  If not
		specified, the last (smallest) strategy set is used.

----------

EfgToAfg[E->EFG, {time<->RATIONAL}] =: NFG

   -	Description:  Converts a problem in extensive form to the same problem
	in the corresponding agent normal form.
   -	Return value:  The new agent normal form game.  
   -	Required parameters:
	  *  E:  The problem in extensive form to be converted to agent normal
		form.
   -	Optional parameters:
	  *  time:  Returns the elapsed time for the operation.

----------

EfgToNfg[E->EFG, {time<->RATIONAL}] =: NFG

   -	Description:  Converts a problem in extensive form to the same problem
	as a reduced normal form game.
   -	Return value:  The new normal form game.  
   -	Required parameters:
	  *  E:  The problem in extensive form to be converted to normal form.
   -	Optional parameters:
	  *  time:  Returns the elapsed time for the operation.

----------

ElapsedTime[] =: RATIONAL

   -	Description:  Calculates the time transpired since the last time
	StartWatch[] was used if the system stopwatch is currently running.
	Otherwise, calculates the time elapsed between the last StartWatch[] -
	StopWatch[] match.
   -	Return value:  Returns the time value given by the system stopwatch.
   -	Required parameters:  None.
   -	Optional parameters:  None.

----------

ElimDom[N->NFG, {pl->LIST(INTEGER)}, {strong->BOOLEAN}, {time<->RATIONAL},
	{output->TEXT}, {NIT->INTEGER}] =: INTEGER

   -	Description:  Performs iterated (unless otherwise specified) deletion 
	of dominated strategies for the list of players specified.  
   -	Return value:  The number of the new strategy set.  The original full
	strategy set is numbered 1.  Each iteration creates a new strategy set
	with an integer value one greater than that of the previous strategy 
	set.  Therefore, if no dominated strategies are found, the return value
	is equal to 1.
   -	Required paremeters:
	  *  N:  The problem in normal form for which dominated strategies are
		to be eliminated.
   -	Optional parameters:
	  *  pl:  Specifies the list of players for which the procedure is to
		be performed.  If unspecified, it defaults to all players. 
 	  *  strong:  Determines the type of dominance used.  The default value
		is False, which signifies that weak dominance is used.  If 
		`strong` is specified to be True, strong dominance is used.  
	  *  time:  Returns the elapsed time for the operation.
	  *  output:  Redirects the output of the procedure to a specified 
		file.  Directing output to ``/dev/null'' under Unix turns 
		output off.  By default, it directs output to the screen.
	  *  NIT:  The number of iterations to be performed by the procedure.
		If not specified, it has a default value of zero which means 
		that all dominated strategies are iteratively deleted.

----------

Equal[l1->LIST(T), l2->LIST(T)] =: BOOLEAN

	For T = BEHAV, BOOLEAN, INTEGER, MIXED, RATIONAL, or TEXT

   -	Description:  Determines whether or not all the elements of the two
	lists are equal.
   -	Return value:  Returns True only if all the elements of the two lists
	are equal.
   -	Required parameters:  
	  *  l1:  The first list of type T which is to be compared for 
		equality.
	  *  l2:  The second list of type T which is to be compared for 
		equality.
   -	Optional parameters:  None.

----------

GetActionName[n->NODE, br->INTEGER] =: TEXT

   -	Description:  Finds the name assigned to the action corresponding to 
	the indicated branch of the specified node.
   -	Return value:  The name of the action.
   -	Required parameters:
	  *  n:  The node at which the action to be found exists.
	  *  br:  The branch which corresponds to the action to be found.
   -	Optional parameters:  None.

----------

GetActionProbs[n->NODE] =: LIST(RATIONAL)

   -	Description:  Finds the vector of probabilities for the actions at the
	specified node.  This is only meaninful for nodes in information sets 
	belonging to the player representing chance (player 0).
   -	Return value:  Returns the vector of action probabilities for the node.
   -	Required parameters: 
	  *  n:  The node for which the action probabilities are to be found.
   -	Optional parameters:  None.

----------

GetDominator[N->NFG, pl->INTEGER, st->INTEGER] =: INTEGER

   -	Description:  Determines the number of strategies which dominate the
	specified strategy for the indicated player in the given problem in 
	normal form.
   -	Return value:  Returns the number of strategies which dominate the
	specified strategy.  If the strategy is undominated, returns a value of
	zero.  
   -	Required parameters:
	  *  N:  The problem in normal form in which the specified strategy of
		the indicated player is to be tested for domination.
	  *  pl:  The number corresponding to the player for whom the specified
		strategy is to be tested for domination.
	  *  st:  The number corresponding to the strategy belonging to the 
		indicated player which is to be tested for domination.
   -	Optional parameters:  None.

----------

GetInfosetName[n->NODE] =: TEXT

   -	Description:  Finds the name of the information set to which the 
	specified node belongs.
   -	Return value:  The name of the information set.
   -	Required parameters:
	  *  n:  The node which belongs to the information set to be found.
   -	Optional parameters:  None.

----------

GetNextSibling[n->NODE] =: NODE

   -	Description:  Finds the next sibling of the specified node.
   -	Return value:  The node which is the next sibling of the specified 
	node.
   -	Required parameters:
	  *  n:  The node for which the next sibling is to be found.
   -	Optional parameters:  None.

----------

GetOutcome[E->EFG, outc->INTEGER] =: LIST(RATIONAL)

   -	Description:  Finds the vector of payoffs to the players for the 
	outcome with the indicated number in the specified problem in extensive
	form.
   -	Return value:  The vector of payoffs corresponding to the specified 
	outcome.  If the outcome is not defined, the procedure returns the 
	empty list.
   -	Required parameters:
	  *  E:  The problem in extensive form for which the outcome is to be
		found.
	  *  outc:  The number assigned to the outcome for which the payoff 
		vector will be returned.
   -	Optional paramteters:  None.

---------

GetOutcomeName[E->EFG, outc->INTEGER] =: TEXT

   -	Description:  Finds the name of the specified outcome in the indicated
	problem in extensive form.  If the outcome is not defined, an error is
	given.
   -	Return value:  The name assigned to the indicated outcome.  By default,
	the name of an outcome is the empty string.
   -	Required parameters:
	  *  E:  The problem in extensive form for which the outcome name is to
		be found.
	  *  outc:  The number corresponding to the outcome for which the name 
		will be returned.
   -	Optional parameters:  None.

----------

GetPlayerName[E->EFG, pl->INTEGER] =: TEXT

   -	Description:  Finds the name of the indicated player in the given 
	problem in extensive form.
   -	Return value:  The name assigned to the indicated player.  If the 
	indicated player has not been assigned a name or does not exist, the
	procedure returns the empty string.
   -	Required parameters:
	  *  E:  The problem in extensive form for which the player name is to
		be found.
	  *  pl:  The number assigned to the player whose name will be 
		returned.
   -	Optional parameters:  None.

----------

GetPriorSibling[n->NODE] =: NODE

   -	Description:  Finds the prior sibling of the specified node.
   -	Return value:  The node which is the prior sibling of the specified 
	node.
   -	Required parameters:
	  *  n:  The node for which the prior sibling is to be found.
   -	Optional parameters:  None.

----------

GetStratName[N->NFG, pl->INTEGER, st->INTEGER] =: TEXT

   -	Description:  Finds the name assigned to the specified strategy of the
	indicated player of the given problem in normal form.
   -	Return value:  Returns the name found.  If a name has not been assigned
	to the strategy, the empty string is returned.
   -	Required parameters:
	  *  N:  The problem in normal form in which the name assigned to the 
		specified strategy of the indicated player is to be found.
	  *  pl:  The number corresponding to the player for which the name of
		the indicated strategy is to be found.
	  *  st:  The number corresponding to the strategy of the indicated 
		player for which the name is to be found.
   -	Optional parameters:  None.

----------

GetTitle[E->EFG] =: TEXT

   -	Description:  Finds the title of the indicated problem in extensive 
	form.
   -	Return value:  The title of the indicated extensive form problem.  If
	the title has not been assigned, the empty string is returned.
   -	Required parameters:
	  *  E:  The problem in extensive form whose title is to be found.
   -	Optional parameters:  None.

----------

Gobit[N->NFG, E->EFG, {nequilib->INTEGER}, {type->INTEGER},
	{maxitsOpt->INTEGER}, {maxitsBrent->INTEGER}, {minLam->RATIONAL},
	{maxLam->RATIONAL}, {delLam->RATIONAL}, {tolDFP->RATIONAL},
	{tolBrent}->RATIONAL}, {time<->RATIONAL}, 
	{output->TEXT}, {pxifile->TEXT}] =: INTEGER

   -	Description:  Computes the Gobit solution for the specified problem in
	either extensive or normal form.  
   -	Return value:  XXXX.
   -	Required parameters:  Exactly one of the following
	  *  N:  The problem in normal form for which the Gobit solution is to
		be found.
	  *  E:  The problem in extensive form for which the Gobit solution 
		is to be found.
   -	Optional parameters:
	  *  nequilib:  Sets the number of equilibria to find.  Has a default 
		value of 1.  
	  *  type:   Type of incrementing 
			0 means Lambda_t = Lambda_{t-1} + delLam
			1 means Lambda_t = Lambda_{t-1} * delLam
	  *  maxitsOpt:  Sets the masimum number of iterations to the 
		n-dimensional optimization routine.  Default is 200.
	  *  maxitsBrent:  Sets the maximum number of iterations in
		the 1-dimensional line search.  Default is 100.
	  *  tolOpt:  Sets the tolerance for the n-dimensional
		optimization routine.  Default is 1.0e-10.
	  *  tolBrent:  Sets the tolerance for the 1-dimensional line
		search.  Default is 2.0e-10.
	  *  minLam:  Sets the minimum value of Lambda.  Has a default value of
		0.01.
	  *  maxLam:  Sets the maximum value of Lambda.  Has a default value of
		30.
	  *  delLam:  Specifies the rate at which the value of Lambda changes.
		Has a default value of 1.01.
	  *  time:  Returns the elapsed time for the operation.
	  *  output:  Can be used to redirect the output of this procedure to a
		file.  Directing output to ``/dev/null'' under Unix turns 
		output off.  By default, output is directed to the screen.
	  *  pxifile: Can be used to generate an output file
		compatible for input to pxi
----------

GridSolve[N->NFG, {plev->INTEGER}, {output->TEXT}, {errors->TEXT},
	{minLam->RATIONAL}, {maxLam->RATIONAL}, {delLam->RATIONAL}, 
	{type->INTEGER}, {delp->RATIONAL}, {tol->RATIONAL}, {time<->RATIONAL}]
	 =: INTEGER

   -	Description:  XXXX .
   -	Return value:  XXXX .
   -	Required parameters:
	  *  N:  The problem in normal form which is to be operated on.
   -	Optional parameters:
	  *  plev:  XXXX .
	  *  output:  Can be used to redirect the output of this procedure to a
		file.  Directing output to ``/dev/null'' under Unix turns 
		output off.  By default, output is directed to the screen.
	  *  errors:  XXXX .
	  *  minLam:  Sets the minimum value of Lambda.  Has a default value of
		XXXX .
	  *  maxLam:  Sets the maximum value of Lambda.  Has a default value of
		XXXX .
	  *  delLam:  Specifies the rate at which the value of Lambda changes.
		Has a default value of XXXX .
	  *  type:  XXXX .
	  *  delp:  XXXX .
	  *  tol:  XXXX .
	  *  time:  Returns the elapsed time for the operation.

----------

InsertAction[n->NODE, as->1, br->3] =: NODE

   -	Description:  Inserts the indicated number of actions into the 
	information set containing the specified node.
   -	Return value:  Returns the specified node.
   -	Required parameters:
	  *  n:  The node which belongs to the information set which is to have
		actions inserted into it.
	  *  as:  The number which will correspond to the first inserted
		action.
	  *  br:  The number of actions to be inserted at the specified node.
   -	Optional parameters:  None.

----------

InsertNode[n->NODE, pl->INTEGER, br->INTEGER] =: NODE

   -	Description:  Inserts a new node belonging to the indicated player at 
	the location of the specified node and moves that node to the end of 
	the first branch of the new node.
   -	Return value:  Returns the specified node.
   -	Required parameters:
	  *  n:  The location where the new node is to be inserted.  The node
		currently at this location is then moved to the end of the 
		first branch of the new node.
	  *  pl:  The number corresponding to the player to which the new node
		will belong.  If the player specified is not already defined in
		the game, the player is created automatically.
	  *  br:  The number of branches which the new node will have.
   -	Optional parameters:  None.

----------

IsDomitated[N->NFG, pl->INTEGER, st->INTEGER] =: BOOLEAN

   -	Description:  Determines if the strategy corresponding to the specified
	number for the indicated player is dominated by another strategy in the
	given problem in normal form.  Uses only strategies in the first 
	strategy set.
   -	Return value:  Returns True only if the specified strategy for the 
	given player is dominated.  Returns false otherwise.
   -	Required parameters:
	  *  N:  The problem in normal form in which the specified strategy of
		the indicated player is to be tested for domination.
	  *  pl:  The number corresponding to the player for whom the specified
		strategy is to be tested for domination.
	  *  st:  The number corresponding to the strategy belonging to the 
		indicated player which is to be tested for domination.
   -	Optional parameters:  None.

----------

IsPredecessor[n->NODE, of->NODE] =: BOOLEAN

   -	Description:  Finds whether or not the first node indicated is a 
	predecessor of the second node given.
   -	Return value:  Returns True only if the first node indicated is a
	predecessor of the second node given.
   -	Required parameters:
	  *  n:  The node which, when it is the predecessor of the other node,
		will result in the return value being True.
	  *  of:  The node which, when it is preceeded by the other node, will
		result in the return value being True.
   -	Optional parameters:  None.

----------

IsSuccessor[n->NODE, from->NODE] =: NODE

   -	Description:  Finds whether or not the first node indicated is a 
	successor of the second node given.
   -	Return value:  Returns True only if the first node indicated is a
	successor of the second node given.
   -	Required parameters:
	  *  n:  The node which, when it is a successor of the other node, will
		result in the return value being True.
	  *  of:  The node which, when it is succeeded by the other node, will
		result in the return value being True.
   -	Optional parameters:  None.

----------

IsWatchRunning[] =: BOOLEAN

   -	Description:  Finds whether or not the system stopwatch is currently
	running.
   -	Return value:  True only if the system stopwatch is currently running.
	Returns False otherwise.
   -	Required parameters:  None.
   -	Optional parameters:  None.

----------

JoinInfoset[n->NODE, to->NODE] =: NODE

   -	Description:  Removes the first node specified from the information set
	to which it currently belongs and places it in the information set to
	which the second node given belongs.
   -	Return value:  XXXX .
   -	Required parameters:
	  *  n:  The node which is to be removed from its current information
		set and placed in the information set belonging to the second
		node given.
	  *  to:  The node belonging to the information set to which the first
		node specified will be transfered.
   -	Optional parameters:  None.

----------

LeaveInfoset[n->NODE] =: NODE

   -	Description:  Removes the specified node from the information set to
	which it currently belongs and creates and places it in a new singleton
	information set belonging to the same player.
   -	Return value:  The specified node.
   -	Required parameters:
	  *  n:  The node which is to be removed from the information which it
		currently belongs to.
   -	Optional parameters:  None.

----------

Lemke[N->NFG, {nequilib->INTEGER}, {time<->RATIONAL}] =: LIST(MIXED)

   -	Description:  Searches for one solution of the specified normal form 
	game specified using the Lemke-Howson algorithm.  
   -	Return value:  The list of solutions found.
   -	Required parameters:
	  *  N:  The problem in normal form for which the solution is to be 
		searched.
   -	Optional parameters: 
	  *  nequilib:  Specifies the number of equilibria to find.  If not
		given the default value is zero, which means that all 
		equilibria are to be found.
	  *  time:  Returns the elapsed time for the operation.

----------

Length[l->LIST(T)] =: INTEGER

	For T = BEHAV, BOOLEAN, INTEGER, MIXED, RATIONAL, or TEXT

   -	Description:  Finds the number of elements in the specified list of 
	type T.
   -	Return value:  The number of elements found in the list.
   -	Required parameters:
	  *  l:  The list of type T for which the number of elements is to be 
		found.
   -	Optional parameters:  None.

----------

Liap[N->NFG, {plev->INTEGER}, {output->TEXT}, {errors->TEXT}, 
	{ntries->INTEGER}, {nequilib->INTEGER}, {maxitsOpt->RATIONAL},
	{maxitsBrent->RATIONAL}, {tolOpt->RATIONAL}, {tolBrent->RATIONAL},
	{time<->RATIONAL}] =: LIST(MIXED)

   -	Description:  Searches for equilibria of the specified problem in 
	normal form using the Liapunov algorithm.
   -	Return value:  Returns the list of solutions found.
   -	Required parameters
	  *  N:  The problem in normal form for which the Liapunov solution is 
		to be found.
   -	Optional parameters:
	  *  plev: XXXX .
	  *  output:  Can be used to redirect the output of this procedure to a
		file.  Directing output to ``/dev/null'' under Unix turns 
		output off.  By default, output is directed to the screen.
	  *  errors:  XXXX .
	  *  ntries:  XXXX .
	  *  nequilib:  Sets the number of equilibria to find.  Has a default 
		value of XXXX . 
	  *  maxitsOpt:  XXXX.
	  *  maxitsBrent:  XXXX .
	  *  tolOpt:  XXXX . 
	  *  tolBrent:  XXXX .
	  *  time:  Returns the elapsed time for the operation.

----------

MergeInfosets[n->NODE, to->NODE] =: NODE

   -	Description:  Moves all the nodes contained in the information set 
	which contains the node first specified to the information to which the
	second node indicated belongs.
   -	Return value:  XXXX .
   -	Required parameters:
	  *  n:  The node which belongs to the information set whose nodes are
		to be moved to the second information set.
	  *  to:  The node which belongs to the information set to which all
		the nodes from the first information set are to be moved.
   -	Optional parameters:  None.

---------

MixedToBehav[E->EFG, mp->MIXED] =: BEHAV

   -	Description:  Projects a specified mixed profile to a behavioral 
	profile on the given extensive form problem.
   -	Return value:  Returns the behavioral profile.
   -	Required parameters:
	  *  E:  The problem in extensive form of which the behavioral profile
		is to be a subvariable.
	  *  mp:  The mixed profile which is to be projected to a behavioral
		profile.
   -	Optional parameters:  None.

---------

MixedToBehav[E->EFG, mp->LIST(MIXED)] =: LIST(BEHAV)

   -	Description:  Projects a specified vector of mixed profiles to a vector
	of behavioral profiles on the given extensive form problem.
   -	Return value:  Returns the vector of behavioral profiles.
   -	Required parameters:
	  *  E:  The problem in extensive form of which the vector of 
		behavioral profiles is to be a subvariable.
	  *  mp:  The vector of mixed profiles which is to be projected to a 
		vector of behavioral profiles.
   -	Optional parameters:  None.

----------

MoveTree[n->NODE, to->NODE] =: NODE

   -	Description:  Moves the subtree rooted at the first node specified to
	the second given node.
   -	Return value:  XXXX .
   -	Required parameters:
	  *  n:  The node at which the subtree to be moved is currently rooted.
	  *  to:  The node to which the subtree is to be moved.
   -	Optional parameters:  None.

----------

NameOf[n->NODE] =: TEXT

   -	Description:  Returns the name of the specified node.
   -	Return value:  The name of the specified node.
   -	Required parameters:
	   *  n:  The node for which the name will be returned.
   -	Optional parameters:  None.

----------

NewEfg[{type->DATATYPE}] =: EFG

   -	Description:  Allocates and returns a new extensive form game.
   -	Return value:  The newly allocated problem in extensive form.
   -	Required parameters:  None.
   -	Optional parameters: 
	  *  type:  Specifies the type (Float or Rational) of the new extensive
		form problem.

----------

NewOutcome[E->EFG, {outc->INTEGER}] =: INTEGER

   -	Description:  Creates and assigns a number to a new outcome within the
	specified problem in extensive form.  Note that outcomes are 
	sequentially numbered, so that if an outcome with the number n exists,
	then outcomes with the numbers 1 . . n-1 necessarily also exist.
	Therefore, this procedure creates not only the outcome with the 
	specified number, but all other outcomes necessary to satisfy this 
	condition.
   -	Return value:  The number of the newly created outcome.  The optional 
	parameter 'outc' allows the user to specify the number given to the new
	outcome created.  If 'outc' is not specified, the new outcome is 
	assigned the lowest positive number for which no outcome is defined.  
	If the number specified by 'outc' already exists as an outcome, no 
	action is taken and the procedure returns a value of zero.
   -	Required parameters:
	  *  E:  The problem in extensive form for which a new outcome is to
	     be created.
   -	Optional parameters:
	  *  outc:  Allows the user to specify the number given to the new 
	     outcome created.  If not specified, the new outcome is assigned
	     the lowest positive number for which no otcome is defined.  If the
	     number specified already exists as an outcome, no action is taken
	     and the procedure returns a value of zero.

----------

NthChild[n->NODE, child->INTEGER] =: NODE

   -	Description:  Finds the node which is the indicated child of the 
	specified node.  The expression:  NthChild[n->node, child->i] is 
	equivalent to:  node\#i.
   -	Return value:  Returns the node which is the indicated child of the
	specified node.
   -	Required parameters:
	  *  n:  The node for which the indicated child is to be found.
	  *  child:  The number corresponding to the child of the specified 
		node which is to be found.
   -	Optional parameters:  None.

----------

NumChildren[n->NODE] := INTEGER

   -	Description:  Finds the number of children of the specified node.
   -	Return value:  Returns the number of children of the specified node.
   -	Required parameters:
	  *  n:  The node whose children are to be counted.
   -	Optional parameters:  None.

----------

NumInfosets[E->EFG, pl->INTEGER] =: INTEGER

   -	Description:  Finds the number of information sets belonging to the
	specified player in the given problem in extensive form.
   -	Return value:  Returns the number of information sets belonging to
	the specified player.  If the indicated player is not defined in the 
	game, the return value is equal to zero.
   -	Required parameters:
	  *  E:  The problem in extensive form in which the information sets
		for the specified player are to be counted.
	  *  pl:  The number corresponding to the player for which the number 
		of information sets are to be counted.
   -	Optional parameters:  None.

----------

NumNodes[E->EFG] =: INTEGER

   -	Description:  Finds the number of nodes (including terminal nodes) in 
	the specified problem in extensive form.
   -	Return value:  Returns the number of nodes found.
   -	Required parameters:
	  *  E:  The problem in extensive form in which the number of nodes are
		to be counted.
   -	Optional parameters:  None.

----------

NumOutcomes[E->EFG] =: INTEGER

   -	Description:  Finds the number of outcomes in the specified problem in
	extensive form.
   -	Return value:  Returns the number of outcomes found.
   -	Required parameters:
	  *  E:  The problem in extensive form in which the number of outcomes
		is to be found.
   -	Optional parameters:  None.


NumOutcomes[N->NFG] =: INTEGER

   -	Description:  Finds the number of outcomes in the specified problem in
	normal form.
   -	Return value:  Returns the number of outcomes found.
   -	Required parameters:
	  *  N:  The problem in normal form in which the number of outcomes is
		to be found.
   -	Optional parameters:  None.

----------

NumPlayers[E->EFG] =: INTEGER

   -	Description:  Finds the number of players in the specified problem in
	extensive form.
   -	Return value:  Returns the number of players found.
   -	Required parameters:
	  *  E:  The problem in extensive form in which the number of players
		is to be found.
   -	Optional parameters:  None.

----------

NumStrats[N->NFG, pl->INTEGER, {sset->INTEGER}] =: INTEGER

   -	Description:  Finds the number of strategies for the specified player 
	in the given problem in normal form.
   -	Return value:  Returns the number of strategies found.
   -	Required parameters:
	  *  N:  The normal form problem in which the number of strategies for
		the specified player is to be found.
	  *  pl:  The number corresponding to the player in the given problem 
		in normal form for whom the number of strategies is to be
		found.
   -	Optional parameters:
	  *  sset:  The number of the strategy set in which strategies for the
		specified player will be counted.  If not given the last
		(smallest) strategy set is used.

----------

OutcomeOf[n->NODE] =: INTEGER

   -	Description:  Finds the number of the outcome associated with the 
	specified node.
   -	Return value:  Returns the number corresponding to the outcome attached
	to the specified node.  If the node does not have an outcome attached,
	a value of zero is returned.
   -	Required parameters:
	  *  n:  The node for which the attached outcome is to be found.
   -	Optional parameters:  None.

----------

ParentOf[n->NODE] =: NODE

   -	Description:  Finds the node which is the parent of the specified node.
   -	Return value:  Returns the node which is the parent of the specified
	node.
   -	Required parameters:
	  *  n:  The node for which the parent is to be found.
   -	Optional parameters:  None.

----------

PlayerOf[n->NODE] =: INTEGER

   -	Description:  Finds the player who makes the decision at the specified
	node.
   -	Return value:  Returns the number corresponding to the player found.
   -	Required parameters:
	  *  n:  The node for which the player making the decision is to be
		found.
   -	Optional parameters:  None.

----------

PureNash[N->NFG, {num->INTEGER}, {time<->RATIONAL}, {output->TEXT}]
	 =: INTEGER

   -	Description:  Finds the weak pure strategy Nash equilibria in the 
	specified normal form game.  
   -	Return value:  The number of equilibria found.  The optional parameter 
	'num' allows the user to set the maximum number of Nash equilibria to 
	find and has a default value of 1.
   -	Required parameters:
	  *  N:  The problem in normal form for which the weak pure strategy
		Nash equilibria are to be found.
   -	Optional parameters:
	  *  num:  Allows the user to set the maximum number of Nash equilibria
		to find.  Has a default value of 1.
	  *  time:  Returns the elapsed time for the operation.
	  *  output:  Can be used to redirect the output of this procedure to a
		file.  Directing output to ``/dev/null'' under Unix turns 
		output off.  By default, output is directed to the screen.  

----------

Quit

   -	Description:  Exits the command language.
   -	Return value:  None.
   -	Required parameters:  None.
   -	Optional parameters:  None.

----------

RandomNfg[dim->LIST(INTEGER), {seed->INTEGER}, {type->DATATYPE}] =: NFG

   -	Description:  Constructs a random new problem in normal form with the 
	specified dimensionality.
   -	Return value:  Returns the new problem in normal form.
   -	Required parameters:
	  *  dim:  The desired dimensionality of the new problem.
   -	Optional parameters:
	  *  seed:  Reseeds the random number generator with the given integer.
	  *  type:  Specifies the type (Float or Rational) of the new normal 
		form problem.

----------

ReadEfgFile[file->TEXT] =: EFG

   -	Description:  Creates a new problem whose contents are the extensive 
	form game stored in the specified file.
   -	Return value:  The problem in extensive form read from the file.
   -	Required parameters:
	  *  file:  Specifies the file from which the extensive form game is to
		be read.  If the file specified does not exist, an error 
		message is returned.
   -	Optional parameters:  None.

----------

ReadNfgFile[file->TEXT, {type->DATATYPE}] =: NFG

   -	Description:  Creates a new problem whose contents are the normal form
	game stored in the specified file.  The file is read as a floating-
	point normal form unless otherwise specified by the user.
   -	Return value:  The problem in normal form read from the file.
   -	Required parameters:
	  *  file:  Specifies the file from which the normal form game is to be
		read.  If the file specified does not exist, an error message
		is returned.
   -	Optional parameters:
	  *  type:  Indicates whether the file is to be read as a floating-
		point normal form or as a rational normal form.  If not given,
		the default value is floating-point.

----------

RemoveOutcome[E->EFG, outc->INTEGER] =: EFG

   -	Description:  Removes the specified outcome from the given problem in
	extensive form.  All nodes with the specified outcome attached are 
	reset to having no outcome attached.  If the outcome does not exist in
	the given problem, no action is taken.  The outcomes remaining in the 
	game are re-numbered, so that the number of the outcome removed is 
	given to the outcome which previously had the next highest number, the
	number previously corresponding to this outcome is assigned to the
	outcome which previously had the next highest number, and so on.  
   -	Return value:  Returns the modified extensive form problem.
   -	Required parameters:
	  *  E:  The problem in extensive form from which the specified outcome
		is to be removed.
	  *  outc:  The number corresponding to the outcome which is to be 
		removed from the given problem.  If no outcome with that number
		exists in the problem, no action is taken.

----------

RootNode[E->EFG, {game->INTEGER}] =: NODE

   -	Description:  Finds the root node of specified game in the given 
	problem in extensive form.  If a game is not specified, the first game 
	is used by default.
   -	Return value:  Returns the root node of the game.
   -	Required parameters:
	  *  E:  The problem in extensive form in which the root node is to be
		found.
   -	Optional parameters:
	  *  game:  Specifies the game of which the root node is to be found.
		If not given, the first game is used by default.

----------

Run[TEXT]

   -	Description:  Includes the commands in the specified file as commands 
	in the running GCL program.  The program treats the command as if it 
	were replaced by the contents of the file.
   -	Return value:  None.
   -	Required parameters:
	  *  TEXT:  Any expression which evaluates to a text string which is a
		valid filename.
   -	Optional parameters:  None.

----------

SetActionName[n->NODE, br->INTEGER, name->TEXT] =: NODE

   -	Description:  Sets the name of the specified branch number of the 
	indicated node to the name given.
   -	Return value:  Returns the node specified.
   -	Required parameters:
	  *  n:  The node at which the desired action occurs.
	  *  br:  The number of the branch or action ocurring at the given node
		which is to be assigned a name.
	  *  name:  The name which is to be assigned to the given action.
   -	Optional parameters:  None.

----------

SetActionProbs[n->NODE, probs->LIST(RATIONAL)] =: NODE

   -	Description:  Sets the action probabilities to the specified values 
	for the given node.  This is only meaninful for nodes in information
	sets belonging to the player representing chance (player 0).
   -	Return value:  Returns the node specified.
   -	Required parameters:
	  *  n:  The node at which the actions will be assigned the specified
		probabilities.
	  *  probs:  The vector of values which represent the probabilites 
		which will be assigned to the actions at the indicated node.
   -	Optional parameters:  None.

----------

SetInfosetName[n->NODE, name->TEXT] =: NODE

   -	Description:  Assigns the given name given to the information set to 
	which the indicated node belongs.
   -	Return value:  Returns the node specified.
   -	Required parameters:
	  *  n:  A node belonging to the information set which is to be 
		assigned a name.
	  *  name:  The name which is to be assigned to the given information
		set.
   -	Optional parameters:  None.

----------

SetNodeName[n->NODE, name->TEXT] =: NODE

   -	Description:  Assigns the given name to the specified node.
   -	Return value:  Returns the specified node.
   -	Required parameters:
	  *  n:  The node which is to have a name assigned.
	  *  name:  The name which is to be assigned to the specified node.
   -	Optional parameters:  None.

----------

SetOutcome[E->EFG, outc->INTEGER, value->LIST(RATIONAL)] =: EFG

   -	Description:  Sets the value of the indicated outcome in the given 
	problem in extensive form, to the values in the specified vector.
   -	Return value:  Returns the modified problem in extensive form. 
   -	Required parameters:
	  *  E:  The extensive form problem in which the given outcome is to be
		assigned values.
	  *  outc:  The number corresponding to the outcome which is to be 
		assigned values.  If no outcome with the given number exists,
		then it is created.
	  *  value:  The vector of payoffs (as a list of rationals) which are 
		to be assigned to the outcome.  The length of `value` must 
		match the number of players defined in the problem.
   -	Optional parameters:  None.


SetOutcome[E->EFG, outc->INTEGER, pl->INTEGER, value->RATIONAL] =: EFG

   -	Description:  Sets the payoff to the player specified for the indicated
	outcome in the given problem in extensive form to the given value.
   -	Return value:  Returns the modified problem in extensive form.
   -	Required parameters:
	  *  E:  The extensive form problem in which the given outcome is to be
		assigned a value for the specified player.
	  *  outc:  The number corresponding to the outcome which is to be 
		assigned a value for the specified player.  If no outcome with
		 the given number exists, no action is performed.
	  *  pl:  The player for which the payoff of the given outcome is to be
		set.
	  *  value:  The value (as a rational) which is to be assigned to the 
		given outcome for the specified player.

----------

SetOutcomeName[E->EFG, outc->INTEGER, name->TEXT] =: EFG

   -	Description:  Assigns to the outcome with the specified number the 
	given title.
   -	Return value:  Returns the modified problem in extensive form.
   -	Required parameters:
	  *  E:  The problem in extensive form in which the indicated outcome 
		is to be assigned the given title.
	  *  outc:  The number corresponding to the outcome which is to be 
		assigned a title.
	  *  name:  The name which is to be assigned to the indicated outcome.
   -	Optional parameters:  None.

----------

SetPlayerName[E->EFG, pl->INTEGER, name->TEXT] =: EFG

   -	Description:  Assigns to the player with the specified number the given
	name.
   -	Return value:  Returns the modified problem in extensive form.
   -	Required parameters:
	  *  E:  The problem in extensive form in which the indicated player is
		to be assigned a name.
	  *  pl:  The number corresponding to the player which is to be 
		assigned a name.
	  *  name:  The name which is to be assigned to the specified player.
   -	Optional parameters:  None.

----------

SetStratName[N->NFG, pl->INTEGER, st->INTEGER, name->TEXT] =: NFG

   -	Description:  Assigns the given name to the specified strategy of the
	indicated player in the given problem in normal form.
   -	Return value:  Returns the modified normal form problem.
   -	Required parameters:
	  *  N:  The problem in normal form in which the given name is to be
		assigned to the specified strategy of the indicated player.
	  *  pl:  The number corresponding to the player for which the 
		indicated strategy is to be assigned the given name.
	  *  st:  The number corresponding to the strategy of the indicated 
		player to which the given name is to be assigned.
   -	Optional parameters:  None.

----------

SetTitle[E->EFG, title->TEXT] =: EFG

   -	Description:  Assigns the specified title to the given problem in 
	extensive form.
   -	Return value:  Returns the modified problem in extensive form.
   -	Required parameters:
	  *  E:  The problem in extensive form which is to be assigned a title.
	  *  title:  The title which is to be assigned to the given problem in 
		extensive form.
  -	Optional parameters:  None.

----------

SimpDiv[N->NFG, {plev->INTEGER}, {output->text}, {errors->TEXT},
	{number->INTEGER}, {ndivs->INTEGER}, {leash->INTEGER}, 
	{nevals->INTEGER}, {time<->RATIONAL}] =: INTEGER

   -	Description:  XXXX .
   -	Return value:  XXXX .
   -	Required parameters
	  *  N:  The problem in normal form on which the operation will be 
		performed.
   -	Optional parameters:
	  *  plev: XXXX .
	  *  output:  Can be used to redirect the output of this procedure to a
		file.  Directing output to ``/dev/null'' under Unix turns 
		output off.  By default, output is directed to the screen.
	  *  errors:  XXXX .
	  *  number:  XXXX .
	  *  ndivs:  XXXX .
	  *  leash:  XXXX .
	  *  nevals:  XXXX .
	  *  time:  Returns the elapsed time for the operation.

----------

StartWatch[] =: INTEGER

   -	Description:  Starts the system stopwatch.  
   -	Return value:  The return value is uninteresting.
   -	Required parameters:  None.
   -	Optional parameters:  None.

----------

StopWatch[] =: INTEGER

   -	Description:  Stops the system stopwatch.  
   -	Return value:  The return value is uninteresting.
   -	Required parameters:  None.
   -	Optional parameters:  None.

----------

WriteEfgFile[E->EFG, file->TEXT] =: EFG

   -	Description:  Writes the given extensive form problem to the specified 
	file.  Indicates in the file the type of the file(Float or Rational) 
	immediately following the title string.  If the type is Float, the file
	contains floating point numbers and if the type is Rational, the file
	contains rational numbers.  
   -	Return value:  Returns the same extensive form problem.
   -	Required parameters:
	  *  E:  The problem in extensive form which is to be written to the
		indicated file.
	  *  file:  The name of the file to which the extensive form problem is
		to be written.

----------

WriteNfgFile[N->NFG, file->TEXT] =: NFG

   -	Description:  Writes the given normal form problem to the specified 
	file.  
   -	Return value:  Returns the same normal form problem.
   -	Required parameters:
	  *  N:  The problem in normal form which is to be written to the
		indicated file.
	  *  file:  The name of the file to which the normal form problem is
		to be written.

----------
\end{document}




























