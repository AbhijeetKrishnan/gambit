%
% FILE: gclman.tex -- source for GCL manual
%
% $Id$
%
\documentstyle[widetext,chicagob]{article}
\renewcommand{\baselinestretch}{.9}
\newcommand{\bd}{\begin{description}}
\newcommand{\ed}{\end{description}}
\begin{document}


\title{GAMBIT COMMAND LANGUAGE\thanks{This is part of the Gambit
Project, which was funded in part by National Science Foundation
grants SBR-9308637 to the California Institute of Technology and
SBR-9308862 to the University of Minnesota.}}

\author{Richard D. McKelvey\\California Institute of
Technology
\and
Andrew McLennan\\University of
Minnesota
\and 
Theodore Turocy\\Northwestern University
}

\date{Version 0.94\\ \today\\ \jobname.tex}

\maketitle

\tableofcontents

\section{Introduction}

This document describes the Gambit Command Language (GCL).  Gambit is
a computer program that allows one to build, manipulate, and solve
finite extensive and normal form games. The GCL provides a method of
directing the operation of Gambit that is analagous to that of a high
level general purpose programming language.

The general purpose of the GCL is to provide a simple, but powerful
and flexible language by which one can perform complicated or
repetitive operations and procedures on games in extensive or normal
form.  The language has facilities for building and editing an
extensive or normal form game, converting back and forth between the
extensive and normal form representations, and then solving the
resulting game for various equilibria of interest. Flow
control statements allow for repetitive operations (such as
investigating games as one changes various parameters) or conditional
operations.

\section{Acknowledgements}

The Gambit Project is a project for the development of computer code
for the solution of extensive and normal form games.  The software
developed under the project is public domain.  The Gambit Project is
funded in part by National Science Foundation grants SBR-9308637 to
the California Institute of Technology and SBR-9308862 to the
University of Minnesota.

Numerous students at Caltech and the University of Minnesota have
contributed to the Gambit Command Language and to the Gambit Project
more generally: Among these are Bruce Bell, Anand Chelian, Nelson
Escobar, Eugene Grayver, Todd Kaplan, Brian Trotter, and Gary Wu.  We
are particularly grateful to Gary Wu for his work on the stack machine
used by the command language, to Bruce Bell and Nelson Escobar for
work on data structures, and to Rob Weber for help in compiling this
manual and testing parts of the language.  We are also grateful to
Eugene Grayver for his extensive work on the related GUI, and for
setting up our Web site.

\section{Installation}

All of the gambit files can be found at the Gambit World Wide Web site
at 

\begin{verbatim}
http://www.hss.caltech.edu/~gambit/Gambit.html
\end{verbatim} 

\noindent Instructions on downoading and installation as well as a
list of platforms supported can be obtained there.  Source code is
also available at the same location. 

Once the program is installed, the gcl can be run by typing \verb+gcl+
at the command line prompt.  You will then receive the GCL prompt 

\begin{verbatim}
GCL1:
\end{verbatim}

\noindent The interpreter is ready for your first command.


\section{Technical support and bug reports}

User feedback is an important part of Gambit's development cycle.
Our design choices have been motivated in large part by our experiences
and by some of the potential uses of the software we have imagined.
But this is by no means complete, and so we are eager to hear from
you, Gambit's users, to find out what features are particularly
useful, and in what areas future releases might be improved.

The authors may be contacted via email at {\tt gambit@hss.caltech.edu}.
This address will forward a copy of your message to the development team.
While a personal reply may not always be possible, we will read all
correspondence and apply as many suggestions as possible to our future
releases.

Although we have made every effort to ensure the reliability and correctness of the
code, it is certain that errors of varying degrees of severity exist.
(However, as the saying goes, no undiscovered bugs have been found yet.)  If you
experience problems with the software,
send us email at {\tt gambit@hss.caltech.edu} describing your problem.

When reporting a bug, it is important to include the following information:

\begin{itemize}
\item the version number
\item the platform(s) on which the problem occurred
\item as complete a description of the circumstances of the problem as possible, including a sequence of steps which reproduces the problem
\end{itemize}
 
\noindent Without this information, it will be difficult for us to identify the source of the
problem to correct it.

At this time, no formal technical support mechanism exists for Gambit.
As time permits, we will make every effort to answer any and all questions
pertaining to the program an its documentation.

We hope you will find Gambit a useful tool for research and instruction.


\section{Basic concepts}

The design motifs for GCL come from two principal families of programming
languages.  The first is traditional imperative programming languages
such as Pascal, C, and Modula-3.  In particular, the GCL's concept of
types draws heavily from these languages, although the number of
predefined types in GCL is much larger due to the specialized nature of
the language.  The second is more specialized programming languages such
as Mathematica, from which the GCL's grammar is partially drawn.  Users
with experience using any of these languages should find the GCL easy to
learn; however, no programming experience is necessary to begin using the
language effectively.

\subsection{Statements}

A GCL program consists of a series of statements.  A statement is
typically an expression built up out of function calls.  A statement
is terminated by a linefeed or by a semicolon.  The GCL interpreter
reports the value of each expression evaluated unless the semicolon is
present. Statements can be continued for more than one line by using
the continuation character, \verb+\+.   

\subsection{Types}

The built-in data types for the GCL are the following:  

\medskip

\begin{tabular} {|l||l|} \hline
Type name	& Description \\ \hline
{\tt BOOL} 	& boolean \\
{\tt INTEGER} 	& integer \\ 
{\tt FLOAT} 	& floating-point number \\
{\tt RATIONAL} 	& rational number with arbitrary precision \\
{\tt TEXT}	& string of arbitrary length \\
{\tt INPUT}	& output stream \\
{\tt OUTPUT}	& output stream \\ \hline
{\tt EFG}	& extensive form game \\
{\tt EFPLAYER}	& a player in an extensive form game \\
{\tt NODE}	& a node in an extensive form game \\ 
{\tt INFOSET}	& an information set in an extensive form game \\
{\tt ACTION}	& an action at an information set \\
{\tt OUTCOME}	& an outcome in an extensive form game \\
{\tt EFSUPPORT}	& a support of actions in an extensive form game \\
{\tt BEHAV}	& a behavioral strategy profile for an extensive form game \\ \hline
{\tt NFG}	& normal form game \\
{\tt NFPLAYER}	& a player in a normal form game \\
{\tt STRATEGY}	& a strategy in a normal form game \\
{\tt NFSUPPORT}	& a support of strategies in a normal form game \\
{\tt MIXED}	& a mixed strategy profile for a normal form game \\ \hline
{\tt LIST}	& a list of objects \\ \hline
\end{tabular}

\medskip

The remainder of this section details the rules concerning the types
{\tt BOOL}, {\tt INTEGER}, {\tt FLOAT}, {\tt RATIONAL}, {\tt TEXT},
{\tt INPUT} and {\tt OUTPUT}, as well as general rules for typing.
The extensive form and normal form types, and their related types, are
detailed later in special sections.

\subsubsection{Boolean}

The {\tt BOOL} type represents boolean values, that is to say, ``true'' and
``false''.  The command language predefines two constant values to
represent these, {\tt True} and {\tt False}.

\subsubsection{Integer}

The {\tt INTEGER} type may contain integer values.  It is implemented
as the machine's long integer type, which is typically at least 32
bits in modern machines.  Thus, there is a danger, however small, of
overflow or underflow in computations involving these numbers.

\subsubsection{Float}

The {\tt FLOAT} type may contain floating point values.  It is implemented
as the machine's double-precision floating point type.  These numbers
are imprecise; for example, operations usually associated with being inverses
of each other may not be with floating point numbers.  For more precise
computations, the {\tt RATIONAL} type is available, although these may
sometimes be bulky and slow.

\subsubsection{Rational}

The {\tt RATIONAL} type is a ratio of two arbitrary-length integers.
This data type is capable of precisely representing any rational
number.  However, they are slow, and output from them may be
unreadably large.  Rational numbers are formed from two integers using
the {\tt /} operator, described below.

\subsubsection{Text}

The {\tt TEXT} type is used to store text strings, typically labels
for parts of games.  It is generally encouraged to label various elements
of games in the command language for ease of identification; however it
is not required.  To specify a {\tt TEXT} constant, surround the
text with double-quote characters ({\tt "}).  Constants may not span
more than one input line.

\subsubsection{Input}

The {\tt INPUT} type is a reference to an input stream, generally a file
on disk.  Its principal use is to read in external data. 

\subsubsection{Output}

The {\tt OUTPUT} type is a reference to an output stream, generally a
file on disk.  Its principal use is as a logging file for writing
formatting output from an extended command language job.  

\subsubsection{List}

Variables of any type can be contained in lists of arbitrary length.
Variables of type {\tt LIST} are defined similarly to the above
variables, except that the expression to the right of the {\tt ":="}
symbol contains a vector of variables of the same type enclosed in
curly braces and separated by commas.  For example, the following is a
list containing the first five integers:

\begin{verbatim}
{ 1, 2, 3, 4, 5 }
\end{verbatim}

\noindent In the same manner, lists of any type may be created and
manipulated.  Lists may be nested to any depth; however, the type of
all the elements of the list and any sublists must always be the same.
Hence

\begin{verbatim}
{ 3, { 4, 6 }, 23 }
\end{verbatim}

\noindent is a legal list, since all the elements are of type 
{\tt INTEGER}, but

\begin{verbatim}
{ 3, { 4.2, 5.7 }, 23 }
\end{verbatim}

\noindent is not, since the second element is a {\tt LIST(FLOAT)}.

Lists are distinct in type from each other and from their scalar
equivalents.  That is to say, {\tt LIST(INTEGER)} is not the same time
as {\tt LIST(FLOAT)}, nor is it the same type as {\tt INTEGER}.

\subsection{Variables}

A variable stores one object of the corresponding data type
To create a user defined variable, or to give
a new value to an existing variable, one can use the built-in
function,
\verb+Assign+, which has the syntax:
\begin{verbatim}
Assign[x<->T, y->T]
\end{verbatim}

\noindent (How to read a function's declaration is described in more
detail in the section of function calls.  For now, suffice it to say that
{\tt Assign} takes two parameters, the first of which is a variable and
the second a value of the same type as the variable.)  The {\tt Assign}
function also has an infix operator form, written {\tt :=}.  So, to assign
the {\tt INTEGER} value 1 to the variable {\tt x}, one could write

\begin{verbatim}
Assign[x, 1]
\end{verbatim}

\noindent or equivalently, and more compactly,

\begin{verbatim}
x := 1
\end{verbatim}

The {\tt Assign} function can be used to either create a new variable or
modify an existing one.  However, it cannot be used to change the type
of a variable.  Consider the calls

\begin{verbatim}
Assign[y, 2]
Assign[y, 3.0]
\end{verbatim}

\noindent The first call defines {\tt y} to be of type {\tt INTEGER}.  The
second is interpreted as {\tt Assign[ INTEGER, FLOAT]}, which does
not match the definition of {\tt Assign}.

An existing variable may be deleted by the use of the {\tt UnAssign} function

\begin{verbatim}
UnAssign[x<->T] =: T
\end{verbatim}

\noindent After this is called on a variable, the variable is no longer
defined.  A subsequent call of {\tt Assign} may redefine the variable to
be of any type.

\subsection{Errors}

Sometimes, programs contain errors.  The interpreter is able to detect
errors which violate rules of the language, and reports information
about the error so the user can correct it.  There are two main
classes of errors which may arise in GCL programs, parse errors and
run time errors.

A parse error occurs when the GCL interpreter cannot determine the
meaning of a statement, because it does not conform to the grammatical
rules of the language.  This most frequently occurs when braces,
brackets, or quotation marks fail to match up or when punctuation is
missing.  When it encounters a parse error, the GCL interpreter will
display an error message giving the filename and line number of the
error and the point at which it determined an error it occurred.

A run time error occurs when a statement which obeys the grammatical
rules of the language violates another rule of the language during its
execution.  Examples of this type of error include attempting to use a
variable name which is not defined, and using a value of one type
where another type was expected.  Also, builtin functions may generate
this type of error on invalid inputs.  A run time error will result in
termination of the GCL at the point where the error occurs, ith a
message indicating the type of error encountered.  However, no line
number is given for run time errors.  


\subsection{Function calls}

A function call consists of the name of a function, and a list of
parameters upon which the function is to operate.  Functions return a
value, which may in turn be used as a parameter to another function
call, allowing more complex computations to be expressed.

A simple example of a function call is

\begin{verbatim}
Plus[x->1, y->2]
\end{verbatim}

This calls the function named {\tt Plus}, with parameter \verb+x+ set
to the value 1 and \verb+y+ set to the value 2.  Since {\tt Plus} is
the function for addition of two integers, the value returned would
be, as you might expect, 3.

In the addition example above, we called a function which is listed in
the function reference as

\begin{verbatim}
Plus[x->INTEGER, y->INTEGER] =: INTEGER
\end{verbatim}

\noindent This listing of a function is called its {\it prototype}.  
It contains the function's name, its list of parameters, and its return
value.  In this case, the function {\tt Plus} takes two parameters, the
first named \verb+x+ and taking a value of type {\tt INTEGER} and the
second named \verb+y+ and taking a value of type {\tt INTEGER}, and
returns a value of type {\tt INTEGER}.

Because the parameters have explicit names, it is possible to rearrange
the order in which parameters are listed when a function is called.
Thus, we could write out sample call equivalently as

\begin{verbatim}
Plus[y->2, x->1]
\end{verbatim}

\noindent and achieve the same effect.

Explicitly specifying the formal names for parameters all the time
will prove tedious and can hinder readability.  For these reasons, it is
also legal to specify parameters without their associated formal names.
These are called passing {\it anonymous} parameters.  Our addition
example could thus also be written

\begin{verbatim}
Plus[1, 2]
\end{verbatim}

In not specifying the formal names, however, function calls are restricted
to specifying parameters in exactly the same order as listed in the function
prototype.  In our example, the GCL interpreter would have no way of
distinguishing whether we meant 1 to be the value of \verb+x+ or the
value of \verb+y+, and vice versa.  While in the case of addition we may
flip the values of the parameters without having an effect on the result,
in general this is not the case.

It is permitted to mix the two styles of parameter specification, subject
to the following rules:

\begin{itemize}
\item All anonymous parameters must be specified before any named parameters
\item No parameters may be omitted in the anonymous parameter list.  If
$k$ parameters are specified anonymously, they must match one-for-one the
first $k$ parameters in the function's prototype.
\item Once a named parameter has been specified, all succeeding parameters
must be named, even if the first named parameter appeared in the same
place in the parameter list as it does in the prototype.
\end{itemize}

\noindent Therefore, it would be legal to write

\begin{verbatim}
Plus[1, y->2]
\end{verbatim}

\noindent but

\begin{verbatim}
Plus[x->1, 2]
\end{verbatim}

\noindent is illegal since it violates the third condition.

To be more precise, the function {\tt Plus} comes in several different
variations listed in the function reference:

\begin{verbatim}
Plus[x->INTEGER, y->INTEGER] =: INTEGER
Plus[x->FLOAT, y->FLOAT] =: FLOAT
Plus[x->RATIONAL, y->RATIONAL] =: RATIONAL
Plus[x->MIXED, y->MIXED] =: MIXED
Plus[x->BEHAV, y->BEHAV] =: BEHAV
\end{verbatim}

\noindent This is a good example of function {\it overloading}.  This
means that one function name may have several possible parameter
lists, sometimes called {\it signatures}.  The GCL interpreter is
capable of determining which version of the function to use by
analyzing the names and types of the parameters used.

Since a function may have multiple signatures, it is conceivable that
a function call might be ambiguous, in the sense that its parameters match
more than one signature for that function.  However, no function call that
is complete may be ambiguous from the way that signatures have been
chosen for the predefined functions.  Any function call flagged by the
interpreter as ambiguous must be missing at least one parameter.

Some functions have parameters which are optional, in the sense that they
need not be specified in order to call the function.  These parameters
are indicated in the function's prototype by being surrounded by curly
braces.  (Note that these braces should not be included in the function
call when specifying an optional parameter.)  If an optional parameter
is left unspecified in a function call, a default value is assumed, as
given in the function's documentation.

For a function, all required parameters always precede any optional
parameters.  Optional parameters may also be specified anonymously,
subject to the above rules on parameter specification.

All parameters so far have been passed by {\it value}, that is, a copy
of the value of the parameter is given to the function to which it is passed.
These parameters may not be modified by the function.  It is also possible
to have parameters to a function passed by {\it reference}.  This means
that the function does not receive a copy of the value, but rather the
memory location of the value itself.  Thus, the function may modify
the value of a parameter passed by reference.

The symbol for passing a parameter by reference, both in a function's
prototype and in a function call, is {\tt <->}.  Constants may not be
passed by reference.  Reference parameters may be specified anonymously
just like a value parameter, subject to the usual rules.  It is a run-time
error to attempt to pass a value to a reference parameter, or vice versa.

\subsection{Aliases for function calls}

There are several functions which are so commonly used that special
``short'' forms are defined for them.  Most of these are the
standard arithmetic and logic operators, for which the usual binary
infix or unary prefix notations are supported.  Our addition example
may more familiarly be written

\begin{verbatim}
1 + 2
\end{verbatim}

\noindent which expression is converted to the ``long form'' function
call by the interpreter.  Note that formal names may not be specified
in a ``short form'' call, and the order of parameters is therefore
significant.

Here is a list of the functions thus abbreviated, and their ``short form''
equivalents:

\medskip

{\tt
\begin{tabular}{lp{4in}}
And[x, y]		& x \&\& y, x AND y \\
Assign[x, y]		& x := y \\
Concat[x, y]            & x \& y \\
Divide[x, y]		& x / y or x DIV y \\
Dot[x, y]		& x . y \\
Equal[x, y]		& x = y \\
Greater[x, y]		& x > y \\
GreaterEqual[x, y]	& x >= y \\
Less[x, y]		& x < y \\
LessEqual[x, y]		& x <= y \\
Minus[x, y]		& x - y \\
Modulus[x, y]		& x \% y, x MOD y \\
Not[x]			& NOT x, !x \\
NotEqual[x, y]		& x != y \\
NthChar[text, n]	& text[[n]] \\
NthChild[node, n]	& node\#n \\ 
NthElement[list, n]	& list[[n]] \\
Or[x, y]		& x || y, x OR y \\
Paren[x]		& (x) \\ 
Plus[x, y]		& x + y \\
Power[x, y]	 	& x $\wedge$ y \\
Read[in,x]		& in >> x \\
Times[x, y]		& x * y \\
Write[out,x]		& out << x \\
\end{tabular}
}

When functions are written in their canonical forms, no ambiguity
arises in the order of evaluation: In order to evaluate a function,
all arguments must be evaluated first.  Arguments are evaluated from
left-to-right as specified in the function call.
This leads to a recursive structure of evaluation,
which stops only when an argument being evaluated is a constant
function (i. e., a function with no arguments).

When short form forms are used, then ambiguity can arise in the
intended order of evaluation.  For example, the statement \verb&a + b * c&,
could be meant as \verb+Plus[a,Times[b,c]]+ or as
\verb+Times[Plus[a,b],c]+.  In order to resolve such ambiguities, all
functions that have a short form representation are given an order of
precedence.  When a statement is parsed by the GCL, it is first
scanned from left to right, replacing each short form expression at the
top level of precedence with its canonical form.  Then it is scanned
again replacing each short form expression at the second level of
precedence with its canonical form, and so on, until all short form
expressions have been eliminated.  

The order of precedence for built-in functions is as follows:
\bd
\item
\verb+()+
\item
\verb+:=+
\item
\verb+>> <<+
\item
\verb+||+
\item
\verb+&&+
\item
\verb+NOT+
\item
\verb+= != < <= > >=+
\item
\verb&+ - &\verb+&+
\item
\verb+* . / DIV MOD+ $\wedge$
\item
\verb&(unary) + -&
\item
\verb+[[ ]]+
\ed

Thus, the statement \verb&a + b * c& would become 
\begin{verbatim}
Plus[a,b*c]
Plus[a,Times[b,c]]
\end{verbatim}

\noindent
On the other hand, the statement \verb&( a + b ) * c& would become 
\begin{verbatim}
Paren[a+b]*c
Paren[Plus[a,b]]*c
Times[Paren[Plus[a,b]],c]
\end{verbatim}

\noindent
which, since \verb+Paren+ is just the identity mapping, is equivalent to
\begin{verbatim}
Times[Plus[a,b],c]
\end{verbatim}

\medskip

\subsection{Flow control structures}

The GCL contains three functions which allow flow control within a
program.  These functions are ``special'' in that their parameters
are evaluated in a special way (since their parameters are expressions
and sequences of statements); they also have no ``formal'' names for
their parameters.

\subsubsection{Conditional execution with {\tt If}}

The function \verb+If[]+ allows execution of a sequence of statements
only under certain conditions.  The syntax of the function is

\begin{verbatim}
If[boolean-expression, statement-list {, statement-list}]
\end{verbatim}

\noindent The function is interpreted as follows: If the 
\verb+boolean-expression+ evaluates to \verb+True+, then the first
list of statements is executed.  If it evaluates to \verb+False+,
and the second (optional) list of statements is present, that list
is executed; if it is not present, execution falls through to the
next statement.

For example, the statement

\begin{verbatim}
If[i = 2, j := 1, j := 2]
\end{verbatim}

\noindent sets \verb+j+ to \verb+1+ if the value of \verb+i+ is \verb+2+,
and sets \verb+j+ to \verb+2+ if the value of \verb+i+ is not \verb+2+.
It would also be perfectly legitimate to write

\begin{verbatim}
If[i = 2, j := 1]
\end{verbatim}

\noindent in which case \verb+j+ would be set to \verb+1+ if \verb+i+
is equal to \verb+2+, but if \verb+i+ were not \verb+2+, nothing would
occur.

This last example brings up an important note about conditional
execution.  Statements which appear in a branch of an \verb+If+
statement which is not taken are treated as if they did not exist.
So, were this the first mention of \verb+j+ in this scope, the last
example would leave \verb+j+ defined only if \verb+i+ was equal to
\verb+2+.  However, \verb+j+ would {\em not} be defined otherwise.  It
is therefore necessary to be careful in constructing \verb+If+
statements which result in the definition of new variables.

\subsubsection{Repetitive execution with {\tt While}}

Often in writing programs it is necessary to execute a block of statements
repeatedly, usually with different values for variables.  To this end
the GCL provides a special function \verb+While+ as a generalized looping
construct.  The syntax of the function is

\begin{verbatim}
While[boolean-expression, statement-list]
\end{verbatim}

The function is interpreted as follows: While \verb+boolean-expression+
evalutes to \verb+True+, execute the statements in \verb+statement-list+.
Note that the evaluation of the boolean takes place at the beginning of
the execution of a block, so it is only important whether the value is
\verb+True+ or \verb+False+ at the beginning of the block, and not at
some point in the middle.

This simple loop generates the numbers from one to ten:

\begin{verbatim}
i := 0;
While[i <= 10, i := i + 1];
\end{verbatim}

\noindent Alternately, one can create a list of the values one through ten with
a small modification:

\begin{verbatim}
i := 1;
list := { };
While[i <= 10, list := list + { i }; i := i + 1;]
\end{verbatim}

As with \verb+If+, be wary of declaring a variable implicitly inside a loop.
A variable is declared only when the corresponding statement is executed;
so, if the \verb+boolean-expression+ is \verb+False+ the first time it is
evaluated, the body of the loop never executes, and no variables which
appear in the loop are considered to be defined.

\subsubsection{Special looping with {\tt For}}

The function \verb+For+ is a specialized looping construct, useful mostly
in cases where some index variable is used to iterate a list or some sequence.
The general syntax for \verb+For+ is

\begin{verbatim}
For[statement-list, boolean-expression, statement-list, statement-list]
\end{verbatim}

\noindent The call is interpreted as follows:
\begin{itemize}
\item Execute the statements in
the first \verb+statement-list+ (this is called the {\em initialization}).
\item Evaluate the \verb+boolean-expression+ (called the {\em guard}).
\item If the \verb+boolean-expression+ is \verb+False+, terminate the loop and
continue with the first statement after the loop.  If it is \verb+True+,
execute the third \verb+statement-list+, called the {\em body} of the loop.
\item Execute the second \verb+statement-list+, called the {\em increment},
and return to the evaluation of the guard.
\end{itemize}

Returning to the examples in the \verb+While+ section, we see another way
of writing the two loops:

\begin{verbatim}
For[i := 1, i <= 10, i := i + 1, i];

For[i := 1, list := { }; i <= 10, list := list + {i}; i := i + 1;]
\end{verbatim}

\noindent The two methods are completely equivalent, but it is often
more convenient to use the structure afforded by the \verb+For+ function.


\section{Advanced topics}

\subsection{Including files}

The function {\tt Include[TEXT]} is used to insert the contents of the file
given into the input stream, as if they had been typed directly by the user.
This can be particularly useful in conjunction with user defined functions, in that
a library of useful functions can be constructed and included into the program
asily.

The {\tt Include} directive may only appear at the ``top level'' of
the program.  That is to say, it cannot be used inside a loop,
function declaration, or expression.  However, files may be nested
arbitrarily deep using {\tt Include}, so you can include a file which
in turn includes other files.
  
\subsection{User defined functions}

As GCL programs become more and more complex, frequently there are complicated
operations which must be performed repeatedly.  The command language therefore
supports user-defined functions, which allow for defining sections of code
which may be called later.

A new function can be created using the function
\verb+NewFunction+.  For example, one might define a function to compute
the absolute value of an {\tt INTEGER} as such:

\begin{verbatim}
NewFunction[Abs[n->INTEGER],
                 If[n > 0, n, If[n < 0, -n, 0]]]
\end{verbatim}

\noindent After defining the \verb+Abs+ function, it may be called in exactly
the same way a system-supplied predefined function may.  The return value
of the function is the value of the last statement executed. 

Parameter type matching rules apply to user defined functions in exactly the
same way as to predefined functions.  From the function's point of view,
the parameter list is a list of variables on which assignments are
automatically done at the beginning of the function execution.  So, taking
the \verb+Abs+ example above, in executing the call

\begin{verbatim}
Abs[42]
\end{verbatim}

\noindent an assignment \verb+n := 42+ is implicitly performed before the
body of the function is executed.

It is also possible to pass variables by ``reference'' to a user-defined
function in the same way as a predefined function.  In this case, the
function's ``local'' variable is stored in the same physical location in the
computer, and modifying the value locally also takes effect on the variable
passed to the function.  For example, it might
be useful instead to define \verb+Abs+ as:

\begin{verbatim}
NewFunction[Abs[n<->INTEGER],
		 If[n > 0, n, If[n < 0, n := -n, 0]]]
\end{verbatim}

\noindent in which case the function would still return the absolute value
of \verb+n+, but also modify the variable passed to \verb+n+ to be the
absolute value of the input \verb+n+.  So,

\begin{verbatim}
q := -37;
Abs[q]
\end{verbatim}

\noindent would result in the variable \verb+q+ containing the value 37
at the conclusion of execution.

Each function has its own ``scope'', or set of variables.  Within a function
body, the only variables which are visible are those which are declared
in the parameter list of the function (this is \verb+n+ in the \verb+Abs+
example above), and those which are created during the function's execution.
That is, no ``global'' or outside variables may be accessed directly by the
function.  For example, if the user typed in the following:

\begin{verbatim}
i := 4;
NewFunction[FooFunc[x->INTEGER], x * i]
\end{verbatim}

\noindent later execution of the \verb+FooFunc+ would yield an ``undefined
variable i'' error message, since \verb+i+ is never defined within the
function.  If instead \verb+FooFunc+ had been defined as follows:

\begin{verbatim}
NewFunction[FooFunc[x->INTEGER], i := 13, x * i]
\end{verbatim}

\noindent \verb+FooFunc+ would always return 13 times the value of the
parameter \verb+x+, since the value of \verb+i+ inside \verb+FooFunc+ is
always 13, regardless of the value of \verb+i+ outside of the function.


\subsection{Lists as arguments to functions}

Almost all of the functions in the GCL are ``listable''.  This means
that if there is a version of the function which takes a type \verb+T+
as the data type for a parameter, then it can be called with
\verb+LIST(T)+ as well.  This results in the function generating a
list of the corresponding length and data type as its output.  For
example, consider a function 

\begin{verbatim}
Foo[x->T,y->S] =: R
\end{verbatim}

\noindent
where \verb+T+, \verb+S+, and \verb+R+ represent arbitrary data types.
Then if \verb+a+ is a \verb+LIST(T)+, and \verb+b+ is of type
\verb+S+, then \verb+c := Foo[a,b]+ generates \verb+c+ of type
\verb+LIST(R)+, where the length of \verb+c+ is equal to the length of
\verb+a+, and where \verb+c[[i]] = Foo[a[[i]],b]+.  

If \verb+Foo[]+ is called with both \verb+a+ and \verb+b+ being lists
of the correct data type, then the GCL checks whether the length of
\verb+a+ and \verb+b+ is the same.  If not, it generates a
dimensionality error. If they are of the same dimension, then 
\verb+c := Foo[a,b]+ generates \verb+c+ of type \verb+LIST(R)+, where the
length of \verb+c+ is equal to the length of \verb+a+, and where
\verb+c[[i]] = Foo[a[[i]],b[[i]]]+.

Note that the above rules implicitly define versions of \verb+Foo[]+
of the following forms:

\begin{verbatim}
Foo[x->LIST(T),y->S] =: LIST(R)
Foo[x->T,y->LIST(S)] =: LIST(R)
Foo[x->LIST(T),y->LIST(S)] =: LIST(R)
\end{verbatim}

The same rules apply recursively using these function prototypes as
well.  So if \verb+a+ is of type \verb+LIST(LIST(T))+, and \verb+b+ is
of type \verb+S+, the command \verb+c := Foo[a, b]+ results in
a listable call to \verb+Foo[x->LIST(T),y->S]+.  Thus, \verb+c+ is of
type \verb+LIST(LIST(R))+, where \verb+c[[i]] = +
\verb+Foo[a[[i]],b]+.  Hence, \verb+c[[i]][[j]] = +
\verb+Foo[a[[i]][[j]],b]+.

Note that many vector and matrix math operations follow directly as
listable calls to the basic arithmetic functions.  For example:

\begin{verbatim}
GCL1: a:={{1,2},{3,4}};
GCL2: 2*a
{{2,4},{6,8}}
GCL3: a+Transpose[a]
{{2,5},{5,8}}
\end{verbatim}

While most functions in the GCL are listable, there are some
exceptions.  Built in functions that are not listable are noted as
such in the Function Reference section of this document.  

Listability of functions is a powerful tool of the GCL. Many GCL
programs using flow control statements can be written using listable
function calls instead.  It is encouraged to use listable functions as
much as possible because it typically leads to more concise, easier to
read GCL programs, and in addition the programs typically run much
faster than they would if flow control satements were used instead.
This is because listable calls to functions are executed in compiled
code, while flow control statements are executed in interpreted code.

\subsection{Input and Output}

Data can be read from an input stream by the Read[] function.  So if
\verb+in+ is an input stream (i. e., of type INPUT) then a successful
call of \verb+Read[in,x]+ will read the exposed data (see function
reference for definition of ``exposed data'') from the input stream,
\verb+in+, assign \verb+x+ to have that type and value, and position
the file pointer at the end of the exposed data, to be ready for the
next call of Read[].  \verb+Read[in,x]+ has the short form \verb+in >>
x+.  Since the return value of \verb+Read[in,x]+ is \verb+in+, these
commands can be chained.  In other words,

\begin{verbatim}
in >> x >> y
\end{verbatim}
 
\noindent
is equivalent to 

\begin{verbatim}
Read[in,x]
Read[in,y]
\end{verbatim}

\noindent
In the statement \verb+Read[in,x]+, if \verb+x+ is undefined, then its
data type is determined from the exposed data in the input stream.  On
the other hand if \verb+x+ is previously defined, then the Read[]
function will expect to find the corresponding data type in the input
stream, and a file read error will be generated if the exposed data is
of the wrong data type.  If \verb+x+ is previously defined to be a
LIST(T), then \verb+Read[in,x]+ will successively read elements into
each element of the list.  If the wrong data type is found for any
element of the list, a file read error will be returned.  Thus, if the
file \verb+"file.out"+ contains the following data

\begin{verbatim}
25 1/3 "This is a text string!" False 3.14159 
{{1, 0},{0, 1}}
1 2 3 4 5
\end{verbatim}

then the following GCL code

\begin{verbatim}
in:=Input["file.dat"]
x:=List[0,5]
in >> i >> r >> t >> b >> f >> l >> x
\end{verbatim}

\noindent
opens an input stream, consisting of the file \verb+"file.dat"+, and
then reads data from the input stream into the corresponding
variables.  After the last statement, 
\verb+i+ is an INTEGER with value \verb+25+, 
\verb+r+ is a RATIONAL with value \verb+1/3+, 
\verb+t+ is a TEXT with value \verb+"This is a text string!"+, 
\verb+b+ is a BOOL with value \verb+False+, 
\verb+f+ is a FLOAT with value \verb+3.14159+, 
\verb+l+ is a LIST(LIST(INTEGER)) with value \verb+{{1,0},{0,1}}+, and 
\verb+x+ is a LIST(INTEGER) with value \verb+{1,2,3,4,5}+.  

Data can be written to an output stream by the use of the Write[]
function.  Thus, the following commands

\begin{verbatim}
out:=Output["file.out"]
x:=0/1;y:={0.0,0.0}
Write[out,x]
Write[out,y]
\end{verbatim}

creates an output stream, \verb+out+, and then writes out a RATIONAL
number, followed by a list of two FLOATs.  \verb+Write[out,x]+ has the
short form \verb+out >> x+.  Since the return value of Write[] is
\verb+out+, these commands can be chained.  So the two lines writing out
\verb+x+ and \verb+y+ in the above example could be written instead

\begin{verbatim}
out << x << y
\end{verbatim}
 
The SetFormat[] function can be used to control the formatting of data
written to an output stream.  Note that the Read[] and Write[]
functions are not listable.

The Read[] and Write[] functions can only be used with certain data
types (see function documentation).  Reading and writing of EFG and
NFG from external files can be done with the LoadEfg[], SaveEfg[],
LoadNfg[] and SaveNfg[] functions.  

\subsection{Extensive forms}

\subsubsection{Creating a new extensive form}

The function {\tt NewEfg[]} can be used to create a new extensive form game.
In order to do anything with it, a variable should be created to be
the new extensive form game.  Thus, the command

\begin{verbatim}
e := NewEfg[]
\end{verbatim}

\noindent will create a new extensive form game stored in \verb+e+.  The game 
is a trivial game with only one node, a \verb+root node+, and one
player, \verb+chance+.  By default, the game will have its data stored
as \verb+FLOAT+.  You can create a game whose data is \verb+RATIONAL+,
and which has two players, named \verb+Fred+ and \verb+Alice+  by
specifying 


\begin{verbatim}
e := NewEfg[True, {"Fred", "Alice"} ]
\end{verbatim}

\subsubsection{Modifying an extensive form}

The extensive form game editing functions can be used to build up any
valid extensive form game from a trivial game.  The following sequence
of commands builds the game tree for a simple poker game as described
in \cite{Mye:91}

\begin{verbatim}
e := NewEfg[];
n := RootNode[e];
deal := NewInfoset[ Chance[e], {"Red", "Black"}];
AppendNode[n, deal];
fred := NewPlayer[e,"Fred"];
fredred := NewInfoset[ fred , {"Raise", "Fold"} ];
fredblack := NewInfoset[ fred , {"Raise", "Fold"} ];
AppendNode[n#1, fredred];
AppendNode[n#2, fredblack];
alice := NewPlayer[e,"Alice"];
alicemove := NewInfoset[ alice , {"Meet", "Pass"} ];
AppendNode[n#1#1, alicemove]; 
AppendNode[n#2#1, alicemove]; 
\end{verbatim}

\noindent Outcomes can be defined and attached:

\begin{verbatim}
ante := 1.00;
raise := 1.00;
win := SetPayoff[NewOutcome[e, "Win"],{ante,-ante}];
winbig := SetPayoff[NewOutcome[e, "Win Big"],{ante+raise,-ante-raise}];
lose := SetPayoff[NewOutcome[e, "Lose"],{-ante,ante}];
losebig := SetPayoff[NewOutcome[e, "Lose Big"],{-ante-raise,ante+raise}];
AttachOutcome[TerminalNodes[e],{winbig,win,win,losebig,win,lose}]
\end{verbatim}

\subsubsection{Saving and loading extensive forms}

Once an extensive form game has been constructed, it can be saved by
the command 

\begin{verbatim}
SaveEfg[e, "filename.efg" ]
\end{verbatim}

\noindent where \verb+e+ is the extensive form game, and \verb+filename.efg+ is
the filename of the file to be created.  It is recommended that the
filename extension \verb+.efg+ be used when saving extensive form
games, as the Gambit graphics user interface recognizes this extension
as containing extensive form games.  Once an extensive form game has
been saved to an external file, it can be loaded by the command
\verb+LoadEfg+, as follows:

\begin{verbatim}
e := LoadEfg["filename.efg" ]
\end{verbatim}

\subsubsection{Subgames}

Gambit implements and supports the concept of a game theoretic
subgame.  When an extensive form is first created, no subgames (except
for the default ROOT subgame) are defined.  The function
\verb+MarkSubgames[]+ can be used to mark all of the subgames in the
extensive form, and \verb+MarkThisSubgame[]+ can be used to check
whether a specific node is a subgame root, and mark it if it is.
Similarly, subgames can be unmarked by using \verb+UnmarkSubgames[]+
and \verb+UnmarkThisSubgame[]+.  The function \verb+SubgameRoots[]+
returns a list of all currently marked subgame roots.  

All of the solution algorithms (with the current exception of the 
GobitSolve[] algorithms) make use of the marked subgames.  When non-trivial 
subgames are marked, then the solution algorithms will solve the 
extensive form game by recursion through the marked subgames.  Thus, a 
subgame is solved only when all subgames following it have been 
solved.  

If all subgames are marked, then any Nash equilibrium found will be a
subgame perfect Nash equilibrium.  Note that the solution algorithms
only respect marked subgames, and hence if you want the solution
algorithms to make use of subgames, you must mark the subgames.

\noindent
[Note: If there are non trivial marked subgames, the solution
algorithms currently only return one equilibrium (the first
found) in each subgame.  If no non-trivial subgames are marked, then
as many solutions as are requested will be found.]

\subsection{Normal forms}

\subsubsection{Creating a new normal form}

The function \verb+NewNfg[]+ is used to create a new normal form game.
In order to do anything with it, a variable should be created to be
the new extensive form game.  Thus, the command

\begin{verbatim}
n := NewNfg[{3,2,2}]
\end{verbatim}

\noindent 
will create a new normal form game stored in \verb+n+, with three players, where
the first player has three strategies, and the second and third
players each have two strategies.  The game has zero payoffs in each
strategy profile.  By default, the game will have its data stored in
\verb+FLOAT+.  You can create a game whose data is \verb+RATIONAL+
by specifying the parameter \verb+rational+ to be \verb+True+.

\subsubsection{Creating a normal form from an extensive form}

A normal form game can also be created from an extensive form game.
If \verb+e+ is an extensive form game, then the command 

\begin{verbatim}
n := Nfg[e]
\end{verbatim}

\noindent
will create a normal form game \verb+n+ which is the reduced normal
form game associated with the extensive form game \verb+e+.  As long
as the game \verb+n+ is not edited, then the GCL will ``remember'' the
extensive form game that \verb+n+ is associated with.  Any mixed
strategy solutions computed on the normal form game \verb+n+ can be
converted back to a behavior strategy of the game \verb+e+ by using
the command \verb+Behav+.  Thus

\begin{verbatim}
n := Nfg[e];
m := LcpSolve[n];
b := Behav[m,e]
\end{verbatim}

\noindent
will convert the game \verb+e+ to reduced normal form, solve it using
the LcpSolve algorithm, and then convert all mixed profiles found back
to behavior profiles, and display the list, \verb+b+ of behavior
profiles found. 
  
\subsubsection{Modifying a normal form}

The normal form game payoff editing functions can be used to build up any
valid normal form game from a trivial game.  Thus, the command

\begin{verbatim}
SetPayoff[n,{2,1,2},{3.0,4.0,1.5}]
\end{verbatim}

\noindent
changes the payoff for the strategy profile in which player one adopts
his second strategy, player 2 adopts her first strategy and player
three adopts his second strategy to the vector \verb+(3.0,4.0,1.5)+,
meaning that player one's payoff is \verb+3.0+, the second player's
payoff is \verb+4.0+ and the third player's payoff is \verb+1.5+.

\subsubsection{Saving and loading normal forms}

Once an normal form game has been constructed, it can be saved in a
similar way to an extensive form game.  The command 

\begin{verbatim}
SaveNfg[n, "filename.nfg" ]
\end{verbatim}

\noindent
will save the normal form game \verb+n+ to the file
\verb+filename.nfg+.  It is recommended that the
filename extension \verb+.nfg+ be used when saving normal form games, as
the Gambit Graphics user interface recognizes this extension as
containing normal form games.  Once a noirmal form game has been
saved to an external file, it can be loaded by the command
\verb+LoadNfg+, as follows:

\begin{verbatim}
n := LoadNfg["filename.nfg" ]
\end{verbatim}

\section{Solving games}

\subsection{Enum}

The two {\tt Enum} functions can be used to enumerate the pure or
mixed Nash equilibria for a normal form game. 

The {\tt EnumPureSolve} function enumerates all pure strategy Nash
equilibria in the support of a normal form game.  This
algorithm simply investigates all pure strategy profiles, checking
each for the Nash equilibrium conditions.  By default, the algorithm
finds all pure strategy Nash equilibrium.  Optionally it can be set to
find the first \verb+k+ Nash equilibria.  This algorithm will work on
any normal form game.  

The {\tt EnumMixedSolve} function enumerates all Nash equilibria (pure
and mixed) for a given support of a two person normal form game.  More
precisely, it finds the set of extreme Nash equilibria, as defined in
\cite[1964]{Man:64}.  For any normal form game, as shown in
Mangasarian, every Nash equilibrium can be expressed as a convex
combination of the extreme Nash equilibria.  For generic games, there
are just a finite number of Nash equilibria, which coincide with the
extreme equilibria.  By default, all extreme equilibria are found.
Optionally, the algorithm can be set to find the first \verb+k+
equilibria.  This algorithm works only on two-person normal form
games.

\subsection{Gobit}

The {\tt GobitSolve} function computes a branch of the logistic
quantal response equilibrium correspondence (as described in
\cite{McKPal:95a} for normal form games, and in
\cite{McKPal:95b} for extensive form games.  The branch is
computed for values of $\lambda$ between $\underline{\lambda}$ and
$\bar{\lambda}.$ The algorithm starts at $\lambda_0 =
\underline{\lambda}$ if $\delta>0,$ or $\lambda_0 = \bar{\lambda}$ if
$\delta<0$. It then increments according to the formula
$$
\lambda_{t+1} = \lambda_t +\delta \lambda_t^a,
$$ 
where $\underline\lambda,$ $\bar\lambda,$ $\delta,$ and $a$ are
parameters that can be specified.  In the computation for the first value of
$\lambda_0$, the algorithm begins its search for a solution at a user
specified starting point.  At each
successive value of $\lambda_t,$ the algorithm begins its search at
the point found in step $t - 1.$ 

The {\em principal branch} of the logistic quantal response
equilibrium mapping is the branch that is connected to the centroid of
the game at $\lambda = 0$.  This branch can be computed by setting
$\lambda_0$ sufficiently small.  As discussed in McKelvey and Palfrey,
for generic normal form games, the principal branch of the quantal
response equilibrium correspondence converges to a unique selection
from the set of Nash equilibria as $\lambda$ goes to infinity.
Similarly, for generic extensive form games, the principal branch of
the quantal response mapping converges to a unique selection from the
set of sequential equilibria as $\lambda$ goes to infinity.  Hence, in
extensive form games, this algorithm can be used to compute an
approximation to a sequential equilibrium.

The {\tt GobitGridSolve} function performs a grid search to compute
the {\em complete} logistic quantal response correspondence.  Points
are evaluated in terms of the value of an objective function, that
measures the distance between the original point, and the best
response to the best response (under the logistic best response
function.)  Points that are close (within 'tol') to being fixed points
are kept, others are discarded.  Values of the probabilities are
evaluated on a grid of mesh 'delp.'  This procedure is very
computationally intensive, and is only feasible for small two-person
normal form games.

\subsection{Linear Complementarity Program}

The {\tt LcpSolve} function formulates and solves the game as a linear
complementarity problem.  This algorithm works for two person
games in either extensive or normal form.  
 
For a normal form game, the game is solved via the Lemke-Howson
Algorithm.  (See, eg.,
\cite{LemHow:64}) using lexicographic rule for insuring
termination, as developed in \cite{Eav:71}.  This algorithm can also
be used to find the set of {\em accessible} Nash equilibria, by
tracing out the pattern of connectedness of the complemenary basic
feasible solutions, as described in \cite{Sha:74}.  The set of
accessible equilibria is frequently the same as the set of all Nash
equilibria, but this is not always so.

For an extensive form game, this algorithm implements Koller, Megiddo
and von Stengel's {\em sequence form} (\cite{KolMegSte:94}. The
sequence form is a formulation of the set of Nash equilibria as the
solution to a non linear complementarity problem in variables that
correspond to ``sequences'' in the extensive form, which they show can
be solved by Lemke's algorithm for Linear complementarity problems.
The method has nice properties in terms of its computational
complexity, as it only grows linearly in the size of the extensive
form game.  

\subsection{Lyapunov Function}

The {\tt LiapSolve} function finds Nash equilibria via the Lyapunov
function method described in \cite{McK:91}.  This method works on
either the extensive or normal form.  This algorithm casts the problem
as a function minimization problem by use of a Lyapunov function for
Nash equilibria.  This is a continuously differentiable non negative
function whose zeros coincide with the set of Nash equilibria of the
game.  A standard descent algorithm is used to find a constrained
local minimum of the function from any given starting location.  Since
a local minimum need not be a global minimum (with value 0,) the
algorithm is not guaranteed to find a Nash equilibrium from any fixed
starting point.  The algorithm thus incorporates the capability of
restarting.  The algorithm starts from the initial starting point
determined by the parameter 'start'.  If a Nash equilibrium is not
found, it will keep searching from new randomly chosen starting points
until a Nash equilibrium has been found or the maximum number of tries
(parameter 'ntries') is exceeded, whichever comes first.

\subsection{Linear Program}

Finds the minmimax solution (a Nash equilibrium) for a two person
constant-sum game in normal form, by solving it as a Linear Program.

\subsection{Simpicial Subdivision}

Computes a Nash equilibrium to a n-person normal form game based on a
simplicial subdivision algorithm.  The algorithm implemented is that
of \cite{VTH:1987}.  The algorithm is a simplicial subdivision
algorithm which can start at any point in the simplex.  The algorithm
starts with a given grid size, follows a path of almost completely
labeled subsimplexes, and converges to a completely labeled
sub-simplex that approximates the solution.  Additional accuracy is
obtained by refining the grid size and restarting from the previously
found point.  The idea is that by restarting at a close approximation
to the solution, each successive increase in accuracy will yield a
short path, and hence be quick.

In its pure form, the algorithm is guaranteed to find at least one
mixed strategy equilibrium to any n-person game.  Experience shows
that the algorithm works well, and is acceptably fast for many
moderate size problems.  But in some examples it can be quite slow.
The reason for this is that sometimes after restarting with a refined
grid size, even though the starting point is a good approximation to
the solution, the algorithm will go to the boundary of the simplex
before converging back to a point that is close to the original
starting point.  When this occurs, each halving of the grid size will
take twice as long to converge as the previous grid size.  If a high
degree of accuracy is required, or if the normal form is large, this
can result in the algorithm taking a long time to converge.

In order to combat the above difficulty, a parameter 'leash' has been
added to the algorithm which places a limit on the distance which the
algorithm can wander from the restart point. (Setting this parameter
to 0 results in no limit, and gives the pure form of the algorithm.)
With this parameter set to a non trivial value, the algorithm is no
longer guaranteed to converge, and setting small values of the
parameter will sometimes yield lack of convergence.  However,
experience shows that values of the parameter on the order of 10
generally do not destroy convergence, and yield much faster
convergence.

\section{Function Reference, by Category}

This section contains a list of functions, organized by
category.  For a description of each function, and the arguments,
refer to the following, alphabetically organized, section.

\subsection{General Functionality}

\begin{verbatim}
Assign[x<->T, y->T] =: T
Clear[]
Include[file->TEXT]
NewFunction[name[argument-list], body]
Quit
UnAssign[x<->T] =: T
\end{verbatim}

\subsection{Flow Control}

\begin{verbatim}
For[statement-list, boolean-expression, statement-list, statement-list]
If[boolean-expression, statement-list]
If[boolean-expression, statement-list, statement-list]
While[boolean-expression, statement-list]
\end{verbatim}

\subsection{Lists}

\noindent {\bf Note}: The function {\tt Concat} was named {\tt Plus}
prior to version 0.92.

\begin{verbatim}
Concat[x->LIST(T), y->LIST(T)] =: LIST(T)
Contains[list->LIST(T), x->T] =: BOOL
Length[list->LIST(T)] =: INTEGER
NthElement[list->LIST(T),n->INTEGER] =: T 
Remove[list->LIST(T), n->INTEGER] =: LIST(T)
Transpose[x->LIST(LIST(T))] := LIST(LIST(T))
\end{verbatim}

\subsection{String Functions}

\noindent {\bf Note}: The function {\tt Concat} was named {\tt Plus}
prior to version 0.92.

\begin{verbatim}
Concat[x->TEXT, y->TEXT] =: TEXT
Greater[x->TEXT, y->TEXT] =: BOOL
GreaterEqual[x->TEXT, y->TEXT] =: BOOL
NumChars[text->TEXT] =: INTEGER
Less[x->TEXT, y->TEXT] =: BOOL
LessEqual[x->TEXT, y->TEXT] =: BOOL
NthChar[text->TEXT, n->INTEGER] =: TEXT
\end{verbatim}


\subsection{Input and Output}

\begin{verbatim}
Input[file->TEXT] =: INPUT
LoadEfg[file->TEXT] =: EFG
LoadNfg[file->TEXT] =: NFG
Output[file->TEXT] =: OUTPUT
Read[input->INPUT, x<->T] =: INPUT  
      for T = BEHAV,BOOL,FLOAT,INTEGER,MIXED,RATIONAL,TEXT,LIST(T)
SaveEfg[efg<->EFG, file->TEXT] =: EFG
SaveNfg[nfg<->NFG, file->TEXT] =: NFG
SetFormat[ {width->INTEGER}, {precis->INTEGER}, {expmode->BOOL},
                {quote->BOOL}, {listBraces->BOOL},
                {listCommas->BOOL}, {listLF->INTEGER},
                {listIndent->INTEGER} ] := BOOL
Write[output->OUTPUT, x->T] =: OUTPUT  
      for T = BEHAV,BOOL,FLOAT,INTEGER,MIXED,RATIONAL,TEXT,LIST(T)
Write[output->OUTPUT, x<->T] =: OUTPUT 
      for T = EFG, NFG
\end{verbatim}

\subsection{Logic}

\begin{verbatim}
And[x->BOOL, y->BOOL] =: BOOL
Equal[x->T, y->T] =: BOOL
Not[x->BOOL] =: BOOL
NotEqual[x->T, y->T] =: BOOL
Or[x->BOOL, y->BOOL] =: BOOL
\end{verbatim}

\subsection{Arithmetic}

\begin{verbatim}
ArgMax[x->LIST(T)] := INTEGER
       for T = FLOAT, INTEGER, RATIONAL
Divide[x->T, y->T] =: T
       for T = FLOAT, RATIONAL  
Dot[x->LIST(T), y->LIST(T)] =: T
       for T = FLOAT, INTEGER, RATIONAL
Exp[x->FLOAT] =: FLOAT
Greater[x->T, y->T] =: BOOL
       for T = FLOAT, INTEGER, RATIONAL
GreaterEqual[x->T, y->T] =: BOOL
       for T = FLOAT, INTEGER, RATIONAL
IntegerDivide[x->INTEGER, y->INTEGER] =: INTEGER
Less[x->T, y->T] =: BOOL
       for T = FLOAT, INTEGER, RATIONAL
LessEqual[x->FLOAT, y->FLOAT] =: BOOL
       for T = FLOAT, INTEGER, RATIONAL
Log[x->FLOAT] =: FLOAT
Minus[x->FLOAT, y->FLOAT] =: FLOAT
       for T = FLOAT, INTEGER, RATIONAL, MIXED, BEHAV
Modulus[x->INTEGER, y->INTEGER] =: INTEGER
Negate[x->FLOAT] =: FLOAT
       for T = FLOAT, INTEGER, RATIONAL
Paren[x->T] =: T
Plus[x->FLOAT, y->FLOAT] =: FLOAT
       for T = FLOAT, INTEGER, RATIONAL, MIXED, BEHAV
Times[x->FLOAT, y->FLOAT] =: FLOAT
       for T = FLOAT, INTEGER, RATIONAL,
Times[x->FLOAT, y->MIXED] =: MIXED
Times[x->MIXED, y->FLOAT] =: MIXED
Times[x->RATIONAL, y->MIXED] =: MIXED
Times[x->MIXED, y->RATIONAL] =: MIXED
Times[x->FLOAT, y->BEHAV] =: BEHAV
Times[x->BEHAV, y->FLOAT] =: BEHAV
Times[x->RATIONAL, y->BEHAV] =: BEHAV
Times[x->BEHAV, y->RATIONAL] =: BEHAV
\end{verbatim}

\subsection{Extensive Form Manipulation}

\begin{verbatim}
AddAction[support->EFSUPPORT, infoset->INFOSET, 
          action->ACTION] =: EFSUPPORT
AppendAction[infoset->INFOSET] =: ACTION
AppendNode[node->NODE, infoset->INFOSET] =: NODE
AttachOutcome[node->NODE, outcome->OUTCOME] =: OUTCOME
Behav[efg<->EFG | support->EFSUPPORT, 
      {list->LIST(LIST(LIST(FLOAT)))}] =: BEHAV
Behav[efg<->EFG | support->EFSUPPORT, 
      {list->LIST(LIST(LIST(RATIONAL)))}] =: BEHAV
CopyTree[from->NODE, to->NODE] =: NODE
DeleteAction[infoset->INFOSET, action->ACTION] =: ACTION
DeleteNode[node->NODE, keep->NODE] =: NODE
DeleteOutcome[outc->OUTCOME] =: BOOL
DeleteTree[node->NODE] =: NODE
DetachOutcome[node->NODE] =: NODE
InsertAction[infoset->INFOSET, at->ACTION] =: ACTION
InsertNode[node->NODE, infoset->INFOSET] =: NODE
JoinInfoset[node->NODE, infoset->INFOSET] =: NODE
LeaveInfoset[node->NODE] =: INFOSET
MarkSubgames[efg<->EFG] =: LIST(NODE)
MarkSubgames[node->NODE] =: LIST(NODE)
MarkThisSubgame[node->NODE] =: BOOL
MergeInfosets[infoset1->INFOSET,
               infoset2->INFOSET] =: INFOSET
MoveTree[from->NODE, to->NODE] =: NODE
NewEfg[{rational->BOOL}, {players->LIST(TEXT)}] =: EFG
NewInfoset[player->EFPLAYER, actions->LIST(TEXT),
           {name->TEXT}] =: INFOSET
NewInfoset[player->EFPLAYER, actions->INTEGER,
           {name->TEXT}] =: INFOSET
NewOutcome[efg<->EFG, {name->TEXT}] =: OUTCOME
NewPlayer[efg<->EFG, {name->TEXT}] =: EFPLAYER 
NewSupport[efg<->EFG] =: EFSUPPORT
RandomEfg[efg<->EFG, {seed->INTEGER}] =: EFG
RemoveAction[support->EFSUPPORT, infoset->INFOSET, 
             action->ACTION] =: EFSUPPORT
Reveal[infoset->INFOSET, who->LIST(EFPLAYER))] =: INFOSET
SetChanceProbs[infoset->INFOSET, probs->LIST(FLOAT)] =: INFOSET
SetChanceProbs[infoset->INFOSET, probs->LIST(RATIONAL)] =: INFOSET
SetComponent[mixed<->MIXED, player->PLAYER, list->LIST(T)] =: MIXED 
SetComponent[behav<->BEHAV, infoset->INFOSET, list->LIST(T)] =: BEHAV 
SetName[x->ACTION, name->TEXT] =: ACTION
SetName[x<->EFG, name->TEXT] =: EFG
SetName[x->INFOSET, name->TEXT] =: INFOSET
SetName[x->NODE, name->TEXT] =: NODE
SetName[x->OUTCOME, name->TEXT] =: OUTCOME
SetName[x->PLAYER, name->TEXT] =: PLAYER
SetPayoff[outcome->OUTCOME, payoff->LIST(FLOAT)] =: OUTCOME
SetPayoff[outcome->OUTCOME, payoff->LIST(RATIONAL)] =: OUTCOME
SubgameRoots[efg<->EFG] =: LIST(NODE)
UnmarkSubgames[efg<->EFG] =: LIST(NODE)
UnmarkSubgames[node->NODE] =: LIST(NODE)
UnmarkThisSubgame[node->NODE] =: NODE
\end{verbatim}

\subsection{Normal Form Manipulation}

\begin{verbatim}
AddStrategy[support->NFSUPPORT, strategy->STRATEGY] =: NFSUPPORT
Mixed[nfg<->NFG, list->LIST(LIST(FLOAT))] =: MIXED
Mixed[nfg<->NFG, list->LIST(LIST(RATIONAL))] =: MIXED
Mixed[support->NFSUPPORT, {list->LIST(LIST(FLOAT))}] =: MIXED
Mixed[support->NFSUPPORT, {list->LIST(LIST(RATIONAL))}] =: MIXED
NewNfg[dim->LIST(INTEGER), {rational->BOOL}] =: NFG
NewSupport[nfg<->NFG] =: NFSUPPORT
RandomNfg[nfg<->NFG, {seed->INTEGER}] =: NFG
RemoveStrategy[support->NFSUPPORT, strategy->STRATEGY] =: NFSUPPORT
SetName[x<->NFG, name->TEXT] =: NFG
SetPayoff[list->LIST(INTEGER), payoffs->LIST(FLOAT)] =: LIST(INTEGER)
SetPayoff[list->LIST(INTEGER), payoffs->LIST(RATIONAL)] =: LIST(INTEGER)
\end{verbatim}

\subsection{Conversions}

\begin{verbatim}
Float[x->INTEGER] =: FLOAT
Float[x->FLOAT] =: FLOAT
Float[x->RATIONAL] =: FLOAT
List[x<->T, {length->INTEGER},{delta->T}] =: LIST(T)
List[x->T, {length->INTEGER},{delta->T}] =: LIST(T)
ListForm[mixed->MIXED] =: LIST(LIST(T))
ListForm[behav->BEHAV] =: LIST(LIST(LIST(T)))
Nfg[efg<->EFG, {time<->FLOAT}] =: NFG
Rational[x->INTEGER] =: RATIONAL
Rational[x->FLOAT] =: RATIONAL
Rational[x->RATIONAL] =: RATIONAL
Text[x->INTEGER] =: TEXT
Text[x->FLOAT] =: TEXT
Text[x->RATIONAL] =: TEXT
Text[x->TEXT] =: TEXT
\end{verbatim}

\subsection{Solving and analyzing games}

\begin{verbatim}
Behav[mixed->MIXED] =: BEHAV
ElimDom[nfg<->NFG | support->NFSUPPORT, {strong->BOOL}, 
        {time<->FLOAT} =: NFSUPPORT
ElimAllDom[nfg<->NFG | support->NFSUPPORT, {strong->BOOL}, 
        {time<->FLOAT} =: NFSUPPORT
EnumMixedSolve[efg<->EFG, {asNfg->BOOL}, {stopAfter->INTEGER},
               {nPivots<->INTEGER}, {time<->FLOAT}] =: LIST(BEHAV)
EnumMixedSolve[nfg<->NFG | support->NFSUPPORT, {stopAfter->INTEGER},
               {nPivots<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
EnumPureSolve[efg<->EFG, {asNfg->BOOL}, {stopAfter->INTEGER},
              {time<->FLOAT}] =: LIST(BEHAV)
EnumPureSolve[nfg<->NFG | support->NFSUPPORT, {stopAfter->INTEGER}, 
              {time<->FLOAT}] =: LIST(MIXED) 
GobitSolve[efg<->EFG | start->BEHAV, {pxifile->TEXT},
           {minLam->FLOAT}, {maxLam->FLOAT},
           {delLam->FLOAT}, {powLam->INTEGER},
           {fullGraph->BOOL}, {maxitsN->INTEGER}, {tolN->FLOAT},
           {maxits1->INTEGER}, {tol1->FLOAT}, {time<->FLOAT},
           {nEvals<->INTEGER}, {nIters<->INTEGER}] =: LIST(BEHAV)
GobitSolve[nfg<->NFG | start->MIXED, {pxifile->TEXT},
           {minLam->FLOAT}, {maxLam->FLOAT},
           {delLam->FLOAT}, {powLam->INTEGER},
           {fullGraph->BOOL}, {maxitsN->INTEGER}, {tolN->FLOAT},
           {maxits1->INTEGER}, {tol1->FLOAT}, {time<->FLOAT},
           {nEvals<->INTEGER}, {nIters<->INTEGER}] =: LIST(MIXED)
GobitGridSolve[nfg<->NFG | support->NFSUPPORT, {pxifile->TEXT},
              {minLam->FLOAT}, {maxLam->FLOAT}, 
              {delLam->FLOAT}, {powLam->INTEGER}, 
              {delp->FLOAT}, {tol->FLOAT},
              {nEvals<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
LcpSolve[efg<->EFG, {asNfg->BOOL}, {stopAfter->INTEGER},
         {nPivots<->INTEGER}, {time<->FLOAT}] =: LIST(BEHAV)
LcpSolve[nfg<->NFG | support->NFSUPPORT, {stopAfter->INTEGER},
         {nPivots<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
LiapSolve[efg<->EFG | start->BEHAV, {asNfg->BOOL},
          {stopAfter->INTEGER}, {nTries->INTEGER},
          {maxitsN->INTEGER}, {tolN->FLOAT},
          {maxits1->INTEGER}, {tol1->FLOAT},
          {time<->FLOAT}, {nEvals<->INTEGER}] =: LIST(BEHAV)
LiapSolve[nfg<->NFG | start->MIXED, 
          {stopAfter->INTEGER}, {nTries->INTEGER},
          {maxitsN->INTEGER}, {tolN->FLOAT},
          {maxits1->INTEGER}, {tol1->FLOAT},
          {time<->FLOAT}, {nEvals<->INTEGER}] =: LIST(MIXED)
LpSolve[efg<->EFG,
        {nPivots<->INTEGER}, {time<->FLOAT}] =: LIST(BEHAV)
LpSolve[nfg<->NFG | support->NFSUPPORT, {nPivots<->INTEGER},
        {time<->FLOAT}] =: LIST(MIXED)
SetOptions[alg->TEXT, param->TEXT, value->T] =: T
SimpDivSolve[nfg<->NFG | support->NFSUPPORT, {stopAfter->INTEGER}, 
             {nRestarts->INTEGER}, {leashLength->INTEGER},
             {nEvals<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
\end{verbatim}

\subsection{Getting Information}

\begin{verbatim}
Actions[infoset->INFOSET] =: LIST(ACTION)
Beliefs[strategy<->BEHAV(T)] =: LIST(LIST(LIST((T)))
Centroid[efg<->EFG | support->EFSUPPORT] =: BEHAV
Centroid[nfg<->NFG | support->NFSUPPORT] =: MIXED
Chance[efg<->EFG] =: EFPLAYER
ChanceProbs[infoset->INFOSET] =: LIST(T)
GobitLambda[strategy->BEHAV(T) | MIXED(T)] =: T
GobitValue[strategy->BEHAV(T) | MIXED(T)] =: T
HasOutcome[node->NODE] =: BOOL
Infoset[node->NODE] =: INFOSET
Infosets[player->EFPLAYER] =: LIST(INFOSET)
IsNash[strategy->MIXED] =: BOOL
IsNash[strategy->BEHAV] =: BOOL
IsntPerfect[strategy->MIXED] =: BOOL
IsntProper[strategy->MIXED] =: BOOL
IsntSequential[strategy->BEHAV] =: BOOL
IsntSubgamePerfect[strategy->BEHAV] =: BOOL
IsPerfect[strategy->MIXED] =: BOOL
IsPredecessor[node->NODE, of->NODE] =: BOOL
IsProper[strategy->MIXED] =: BOOL
IsSequential[strategy->BEHAV] =: BOOL
IsSubgamePerfect[strategy->BEHAV] =: BOOL
IsRoot[node->NODE] =: BOOL
IsSuccessor[node->NODE, from->NODE] =: BOOL
LastAction[node->NODE] =: ACTION
LiapValue[strategy->BEHAV(T) | MIXED(T)] =: T
Members[infoset->INFOSET] =: LIST(NODE)
Name[x->ACTION] =: TEXT
Name[x<->EFG] =: TEXT
Name[x->EFPLAYER] =: TEXT
Name[x->INFOSET] =: TEXT
Name[x<->NFG] =: TEXT
Name[x->NFPLAYER] =: TEXT
Name[x->NODE] =: TEXT
Name[x->OUTCOME] =: TEXT
Name[x->STRATEGY] =: TEXT
NextSibling[node->NODE] =: NODE
Nodes[efg<->EFG] =: LIST(NODE)
NonterminalNodes[efg<->EFG] =: LIST(NODE)
NthChild[node->NODE, n->INTEGER] =: NODE
NumActions[infoset->INFOSET, {support->EFSUPPORT}] =: INTEGER
NumChildren[node->NODE] := INTEGER
NumInfosets[player->EFPLAYER] =: INTEGER
NumMembers[infoset->INFOSET] =: INTEGER
NumNodes[efg<->EFG] =: INTEGER
NumOutcomes[efg<->EFG] =: INTEGER
NumPlayers[efg<->EFG] =: INTEGER
NumPlayers[nfg<->NFG] =: INTEGER
NumStrats[player->NFPLAYER, {support->NFSUPPORT}] =: INTEGER
Outcome[node->NODE] =: OUTCOME
Outcomes[efg<->EFG] =: LIST(OUTCOME)
Parent[node->NODE] =: NODE
Payoff[outcome->OUTCOME] =: LIST(T)
Payoff[strategy->BEHAV] =: LIST(T)
Payoff[strategy->MIXED] =: LIST(T)
Player[infoset->INFOSET] =: EFPLAYER
Player[node->NODE] =: EFPLAYER
Players[efg<->EFG] =: LIST(EFPLAYER)
Players[nfg<->NFG] =: LIST(NFPLAYER)
PriorSibling[node->NODE] =: NODE
RealizProbs[strategy->BEHAV(T)] =: LIST(T)
RootNode[efg<->EFG] =: NODE
Support[strategy->MIXED] =: NFSUPPORT
Support[strategy->BEHAV] =: EFSUPPORT
TerminalNodes[efg<->EFG] =: LIST(NODE)
\end{verbatim}

\subsection{Timing}

\begin{verbatim}
ElapsedTime[] =: FLOAT
IsWatchRunning[] =: BOOL
StartWatch[] =: FLOAT
StopWatch[] =: FLOAT
\end{verbatim}


\section{Function Reference, Alphabetical}

The following is a list of procedures with the operations that they
perform in the Gambit Command Language:

Variable types in all capital letters indicate the type of the
required parameter or return value of the procedure.

The symbol {\tt "=:"} to the right of a procedure specifies the type
of the return value (if any exists) produced by the procedure.

Paremeters enclosed in brackets {\tt "\{ \}"} represent optional
parameters which are not necessary for the procedure to function.

\begin{itemize}

%--A--


\item
\protect \large \begin{verbatim} 
Actions[infoset->INFOSET] =: LIST(ACTION)
\end{verbatim}\normalsize

\bd
Returns the list of actions available at the information set
\verb+infoset+.
\item
[See also:] {\tt AppendAction}, {\tt DeleteAction}, {\tt InsertAction},
{\tt NumActions}.
\ed

\item
\protect \large \begin{verbatim}
ActionValues[strategy->BEHAV, 
             infoset->INFOSET] =: LIST(FLOAT)
ActionValues[strategy->BEHAV, 
             infoset->INFOSET] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns the list of values at information set \verb+infoset+ for each
action for the player making the decision at \verb+infoset+, assuming that
all players obey the behavioral strategy profile \verb+strategy+.
\item
[See also:] {\tt Beliefs}, {\tt InfosetProbs}, {\tt NodeValues},
{\tt RealizProbs}.
\ed

\item
\protect \large \begin{verbatim} 
AddAction[support->EFSUPPORT, infoset->INFOSET, 
          action->ACTION] =: EFSUPPORT
\end{verbatim}\normalsize

\bd 
Adds the action \verb+action+, from \verb+infoset+ to the
EFSUPPORT \verb+support+.
\item
[See also:] {\tt RemoveAction}
\ed


\item
\protect \large \begin{verbatim}
AddStrategy[support->NFSUPPORT, 
            strategy->STRATEGY] =: NFSUPPORT
\end{verbatim}\normalsize

\bd
Adds the strategy \verb+strategy+ to the
strategies in the support \verb+support+.  If \verb+strategy+ is already in the
support, no action is taken.  The modified support is returned.
\item
[See also:] {\tt NewSupport}, {\tt RemoveStrategy}.
\ed

\item
\protect \large \begin{verbatim}
Afg[efg<->EFG] =: NFG
\end{verbatim}\normalsize

\bd
Returns the agent normal form associated with the extensive form game
\verb+efg+.
\ed


\item 
\protect \large \begin{verbatim}
And[x->BOOL, y->BOOL] =: BOOL
\end{verbatim} \normalsize

\bd
Computes the logical conjunction of \verb+x+ and \verb+y+.
\item
[Short forms:] \verb+x && y+, \verb+x AND y+.
\ed


\item
\protect \large \begin{verbatim}
AppendAction[infoset->INFOSET] =: ACTION
\end{verbatim}\normalsize

\bd
Adds an action into the information set \verb+infoset+,
as the last action.  Returns the newly created action.
\item
[See also:] {\tt Actions}, {\tt DeleteAction}, {\tt InsertAction},
{\tt NumActions}.
\ed


\item
\protect \large \begin{verbatim} 
AppendNode[node->NODE, infoset->INFOSET] =: NODE
\end{verbatim}\normalsize

\bd
Places \verb+node+ into the information set
\verb+infoset+.  The result is \verb+node+ becomes a decision node,
with number of branches equal to the number of actions in \verb+infoset+.
Returns the first child of \verb+node+.
\item
[See also:] {\tt InsertNode}, {\tt NewInfoset}.
\ed


\item 
\protect \large \begin{verbatim}
ArgMax[x->LIST(T)] := INTEGER
       for T = FLOAT, INTEGER, RATIONAL
\end{verbatim} \normalsize

\bd
Returns the index of the first element of the list which attains the
maximum value. 
\ed

\item 
\protect \large \begin{verbatim}
Assign[x<->T, y->T] =: T
\end{verbatim} \normalsize

\bd
Assigns the value \verb+y+ to the variable referred to by
\verb+x+.  Returns the value assigned.
\item
[Short form:] \verb+x := y+
\item
[See also:] {\tt UnAssign}.
\ed

\item
\protect \large \begin{verbatim} 
AttachOutcome[node->NODE, outcome->OUTCOME] =: OUTCOME
\end{verbatim}\normalsize

\bd
Attaches the outcome \verb+outcome+ to the node \verb+node+.
Returns the outcome attached.  Note that nonterminal nodes may have
attached outcomes.
\item
[See also:] {\tt DetachOutcome}, {\tt HasOutcome}, {\tt Outcome}.
\ed

%--B--


\item
\protect \large \begin{verbatim}
Behav[efg<->EFG | support->EFSUPPORT, 
      {list->LIST(LIST(LIST(FLOAT)))}] =: BEHAV
Behav[efg<->EFG | support->EFSUPPORT, 
      {list->LIST(LIST(LIST(RATIONAL)))}] =: BEHAV
\end{verbatim}\normalsize

\bd Creates a behavioral profile for the game \verb+efg+, or EFSUPPORT
\verb+support+ with values equal to that in \verb+list+.
\item
[See also:] {\tt Mixed}.
\ed

\item
\protect \large \begin{verbatim}
Behav[mixed->MIXED, efg<->EFG] =: BEHAV
\end{verbatim}\normalsize

\bd
Converts the mixed profile \verb+mixed+ to the equivalent
behavioral profile on the associated extensive form game \verb+efg+.
\ed

\item
\protect \large \begin{verbatim}
Beliefs[strategy<->BEHAV(T)] =: LIST(LIST(LIST((T)))
\end{verbatim}\normalsize

\bd 
Returns a list of the conditional probabilities of being at a node
given that a player knows he/she is in that node's information set, if
all players are playing the behavioral strategy profile
\verb+strategy+.  The list is ordered first by player, then
by information set number, and then by node number (in the projection
of the prefix-traversal order of the game tree) of the nodes within
the information set.  
\item
[See also:] {\tt ActionValues}, {\tt InfosetProbs},
{\tt NodeValues}, {\tt RealizProbs}.
\ed


%--C--

\item
\protect \large \begin{verbatim} 
Centroid[efg<->EFG | support->EFSUPPORT] =: BEHAV
\end{verbatim}\normalsize

\bd
Returns a behavioral profile for the extensive form
support \verb+efg+ initialized to the centroid, that is, the behavioral
profile in which all actions at each information set are equally
likely to be chosen.  If \verb+efg+ is specified, the support is the
full support.  
\ed

\item
\protect \large \begin{verbatim}
Centroid[nfg<->NFG | support->NFSUPPORT] =: MIXED
\end{verbatim}\normalsize

\bd
Returns a mixed profile over the support \verb+support+
initialized to the centroid, that is, the mixed profile in which 
all strategies in the support for each player are equally likely to be
chosen, and all strategies not in the support are chosen with probability
zero.  If \verb+nfg+ is specified, the support is the full support.  
\ed

\item
\protect \large \begin{verbatim}
Chance[efg<->EFG] =: EFPLAYER
\end{verbatim}\normalsize

\bd
Returns the chance, or nature, player defined on the
extensive form game \verb+efg+.  Each extensive form has exactly one
chance player predefined, and it is not possible to define any additional
chance players.
\ed

\item
\protect \large \begin{verbatim}
ChanceProbs[infoset->INFOSET] =: LIST(FLOAT)
ChanceProbs[infoset->INFOSET] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns the vector of probabilities over the actions at
information set \verb+infoset+ as a list.  A run-time error results if
the given information set does not belong to the chance player.
\ed

\item
\protect \large \begin{verbatim}
Clear[]
\end{verbatim}\normalsize

\bd
Unassigns all currently defined variables.
\ed

\item
\protect \large \begin{verbatim}
Concat[x->LIST(T), y->LIST(T)] =: LIST(T)
\end{verbatim}\normalsize

\bd
Returns the concatenation of the lists \verb+x+ and \verb+y+.
\item
[Short form:] \verb%x & y%
\item
[Note:] This function is not listable.
\item
[Note:] Prior to version 0.92 this function was named {\tt Plus}.
\ed

\item 
\protect \large \begin{verbatim}
Concat[x->TEXT, y->TEXT] =: TEXT
\end{verbatim} \normalsize

\bd
Returns the concatenation of the text strings \verb+x+
and \verb+y+.
\item
[Short form:] \verb%x & y%
\item
[Note:] This function is not listable.
\item
[Note:] Prior to version 0.92 this function was named {\tt Plus}.
\ed

\item
\protect \large \begin{verbatim}
Contains[list->LIST(T), x->T] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the value \verb+x+ is contained in the list
\verb+list+.
\item
[Note:] This function is not listable.
\item
[See also:] {\tt Length}, {\tt Subscript}.
\ed

\item
\protect \large \begin{verbatim}
CopyTree[from->NODE, to->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Copies the subtree rooted at \verb+from+ to the terminal
node \verb+to+ in the same extensive form game.  The nodes in the
copied subtree belong to the same information sets as their counterparts in
the original subtree.  Returns the node \verb+to+.
\item
[See also:] {\tt MoveTree}, {\tt Reveal}.
\ed

%--D--

\item
\protect \large \begin{verbatim}
DeleteAction[infoset->INFOSET, action->ACTION] =: INFOSET
\end{verbatim}\normalsize

\bd
Deletes the action \verb+action+ from the information set
\verb+infoset+.  As a consequence, the corresponding subtrees associated
with the action from each member of the information set are deleted.
Returns the information set.
\item
[See also:] {\tt Actions}, {\tt AppendAction}, {\tt InsertAction},
{\tt NumActions}.
\ed

\item
\protect \large \begin{verbatim}
DeleteNode[node->NODE, keep->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Deletes the node \verb+node+ from the tree.  The
subtree rooted in node \verb+keep+, which must be a child of
\verb+node+, is kept, and \verb+keep+ takes the place of \verb+node+ in
the tree.  All other subtrees descending from \verb+node+ are deleted.
The kept node \verb+keep+ is returned.
\item
[See also:] {\tt DeleteTree}, {\tt InsertNode}.
\ed

\item
\protect \large \begin{verbatim}
DeleteOutcome[outcome->OUTCOME] =: BOOL
\end{verbatim}\normalsize

\bd
Removes the outcome \verb+outcome+ from its extensive
form game.  All nodes with the specified outcome attached are reset to
having no outcome attached; this is equivalent to an implicit call to
{\tt DetachOutcome} on these nodes.  Returns \verb+True+ on success.
\item
[See also:] {\tt NewOutcome}.
\ed

\item
\protect \large \begin{verbatim}
DeleteTree[node->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Deletes the subtree rooted at the node \verb+node+.  The
node then becomes a terminal node, which is returned.
\item
[See also:] {\tt DeleteNode}.
\ed

\item
\protect \large \begin{verbatim}
DetachOutcome[node->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Sets the outcome associated with \verb+node+ to be the
null outcome.  If there is no outcome associated with \verb+node+ no
action is taken.  Returns \verb+node+.
\item
[See also:] {\tt AttachOutcome}, {\tt Outcome}.
\ed

\item 
\protect \large \begin{verbatim}
Divide[x->T, y->T] =: T
       for T = FLOAT, RATIONAL  
\end{verbatim} \normalsize

\bd
Returns the quotient $x / y$. 
\item
[Short form:] \verb+x / y+
\item
[See also:] {\tt IntegerDivide}
\ed

\item
\protect \large \begin{verbatim}
Dot[x->LIST(T), y->LIST(T)] =: T
       for T = FLOAT, INTEGER, RATIONAL
\end{verbatim}\normalsize

\bd
Returns the dot product of $x$ and $y$, where the lists are treated as vectors.
It is a run-time error to attempt to multiply two lists of different
lengths.
\item
[Short form:] \verb%x . y%
\ed

%--E--

\item
\protect \large \begin{verbatim}
ElapsedTime[] =: FLOAT
\end{verbatim}\normalsize

\bd
If the system stopwatch is currently running, returns the
time elapsed since the stopwatch was started.  If the system stopwatch
is not running, returns the time elapsed during the last period during which
the stopwatch was running.
\item
[See also:] {\tt IsWatchRunning}, {\tt StartWatch}, {\tt StopWatch}.
\ed


\item
\protect \large \begin{verbatim}
ElimAllDom[nfg<->NFG | support->NFSUPPORT, {strong->BOOL}, 
        {time<->FLOAT} =: NFSUPPORT
\end{verbatim} \normalsize

\bd Iteratively eliminates dominated strategies until no further
elimination is possible.  Operation and parameters are the same as in
{\tt ElimDom}.
\item
[See also:] {\tt ElimDom}.  
\ed

\item
\protect \large \begin{verbatim}
ElimDom[nfg<->NFG | support->NFSUPPORT, {strong->BOOL}, 
        {time<->FLOAT} =: NFSUPPORT
\end{verbatim} \normalsize

\bd
Finds dominated strategies in a support \verb+support+ of a normal
form game.  By default, all weakly dominated strategies are eliminated;
if the optional parameter \verb+strong+ is specified and is \verb+True+,
only strongly dominated strategies are eliminated.  Returns a new support
containing only the undominated strategies.  If the returned support
is equal to the input support \verb+support+, no dominated strategies were
found.  The optional parameter \verb+time+, if specified, upon completion
contains the amount of time consumed by the elimination.  (Note that in
the current implementation, only strategies that are dominated by
other {\em pure} strategies are eliminated.)  
\item
[See also:] {\tt ElimAllDom}.  
\ed

\item
\protect \large \begin{verbatim}
EnumMixedSolve[efg<->EFG, {asNfg->BOOL}, 
               {stopAfter->INTEGER}, {nPivots<->INTEGER}, 
               {time<->FLOAT}] =: LIST(BEHAV)
EnumMixedSolve[nfg<->NFG | support->NFSUPPORT, 
               {stopAfter->INTEGER}, {nPivots<->INTEGER}, 
               {time<->FLOAT}] =: LIST(MIXED)
\end{verbatim}\normalsize

\bd
Returns the extreme points of the set of all Nash equilibria (pure or
mixed) for a two person game.  The extensive form version converts
each marked subgame into its associated reduced normal form, enumerates
equilibria, and reassembles the behavioral profiles.  The normal form
and support versions operate directly on the given normal form or support
of the normal form.

The following optional parameters may be used to modify the behavior
of the algorithm:
\bd
\item
[asNfg:] By default, this is \verb+False+.  If it is specified to be
\verb+True+, the extensive form game is solved by recursively converting
its marked subgames into normal form, solving, and reconstructing the
solution as a behavioral profile.  {\it Note that currently this algorithm
is only supported on the normal form, so this parameter
must always be specified and {\tt True}.  Future versions will implement
the algorithm on extensive forms.}
\item
[stopAfter:] By default, all equilibria are found.  This parameter may
be used to specify a maximum number of equilibria to be found.
\item
[nPivots:] Upon completion, contains the number of pivots done by the
algorithm.
\item
[time:] Upon completion, returns the elapsed time during the execution
of the algorithm.
\ed
\item
[Note:] Prior to version .93, this algorithm computed the set of all
complementary basic feasible solutions, rather than the set of extreme
Nash equilibria.  \
item
[See also:] {\tt EnumPureSolve}.
\ed

\item
\protect \large \begin{verbatim}
EnumPureSolve[efg<->EFG, {asNfg->BOOL},
        {stopAfter->INTEGER}, {time<->FLOAT}] =: LIST(BEHAV)
EnumPureSolve[nfg<->NFG | support->NFSUPPORT,
        {stopAfter->INTEGER}, {time<->FLOAT}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd
Returns all pure strategy Nash equilibria of a game.  The behavior
of the algorithm may be modified by the following optional parameters:
\bd
\item
[asNfg:] By default, this is \verb+False+.  If it is specified to be
\verb+True+, the extensive form game is solved by recursively converting
its marked subgames into normal form, solving, and reconstructing the
solution as a behavioral profile.  {\it Note that currently this algorithm
is only supported on the normal form, so this parameter
must always be specified and {\tt True}.  Future versions will implement
the algorithm on extensive forms.}
\item
[stopAfter:] By default, all equilibria are found.  This parameter may
be used to specify a maximum number of equilibria to be found.
\item
[time:] Upon completion, returns the elapsed time during the execution
of the algorithm.
\ed
\item
[See also:] {\tt EnumMixedSolve}.
\ed

\item
\protect \large \begin{verbatim}
Equal[x->T, y->T] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the two objects \verb+x+ and \verb+y+ are
equal.
\item
[Short form:] \verb+x = y+.
\item
[See also:] {\tt NotEqual}.
\ed

\item
\protect \large \begin{verbatim}
Exp[x->FLOAT] =: FLOAT
\end{verbatim} \normalsize

\bd
Returns the value of the function ${\rm e}^{x}$ for the
value \verb+x+.
\item
[See also:] {\tt Log}, {\tt Power}.
\ed


%--F--

\item
\protect \large \begin{verbatim}
Float[x->INTEGER] =: FLOAT
Float[x->FLOAT] =: FLOAT
Float[x->RATIONAL] =: FLOAT
\end{verbatim} \normalsize

\bd
Returns the value \verb+x+ as a value of type {\tt FLOAT}.
In the case where \verb+x+ is {\tt RATIONAL}, this may result in a loss
of precision.
\item
[See also:] {\tt Rational}.
\ed

\item
\protect \large \begin{verbatim}
For[statement-list, boolean-expression, 
    statement-list, statement-list]
\end{verbatim}\normalsize

\bd
Defines a piece of code to be executed repeatedly.  See the section
on control structures for complete information.
\item
[See also:] \verb+While+.
\ed

%--G--

\item
\protect \large \begin{verbatim}
GobitGridSolve[nfg<->NFG | support->NFSUPPORT, {pxifile->TEXT},
         {minLam->FLOAT}, {maxLam->FLOAT}, 
         {delLam->FLOAT}, {powLam->INTEGER}, 
         {delp->FLOAT}, {tol->FLOAT},
         {nEvals<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
\end{verbatim}\normalsize

\bd
Computes the complete logistic quantal response correspondence for
a (small) two-person normal form game \verb+nfg+, for values of
$\lambda$ between $\underline{\lambda}$ and $\bar{\lambda}.$ Returns
the list of mixed profiles computed, one profile for each value of
$\lambda_t$ from lowest to highest.

The operation of the algorithm may be modified by specifying optional
parameters.  See {\tt GobitSolve} for a description of parameters
not listed here:
\bd
\item
[delp:] Grid size for search over probability space.  Default is $0.02$ .
\item
[tol:] The tolerance on the objective function.  Values of $p$ for
which the objective function is less this value are kept.  The default
is $0.02$.  
\ed
\ed

\item
\protect \large \begin{verbatim}
GobitLambda[strategy->BEHAV(T) | MIXED(T)] =: T
\end{verbatim}\normalsize

\bd
Returns the value of \verb+lambda+ for mixed or behavior solutions
computed by the GobitSolve[] algorithm. 
\item
[See also:] {\tt GobitSolve}, {\tt GobitGridSolve}, {\tt GobitValue}
\ed

\item
\protect \large \begin{verbatim}
GobitSolve[efg<->EFG | start->BEHAV, {pxifile->TEXT},
         {minLam->FLOAT}, {maxLam->FLOAT},
         {delLam->FLOAT}, {powLam->INTEGER},
         {fullGraph->BOOL}, {maxitsN->INTEGER}, {tolN->FLOAT},
         {maxits1->INTEGER}, {tol1->FLOAT}, {time<->FLOAT},
         {nEvals<->INTEGER}, {nIters<->INTEGER}] =: LIST(BEHAV)
GobitSolve[nfg<->NFG | start->MIXED, {pxifile->TEXT},
         {minLam->FLOAT}, {maxLam->FLOAT},
         {delLam->FLOAT}, {powLam->INTEGER},
         {fullGraph->BOOL}, {maxitsN->INTEGER}, {tolN->FLOAT},
         {maxits1->INTEGER}, {tol1->FLOAT}, {time<->FLOAT},
         {nEvals<->INTEGER}, {nIters<->INTEGER}] =: LIST(MIXED)
\end{verbatim}\normalsize

\bd 
Computes a branch of the logistic quantal response equilibrium
correspondence.  The first version computes for an extensive form
game, and the second version for a normal form game.  \verb+start+ is
used as the starting point for the computation of $\lambda_{0}$.  The
behavior of the algorithm may be modified by specifying some of the
following optional parameters:
\bd
\item
[pxifile:] Generate output to this file for later retrieval and viewing by
the PXI program.  By default no output file is generated.
\item
[minLam:] Sets $\underline{\lambda}$, the minimum value of $\lambda$.  The 
default value is $\underline{\lambda}=0.01$.
\item
[maxLam:] Sets $\overline{\lambda}$, the maximum value of $\lambda$.  The
default value is $\overline{\lambda}=30.0$.
\item
[delLam:] Sets the constant $\delta$ used in incrementing $\lambda$.  The
default value is $\delta=0.01$.
\item
[powLam:] Sets the exponent $a$ used in incrementing $\lambda$.  The default
value is $a=1$, producing geometric incrementing.  Setting $a=0$ corresponds
to linear incrementing.
\item
[fullGraph:] If \verb+True+, the list of behavioral strategy profiles
returned contains the full sequence of profiles computed from each successive
value of $\lambda$.  The default value is \verb+False+, in which case only
the profile for the last value of $\lambda$ computed is returned.
\item
[maxitsN:] Sets the maximum number of iterations for the $n$-dimensional
optimization routine.  The default value is $200$.
\item
[tolN:] Sets the tolerance for the $n$-dimensional optimization routine.
The default is 1.0e-10.
\item
[maxits1:] Sets the maximum number of iterations for the 1-dimensional
optimization routine.  The default is $100$.
\item
[tol1:] Sets the tolerance for the 1-dimensional optimization routine.
The default is 2.0e-10.
\item
[time:] Upon completion, contains the amount of time consumed by the
algorithm.
\item
[nEvals:] Upon completion, contains the number of function evaluations
performed by the algorithm.
\item
[nIters:] Upon completion, contains the number of iterations performed
by the algorithm.
\ed

\item
[Note:] The extensive form version does not pay attention to any marked
subgames.
\ed

\item
\protect \large \begin{verbatim}
GobitValue[strategy->BEHAV(T) | MIXED(T)] =: T
\end{verbatim}\normalsize

\bd
Returns the value of the Gobit objective function for mixed or behavior solutions
computed by the GobitSolve[] algorithm. 
\item
[See also:] {\tt GobitSolve}, {\tt GobitGridSolve}, {\tt GobitLambda}
\ed

\item
\protect \large \begin{verbatim}
Greater[x->T, y->T] =: BOOL
       for T = FLOAT, INTEGER, RATIONAL
\end{verbatim}\normalsize

\bd
Returns whether the value of \verb+x+ is greater than
that of \verb+y+.
\item
[Short form:] \verb+x > y+
\item
[See also:] {\tt GreaterThan}, {\tt Less}, {\tt LessEqual}.
\ed

\item
\protect \large \begin{verbatim}
Greater[x->TEXT, y->TEXT] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the string \verb+x+ is lexicographically greater than
the string \verb+y+, using the native character set of the machine.
\item
[Short form:] \verb+x > y+
\item
[See also:] {\tt GreaterThan}, {\tt Less}, {\tt LessEqual}.
\ed

\item
\protect \large \begin{verbatim}
GreaterEqual[x->T, y->T] =: BOOL
       for T = FLOAT, INTEGER, RATIONAL
\end{verbatim}\normalsize

\bd
Returns whether the value of \verb+x+ is at least that of
\verb+y+.
\item
[Short form:] \verb+x >= y+
\item
[See also:] {\tt Greater}, {\tt Less}, {\tt LessEqual}.
\ed

\item
\protect \large \begin{verbatim}
GreaterEqual[x->TEXT, y->TEXT] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the string \verb+x+ is lexicographically greater than
or equal to the string \verb+y+, using the native character set of the
machine.
\item
[Short form:] \verb+x >= y+
\item
[See also:] {\tt Greater}, {\tt Less}, {\tt LessEqual}.
\ed

%--H--


\item
\protect \large \begin{verbatim}
HasOutcome[node->NODE] =: BOOL
\end{verbatim} \normalsize

\bd
Returns whether the node \verb+node+ currently has an outcome associated
with it.
\item
[See also:] {\tt AttachOutcome}, {\tt DetachOutcome}, {\tt Outcome}.
\ed

%--I--

\item 
\protect \large \begin{verbatim}
If[boolean-expression, statement-list]
If[boolean-expression, statement-list, statement-list]
\end{verbatim} \normalsize
  
\bd
Defines a block of statements to be executed under certain conditions.
See the section on control structures for complete information. 
\ed


\item
\protect \large \begin{verbatim}
Include[file->TEXT]
\end{verbatim}\normalsize

\bd
Includes the commands in the specified file as commands
in the running GCL program.  The program treats the command as if it
were replaced by the contents of the file.  \verb+Include+ may only be used
at the ``top level'', that is, it cannot be used inside of \verb+NewFunction+
or flow control structures.
\ed

\item
\protect \large \begin{verbatim}
Infoset[node->NODE] =: INFOSET
\end{verbatim}\normalsize

\bd
Returns the information set to which the node \verb+node+
belongs.  All nonterminal nodes belong to an information set.  Terminal
nodes belong to an information set, and a call to this function using
a terminal node will result in a run-time error.
\ed

\item
\protect \large \begin{verbatim}
InfosetProbs[strategy->BEHAV] =: LIST(FLOAT)
InfosetProbs[strategy->BEHAV] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns a (nested) list of the probabilities of reaching all information
sets in an extensive form game, given that all players obey the
behavioral strategy profile \verb+strategy+.  The $i$th element
in the list returned is a list of the probabilities for the information
sets owned by player $i$.
\item
[See also:] {\tt ActionValues}, {\tt Beliefs}, {\tt NodeValues},
{\tt RealizProbs}.
\ed

\item
\protect \large \begin{verbatim}
Infosets[player->EFPLAYER] =: LIST(INFOSET)
\end{verbatim}\normalsize

\bd
Returns the list of information sets at which player
\verb+player+ has the decision.
\ed

\item
\protect \large \begin{verbatim}
Input[file->TEXT] =: INPUT
\end{verbatim}\normalsize

\bd
Opens a new input stream for reading from the file \verb+text+.
\item
[See also:]  {\tt Output}, {\tt Read}, {\tt Write}.
\ed

\item
\protect \large \begin{verbatim}
InsertAction[infoset->INFOSET, at->ACTION] =: ACTION
\end{verbatim}\normalsize

\bd
Inserts a new action into the information set \verb+infoset+
before the action \verb+at+.  The corresponding new branch is created for
each node belonging to the information set.  Returns the newly created action.
\item
[See also:] {\tt Actions}, {\tt AppendAction}, {\tt DeleteAction},
{\tt NumActions}.
\ed

\item
\protect \large \begin{verbatim}
InsertNode[node->NODE, infoset->INFOSET] =: NODE
\end{verbatim}\normalsize

\bd
Inserts a new node in the tree at the location of
node \verb+node+.  The
new node is placed in the information set \verb+infoset+, and the
corresponding number of branches are created from the new node.  \verb+node+
becomes the first child of the new node.  Returns the new node.
\item
[See also:] {\tt AppendNode}, {\tt NewInfoset}.
\ed

\item
\protect \large \begin{verbatim}
Integer[x->FLOAT] =: INTEGER
Integer[x->INTEGER] =: INTEGER
Integer[x->RATIONAL] =: INTEGER
\end{verbatim} \normalsize

\bd
Converts \verb+x+ into a value of type \verb+INTEGER+.
\item
[See also:] {\tt Float}, {\tt Rational}.
\ed

\item 
\protect \large \begin{verbatim}
IntegerDivide[x->INTEGER, y->INTEGER] =: INTEGER
\end{verbatim} \normalsize

\bd
Returns the quotient $x / y$, rounded to the next integer
towards zero.
\item
[Short form:] \verb%x DIV y%
\item
[See also:] \verb+Divide+, \verb+Modulus+.
\ed

\item
\protect \large \begin{verbatim}
IsConstSum[efg<->EFG] =: BOOL
IsConstSum[nfg<->NFG] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether an extensive form game \verb+efg+ or a normal form
game \verb+nfg+ game, as appropriate, is constant sum.
\ed

\item
\protect \large \begin{verbatim}
IsNash[strategy->MIXED] =: BOOL
IsNash[strategy->BEHAV] =: BOOL
\end{verbatim}\normalsize

\bd Returns whether the mixed or behavior strategy profile
\verb+strategy+ is a Nash equilibrium of the corresponding game.  
\ed

\item
\protect \large \begin{verbatim}
IsntPerfect[strategy->MIXED] =: BOOL
\end{verbatim}\normalsize

\bd Returns \verb+True+ if the mixed strategy profile \verb+strategy+
is known by Gambit not to be a perfect Nash equilibrium, and \verb+False+
otherwise.  
\item
[See also:] {\tt IsPerfect}.
\ed

\item
\protect \large \begin{verbatim}
IsntProper[strategy->MIXED] =: BOOL
\end{verbatim}\normalsize

\bd Returns \verb+True+ if the mixed strategy profile \verb+strategy+
is known by Gambit not to be a proper Nash equilibrium, and \verb+False+
otherwise.  
\item
[See also:] {\tt IsProper}.
\ed

\item
\protect \large \begin{verbatim}
IsntSequential[strategy->BEHAV] =: BOOL
\end{verbatim}\normalsize

\bd Returns \verb+True+ if the behavior strategy profile
\verb+strategy+ is known by Gambit not to be a sequential Nash
equilibrium, and \verb+False+ otherwise. 
\item
[See also:] {\tt IsSequential}.
\ed

\item
\protect \large \begin{verbatim}
IsntSubgamePerfect[strategy->BEHAV] =: BOOL
\end{verbatim}\normalsize

\bd Returns \verb+True+ if the behavior strategy profile
\verb+strategy+ is known by Gambit not to be a SubgamePerfect Nash
equilibrium, and \verb+False+ otherwise. 
\item
[See also:] {\tt IsSubgamePerfect}.
\ed

\item
\protect \large \begin{verbatim}
IsPerfect[strategy->MIXED] =: BOOL
\end{verbatim}\normalsize

\bd Returns \verb+True+ if the mixed strategy profile \verb+strategy+
is known by Gambit to be a perfect Nash equilibrium, and \verb+False+
otherwise.  There is currently no definitive test in Gambit for
whether an arbitrary profile is perfect, so it is possible for a
perfect equilibrium to return \verb+False+.  However some of the
algorithms (notably the \verb+LcpSolve[]+ will only return perfect
equilibria, which are marked as such.  
\item
[See also:] {\tt IsntPerfect}.
\ed

\item
\protect \large \begin{verbatim}
IsPredecessor[node->NODE, of->NODE] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the node \verb+node+ is a predecessor
in the tree of the node \verb+of+.  For the purposes of this function,
a node is considered its own predecessor.
\item
[See also:] {\tt IsSuccessor}.
\ed

\item
\protect \large \begin{verbatim}
IsProper[strategy->MIXED] =: BOOL
\end{verbatim}\normalsize

\bd Returns \verb+True+ if the mixed strategy profile \verb+strategy+
is known by Gambit to be a proper Nash equilibrium, and \verb+False+
otherwise.  There is currently no definitive test in Gambit for
whether an arbitrary profile is proper, so it is possible for a
perfect equilibrium to return \verb+False+.  
\item
[See also:] {\tt IsntProper}.
\ed

\item
\protect \large \begin{verbatim}
IsRoot[node->NODE] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the node \verb+node+ is the root node of its
extensive form.
\item
[See also:] {\tt Parent}.
\ed

\item
\protect \large \begin{verbatim}
IsSequential[strategy->BEHAV] =: BOOL
\end{verbatim}\normalsize

\bd Returns \verb+True+ if the behavior strategy profile
\verb+strategy+ is known by Gambit to be an approximation to a
Sequential Nash equilibrium, and \verb+False+ otherwise.  There is
currently no definitive test in Gambit for whether an arbitrary
profile is sequential.  However any Nash equilibrium of an extensive
form game which is computed via the \verb+LiapSolve+ or
\verb+GobitSolve+ algorithms will also be sequential.
\item
[See also:] {\tt IsntSequential}.
\ed

\item
\protect \large \begin{verbatim}
IsSubgamePerfect[strategy->BEHAV] =: BOOL
\end{verbatim}\normalsize

\bd Returns \verb+True+ if the behavior strategy profile
\verb+strategy+ is known by Gambit to be a SubgamePerfect Nash
equilibrium, and \verb+False+ otherwise.  There is currently no
definitive test in Gambit for whether an arbitrary profile is subgame
perfect.  However any Nash equilibrium of an extensive form game which
is computed when all subgames are marked will only return a subgame
perfect equilibrium.  
\item
[See also:] {\tt IsntSubgamePerfect}.
\ed

\item
\protect \large \begin{verbatim}
IsSuccessor[node->NODE, from->NODE] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the node \verb+node+ is a successor
in the tree of the node \verb+from+.  For the purposes of this function,
a node is considered its own successor.
\item
[See also:] {\tt IsPredecessor}.
\ed

\item
\protect \large \begin{verbatim}
IsWatchRunning[] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the system stopwatch is currently running.
\item
[See also:] {\tt ElapsedTime}, {\tt StartWatch}, {\tt StopWatch}.
\ed

%--J--

\item
\protect \large \begin{verbatim}
JoinInfoset[node->NODE, infoset->INFOSET] =: NODE
\end{verbatim}\normalsize

\bd
Makes the node \verb+node+ a member of the information set
\verb+infoset+.  If the previous information set of \verb+node+ was
a singleton (i.e., it contained only \verb+node+), it is removed from the
extensive form.  It is a run-time error if the number of actions at the
information set does not match the number of branches at the node.
Returns the node \verb+node+.
\item
[See also:] {\tt LeaveInfoset}, {\tt MergeInfosets}.
\ed

%--K--

%--L--

\item
\protect \large \begin{verbatim} 
LastAction[node->NODE] =: ACTION
\end{verbatim}\normalsize

\bd
Returns the action corresponding to the branch leading to
the node \verb+node+.  It is a run-time error if the node \verb+node+ is
the root node of the tree and thus has no such action.
\ed

\item
\protect \large \begin{verbatim}
LcpSolve[efg<->EFG, {asNfg->BOOL}, {stopAfter->INTEGER},
         {nPivots<->INTEGER}, {time<->FLOAT}] =: LIST(BEHAV)
LcpSolve[nfg<->NFG | support->NFSUPPORT, {stopAfter->INTEGER},
         {nPivots<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
\end{verbatim}\normalsize

\bd
Solves the game as a linear complementarity problem, using the
Lemke-Howson algorithm for normal form games, and the
Koller-Meggiddo-Stengel sequence form for extensive form games.  


The behavior of the algorithm may be modified by the following
optional parameters:
\bd
\item
[asNfg:] By default, extensive forms are solved by the sequence form.
By setting this parameter to \verb+True+, each marked subgame of the extensive
form is converted to its corresponding reduced normal form, solved
via Lemke-Howson, and the mixed strategy solutions converted back into
behavioral profiles.
\item
[stopAfter:] Specifies the maximum number of equilibria to find.  If
not specified, the default value is zero, which means that all
equilibria reachable by the algorithm are to be found.
\item
[nPivots:] The total number of pivots. 
\item
[time:] Returns the elapsed time for the operation.
\ed
\ed

\item
\protect \large \begin{verbatim}
LeaveInfoset[node->NODE] =: INFOSET
\end{verbatim}\normalsize

\bd
Removes the node \verb+node+ from the information set to
which it currently belongs and places it in a newly created
singleton information set belonging to the same player.  If \verb+node+
is already the only member of its information set, no action is taken.
Returns information set to which \verb+node+ belongs upon completion.
\item
[See also:] {\tt JoinInfoset}, {\tt MergeInfosets}.
\ed

\item
\protect \large \begin{verbatim}
Length[list->LIST(T)] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of elements in the list \verb+list+.
\item
[See also:] {\tt NthElement}.
\ed

\item
\protect \large \begin{verbatim}
Less[x->T, y->T] =: BOOL
       for T = FLOAT, INTEGER, RATIONAL
\end{verbatim}\normalsize

\bd
Returns whehter the value of \verb+x+ is less than that of
\verb+y+.
\item
[Short form:] \verb+x < y+
\item
[See also:] {\tt Greater}, {\tt GreaterEqual}, {\tt LessEqual}.
\ed

\item
\protect \large \begin{verbatim}
Less[x->TEXT, y->TEXT] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the string \verb+x+ is lexicographically less than
the string \verb+y+, using the native character set of the machine.
\item
[Short form:] \verb+x < y+
\item
[See also:] {\tt Greater}, {\tt GreaterEqual}, {\tt LessEqual}.
\ed

\item
\protect \large \begin{verbatim}
LessEqual[x->FLOAT, y->FLOAT] =: BOOL
       for T = FLOAT, INTEGER, RATIONAL
\end{verbatim}\normalsize

\bd
Returns whether the value of \verb+x+ is no more than that
of \verb+y+.
\item
[Short form:] \verb+x <= y+
\item
[See also:] {\tt Greater}, {\tt GreaterEqual}, {\tt Less}.
\ed

\item
\protect \large \begin{verbatim}
LessEqual[x->TEXT, y->TEXT] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the string \verb+x+ is lexicographically less than
the string \verb+y+, using the native character set of the machine.
\item
[Short form:] \verb+x <= y+
\item
[See also:] {\tt Greater}, {\tt GreaterEqual}, {\tt Less}.
\ed

\item
\protect \large \begin{verbatim}
LiapSolve[efg<->EFG | start->BEHAV, {asNfg->BOOL},
          {stopAfter->INTEGER}, {nTries->INTEGER},
          {maxitsN->INTEGER}, {tolN->FLOAT},
          {maxits1->INTEGER}, {tol1->FLOAT},
          {time<->FLOAT}, {nEvals<->INTEGER}] =: LIST(BEHAV)
LiapSolve[nfg<->NFG | start->MIXED, 
          {stopAfter->INTEGER}, {nTries->INTEGER},
          {maxitsN->INTEGER}, {tolN->FLOAT},
          {maxits1->INTEGER}, {tol1->FLOAT},
          {time<->FLOAT}, {nEvals<->INTEGER}] =: LIST(MIXED)
\end{verbatim}\normalsize


\bd Searches for a Nash equilibrium by minimizing a Lyapunov function
which is zero exactly at Nash equilibria.  The algorithm starts from
the initial starting point determined by the parameter \verb+start+.
The algorithm is not guaranteed to find a Nash equilibrium from any
fixed starting point.  The algorithm thus incorporates the capability
of restarting.  If a Nash equilibrium is not found, it will keep
searching from new randomly chosen starting points until a Nash
equilibrium has been found or the maximum number of tries (parameter
\verb+ntries+) is exceeded, whichever comes first.  The list of
solutions found is returned.

The behavior of the algorithm may be modified by specifying the following
optional parameters:
\bd
\item
[asNfg:] By default, extensive forms are solved in the extensive form.
By setting this parameter to \verb+True+, each marked subgame of the
extensive form is converted to its corresponding reduced normal form game,
solved, and the overall behavioral profile reconstructed from these
solutions.
\item
[start:] Sets the starting profile for the descent algorithm.  The
default (that is, when the game is passed instead of a strategy
profile) is the centroid.
\item
[nTries:] Sets the maximum number of attempts at finding each
equilibrium. Default is 10.
\item
[stopAfter:] Sets the number of equilibria to find.  Has a default
value of 1.  
\item
[maxits1:] Sets the maximum number of iterations in the
1-dimensional line search.  Default is 100.
\item
[maxitsN:] Sets the maximum number of iterations in the
n-dimensional optimization.  
\item
[tolN:] Sets the tolerance for the n-dimensional optimization
routine.  Default is 1.0e-10.
\item
[tol1:] Sets the tolerance for the 1-dimensional line search.
Default is 2.0e-10.
\item
[time:] Returns the elapsed time for the operation.
\item
[nEvals:] Returns the number of function evaluations for the operation.
\ed

\item
[Note:] Solution of extensive form via normal form is not currently
available; if \verb+start->+ \verb+BEHAV+ is specified, subgame markings are ignored.
\ed

\item
\protect \large \begin{verbatim}
LiapValue[strategy->MIXED(T) | BEHAV(T)] =: T
\end{verbatim} \normalsize

\bd Returns the Liapunov function value for the mixed or behavior
strategy profile \verb+strategy+.  This value is zero exactly when the
profile is a Nash equilibrium of the normal form game.  \ed

\item
\protect \large \begin{verbatim}
List[x<->T, {length->INTEGER},{delta->T}] =: LIST(T)
List[x->T, {length->INTEGER},{delta->T}] =: LIST(T)
\end{verbatim}\normalsize

\bd Creates an initialized list of dimension \verb+length+ whose
$i^{th}$ entry is \verb&x + (i * delta)&.  The type \verb+T+ of the list is
the same as the type of \verb+x+.  The default length is 1. The
default \verb+delta+ is 0.   
\item
[Note:] This function is not listable.
\ed

\item
\protect \large \begin{verbatim}
ListForm[mixed->MIXED] =: LIST(LIST(T))
ListForm[behav->BEHAV] =: LIST(LIST(LIST(T)))
\end{verbatim}\normalsize

\bd Returns the probabilities of each strategy for each player for a
mixed strategy profile, or the probabilities of each action at each
information of each player for a behavior strategy profile in the form
of a nested list.  The ordering of information sets is in indexed
traversal order.  The type \verb+T+ of the list is the same as the
type of \verb+behav+ or \verb+mixed+.
\item
[See also:] {\tt Behav, Mixed}.
\ed

\item
\protect \large \begin{verbatim}
LoadEfg[file->TEXT] =: EFG
\end{verbatim}\normalsize

\bd
Loads an extensive form game from an external savefile
and returns the game.
\item
[See also:] {\tt SaveEfg}.
\ed

\item
\protect \large \begin{verbatim}
LoadNfg[file->TEXT] =: NFG
\end{verbatim}\normalsize

\bd
Loads a normal form game from an external savefile
and returns the game.  
\item
[See also:] {\tt SaveNfg}.
\ed

\item
\protect \large \begin{verbatim}
Log[x->FLOAT] =: FLOAT
\end{verbatim} \normalsize

\bd
Computes the natural logarithm of \verb+x+.
\item
[See also:] {\tt Exp}.
\ed

\item
\protect \large \begin{verbatim}
LpSolve[efg<->EFG,
        {nPivots<->INTEGER}, {time<->FLOAT}] =: LIST(BEHAV)
LpSolve[nfg<->NFG | support->NFSUPPORT, {nPivots<->INTEGER},
        {time<->FLOAT}] =: LIST(MIXED)
\end{verbatim}\normalsize

\bd
Finds the minimax solution (a Nash equilibrium) for a
two person constant-sum game, by solving it as a linear program.
The list of solutions computed is returned.  If \verb+npivots+ is
specified, upon return it contains the number of pivots required to
compute the solution.  If \verb+time+ is specified, upon return it
contains the time elapsed in computing the solution.
\item
[Note:] The extensive form version implicitly creates the associated
reduced normal form for computation of equilibrium.
\item
[See also:] {\tt LcpSolve}.
\ed

%--M--

\item
\protect \large \begin{verbatim}
MarkSubgames[efg<->EFG] =: LIST(NODE)
MarkSubgames[node->NODE] =: LIST(NODE)
\end{verbatim} \normalsize

\bd
Defines all legal game theoretic subgames in a subtree of an extensive
form.  The first version finds all subgames in the entire tree; the
second version finds subgames only in the subtree rooted in \verb+node+.
Both versions return the list of nodes which are roots of defined
subgames after the operation.
\item
[See also:] {\tt MarkThisSubgame}, {\tt SubgameRoots}, {\tt UnmarkSubgames},
{\tt UnmarkThisSubgame}
\ed

\item
\protect \large \begin{verbatim}
MarkThisSubgame[node->NODE] =: BOOL
\end{verbatim}\normalsize

\bd
If \verb+node+ is the root node of a subgame in the game theoretic
sense, defines a new subgame rooted at \verb+node+ in its extensive
form game.  If \verb+node+ is not a subgame root, this function has
no effect.  Returns \verb+True+ if \verb+node+ is marked after termination.
\item
[See also:] {\tt MarkSubgames}, {\tt SubgameRoots}, {\tt UnmarkSubgames},
{\tt UnmarkThisSubgame}
\ed

\item
\protect \large \begin{verbatim}
Members[infoset->INFOSET] =: LIST(NODE)
\end{verbatim}\normalsize

\bd
Returns the list of nodes which are members of the information
set \verb+infoset+.
\ed

\item
\protect \large \begin{verbatim}
MergeInfosets[infoset1->INFOSET,
              infoset2->INFOSET] =: INFOSET
\end{verbatim}\normalsize

\bd
Moves all the nodes from \verb+infoset2+ into \verb+infoset1+.
It is a run-time error if the number of actions is not the same at the
two information sets.  \verb+infoset2+ is deleted from the extensive form,
and \verb+infoset1+ is returned.
\ed

\item 
\protect \large \begin{verbatim}
Minus[x->FLOAT, y->FLOAT] =: FLOAT
       for T = FLOAT, INTEGER, RATIONAL, MIXED, BEHAV
\end{verbatim} \normalsize

\bd
Returns the difference $x - y$.
\item
[Short form:] \verb+x - y+
\ed

\item
\protect \large \begin{verbatim}
Mixed[nfg<->NFG | support->NFSUPPORT, 
      list->LIST(LIST(T))] =: MIXED
\end{verbatim}\normalsize

\bd
Creates a mixed profile attached for the normal form game \verb+nfg+
with values given by list.  
\item
[See also:] {\tt Behav}.
\ed


\item
\protect \large \begin{verbatim}
Modulus[x->INTEGER, y->INTEGER] =: INTEGER
\end{verbatim}\normalsize

\bd
Computes the remainder from dividing \verb+y+ into \verb+x+.
\item
[Short form:] \verb+x MOD y+
\item
[See also:] {\tt Divide}.
\ed


\item
\protect \large \begin{verbatim}
MoveTree[from->NODE, to->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Moves the subtree rooted at \verb+from+ to
the terminal node \verb+to+.  \verb+from+ becomes a terminal node.
Returns \verb+to+.
\item
[See also:] {\tt CopyTree}.
\ed

%--N--

\item
\protect \large \begin{verbatim}
Name[x->ACTION] =: TEXT
Name[x<->EFG] =: TEXT
Name[x->EFPLAYER] =: TEXT
Name[x->INFOSET] =: TEXT
Name[x<->NFG] =: TEXT
Name[x->NFPLAYER] =: TEXT
Name[x->NODE] =: TEXT
Name[x->OUTCOME] =: TEXT
Name[x->STRATEGY] =: TEXT
\end{verbatim}\normalsize

\bd
Returns the name of the object \verb+x+.
\item
[See also:] {\tt SetName}.
\ed

\item 
\protect \large \begin{verbatim}
Negate[x->FLOAT] =: FLOAT
       for T = FLOAT, INTEGER, RATIONAL
\end{verbatim} \normalsize

\bd
Returns $-x$.
\item
[Short form:] \verb+-x+
\ed


\item
\protect \large \begin{verbatim} 
NewEfg[{rational->BOOL}, {players->LIST(TEXT)}] =: EFG
\end{verbatim}\normalsize

\bd
Creates a new extensive form game.  By default, the
outcomes and probabilities associated with the game will be stored as
{\tt FLOAT}.  If the \verb+rational+ parameter is specified and is \verb+True+,
these values will be stored as {\tt RATIONAL}.  The default extensive form
game has no players (other than the chance player) defined on it; the
optional parameter \verb+players+ specifies a list of players to be
created and the names to be assigned to them.  Returns the newly created
game.
\ed

\item   
\protect \large \begin{verbatim}
NewFunction[name[argument-list], body]
\end{verbatim}\normalsize

\bd
Creates a new function.  The function may be called exactly
as if it were a predefined function of the command language.  See the
section on user-defined functions for more detailed information.
\ed

\item
\protect \large \begin{verbatim} 
NewInfoset[player->EFPLAYER, actions->LIST(TEXT),
            {name->TEXT}] =: INFOSET
NewInfoset[player->EFPLAYER, actions->INTEGER,
            {name->TEXT}] =: INFOSET
\end{verbatim}\normalsize

\bd
Creates a new information set belonging to \verb+player+.
If the integer version of \verb+actions+ is used, the information set
will contain that number of actions, each named with the empty string.
Alternatively, the list version of \verb+actions+ causes the information
set to have the same number of actions as the list has elements, with
the actions named by the corresponding element in the list.  (In either
case, the number of actions specified must be positive.)  The optional
parameter \verb+name+ allows a name to be specified for the information
set; by default it is labeled by the empty string.  The newly created
information set is returned.
\ed

\item
\protect \large \begin{verbatim}
NewNfg[dim->LIST(INTEGER), {rational->BOOL}] =: NFG
\end{verbatim}\normalsize

\bd
Creates a new normal form game with dimensionality \verb+dim+.
By default, the payoffs and probabilities associated with the game will
be stored as {\tt FLOAT}.  If the \verb+rational+ parameter is specified
and is \verb+True+, these values will be stored as {\tt RATIONAL}.
No initialization of the payoffs of the game is done.
Returns the newly created game.
\ed

\item
\protect \large \begin{verbatim} 
NewOutcome[efg<->EFG, {name->TEXT}] =: OUTCOME
\end{verbatim}\normalsize

\bd
Defines a new outcome in the extensive form game \verb+efg+.
By default the outcome is named with the empty string; the optional parameter
\verb+name+, if specified, gives the name of the new outcome.  Returns the
newly created outcome.
\item
[See also:] {\tt DeleteOutcome}.
\ed

\item
\protect \large \begin{verbatim}
NewPlayer[efg<->EFG, {name->TEXT}] =: EFPLAYER 
\end{verbatim}\normalsize

\bd
Defines a new player in the extensive form game \verb+efg+.
By default the player is named with the empty string; the optional parameter
\verb+name+, if specified, gives the name of the new player.  Returns the
newly created player.
\ed

\item
\protect \large \begin{verbatim}
NewSupport[efg<->EFG] =: EFSUPPORT
\end{verbatim}\normalsize

\bd
Creates and returns a new support on the extensive form
game \verb+nfg+.  The support contains all actions at every
information set for all players.
\ed

\item
\protect \large \begin{verbatim}
NewSupport[nfg<->NFG] =: NFSUPPORT
\end{verbatim}\normalsize

\bd
Creates and returns a new support on the normal form
game \verb+nfg+.  The support contains all strategies for all players.
\item
[See also:] {\tt AddStrategy}, {\tt RemoveStrategy}.
\ed

\item
\protect \large \begin{verbatim}
NextSibling[node->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Returns the next sibling of the node \verb+node+.
\item
[See also:] {\tt PriorSibling}.
\ed

\item
\protect \large \begin{verbatim}
Nfg[efg<->EFG, {time<->FLOAT}] =: NFG
\end{verbatim}\normalsize

\bd
Creates and returns the reduced normal form game equivalent
to the extensive form game \verb+efg+.  The optional parameter \verb+time+,
if specified, contains upon completion the amount of time consumed by
the transformation.
\ed

\item
\protect \large \begin{verbatim} 
Nodes[efg<->EFG] =: LIST(NODE)
\end{verbatim}\normalsize

\bd
Returns the list of nodes in the extensive form game
\verb+efg+ in prefix-traversal order of the tree.
\item
[See also:] {\tt NonterminalNodes}, {\tt NumNodes}, {\tt TerminalNodes}.
\ed

\item
\protect \large \begin{verbatim}
NodeValues[strategy->BEHAV, player->EFPLAYER] =: LIST(FLOAT)
NodeValues[strategy->BEHAV, player->EFPLAYER] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns a list containing the expected payoff to the player \verb+player+
at each node in an extensive form game, given that all players are obeying
the behavioral strategy profile \verb+strategy+.  The list is ordered
in the prefix traversal order of the tree, the same order as returned
by the function {\tt Nodes}.
\item
[See also:] {\tt ActionValues}, {\tt Beliefs}, {\tt InfosetProbs},
{\tt RealizProbs}.
\ed

\item
\protect \large \begin{verbatim} 
NonterminalNodes[efg<->EFG] =: LIST(NODE)
\end{verbatim}\normalsize

\bd
Returns the list of nonterminal nodes in the extensive form
game \verb+efg+ in prefix-traversal order of the tree.
\item
[See also:] {\tt Nodes}, {\tt NumNodes}, {\tt TerminalNodes}.
\ed

\item
\protect \large \begin{verbatim}
Not[x->BOOL] =: BOOL
\end{verbatim}\normalsize

\bd
Returns the boolean inverse of \verb+x+.
\item
[Short forms:] \verb+NOT x+, \verb+!x+.
\ed

\item
\protect \large \begin{verbatim}
NotEqual[x->T, y->T] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the values of \verb+x+ and \verb+y+ are
not equal.
\item
[Short form:] \verb+x != y+.
\item
[See also:] {\tt Equal}.
\ed

\item
\protect \large \begin{verbatim}
NthChar[text->TEXT, n->INTEGER] =: TEXT
\end{verbatim}\normalsize

\bd
Returns a text string of length 1 containing the \verb+n+th
character from the string \verb+text+.  By convention, the first character
in a string is indexed by 1.
\item
[Short form:] \verb+text[[n]]+.
\item
[See also:] {\tt NumChars}.
\ed

\item
\protect \large \begin{verbatim} 
NthChild[node->NODE, n->INTEGER] =: NODE
\end{verbatim}\normalsize

\bd
Returns the \verb+n+th child of the node \verb+node+.
By convention, the first child of a node is indexed by 1.
\item
[Short form:] \verb+node#n+.
\item
[See also:] {\tt NumChildren}.
\ed

\item
\protect \large \begin{verbatim}
NthElement[list->LIST(T), n->INTEGER] =: T 
\end{verbatim}\normalsize

\bd
Returns the \verb+n+th element of the list \verb+list+.
By convention, the first element of a list is indexed by 1.
\item
[Short form:] \verb+list[[n]]+.
\item
[Note:] This function is not listable.
\item
[See also:] {\tt Length}.
\ed

\item
\protect \large \begin{verbatim}
NumActions[infoset->INFOSET, {support->EFSUPPORT}] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of actions defined at the information
set \verb+infoset+ of EFSUPPORT \verb+support+.  The default support
is the full support of the game of which \verb+infoset+ is a member.  
\item
[See also:] {\tt Actions}.
\ed

\item
\protect \large \begin{verbatim}
NumChars[text->TEXT] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of characters in the text string
\verb+text+.
\item
[See also:] {\tt NthChar}.
\ed

\item
\protect \large \begin{verbatim}
NumChildren[node->NODE] := INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of children of the node \verb+node+.
\item
[See also:] {\tt NthChild}.
\ed

\item
\protect \large \begin{verbatim}
NumInfosets[player->EFPLAYER] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of information sets belonging to the
player \verb+player+.
\item
[See also:] {\tt Infosets}.
\ed

\item
\protect \large \begin{verbatim}
NumMembers[infoset->INFOSET] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of nodes belonging to the information
set \verb+infoset+.
\item
[See also:] {\tt Members}.
\ed

\item
\protect \large \begin{verbatim}
NumNodes[efg<->EFG] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of nodes in the tree of the extensive form
game \verb+efg+.
\item
[See also:] {\tt Nodes}.
\ed

\item
\protect \large \begin{verbatim}
NumOutcomes[efg<->EFG] =: INTEGER
\end{verbatim} \normalsize

\bd
Returns the number of outcomes defined on the extensive from
game \verb+efg+.
\item
[See also:] {\tt Outcomes}.
\ed

\item
\protect \large \begin{verbatim}
NumPlayers[efg<->EFG] =: INTEGER
\end{verbatim} \normalsize

\bd
Returns the number of players defined on the extensive form
game \verb+efg+.
\item
[See also:] {\tt Players}.
\ed

\item
\protect \large \begin{verbatim}
NumPlayers[nfg<->NFG] =: INTEGER
\end{verbatim} \normalsize

\bd
Returns the number of players defined on the normal form
game \verb+nfg+.
\item
[See also:] {\tt Players}.
\ed

\item
\protect \large \begin{verbatim}
NumStrats[player->NFPLAYER, {support->NFSUPPORT}] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of strategies for the player \verb+player+
in a normal form game.  By default, the total number of strategies is
returned; if \verb+support+ is specified, the number of strategies
for \verb+player+ in that support is returned instead.
\ed

%--O--

\item 
\protect \large \begin{verbatim}
Or[x->BOOL, y->BOOL] =: BOOL
\end{verbatim} \normalsize
  
\bd
Returns the disjunction of \verb+x+ and \verb+y+.
\item
[Short form:] \verb+x || y+, \verb+x OR y+.
\ed

\item
\protect \large \begin{verbatim}
Outcome[node->NODE] =: OUTCOME
\end{verbatim}\normalsize

\bd
Returns the outcome attached to the node \verb+node+.
\item
[See also:] {\tt AttachOutcome}, {\tt DetachOutcome}.
\ed

\item
\protect \large \begin{verbatim}
Outcomes[efg<->EFG] =: LIST(OUTCOME)
\end{verbatim}\normalsize

\bd
Returns the list of outcomes defined on the extensive form
game \verb+efg+.
\item
[See also:] {\tt DeleteOutcome}, {\tt NewOutcome}, {\tt NumOutcomes}.
\ed

\item
\protect \large \begin{verbatim}
Output[file->TEXT] =: OUTPUT
\end{verbatim}\normalsize

\bd
Opens a new output stream for writing to the file \verb+text+.
\item
[See also:]  {\tt Input}, {\tt SetFormat}, {\tt Write}.
\ed

%--P--

\item
\protect \large \begin{verbatim}
Paren[x->T] =: T
\end{verbatim}\normalsize

\bd
Returns the value passed in \verb+x+.  This is used to control
the order of evaluation of expressions.
\item
[Short form:] \verb+(x)+
\ed

\item
\protect \large \begin{verbatim}
Parent[node->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Returns the parent node of \verb+node+.
\item
[See also:] {\tt IsRoot}.
\ed

\item
\protect \large \begin{verbatim}
Payoff[outcome->OUTCOME] =: LIST(FLOAT)
Payoff[outcome->OUTCOME] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns the payoffs associated with outcome \verb+outcome+
as a list.
\item
[See also:] {\tt SetPayoff}.
\ed

\item
\protect \large \begin{verbatim}
Payoff[nfg<->NFG, list->LIST(INTEGER)] =: LIST(FLOAT)
Payoff[nfg<->NFG, list->LIST(INTEGER)] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns the list of payoffs to all players in the normal form game
\verb+nfg+ in the contingency specified by \verb+list+.
\item
[See also:] {\tt SetPayoff}.
\ed

\item
\protect \large \begin{verbatim}
Payoff[strategy->BEHAV] =: LIST(FLOAT)
Payoff[strategy->BEHAV] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns the payoffs to each player in an extensive form game
if players follow the behavioral strategy profile \verb+strategy+.
\ed

\item
\protect \large \begin{verbatim}
Payoff[strategy->MIXED] =: LIST(FLOAT)
Payoff[strategy->MIXED] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns the payoffs to each player in a normal form game
if players follow the mixed strategy profile \verb+strategy+.
\ed

\item
\protect \large \begin{verbatim}
Player[infoset->INFOSET] =: EFPLAYER
\end{verbatim}\normalsize

\bd
Returns the player who makes the decision at the information
set \verb+infoset+.
\ed

\item
\protect \large \begin{verbatim}
Player[node->NODE] =: EFPLAYER
\end{verbatim}\normalsize

\bd
Returns the player who makes the decision at the node
\verb+node+.
\ed

\item
\protect \large \begin{verbatim}
Players[efg<->EFG] =: LIST(EFPLAYER)
\end{verbatim} \normalsize

\bd
Returns the list of players defined on the extensive form
game \verb+efg+.
\item
[See also:] {\tt NumPlayers}.
\ed

\item
\protect \large \begin{verbatim}
Players[nfg<->NFG] =: LIST(NFPLAYER)
\end{verbatim} \normalsize

\bd
Returns the list of players defined on the normal form
game \verb+nfg+.
\item
[See also:] {\tt NumPlayers}.
\ed

\item 
\protect \large \begin{verbatim}
Plus[x->FLOAT, y->FLOAT] =: FLOAT
       for T = FLOAT, INTEGER, RATIONAL, MIXED, BEHAV
\end{verbatim} \normalsize

\bd
Returns the sum of \verb+x+ and \verb+y+.
\item
[Short form:] \verb%x + y%
\ed

\item
\protect \large \begin{verbatim}
Plus[x->TEXT, y->TEXT] =: TEXT
\end{verbatim} \normalsize

\bd
This function has been replaced by {\tt Concat}.
\ed

\item
\protect \large \begin{verbatim}
Power[x->INTEGER, y->INTEGER] =: INTEGER
Power[x->FLOAT, y->FLOAT] =: FLOAT
\end{verbatim} \normalsize

\bd
Computes the value $x^{y}$.
\item
[Short form:] \verb%x ^ y%.
\item
[See also:] {\tt Exp}.
\ed

\item
\protect \large \begin{verbatim}
PriorSibling[node->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Returns the prior sibling of the node \verb+node+ in its
game tree.
\item
[See also:] {\tt NextSibling}.
\ed


%--Q--


\item
\protect \large \begin{verbatim}
Quit
\end{verbatim}\normalsize

\bd
Exits the command language.
\ed

%--R--

\item
\protect \large \begin{verbatim}
RandomEfg[efg<->EFG, {seed->INTEGER}] =: EFG
\end{verbatim}\normalsize

\bd
Assigns a payoff for each outcome for each player in the
extensive form \verb+efg+ randomly chosen from the uniform distribution
between 0 and 1.  The optional parameter \verb+seed+ may be used to
set the seed of the pseudo-random number generator.  The identical game
randomized with the same seed on the same machine will always produce
the same results.
\ed

\item
\protect \large \begin{verbatim}
RandomNfg[nfg<->NFG, {seed->INTEGER}] =: NFG
\end{verbatim}\normalsize

\bd
Assigns a payoff for each contingency for each player in
the normal form \verb+nfg+ randomly chosen from the uniform distribution
between 0 and 1.  The optional parameter \verb+seed+ may be used to
set hte seed of the pseudo-random number generator.  The identical game
randomized with the same seed on the same machine will always produce
the same results.
\ed

\item
\protect \large \begin{verbatim}
Rational[x->INTEGER] =: RATIONAL
Rational[x->FLOAT] =: RATIONAL
Rational[x->RATIONAL] =: RATIONAL
\end{verbatim} \normalsize

\bd
Converts the value \verb+x+ to the equivalent value of
type {\tt RATIONAL}.
\item
[See also:] {\tt Float}.
\ed

\item
\protect \large \begin{verbatim}
Read[input->INPUT, x<->T] =: INPUT  
      for T = BEHAV,BOOL,FLOAT,INTEGER,MIXED,
              RATIONAL,TEXT,LIST(T)
\end{verbatim}\normalsize

\bd Reads data of type T from the input stream and assigns it to
\verb+x+.  If \verb+x+ is undefined, then its data type is determined
from the exposed data in the input stream.  If \verb+x+ is previously
defined, then the Read[] function will expect to find the
corresponding data type in the input stream, and a file read error
will be generated if the exposed data is of the wrong data type.  If
\verb+x+ is previously defined to be a LIST(T), then \verb+Read[in,x]+
will successively read elements into each element of the list.  If the
wrong data type is found for any element of the list, a file read
error will be returned.

The ``exposed data'' in the input stream consists of the following: If
first character is a double quote (\verb+"+), then the exposed data
consists of all characters up until the next double quote.  If the
first character is a \verb+{+, then the exposed data consists of all
the characters up until the next matching \verb+}+.  Otherwise, the
exposed data consists of all characters until the next whitespace.
\item
[Short form:] \verb+input >> x+
\item
[Note:] This function is not listable
\item
[See also:] {\tt Input},  {\tt Write}
\ed

\item
\protect \large \begin{verbatim}
RealizProbs[strategy->BEHAV(T)] =: LIST(T)
\end{verbatim}\normalsize

\bd
Returns the list of realization probabilities for the
nodes in an extensive form given that the players are using the behavioral
strategy profile \verb+strategy+.  The list is ordered in the prefix-traversal
of the nodes in the tree, the same order in which the {\tt Nodes} function
returns the nodes in the tree.
\ed

\item
\protect \large \begin{verbatim}
Remove[list->LIST(T), n->INTEGER] =: LIST(T)
\end{verbatim}\normalsize

\bd
Returns a new list consisting of the elements of list
\verb+list+ with the \verb+n+th element removed.  {\tt Remove} does not
modify the input list \verb+list+.
\item
[Note:] This function is not listable.
\ed

\item
\protect \large \begin{verbatim}
RemoveAction[support->EFSUPPORT, infoset->INFOSET, 
             action->ACTION] =: EFSUPPORT
\end{verbatim}\normalsize

\bd
Removes the action \verb+action+, of \verb+infoset+  from the 
EFSUPPORT \verb+support+.
\item
[See also:] {\tt AddAction}.
\ed

\item
\protect \large \begin{verbatim}
RemoveStrategy[support->NFSUPPORT, 
               strategy->STRATEGY] =: NFSUPPORT
\end{verbatim}\normalsize

\bd
Removes the strategy \verb+strategy+ from the
support \verb+support+.  If \verb+strategy+ is not in the support,
no action is taken.  Returns the modified support.
\item
[See also:] {\tt AddStrategy}, {\tt NewSupport}.
\ed

\item
\protect \large \begin{verbatim}
Reveal[infoset->INFOSET, who->LIST(EFPLAYER)] =: INFOSET
\end{verbatim}\normalsize

\bd
Reveals the list of actions at the given information
set to the indicated players, refining their information partitions at
all information sets in the extensive form game accordingly.  The list
of actions is considered as a set Thus, it is indicated to the
spceified players whether the set of actions in \verb+what+ or its
complement has occurred.  If \verb+what+ is not specified, then all of
the actions in the information set are individually revealed to
the players specified.  
\ed


\item
\protect \large \begin{verbatim}
RootNode[efg<->EFG] =: NODE
\end{verbatim}\normalsize

\bd
Returns the root node of the extensive form game \verb+efg+.
\item
[See also:] {\tt IsRoot}.
\ed

%--S--

\item
\protect \large \begin{verbatim}
SaveEfg[efg<->EFG, file->TEXT] =: EFG
\end{verbatim}\normalsize

\bd
Writes the extensive form game \verb+efg+ to an external
save file.  Returns \verb+efg+.
\item
[See also:] {\tt LoadEfg}.
\ed

\item
\protect \large \begin{verbatim}
SaveNfg[nfg<->NFG, file->TEXT] =: NFG
\end{verbatim}\normalsize

\bd
Writes the normal form game \verb+nfg+ to an external
save file.  Returns \verb+nfg+.
\item
[See also:] {\tt LoadNfg}.
\ed

\item
\protect \large \begin{verbatim} 
SetComponent[behav<->BEHAV, infoset->INFOSET, 
             list->LIST(T)] =: BEHAV 
\end{verbatim}\normalsize

\bd
Sets the componensts of a behavior profile \verb+behav+ for
information set \verb+infoset+ to be equal to the values in \verb+list+.
Returns \verb+behav+. 
\ed

\item
\protect \large \begin{verbatim} 
SetComponent[mixed<->MIXED, player->PLAYER, 
             list->LIST(T)] =: MIXED 
\end{verbatim}\normalsize

\bd
Sets the componensts of a mixed profile \verb+mixed+ for player
\verb+player+ to be equal to the values in \verb+list+.
Returns \verb+mixed+. 
\ed

\item
\protect \large \begin{verbatim} 
SetChanceProbs[infoset->INFOSET, 
               probs->LIST(FLOAT)] =: INFOSET
SetChanceProbs[infoset->INFOSET, 
               probs->LIST(RATIONAL)] =: INFOSET
\end{verbatim}\normalsize

\bd
Sets the action probabilities for the information set
\verb+infoset+ to the values given in \verb+probs+.  This is only
meaninful for nodes in information sets belonging to the chance
player.  Returns \verb+infoset+. 
\item
[See also:] {\tt ChanceProbs}.
\ed


\item
\protect \large \begin{verbatim}
SetFormat[ {width->INTEGER}, {precis->INTEGER}, {expmode->BOOL},
                {quote->BOOL}, {listBraces->BOOL},
                {listCommas->BOOL}, {listLF->INTEGER},
                {listIndent->INTEGER} ] := BOOL
\end{verbatim}\normalsize

\bd Sets the formatting style for output on output streams.  The
parameters have the following effect:
\bd
\item[\verb+width+] Sets the width for a numeric field. If the width
of the data is greater than this width, the width is overridden (default = 0).
\item[\verb+precis+] Sets the number of decimal places shown for floating
point numbers.
\item[\verb+expmode+] Sets whether floating point numbers are in
exponential format or not.
\item[\verb+quote+] Determines whether quotes are printed before and
after text strings.
\item[\verb+listBraces+] Determines if LISTs are delimited with
braces.
\item[\verb+listCommas+] Determines if LIST elements are delimited
with commas.
\item[\verb+listLF+] Number of levels of LIST that are displayed with
a line feed.  
\item[\verb+listIndent+] Number of spaces to indent each level of a
LIST. 
\ed

\item
[See also:] {\tt Write}.
\ed

\item
\protect \large \begin{verbatim}
SetName[x->ACTION, name->TEXT] =: ACTION
SetName[x<->EFG, name->TEXT] =: EFG
SetName[x->EFPLAYER, name->TEXT] =: EFPLAYER
SetName[x->INFOSET, name->TEXT] =: INFOSET
SetName[x<->NFG, name->TEXT] =: NFG
SetName[x->NFPLAYER, name->TEXT] =: NFPLAYER
SetName[x->NODE, name->TEXT] =: NODE
SetName[x->OUTCOME, name->TEXT] =: OUTCOME
SetName[x->STRATEGY, name->TEXT] =: STRATEGY
\end{verbatim}\normalsize

\bd
Sets the name of the object \verb+x+ to \verb+name+.
Returns the object \verb+x+.
\item
[See also:] {\tt Name}.
\ed

\item
\protect \large \begin{verbatim}
SetPayoff[outcome->OUTCOME, payoff->LIST(FLOAT)] =: OUTCOME
SetPayoff[outcome->OUTCOME, payoff->LIST(RATIONAL)] =: OUTCOME
\end{verbatim}\normalsize

\bd
Sets the payoffs of the outcome \verb+outcome+ to the
values specified by \verb+payoff+.  It is a run-time error if the type
of the list \verb+payoff+ does not match the type of the game in which
\verb+outcome+ is defined.  Returns \verb+outcome+.
\item
[See also:] {\tt Payoff}.
\ed

\item
\protect \large \begin{verbatim}
SetPayoff[nfg<->NFG, list->LIST(INTEGER),
          payoff->LIST(FLOAT)] =: LIST(STRATEGY)
SetPayoff[nfg<->NFG, list->LIST(INTEGER), 
          payoff->LIST(RATIONAL)] =: LIST(STRATEGY)
\end{verbatim}\normalsize

\bd
Sets the payoffs in the normal form game \verb+nfg+ of the
contingency specified by \verb+list+ to the values specified by
\verb+payoff+.  It is a run-time error if the type of the list
\verb+payoff+ does not match the type of the game in which the
strategies in \verb+list+ are defined.  Returns \verb+list+.
\item
[See also:] {\tt Payoff}.  
\ed

\item
\protect \large \begin{verbatim}
SimpDivSolve[efg<->EFG, {asNfg->BOOL}, 
       {stopAfter->INTEGER}, {nRestarts->INTEGER}, 
       {leashLength->INTEGER}, {nEvals<->INTEGER}, 
       {time<->FLOAT}] =: LIST(BEHAV)
SimpDivSolve[nfg<->NFG | support->NFSUPPORT, 
       {stopAfter->INTEGER}, {nRestarts->INTEGER}, 
       {leashLength->INTEGER}, {nEvals<->INTEGER}, 
       {time<->FLOAT}] =: LIST(MIXED)
\end{verbatim}\normalsize

\bd
Computes a Nash equilibrium for a game using a simplicial subdivision
algorithm.  The list of solutions found is returned.

The behavior of the algorithm may be modified by several optional
parameters:

\bd
\item
[asNfg:] By default, this is \verb+False+.  If it is specified to be
\verb+True+, the extensive form game is solved by recursively converting
its marked subgames into normal form, solving, and reconstructing the
solution as a behavioral profile.  {\it Note that currently simplicial
subdivision is only supported on the normal form, so this parameter
must always be specified and {\tt True}.  Future versions will include
a simplicial subdivision algorithm on extensive forms.}
\item
[stopAfter:] Maximum number of equilibria to find. Default is 1.  
\item 
[nRestarts:] Number of restarts.  At each restart the mesh of the
triangulation is halved.  So this parameter determines the final mesh
by the formula $\frac{1}{2}^{ndivs}$.
\item
[leashLength:] Sets the leashlength. Default is 0, which results in no
constraint, or no leash.  Note that if this parameter is set to a value
different from 0, the algorithm is no longer guaranteed to converge.
\item
[time:] Upon termination, returns the elapsed time for the algorithm.
\ed
\ed

\item
\protect \large \begin{verbatim}
StartWatch[] =: FLOAT
\end{verbatim}\normalsize

\bd Starts the system stopwatch running.  This command has no
effect if the stopwatch is already running.
Returns the amount of time since the stopwatch was started.
\item
[See also:] {\tt ElapsedTime}, {\tt IsWatchRunning}, {\tt StopWatch}.
\ed

\item
\protect \large \begin{verbatim}
Strategies[player->NFPLAYER, 
           {support->NFSUPPORT}] =: LIST(STRATEGY)
\end{verbatim}\normalsize

\bd
Returns the list of strategies from which player \verb+player+ may choose
in a normal form game.  If \verb+support+ is unspecified, returns the
player's full complement of strategies; else returns the list of strategies
in the support for the player.
\ed

\item
\protect \large \begin{verbatim}
StopWatch[] =: FLOAT
\end{verbatim}\normalsize

\bd
Stops the system stopwatch.  If the stopwatch was not
running, {\tt StopWatch} has no effect.  Returns the amount of time
on the stopwatch.
\item
[See also:] {\tt ElapsedTime}, {\tt IsWatchRunning}, {\tt StartWatch}.
\ed

\item
\protect \large \begin{verbatim}
SubgameRoots[efg<->EFG] =: LIST(NODE)
\end{verbatim}\normalsize

\bd Returns the list of nodes which are roots of marked subgames in
the extensive form {\tt efg}.  The ordering of the list is such that
all children of a node are listed before a node.
\item
[See also:] {\tt MarkSubgames}, {\tt MarkThisSubgame}, {\tt UnmarkSubgames},
{\tt UnmarkThisSubgame}.
\ed

\item
\protect \large \begin{verbatim}
Support[strategy->MIXED] =: NFSUPPORT
Support[strategy->BEHAV] =: EFSUPPORT
\end{verbatim}\normalsize

\bd Returns the support of the mixed or behavior strategy
\verb+strategy+.  
\ed

%--T--

\item
\protect \large \begin{verbatim} 
TerminalNodes[efg<->EFG] =: LIST(NODE)
\end{verbatim}\normalsize

\bd
Returns the list of terminal nodes in the extensive form
game \verb+efg+ in prefix-traversal order.
\item
[See also:] {\tt Nodes}, {\tt NonterminalNodes}.
\ed

\item
\protect \large \begin{verbatim}
Text[x->INTEGER] =: TEXT
Text[x->FLOAT] =: TEXT
Text[x->RATIONAL] =: TEXT
Text[x->TEXT] =: TEXT
\end{verbatim} \normalsize

\bd
Converts the object \verb+x+ into the equivalent text object.
\item
[See also:] {\tt Float}, {\tt Rational}.
\ed

\item 
\protect \large \begin{verbatim}
Times[x->FLOAT, y->FLOAT] =: FLOAT
       for T = FLOAT, INTEGER, RATIONAL,
Times[x->FLOAT, y->MIXED] =: MIXED
Times[x->MIXED, y->FLOAT] =: MIXED
Times[x->RATIONAL, y->MIXED] =: MIXED
Times[x->MIXED, y->RATIONAL] =: MIXED
Times[x->FLOAT, y->BEHAV] =: BEHAV
Times[x->BEHAV, y->FLOAT] =: BEHAV
Times[x->RATIONAL, y->BEHAV] =: BEHAV
Times[x->BEHAV, y->RATIONAL] =: BEHAV
\end{verbatim} \normalsize
  
\bd
Computes the product of \verb+x+ and \verb+y+.  In the cases where one
argument is a Mixed or Behavior profile, and the other is a scalar
type, it computes the scalar product of the scalar and the profile. 
\item
[Short form:] \verb+x * y+
\ed

\item
\protect \large \begin{verbatim} 
Transpose[x->LIST(LIST(T))] := LIST(LIST(T))
\end{verbatim}\normalsize

\bd
Returns the transpose of a rectangular matrix. Fails if the 
\ed



%--U--

\item
\protect \large \begin{verbatim}
UnAssign[x<->T] =: T
\end{verbatim}\normalsize

\bd
Undefines the variable referenced by \verb+x+.  Returns the
last value of the variable.
\item
[See also:] {\tt Assign}.
\ed

\item
\protect \large \begin{verbatim}
UnmarkSubgames[efg<->EFG] =: LIST(NODE)
UnmarkSubgames[node->NODE] =: LIST(NODE)
\end{verbatim}\normalsize

\bd
Unmarks all subgames in a subtree.  If \verb+efg+ is given, unmarks all
subgames in the extensive form (except the root subgame, which is always
marked).  If \verb+node+ is given, unmarks all subgames in the subtree
rooted at \verb+node+.  Returns the list of subgames marked at the
end of the operation.
\item
[See also:] {\tt MarkSubgames}, {\tt MarkThisSubgame}, {\tt SubgameRoots},
{\tt UnmarkThisSubgame}
\ed

\item
\protect \large \begin{verbatim}
UnmarkThisSubgame[node->NODE] =: NODE
\end{verbatim}\normalsize

\bd
If \verb+node+ is the root of a defined subgame in its extensive form,
that subgame is undefined.  It is not permitted to undefine the root
subgame.  If \verb+node+ is not the root of a subgame, no action is
taken.  The node rooting the subgame to which \verb+node+ belongs after
the operation is returned.
\item
[See also:] {\tt MarkSubgames}, {\tt MarkThisSubgame}, {\tt SubgameRoots},
{\tt UnmarkSubgames}
\ed

%--V--

\item
\protect \large \begin{verbatim}
Version[] =: FLOAT
\end{verbatim} \normalsize

\bd
Returns the version number of the command language.
\item
[Note:] This function was introduced in version 0.93 of the command language.
\ed

%--W--

\item 
\protect \large \begin{verbatim}
While[boolean-expression, statement-list]
\end{verbatim} \normalsize
  
\bd
Defines a block of statements to be executed repeatedly.
See the section on control structures for complete information.
\item
[See also:] \verb+For+.
\ed

\item
\protect \large \begin{verbatim}
Write[output->OUTPUT, x->T] =: OUTPUT  
      for T = BEHAV,BOOL,FLOAT,INTEGER,MIXED,
              RATIONAL,TEXT,LIST(T)
Write[output->OUTPUT, x<->T] =: OUTPUT 
      for T = EFG, NFG
\end{verbatim}\normalsize

\bd
Does a formatted write of the object \verb+x+ to the
output stream \verb+output+.
\item
[Short form:] \verb+output << x+
\item
[Note:] This function is not listable
\item
[See also:] {\tt Output}, {\tt SetFormat}, {\tt Read}
\ed

%--X--

%--Y--

%--Z--

\end{itemize}
\bibliographystyle{chicagob}
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{gambit}
\end{document}

