%
% FILE: gclman.tex -- source for GCL manual
%
% $Id$
%
\documentstyle[widetext,chicagob]{article}
\renewcommand{\baselinestretch}{.9}
\newcommand{\bd}{\begin{description}}
\newcommand{\ed}{\end{description}}
\input{psfig}
\begin{document}


\title{GAMBIT COMMAND LANGUAGE\thanks{This is part of the Gambit
Project, which was funded in part by National Science Foundation
grants SBR-9308637 to the California Institute of Technology and
SBR-9308862 to the University of Minnesota.}}

\author{Richard D. McKelvey\\California Institute of
Technology
\and
Andrew McLennan\\University of
Minnesota
\and 
Theodore Turocy\\Northwestern University
}

\date{Version 0.94\\ \today\\ \jobname.tex}

\maketitle

\tableofcontents

\section{Introduction}

This document describes the Gambit Command Language (GCL).  Gambit is
a computer program that allows one to build, manipulate, and solve
finite extensive and normal form games. The GCL provides a method of
directing the operation of Gambit that is analagous to that of a high
level general purpose programming language.

The general purpose of the GCL is to provide a simple, but powerful
and flexible language by which one can perform complicated or
repetitive operations and procedures on games in extensive or normal
form.  The language has facilities for building and editing an
extensive or normal form game, converting back and forth between the
extensive and normal form representations, and then solving the
resulting game for various equilibria of interest. Flow
control statements allow for repetitive operations (such as
investigating games as one changes various parameters) or conditional
operations.

\section{Acknowledgements}

The Gambit Project is a project for the development of computer code
for the solution of extensive and normal form games.  The software
developed under the project is public domain.  The Gambit Project is
funded in part by National Science Foundation grants SBR-9308637 to
the California Institute of Technology and SBR-9308862 to the
University of Minnesota.

Numerous students at Caltech and the University of Minnesota have
contributed to the Gambit Command Language and to the Gambit Project
more generally: Among these are Bruce Bell, Anand Chelian, Nelson
Escobar, Eugene Grayver, Todd Kaplan, Brian Trotter, and Gary Wu.  We
are particularly grateful to Gary Wu for his work on the stack machine
used by the command language, to Bruce Bell and Nelson Escobar for
work on data structures, and to Rob Weber for help in compiling this
manual and testing parts of the language.  We are also grateful to
Eugene Grayver for his extensive work on the related GUI, and for
setting up our Web site.

\section{Installation}

All of the gambit files can be found at the Gambit World Wide Web site
at 

\begin{verbatim}
http://www.hss.caltech.edu/~gambit/Gambit.html
\end{verbatim} 

\noindent Instructions on downoading and installation as well as a
list of platforms supported can be obtained there.  Source code is
also available at the same location. 

Once the program is installed, the gcl can be run by typing \verb+gcl+
at the command line prompt.  You will then receive the GCL prompt 

\begin{verbatim}
GCL1:
\end{verbatim}

\noindent The interpreter is ready for your first command.


\section{Technical support and bug reports}

User feedback is an important part of Gambit's development cycle.
Our design choices have been motivated in large part by our experiences
and by some of the potential uses of the software we have imagined.
But this is by no means complete, and so we are eager to hear from
you, Gambit's users, to find out what features are particularly
useful, and in what areas future releases might be improved.

The authors may be contacted via email at {\tt gambit@hss.caltech.edu}.
This address will forward a copy of your message to the development team.
While a personal reply may not always be possible, we will read all
correspondence and apply as many suggestions as possible to our future
releases.

Although we have made every effort to ensure the reliability and correctness of the
code, it is certain that errors of varying degrees of severity exist.
(However, as the saying goes, no undiscovered bugs have been found yet.)  If you
experience problems with the software,
send us email at {\tt gambit@hss.caltech.edu} describing your problem.

When reporting a bug, it is important to include the following information:

\begin{itemize}
\item the version number
\item the platform(s) on which the problem occurred
\item as complete a description of the circumstances of the problem as possible, including a sequence of steps which reproduces the problem
\end{itemize}
 
\noindent Without this information, it will be difficult for us to identify the source of the
problem to correct it.

At this time, no formal technical support mechanism exists for Gambit.
As time permits, we will make every effort to answer any and all questions
pertaining to the program an its documentation.

We hope you will find Gambit a useful tool for research and instruction.


\section{Basic concepts}

The design motifs for GCL come from two principal families of programming
languages.  The first is traditional imperative programming languages
such as Pascal, C, and Modula-3.  In particular, the GCL's concept of
types draws heavily from these languages, although the number of
predefined types in GCL is much larger due to the specialized nature of
the language.  The second is more specialized programming languages such
as Mathematica, from which the GCL's grammar is partially drawn.  Users
with experience using any of these languages should find the GCL easy to
learn; however, no programming experience is necessary to begin using the
language effectively.

\subsection{Statements}

A GCL program consists of a series of statements.  A statement is
typically an expression built up out of function calls.  A statement
is terminated by a linefeed or by a semicolon.  The GCL interpreter
reports the value of each expression evaluated unless the semicolon is
present. Statements can be continued for more than one line by using
the continuation character, \verb+\+.   

\subsection{Types}

The built-in data types for the GCL are the following:  

\medskip

\begin{tabular} {|l||l|} \hline
Type name	& Description \\ \hline
{\tt BOOLEAN} 	& boolean \\
{\tt INTEGER} 	& integer \\ 
{\tt FLOAT} 	& floating-point number \\
{\tt RATIONAL} 	& rational number with arbitrary precision \\
{\tt TEXT}	& string of arbitrary length \\
{\tt INPUT}	& output stream \\
{\tt OUTPUT}	& output stream \\ \hline
{\tt EFG}	& extensive form game \\
{\tt EFPLAYER}	& a player in an extensive form game \\
{\tt NODE}	& a node in an extensive form game \\ 
{\tt INFOSET}	& an information set in an extensive form game \\
{\tt ACTION}	& an action at an information set \\
{\tt OUTCOME}	& an outcome in an extensive form game \\
{\tt EFSUPPORT}	& a support of actions in an extensive form game \\
{\tt BEHAV}	& a behavioral strategy profile for an extensive form game \\ \hline
{\tt NFG}	& normal form game \\
{\tt NFPLAYER}	& a player in a normal form game \\
{\tt STRATEGY}	& a strategy in a normal form game \\
{\tt NFSUPPORT}	& a support of strategies in a normal form game \\
{\tt MIXED}	& a mixed strategy profile for a normal form game \\ \hline
{\tt LIST}	& a list of objects \\ \hline
\end{tabular}

\medskip

The remainder of this section details the rules concerning the types
{\tt BOOLEAN}, {\tt INTEGER}, {\tt FLOAT}, {\tt RATIONAL}, {\tt TEXT},
{\tt INPUT} and {\tt OUTPUT}, as well as general rules for typing.
The extensive form and normal form types, and their related types, are
detailed later in special sections.

\subsubsection{Boolean}

The {\tt BOOLEAN} type represents boolean values, that is to say, ``true'' and
``false''.  The command language predefines two constant values to
represent these, {\tt True} and {\tt False}.

\subsubsection{Integer}

The {\tt INTEGER} type may contain integer values.  It is implemented
as the machine's long integer type, which is typically at least 32
bits in modern machines.  Thus, there is a danger, however small, of
overflow or underflow in computations involving these numbers.

\subsubsection{Float}

The {\tt FLOAT} type may contain floating point values.  It is implemented
as the machine's double-precision floating point type.  These numbers
are imprecise; for example, operations usually associated with being inverses
of each other may not be with floating point numbers.  For more precise
computations, the {\tt RATIONAL} type is available, although these may
sometimes be bulky and slow.

\subsubsection{Rational}

The {\tt RATIONAL} type is a ratio of two arbitrary-length integers.
This data type is capable of precisely representing any rational
number.  However, they are slow, and output from them may be
unreadably large.  Rational numbers are formed from two integers using
the {\tt /} operator, described below.

\subsubsection{Text}

The {\tt TEXT} type is used to store text strings, typically labels
for parts of games.  It is generally encouraged to label various elements
of games in the command language for ease of identification; however it
is not required.  To specify a {\tt TEXT} constant, surround the
text with double-quote characters ({\tt "}).  Constants may not span
more than one input line.

\subsubsection{Input}

The {\tt INPUT} type is a reference to an input stream, generally a file
on disk.  Its principal use is to read in external data. 

\subsubsection{Output}

The {\tt OUTPUT} type is a reference to an output stream, generally a
file on disk.  Its principal use is as a logging file for writing
formatting output from an extended command language job.  

\subsubsection{List}

Variables of any type can be contained in lists of arbitrary length.
Variables of type {\tt LIST} are defined similarly to the above
variables, except that the expression to the right of the {\tt ":="}
symbol contains a vector of variables of the same type enclosed in
curly braces and separated by commas.  For example, the following is a
list containing the first five integers:

\begin{verbatim}
{ 1, 2, 3, 4, 5 }
\end{verbatim}

\noindent In the same manner, lists of any type may be created and
manipulated.  Lists may be nested to any depth; however, the type of
all the elements of the list and any sublists must always be the same.
Hence

\begin{verbatim}
{ 3, { 4, 6 }, 23 }
\end{verbatim}

\noindent is a legal list, since all the elements are of type 
{\tt INTEGER}, but

\begin{verbatim}
{ 3, { 4.2, 5.7 }, 23 }
\end{verbatim}

\noindent is not, since the second element is a {\tt LIST(FLOAT)}.

Lists are distinct in type from each other and from their scalar
equivalents.  That is to say, {\tt LIST(INTEGER)} is not the same time
as {\tt LIST(FLOAT)}, nor is it the same type as {\tt INTEGER}.

\subsection{Variables}

A variable stores one object of the corresponding data type
To create a user defined variable, or to give
a new value to an existing variable, one can use the built-in
function,
\verb+Assign+, which has the syntax:
\begin{verbatim}
Assign[x<->T, y->T]
\end{verbatim}

\noindent (How to read a function's declaration is described in more
detail in the section of function calls.  For now, suffice it to say that
{\tt Assign} takes two parameters, the first of which is a variable and
the second a value of the same type as the variable.)  The {\tt Assign}
function also has an infix operator form, written {\tt :=}.  So, to assign
the {\tt INTEGER} value 1 to the variable {\tt x}, one could write

\begin{verbatim}
Assign[x, 1]
\end{verbatim}

\noindent or equivalently, and more compactly,

\begin{verbatim}
x := 1
\end{verbatim}

The {\tt Assign} function can be used to either create a new variable or
modify an existing one.  However, it cannot be used to change the type
of a variable.  Consider the calls

\begin{verbatim}
Assign[y, 2]
Assign[y, 3.0]
\end{verbatim}

\noindent The first call defines {\tt y} to be of type {\tt INTEGER}.  The
second is interpreted as {\tt Assign[ INTEGER, FLOAT]}, which does
not match the definition of {\tt Assign}.

An existing variable may be deleted by the use of the {\tt UnAssign} function

\begin{verbatim}
UnAssign[x<->T] =: T
\end{verbatim}

\noindent After this is called on a variable, the variable is no longer
defined.  A subsequent call of {\tt Assign} may redefine the variable to
be of any type.

\subsection{Errors}

Sometimes, programs contain errors.  The interpreter is able to detect
errors which violate rules of the language, and reports information
about the error so the user can correct it.  There are two main
classes of errors which may arise in GCL programs, parse errors and
run time errors.

A parse error occurs when the GCL interpreter cannot determine the
meaning of a statement, because it does not conform to the grammatical
rules of the language.  This most frequently occurs when braces,
brackets, or quotation marks fail to match up or when punctuation is
missing.  When it encounters a parse error, the GCL interpreter will
display an error message giving the filename and line number of the
error and the point at which it determined an error it occurred.

A run time error occurs when a statement which obeys the grammatical
rules of the language violates another rule of the language during its
execution.  Examples of this type of error include attempting to use a
variable name which is not defined, and using a value of one type
where another type was expected.  Also, builtin functions may generate
this type of error on invalid inputs.  A run time error will result in
termination of the GCL at the point where the error occurs, ith a
message indicating the type of error encountered.  However, no line
number is given for run time errors.  


\subsection{Function calls}

A function call consists of the name of a function, and a list of
parameters upon which the function is to operate.  Functions return a
value, which may in turn be used as a parameter to another function
call, allowing more complex computations to be expressed.

A simple example of a function call is

\begin{verbatim}
Plus[x->1, y->2]
\end{verbatim}

This calls the function named {\tt Plus}, with parameter \verb+x+ set
to the value 1 and \verb+y+ set to the value 2.  Since {\tt Plus} is
the function for addition of two integers, the value returned would
be, as you might expect, 3.

In the addition example above, we called a function which is listed in
the function reference as

\begin{verbatim}
Plus[x->INTEGER, y->INTEGER] =: INTEGER
\end{verbatim}

\noindent This listing of a function is called its {\it prototype}.  
It contains the function's name, its list of parameters, and its return
value.  In this case, the function {\tt Plus} takes two parameters, the
first named \verb+x+ and taking a value of type {\tt INTEGER} and the
second named \verb+y+ and taking a value of type {\tt INTEGER}, and
returns a value of type {\tt INTEGER}.

Because the parameters have explicit names, it is possible to rearrange
the order in which parameters are listed when a function is called.
Thus, we could write out sample call equivalently as

\begin{verbatim}
Plus[y->2, x->1]
\end{verbatim}

\noindent and achieve the same effect.

Explicitly specifying the formal names for parameters all the time
will prove tedious and can hinder readability.  For these reasons, it is
also legal to specify parameters without their associated formal names.
These are called passing {\it anonymous} parameters.  Our addition
example could thus also be written

\begin{verbatim}
Plus[1, 2]
\end{verbatim}

In not specifying the formal names, however, function calls are restricted
to specifying parameters in exactly the same order as listed in the function
prototype.  In our example, the GCL interpreter would have no way of
distinguishing whether we meant 1 to be the value of \verb+x+ or the
value of \verb+y+, and vice versa.  While in the case of addition we may
flip the values of the parameters without having an effect on the result,
in general this is not the case.

It is permitted to mix the two styles of parameter specification, subject
to the following rules:

\begin{itemize}
\item All anonymous parameters must be specified before any named parameters
\item No parameters may be omitted in the anonymous parameter list.  If
$k$ parameters are specified anonymously, they must match one-for-one the
first $k$ parameters in the function's prototype.
\item Once a named parameter has been specified, all succeeding parameters
must be named, even if the first named parameter appeared in the same
place in the parameter list as it does in the prototype.
\end{itemize}

\noindent Therefore, it would be legal to write

\begin{verbatim}
Plus[1, y->2]
\end{verbatim}

\noindent but

\begin{verbatim}
Plus[x->1, 2]
\end{verbatim}

\noindent is illegal since it violates the third condition.

To be more precise, the function {\tt Plus} comes in several different
variations listed in the function reference:

\begin{verbatim}
Plus[x->INTEGER, y->INTEGER] =: INTEGER
Plus[x->FLOAT, y->FLOAT] =: FLOAT
Plus[x->RATIONAL, y->RATIONAL] =: RATIONAL
Plus[x->MIXED, y->MIXED] =: MIXED
Plus[x->BEHAV, y->BEHAV] =: BEHAV
\end{verbatim}

\noindent This is a good example of function {\it overloading}.  This
means that one function name may have several possible parameter
lists, sometimes called {\it signatures}.  The GCL interpreter is
capable of determining which version of the function to use by
analyzing the names and types of the parameters used.

Since a function may have multiple signatures, it is conceivable that
a function call might be ambiguous, in the sense that its parameters match
more than one signature for that function.  However, no function call that
is complete may be ambiguous from the way that signatures have been
chosen for the predefined functions.  Any function call flagged by the
interpreter as ambiguous must be missing at least one parameter.

Some functions have parameters which are optional, in the sense that they
need not be specified in order to call the function.  These parameters
are indicated in the function's prototype by being surrounded by curly
braces.  (Note that these braces should not be included in the function
call when specifying an optional parameter.)  If an optional parameter
is left unspecified in a function call, a default value is assumed, as
given in the function's documentation.

For a function, all required parameters always precede any optional
parameters.  Optional parameters may also be specified anonymously,
subject to the above rules on parameter specification.

All parameters so far have been passed by {\it value}, that is, a copy
of the value of the parameter is given to the function to which it is passed.
These parameters may not be modified by the function.  It is also possible
to have parameters to a function passed by {\it reference}.  This means
that the function does not receive a copy of the value, but rather the
memory location of the value itself.  Thus, the function may modify
the value of a parameter passed by reference.

The symbol for passing a parameter by reference, both in a function's
prototype and in a function call, is {\tt <->}.  Constants may not be
passed by reference.  Reference parameters may be specified anonymously
just like a value parameter, subject to the usual rules.  It is a run-time
error to attempt to pass a value to a reference parameter, or vice versa.

\subsection{Aliases for function calls}

There are several functions which are so commonly used that special
``short'' forms are defined for them.  Most of these are the
standard arithmetic and logic operators, for which the usual binary
infix or unary prefix notations are supported.  Our addition example
may more familiarly be written

\begin{verbatim}
1 + 2
\end{verbatim}

\noindent which expression is converted to the ``long form'' function
call by the interpreter.  Note that formal names may not be specified
in a ``short form'' call, and the order of parameters is therefore
significant.

Here is a list of the functions thus abbreviated, and their ``short form''
equivalents:

\medskip

{\tt
\begin{tabular}{lp{4in}}
And[x, y]		& x \&\& y, x AND y \\
Assign[x, y]		& x := y \\
Concat[x, y]            & x \& y \\
Divide[x, y]		& x / y or x DIV y \\
Dot[x, y]		& x . y \\
Equal[x, y]		& x = y \\
Greater[x, y]		& x > y \\
GreaterEqual[x, y]	& x >= y \\
Less[x, y]		& x < y \\
LessEqual[x, y]		& x <= y \\
Minus[x, y]		& x - y \\
Modulus[x, y]		& x \% y, x MOD y \\
Not[x]			& NOT x, !x \\
NotEqual[x, y]		& x != y \\
NthChar[text, n]	& text[[n]] \\
NthChild[node, n]	& node\#n \\ 
NthElement[list, n]	& list[[n]] \\
Or[x, y]		& x || y, x OR y \\
Paren[x]		& (x) \\ 
Plus[x, y]		& x + y \\
Power[x, y]	 	& x $\wedge$ y \\
Read[in,x]		& in >> x \\
Times[x, y]		& x * y \\
Write[out,x]		& out << x \\
\end{tabular}
}

When functions are written in their canonical forms, no ambiguity
arises in the order of evaluation: In order to evaluate a function,
all arguments must be evaluated first.  Arguments are evaluated from
left-to-right as specified in the function call.
This leads to a recursive structure of evaluation,
which stops only when an argument being evaluated is a constant
function (i. e., a function with no arguments).

When short form forms are used, then ambiguity can arise in the
intended order of evaluation.  For example, the statement \verb&a + b * c&,
could be meant as \verb+Plus[a,Times[b,c]]+ or as
\verb+Times[Plus[a,b],c]+.  In order to resolve such ambiguities, all
functions that have a short form representation are given an order of
precedence.  When a statement is parsed by the GCL, it is first
scanned from left to right, replacing each short form expression at the
top level of precedence with its canonical form.  Then it is scanned
again replacing each short form expression at the second level of
precedence with its canonical form, and so on, until all short form
expressions have been eliminated.  

The order of precedence for built-in functions is as follows:
\bd
\item
\verb+()+
\item
\verb+:=+
\item
\verb+>> <<+
\item
\verb+||+
\item
\verb+&&+
\item
\verb+NOT+
\item
\verb+= != < <= > >=+
\item
\verb&+ - &\verb+&+
\item
\verb+* . / DIV MOD+ $\wedge$
\item
\verb&(unary) + -&
\item
\verb+[[ ]]+
\ed

Thus, the statement \verb&a + b * c& would become 
\begin{verbatim}
Plus[a,b*c]
Plus[a,Times[b,c]]
\end{verbatim}

\noindent
On the other hand, the statement \verb&( a + b ) * c& would become 
\begin{verbatim}
Paren[a+b]*c
Paren[Plus[a,b]]*c
Times[Paren[Plus[a,b]],c]
\end{verbatim}

\noindent
which, since \verb+Paren+ is just the identity mapping, is equivalent to
\begin{verbatim}
Times[Plus[a,b],c]
\end{verbatim}

\medskip

\subsection{Flow control structures}

The GCL contains three functions which allow flow control within a
program.  These functions are ``special'' in that their parameters
are evaluated in a special way (since their parameters are expressions
and sequences of statements); they also have no ``formal'' names for
their parameters.

\subsubsection{Conditional execution with {\tt If}}

The function \verb+If[]+ allows execution of a sequence of statements
only under certain conditions.  The syntax of the function is

\begin{verbatim}
If[boolean-expression, statement-list {, statement-list}]
\end{verbatim}

\noindent The function is interpreted as follows: If the 
\verb+boolean-expression+ evaluates to \verb+True+, then the first
list of statements is executed.  If it evaluates to \verb+False+,
and the second (optional) list of statements is present, that list
is executed; if it is not present, execution falls through to the
next statement.

For example, the statement

\begin{verbatim}
If[i = 2, j := 1, j := 2]
\end{verbatim}

\noindent sets \verb+j+ to \verb+1+ if the value of \verb+i+ is \verb+2+,
and sets \verb+j+ to \verb+2+ if the value of \verb+i+ is not \verb+2+.
It would also be perfectly legitimate to write

\begin{verbatim}
If[i = 2, j := 1]
\end{verbatim}

\noindent in which case \verb+j+ would be set to \verb+1+ if \verb+i+
is equal to \verb+2+, but if \verb+i+ were not \verb+2+, nothing would
occur.

This last example brings up an important note about conditional
execution.  Statements which appear in a branch of an \verb+If+
statement which is not taken are treated as if they did not exist.
So, were this the first mention of \verb+j+ in this scope, the last
example would leave \verb+j+ defined only if \verb+i+ was equal to
\verb+2+.  However, \verb+j+ would {\em not} be defined otherwise.  It
is therefore necessary to be careful in constructing \verb+If+
statements which result in the definition of new variables.

\subsubsection{Repetitive execution with {\tt While}}

Often in writing programs it is necessary to execute a block of statements
repeatedly, usually with different values for variables.  To this end
the GCL provides a special function \verb+While+ as a generalized looping
construct.  The syntax of the function is

\begin{verbatim}
While[boolean-expression, statement-list]
\end{verbatim}

The function is interpreted as follows: While \verb+boolean-expression+
evalutes to \verb+True+, execute the statements in \verb+statement-list+.
Note that the evaluation of the boolean takes place at the beginning of
the execution of a block, so it is only important whether the value is
\verb+True+ or \verb+False+ at the beginning of the block, and not at
some point in the middle.

This simple loop generates the numbers from one to ten:

\begin{verbatim}
i := 0;
While[i <= 10, i := i + 1];
\end{verbatim}

\noindent Alternately, one can create a list of the values one through ten with
a small modification:

\begin{verbatim}
i := 1;
list := { };
While[i <= 10, list := list + { i }; i := i + 1;]
\end{verbatim}

As with \verb+If+, be wary of declaring a variable implicitly inside a loop.
A variable is declared only when the corresponding statement is executed;
so, if the \verb+boolean-expression+ is \verb+False+ the first time it is
evaluated, the body of the loop never executes, and no variables which
appear in the loop are considered to be defined.

\subsubsection{Special looping with {\tt For}}

The function \verb+For+ is a specialized looping construct, useful mostly
in cases where some index variable is used to iterate a list or some sequence.
The general syntax for \verb+For+ is

\begin{verbatim}
For[statement-list, boolean-expression, statement-list, statement-list]
\end{verbatim}

\noindent The call is interpreted as follows:
\begin{itemize}
\item Execute the statements in
the first \verb+statement-list+ (this is called the {\em initialization}).
\item Evaluate the \verb+boolean-expression+ (called the {\em guard}).
\item If the \verb+boolean-expression+ is \verb+False+, terminate the loop and
continue with the first statement after the loop.  If it is \verb+True+,
execute the third \verb+statement-list+, called the {\em body} of the loop.
\item Execute the second \verb+statement-list+, called the {\em increment},
and return to the evaluation of the guard.
\end{itemize}

Returning to the examples in the \verb+While+ section, we see another way
of writing the two loops:

\begin{verbatim}
For[i := 1, i <= 10, i := i + 1, i];

For[i := 1, list := { }; i <= 10, list := list + {i}; i := i + 1;]
\end{verbatim}

\noindent The two methods are completely equivalent, but it is often
more convenient to use the structure afforded by the \verb+For+ function.


\section{Advanced topics}

\subsection{Including files}

The function {\tt Include[TEXT]} is used to insert the contents of the file
given into the input stream, as if they had been typed directly by the user.
This can be particularly useful in conjunction with user defined functions, in that
a library of useful functions can be constructed and included into the program
asily.

The {\tt Include} directive may only appear at the ``top level'' of
the program.  That is to say, it cannot be used inside a loop,
function declaration, or expression.  However, files may be nested
arbitrarily deep using {\tt Include}, so you can include a file which
in turn includes other files.
  
\subsection{User defined functions}

As GCL programs become more and more complex, frequently there are complicated
operations which must be performed repeatedly.  The command language therefore
supports user-defined functions, which allow for defining sections of code
which may be called later.

A new function can be created using the function
\verb+NewFunction+.  For example, one might define a function to compute
the absolute value of an {\tt INTEGER} as such:

\begin{verbatim}
NewFunction[Abs[n->INTEGER],
                 If[n > 0, n, If[n < 0, -n, 0]]]
\end{verbatim}

\noindent After defining the \verb+Abs+ function, it may be called in exactly
the same way a system-supplied predefined function may.  The return value
of the function is the value of the last statement executed. 

Parameter type matching rules apply to user defined functions in exactly the
same way as to predefined functions.  From the function's point of view,
the parameter list is a list of variables on which assignments are
automatically done at the beginning of the function execution.  So, taking
the \verb+Abs+ example above, in executing the call

\begin{verbatim}
Abs[42]
\end{verbatim}

\noindent an assignment \verb+n := 42+ is implicitly performed before the
body of the function is executed.

It is also possible to pass variables by ``reference'' to a user-defined
function in the same way as a predefined function.  In this case, the
function's ``local'' variable is stored in the same physical location in the
computer, and modifying the value locally also takes effect on the variable
passed to the function.  For example, it might
be useful instead to define \verb+Abs+ as:

\begin{verbatim}
NewFunction[Abs[n<->INTEGER],
		 If[n > 0, n, If[n < 0, n := -n, 0]]]
\end{verbatim}

\noindent in which case the function would still return the absolute value
of \verb+n+, but also modify the variable passed to \verb+n+ to be the
absolute value of the input \verb+n+.  So,

\begin{verbatim}
q := -37;
Abs[q]
\end{verbatim}

\noindent would result in the variable \verb+q+ containing the value 37
at the conclusion of execution.

Each function has its own ``scope'', or set of variables.  Within a function
body, the only variables which are visible are those which are declared
in the parameter list of the function (this is \verb+n+ in the \verb+Abs+
example above), and those which are created during the function's execution.
That is, no ``global'' or outside variables may be accessed directly by the
function.  For example, if the user typed in the following:

\begin{verbatim}
i := 4;
NewFunction[FooFunc[x->INTEGER], x * i]
\end{verbatim}

\noindent later execution of the \verb+FooFunc+ would yield an ``undefined
variable i'' error message, since \verb+i+ is never defined within the
function.  If instead \verb+FooFunc+ had been defined as follows:

\begin{verbatim}
NewFunction[FooFunc[x->INTEGER], i := 13, x * i]
\end{verbatim}

\noindent \verb+FooFunc+ would always return 13 times the value of the
parameter \verb+x+, since the value of \verb+i+ inside \verb+FooFunc+ is
always 13, regardless of the value of \verb+i+ outside of the function.


\subsection{Lists as arguments to functions}

Almost all of the functions in the GCL are ``listable''.  This means
that if there is a version of the function which takes a type \verb+T+
as the data type for a parameter, then it can be called with
\verb+LIST(T)+ as well.  This results in the function generating a
list of the corresponding length and data type as its output.  For
example, consider a function 

\begin{verbatim}
Foo[x->T,y->S] =: R
\end{verbatim}

\noindent
where \verb+T+, \verb+S+, and \verb+R+ represent arbitrary data types.
Then if \verb+a+ is a \verb+LIST(T)+, and \verb+b+ is of type
\verb+S+, then \verb+c := Foo[a,b]+ generates \verb+c+ of type
\verb+LIST(R)+, where the length of \verb+c+ is equal to the length of
\verb+a+, and where \verb+c[[i]] = Foo[a[[i]],b]+.  

If \verb+Foo[]+ is called with both \verb+a+ and \verb+b+ being lists
of the correct data type, then the GCL checks whether the length of
\verb+a+ and \verb+b+ is the same.  If not, it generates a
dimensionality error. If they are of the same dimension, then 
\verb+c := Foo[a,b]+ generates \verb+c+ of type \verb+LIST(R)+, where the
length of \verb+c+ is equal to the length of \verb+a+, and where
\verb+c[[i]] = Foo[a[[i]],b[[i]]]+.

Note that the above rules implicitly define versions of \verb+Foo[]+
of the following forms:

\begin{verbatim}
Foo[x->LIST(T),y->S] =: LIST(R)
Foo[x->T,y->LIST(S)] =: LIST(R)
Foo[x->LIST(T),y->LIST(S)] =: LIST(R)
\end{verbatim}

The same rules apply recursively using these function prototypes as
well.  So if \verb+a+ is of type \verb+LIST(LIST(T))+, and \verb+b+ is
of type \verb+S+, the command \verb+c := Foo[a, b]+ results in
a listable call to \verb+Foo[x->LIST(T),y->S]+.  Thus, \verb+c+ is of
type \verb+LIST(LIST(R))+, where \verb+c[[i]] = +
\verb+Foo[a[[i]],b]+.  Hence, \verb+c[[i]][[j]] = +
\verb+Foo[a[[i]][[j]],b]+.

Note that many vector and matrix math operations follow directly as
listable calls to the basic arithmetic functions.  For example:

\begin{verbatim}
GCL1: a:={{1,2},{3,4}};
GCL2: 2*a
{{2,4},{6,8}}
GCL3: a+Transpose[a]
{{2,5},{5,8}}
\end{verbatim}

While most functions in the GCL are listable, there are some
exceptions.  Built in functions that are not listable are noted as
such in the Function Reference section of this document.  

Listability of functions is a powerful tool of the GCL. Many GCL
programs using flow control statements can be written using listable
function calls instead.  It is encouraged to use listable functions as
much as possible because it typically leads to more concise, easier to
read GCL programs, and in addition the programs typically run much
faster than they would if flow control satements were used instead.
This is because listable calls to functions are executed in compiled
code, while flow control statements are executed in interpreted code.

\subsection{Input and Output}

Data can be read from an input stream by the \verb+Read[]+ function.
So if \verb+in+ is an input stream (i. e., of type \verb+INPUT+) then a
successful call of \verb+Read[in,x]+ will read the exposed data (see
function reference for definition of ``exposed data'') from the input
stream, \verb+in+, assign \verb+x+ to have that type and value, and
position the file pointer at the end of the exposed data, to be ready
for the next call of \verb+Read[]+.  \verb+Read[in,x]+ has the short form
\verb+in >> x+.  Since the return value of \verb+Read[in,x]+ is
\verb+in+, these commands can be chained.  In other words,

\begin{verbatim}
in >> x >> y
\end{verbatim}
 
\noindent
is equivalent to 

\begin{verbatim}
Read[in,x]
Read[in,y]
\end{verbatim}

\noindent
In the statement \verb+Read[in,x]+, if \verb+x+ is undefined, then its
data type is determined from the exposed data in the input stream.  On
the other hand if \verb+x+ is previously defined, then the \verb+Read[]+
function will expect to find the corresponding data type in the input
stream, and a file read error will be generated if the exposed data is
of the wrong data type.  If \verb+x+ is previously defined to be a
\verb+LIST(T)+, then \verb+Read[in,x]+ will successively read elements into
each element of the list.  If the wrong data type is found for any
element of the list, a file read error will be returned.  Thus, if the
file \verb+"file.out"+ contains the following data

\begin{verbatim}
25 1/3 "This is a text string!" False 3.14159 
{{1, 0},{0, 1}}
1 2 3 4 5
\end{verbatim}

\noindent
then the following GCL code

\begin{verbatim}
in:=Input["file.dat"]
x:=List[0,5]
in >> i >> r >> t >> b >> f >> l >> x
\end{verbatim}

\noindent
opens an input stream, consisting of the file \verb+"file.dat"+, and
then reads data from the input stream into the corresponding
variables.  After the last statement, 
\verb+i+ is an \verb+INTEGER+ with value \verb+25+, 
\verb+r+ is a \verb+RATIONAL+ with value \verb+1/3+, 
\verb+t+ is a \verb+TEXT+ with value \verb+"This is a text string!"+, 
\verb+b+ is a \verb+BOOLEAN+ with value \verb+False+, 
\verb+f+ is a \verb+FLOAT+ with value \verb+3.14159+, 
\verb+l+ is a \verb+LIST(LIST(INTEGER))+ with value \verb+{{1,0},{0,1}}+, and 
\verb+x+ is a \verb+LIST(INTEGER)+ with value \verb+{1,2,3,4,5}+.  

Data can be written to an output stream by the use of the \verb+Write[]+
function.  Thus, the following commands

\begin{verbatim}
out:=Output["file.out"]
x:=0/1;y:={0.0,0.0}
Write[out,x]
Write[out,y]
\end{verbatim}

\noindent
creates an output stream, \verb+out+, and then writes out a \verb+RATIONAL+
number, followed by a list of two \verb+FLOAT+s.  \verb+Write[out,x]+ has the
short form \verb+out << x+.  Since the return value of \verb+Write[]+ is
\verb+out+, these commands can be chained.  So the two lines writing out
\verb+x+ and \verb+y+ in the above example could be written instead

\begin{verbatim}
out << x << y
\end{verbatim}
 
The \verb+SetFormat[]+ function can be used to control the formatting of data
written to an output stream.  Note that the \verb+Read[]+ and \verb+Write[]+
functions are not listable.

The \verb+Read[]+ and \verb+Write[]+ functions can only be used with
certain data types (see function documentation).  Reading and writing
of \verb+EFG+ and \verb+NFG+ from external files can be done with the
\verb+LoadEfg[]+, \verb+SaveEfg[]+, \verb+LoadNfg[]+ and
\verb+SaveNfg[]+ functions.

\subsection{Extensive forms}

\subsubsection{Creating a new extensive form}

The function {\tt NewEfg[]} can be used to create a new extensive form game.
In order to do anything with it, a variable should be created to be
the new extensive form game.  Thus, the command

\begin{verbatim}
e := NewEfg[]
\end{verbatim}

\noindent will create a new extensive form game stored in \verb+e+.  The game 
is a trivial game with only one node, a \verb+root node+, and one
player, \verb+chance+.  By default, the game will have its data stored
as \verb+FLOAT+.  You can create a game whose data is \verb+RATIONAL+,
and which has two players, named \verb+Fred+ and \verb+Alice+  by
specifying 


\begin{verbatim}
e := NewEfg[True, {"Fred", "Alice"} ]
\end{verbatim}

\subsubsection{Modifying an extensive form}

The extensive form game editing functions can be used to build up any
valid extensive form game from a trivial game.  The following sequence
of commands builds the game tree for a simple poker game as described
in \cite{Mye:91}

\begin{verbatim}
e := NewEfg[];
n := RootNode[e];
deal := NewInfoset[ Chance[e], {"Red", "Black"}];
AppendNode[n, deal];
fred := NewPlayer[e,"Fred"];
fredred := NewInfoset[ fred , {"Raise", "Fold"} ];
fredblack := NewInfoset[ fred , {"Raise", "Fold"} ];
AppendNode[n#1, fredred];
AppendNode[n#2, fredblack];
alice := NewPlayer[e,"Alice"];
alicemove := NewInfoset[ alice , {"Meet", "Pass"} ];
AppendNode[n#1#1, alicemove]; 
AppendNode[n#2#1, alicemove]; 
\end{verbatim}

\noindent Outcomes can be defined and attached:

\begin{verbatim}
ante := 1.00;
raise := 1.00;
win := SetPayoff[NewOutcome[e, "Win"],{ante,-ante}];
winbig := SetPayoff[NewOutcome[e, "Win Big"],{ante+raise,-ante-raise}];
lose := SetPayoff[NewOutcome[e, "Lose"],{-ante,ante}];
losebig := SetPayoff[NewOutcome[e, "Lose Big"],{-ante-raise,ante+raise}];
AttachOutcome[TerminalNodes[e],{winbig,win,win,losebig,win,lose}]
\end{verbatim}

\subsubsection{Saving and loading extensive forms}

Once an extensive form game has been constructed, it can be saved by
the command 

\begin{verbatim}
SaveEfg[e, "filename.efg" ]
\end{verbatim}

\noindent where \verb+e+ is the extensive form game, and \verb+filename.efg+ is
the filename of the file to be created.  It is recommended that the
filename extension \verb+.efg+ be used when saving extensive form
games, as the Gambit graphics user interface recognizes this extension
as containing extensive form games.  Once an extensive form game has
been saved to an external file, it can be loaded by the command
\verb+LoadEfg+, as follows:

\begin{verbatim}
e := LoadEfg["filename.efg" ]
\end{verbatim}

\subsubsection{Subgames}

Gambit implements and supports the concept of a game theoretic
subgame.  When an extensive form is first created, no subgames (except
for the default ROOT subgame) are defined.  The function
\verb+MarkSubgames[]+ can be used to mark all of the subgames in the
extensive form, and \verb+MarkThisSubgame[]+ can be used to check
whether a specific node is a subgame root, and mark it if it is.
Similarly, subgames can be unmarked by using \verb+UnmarkSubgames[]+
and \verb+UnmarkThisSubgame[]+.  The function \verb+SubgameRoots[]+
returns a list of all currently marked subgame roots.  

All of the solution algorithms (with the current exception of the 
\verb+GobitSolve[]+ algorithms) make use of the marked subgames.  When non-trivial 
subgames are marked, then the solution algorithms will solve the 
extensive form game by recursion through the marked subgames.  Thus, a 
subgame is solved only when all subgames following it have been 
solved.  

If all subgames are marked, then any Nash equilibrium found will be a
subgame perfect Nash equilibrium.  Note that the solution algorithms
only respect marked subgames, and hence if you want the solution
algorithms to make use of subgames, you must mark the subgames.

\noindent
[Note: If there are non trivial marked subgames, the solution
algorithms currently only return one equilibrium (the first
found) in each subgame.  If no non-trivial subgames are marked, then
as many solutions as are requested will be found.]

\subsection{Normal forms}

\subsubsection{Creating a new normal form}

The function \verb+NewNfg[]+ is used to create a new normal form game.
In order to do anything with it, a variable should be created to be
the new extensive form game.  Thus, the command

\begin{verbatim}
n := NewNfg[{3,2,2}]
\end{verbatim}

\noindent 
will create a new normal form game stored in \verb+n+, with three players, where
the first player has three strategies, and the second and third
players each have two strategies.  The game has zero payoffs in each
strategy profile.  By default, the game will have its data stored in
\verb+FLOAT+.  You can create a game whose data is \verb+RATIONAL+
by specifying the parameter \verb+rational+ to be \verb+True+.

\subsubsection{Creating a normal form from an extensive form}

A normal form game can also be created from an extensive form game.
If \verb+e+ is an extensive form game, then the command 

\begin{verbatim}
n := Nfg[e]
\end{verbatim}

\noindent
will create a normal form game \verb+n+ which is the reduced normal
form game associated with the extensive form game \verb+e+.  As long
as the game \verb+n+ is not edited, then the GCL will ``remember'' the
extensive form game that \verb+n+ is associated with.  Any mixed
strategy solutions computed on the normal form game \verb+n+ can be
converted back to a behavior strategy of the game \verb+e+ by using
the command \verb+Behav+.  Thus

\begin{verbatim}
n := Nfg[e];
m := LcpSolve[n];
b := Behav[m,e]
\end{verbatim}

\noindent
will convert the game \verb+e+ to reduced normal form, solve it using
the LcpSolve algorithm, and then convert all mixed profiles found back
to behavior profiles, and display the list, \verb+b+ of behavior
profiles found. 
  
\subsubsection{Modifying a normal form}

The normal form game payoff editing functions can be used to build up any
valid normal form game from a trivial game.  Thus, the command

\begin{verbatim}
SetPayoff[n,{2,1,2},{3.0,4.0,1.5}]
\end{verbatim}

\noindent
changes the payoff for the strategy profile in which player one adopts
his second strategy, player 2 adopts her first strategy and player
three adopts his second strategy to the vector \verb+(3.0,4.0,1.5)+,
meaning that player one's payoff is \verb+3.0+, the second player's
payoff is \verb+4.0+ and the third player's payoff is \verb+1.5+.

\subsubsection{Saving and loading normal forms}

Once an normal form game has been constructed, it can be saved in a
similar way to an extensive form game.  The command 

\begin{verbatim}
SaveNfg[n, "filename.nfg" ]
\end{verbatim}

\noindent
will save the normal form game \verb+n+ to the file
\verb+filename.nfg+.  It is recommended that the
filename extension \verb+.nfg+ be used when saving normal form games, as
the Gambit Graphics user interface recognizes this extension as
containing normal form games.  Once a normal form game has been
saved to an external file, it can be loaded by the command
\verb+LoadNfg+, as follows:

\begin{verbatim}
n := LoadNfg["filename.nfg" ]
\end{verbatim}

\section{Solving games}

\subsection{Enum}

The two {\tt Enum} functions can be used to enumerate the pure or
mixed Nash equilibria for a normal form game. 

The {\tt EnumPureSolve} function enumerates all pure strategy Nash
equilibria in the support of a normal form game.  This
algorithm simply investigates all pure strategy profiles, checking
each for the Nash equilibrium conditions.  By default, the algorithm
finds all pure strategy Nash equilibrium.  Optionally it can be set to
find the first \verb+k+ Nash equilibria.  This algorithm will work on
any normal form game.  

The {\tt EnumMixedSolve} function enumerates all Nash equilibria (pure
and mixed) for a given support of a two person normal form game.  More
precisely, it finds the set of extreme Nash equilibria, as defined in
\cite[1964]{Man:64}.  For any normal form game, as shown in
Mangasarian, every Nash equilibrium can be expressed as a convex
combination of the extreme Nash equilibria.  For generic games, there
are just a finite number of Nash equilibria, which coincide with the
extreme equilibria.  By default, all extreme equilibria are found.
Optionally, the algorithm can be set to find the first \verb+k+
equilibria.  This algorithm works only on two-person normal form
games.

\subsection{Gobit}

The {\tt GobitSolve} function computes a branch of the logistic
quantal response equilibrium correspondence (as described in
\cite{McKPal:95a} for normal form games, and in
\cite{McKPal:95b} for extensive form games.  The branch is
computed for values of $\lambda$ between $\underline{\lambda}$ and
$\bar{\lambda}.$ The algorithm starts at $\lambda_0 =
\underline{\lambda}$ if $\delta>0,$ or $\lambda_0 = \bar{\lambda}$ if
$\delta<0$. It then increments according to the formula
$$
\lambda_{t+1} = \lambda_t +\delta \lambda_t^a,
$$ 
where $\underline\lambda,$ $\bar\lambda,$ $\delta,$ and $a$ are
parameters that can be specified.  In the computation for the first value of
$\lambda_0$, the algorithm begins its search for a solution at a user
specified starting point.  At each
successive value of $\lambda_t,$ the algorithm begins its search at
the point found in step $t - 1.$ 

The {\em principal branch} of the logistic quantal response
equilibrium mapping is the branch that is connected to the centroid of
the game at $\lambda = 0$.  This branch can be computed by setting
$\lambda_0$ sufficiently small.  As discussed in McKelvey and Palfrey,
for generic normal form games, the principal branch of the quantal
response equilibrium correspondence converges to a unique selection
from the set of Nash equilibria as $\lambda$ goes to infinity.
Similarly, for generic extensive form games, the principal branch of
the quantal response mapping converges to a unique selection from the
set of sequential equilibria as $\lambda$ goes to infinity.  Hence, in
extensive form games, this algorithm can be used to compute an
approximation to a sequential equilibrium.

The {\tt GobitGridSolve} function performs a grid search to compute
the {\em complete} logistic quantal response correspondence.  Points
are evaluated in terms of the value of an objective function, that
measures the distance between the original point, and the best
response to the best response (under the logistic best response
function.)  Points that are close (within 'tol') to being fixed points
are kept, others are discarded.  Values of the probabilities are
evaluated on a grid of mesh 'delp.'  This procedure is very
computationally intensive, and is only feasible for small two-person
normal form games.

\subsection{Linear Complementarity Program}

The {\tt LcpSolve} function formulates and solves the game as a linear
complementarity problem.  This algorithm works for two person
games in either extensive or normal form.  
 
For a normal form game, the game is solved via the Lemke-Howson
Algorithm.  (See, eg.,
\cite{LemHow:64}) using lexicographic rule for insuring
termination, as developed in \cite{Eav:71}.  This algorithm can also
be used to find the set of {\em accessible} Nash equilibria, by
tracing out the pattern of connectedness of the complemenary basic
feasible solutions, as described in \cite{Sha:74}.  The set of
accessible equilibria is frequently the same as the set of all Nash
equilibria, but this is not always so.

For an extensive form game, this algorithm implements Koller, Megiddo
and von Stengel's {\em sequence form} (\cite{KolMegSte:94}. The
sequence form is a formulation of the set of Nash equilibria as the
solution to a non linear complementarity problem in variables that
correspond to ``sequences'' in the extensive form, which they show can
be solved by Lemke's algorithm for Linear complementarity problems.
The method has nice properties in terms of its computational
complexity, as it only grows linearly in the size of the extensive
form game.  

\subsection{Lyapunov Function}

The {\tt LiapSolve} function finds Nash equilibria via the Lyapunov
function method described in \cite{McK:91}.  This method works on
either the extensive or normal form.  This algorithm casts the problem
as a function minimization problem by use of a Lyapunov function for
Nash equilibria.  This is a continuously differentiable non negative
function whose zeros coincide with the set of Nash equilibria of the
game.  A standard descent algorithm is used to find a constrained
local minimum of the function from any given starting location.  Since
a local minimum need not be a global minimum (with value 0,) the
algorithm is not guaranteed to find a Nash equilibrium from any fixed
starting point.  The algorithm thus incorporates the capability of
restarting.  The algorithm starts from the initial starting point
determined by the parameter 'start'.  If a Nash equilibrium is not
found, it will keep searching from new randomly chosen starting points
until a Nash equilibrium has been found or the maximum number of tries
(parameter 'ntries') is exceeded, whichever comes first.

\subsection{Linear Program}

Finds the minmimax solution (a Nash equilibrium) for a two person
constant-sum game in normal form, by solving it as a Linear Program.

\subsection{Simpicial Subdivision}

Computes a Nash equilibrium to a n-person normal form game based on a
simplicial subdivision algorithm.  The algorithm implemented is that
of \cite{VTH:1987}.  The algorithm is a simplicial subdivision
algorithm which can start at any point in the simplex.  The algorithm
starts with a given grid size, follows a path of almost completely
labeled subsimplexes, and converges to a completely labeled
sub-simplex that approximates the solution.  Additional accuracy is
obtained by refining the grid size and restarting from the previously
found point.  The idea is that by restarting at a close approximation
to the solution, each successive increase in accuracy will yield a
short path, and hence be quick.

In its pure form, the algorithm is guaranteed to find at least one
mixed strategy equilibrium to any n-person game.  Experience shows
that the algorithm works well, and is acceptably fast for many
moderate size problems.  But in some examples it can be quite slow.
The reason for this is that sometimes after restarting with a refined
grid size, even though the starting point is a good approximation to
the solution, the algorithm will go to the boundary of the simplex
before converging back to a point that is close to the original
starting point.  When this occurs, each halving of the grid size will
take twice as long to converge as the previous grid size.  If a high
degree of accuracy is required, or if the normal form is large, this
can result in the algorithm taking a long time to converge.

In order to combat the above difficulty, a parameter 'leash' has been
added to the algorithm which places a limit on the distance which the
algorithm can wander from the restart point. (Setting this parameter
to 0 results in no limit, and gives the pure form of the algorithm.)
With this parameter set to a non trivial value, the algorithm is no
longer guaranteed to converge, and setting small values of the
parameter will sometimes yield lack of convergence.  However,
experience shows that values of the parameter on the order of 10
generally do not destroy convergence, and yield much faster
convergence.

\section{Function Reference, by Category}

This section contains a list of functions, organized by
category.  For a description of each function, and the arguments,
refer to the following, alphabetically organized, section.

{\bf This section was so out of date I took it out and am starting it
over from scratch.}

\section{Function Reference, Alphabetical}

The following is a list of procedures with the operations that they
perform in the Gambit Command Language:

Variable types in all capital letters indicate the type of the
required parameter or return value of the procedure.

The symbol {\tt "=:"} to the right of a procedure specifies the type
of the return value (if any exists) produced by the procedure.

Paremeters enclosed in brackets {\tt "\{ \}"} represent optional
parameters which are not necessary for the procedure to function.

\begin{itemize}

%--A--


\item
\protect \large \begin{verbatim}
ActionProb[profile->BEHAV(T), action->ACTION] =: T
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the probability that \verb+action+ is chosen at its
information set when all players are following \verb+profile+.
If \verb+action+ is a chance action, the probability of chance selecting
the action is returned.  If the probability is not specified by the 
profile, the null value is returned.  It is an error if \verb+profile+
and \verb+action+ are not from the same extensive form game.

\item [See also:] \verb+SetActionProbs+.
\ed

\item
\protect \large \begin{verbatim}
ActionValue[profile->BEHAV(T), action->ACTION] =: T
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd 
Returns the expected payoff to a player of choosing \verb+action+ when
all players are following \verb+profile+.  If the value is not well-defined,
the null value is returned.  It is an error if \verb+profile+ and
\verb+action+ are not from the same extensive form game, or if \verb+action+
is an action at an information set owned by the chance player.

\item [See also:] \verb+Belief+, \verb+InfosetProb+, \verb+NodeValue+,
\verb+RealizProb+.
\ed

\item
\protect \large \begin{verbatim} 
Actions[infoset->INFOSET*, support->EFSUPPORT] =: LIST(ACTION)
\end{verbatim}\normalsize

\bd
Returns the list of actions available at \verb+infoset+ in
\verb+support+.  If \verb+infoset+ is the null information set, the
empty list of actions is returned.  It is an error if \verb+infoset+
and \verb+support+ are not from the same extensive form game.

\item [See also:] \verb+DeleteAction+, \verb+InsertAction+.
\ed

\item
\protect \large \begin{verbatim} 
AddAction[support<->EFSUPPORT, action->ACTION] =: EFSUPPORT
\end{verbatim}\normalsize

\bd 
Adds \verb+action+ to the \verb+support+.  If the action is already in
the support, no change is made.  A copy of the modified support is
returned.  It is an error if \verb+support+ and \verb+action+ are not from the
same extensive form game.

\item [See also:] \verb+RemoveAction+, \verb+Support+.
\ed

\item
\protect \large \begin{verbatim}
AddStrategy[support<->NFSUPPORT, strategy->STRATEGY] =: NFSUPPORT
\end{verbatim}\normalsize

\bd
Adds \verb+strategy+ to the \verb+support+.  If the strategy is already
in the support, no change is made.  A copy of the modified support is
returned.  It is an error if \verb+support+ and \verb+strategy+ are not
from the same normal form game.

\item [See also:] \verb+RemoveStrategy+, \verb+Support+.
\ed

\item
\protect \large \begin{verbatim}
AgentForm[efg->EFG(T), {time<->FLOAT}] =: NFG(T)
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Creates and returns the agent normal form representation of \verb+efg+.
The optional parameter \verb+time+, if specified, returns the amount
of time consumed by the conversion.

\item [See also:] \verb+Nfg+.
\ed

\item 
\protect \large \begin{verbatim}
And[x->BOOLEAN, y->BOOLEAN] =: BOOLEAN
\end{verbatim} \normalsize

\bd
Computes the logical conjunction of \verb+x+ and \verb+y+.
\item
[Short forms:] \verb+x && y+, \verb+x AND y+.
\ed

\item
\protect \large \begin{verbatim} 
AppendNode[node->NODE, infoset->INFOSET] =: NODE
\end{verbatim}\normalsize

\bd
Places a terminal \verb+node+ into the information set
\verb+infoset+.  The result is \verb+node+ becomes a decision node,
with number of branches equal to the number of actions in \verb+infoset+.
New child nodes are created as successor nodes to the actions in the
information set.  The child which succeeds the first action is returned.
It is an error if \verb+node+ and \verb+infoset+ are not from the same
extensive form game, or if \verb+node+ is not a terminal node.

\item [See also:] \verb+InsertNode+, \verb+NewInfoset+.
\ed

\item 
\protect \large \begin{verbatim}
Assign[x<->T, value->T*] =: T
\end{verbatim} \normalsize

{\it for all types} {\tt T}
\bd
Copies the \verb+value+ to the variable referred to by \verb+x+.
Note that the type-matching rules combined with this signature imply that
a variable's type may not be directly changed.  Returns the value assigned.
\item [Short form:] \verb+x := value+
\item [See also:] \verb+Clear+, \verb+UnAssign+.
\ed

\item
\protect \large \begin{verbatim} 
AttachOutcome[node->NODE, outcome->OUTCOME*] =: OUTCOME
\end{verbatim}\normalsize

\bd
Attaches \verb+outcome+ to \verb+node+.  Returns the outcome attached.
Note that nonterminal nodes may have outcomes attached; the interpretation
is that nonterminal outcomes represent incremental payoffs.  Attaching
the null outcome is equivalent to a call to \verb+DetachOutcome+.  It is
an error if \verb+node+ and \verb+outcome+ are not from the same
extensive form game.
\item [See also:] \verb+DetachOutcome+, \verb+HasOutcome+, \verb+Outcome+.
\ed

%--B--


\item
\protect \large \begin{verbatim}
Behav[support->EFSUPPORT, value->LIST(LIST(LIST(T)))] =: BEHAV(T)
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns a behavioral strategy profile over \verb+support+ with the
values specified by \verb+value+.  It is an error if the dimensions of
\verb+value+ do not match those of \verb+support+.
\item [See also:] \verb+Centroid+, \verb+Mixed+.
\ed

\item
\protect \large \begin{verbatim}
Behav[profile->MIXED(T)] =: BEHAV(T)
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Converts \verb+profile+ to the equivalent behavioral profile on the
associated extensive form game using Kuhn's Theorem.  It is an error
if there is no extensive form game associated with the normal form game
of \verb+profile+.
\item [See also:] \verb+Mixed+.
\ed

\item
\protect \large \begin{verbatim}
Belief[profile->MIXED(T), node->NODE] =: T
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the probability of being at \verb+node+, conditional on the
player who chooses at \verb+node+ knowing she is in \verb+node+'s
information set, assuming all players follow \verb+profile+.  The null
value is returned if the belief value is not well-defined, or if
\verb+node+ is terminal.  It is an error if \verb+profile+ and \verb+node+
are not from the same extensive form game.
\item [See also:] \verb+ActionValue+, \verb+InfosetProb+, \verb+NodeValue+,
\verb+RealizProb+.
\ed


%--C--

\item
\protect \large \begin{verbatim} 
Centroid[support->EFSUPPORT] =: BEHAV(T)
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns a behavioral profile over \verb+support+ initialized to the
centroid, that is, the behavioral profile in which all actions in the
support at each information set are equally likely to be chosen, and
all actions not in the support are chosen with probability zero.
\item [See also:] \verb+Behav+.
\ed

\item
\protect \large \begin{verbatim}
Centroid[support->NFSUPPORT] =: MIXED(T)
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns a mixed profile over \verb+support+
initialized to the centroid, that is, the mixed profile in which 
all strategies in the support for each player are equally likely to be
chosen, and all strategies not in the support are chosen with probability
zero.
\item [See also:] \verb+Mixed+.
\ed

\item
\protect \large \begin{verbatim}
Chance[efg->EFG(T)] =: EFPLAYER
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the chance, or nature, player defined on \verb+efg+.
Each extensive form has exactly one
chance player predefined, and it is not possible to define any additional
chance players.
\ed

\item
\protect \large \begin{verbatim}
ChanceProb[action->ACTION] =: T
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the probability of \verb+action+ being chosen at its information
set by the chance player.  It is an error if \verb+action+ is not an action
which is chosen by the chance player.
\item [See also:] \verb+SetChanceProbs+.
\ed

\item
\protect \large \begin{verbatim} 
Children[node->NODE] =: LIST(NODE)
\end{verbatim}\normalsize

\bd
Returns the list of children of \verb+node+.
\item [See also:] \verb+Parent+.
\ed

\item
\protect \large \begin{verbatim}
Clear[] =: BOOLEAN
\end{verbatim}\normalsize

\bd
Unassigns all variables defined in the current scope.  Within a user-defined
function, parameters are not unassigned.  Returns \verb+True+.
\item [See also:] \verb+Assign+, \verb+UnAssign+.
\ed

\item
\protect \large \begin{verbatim}
CompressEfg[support->EFSUPPORT] =: EFG(T)
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Creates a copy of the extensive form game on which \verb+support+ is
defined, where all actions not present in \verb+support+ have been
removed.
\ed

\item
\protect \large \begin{verbatim}
CompressNfg[support->NFSUPPORT] =: NFG(T)
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Creates a copy of the normal form game on which \verb+support+ is
defined, where all strategies not present in \verb+support+ have been
removed.
\ed

\item
\protect \large \begin{verbatim}
Concat[x->NLIST(T), y->NLIST(T)] =: LIST(T)
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns the concatenation of the lists \verb+x+ and \verb+y+.
\item
[Short form:] \verb%x & y%
\ed

\item
\protect \large \begin{verbatim}
Contains[list->NLIST(T), x->T] =: BOOLEAN
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns \verb+True+ when the value \verb+x+ is contained in \verb+list+.
\item [See also:] \verb+NthElement+.
\ed

\item
\protect \large \begin{verbatim}
CopyTree[from->NODE, to->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Copies the subtree rooted at \verb+from+ to the terminal
node \verb+to+ in the same extensive form game.  The nodes in the
copied subtree belong to the same information sets as their counterparts in
the original subtree.  Returns the node \verb+to+.  It is an error if
\verb+from+ and \verb+to+ are not from the same extensive form game,
or if \verb+to+ is not a terminal node.  The function has no effect if
the copying operation would violate the currently marked subgame
structure.

\item
[See also:] \verb+MoveTree+.
\ed

%--D--

\item
\protect \large \begin{verbatim}
Date[] =: TEXT
\end{verbatim}\normalsize

\bd
Returns the current date and time. 
\ed

\item
\protect \large \begin{verbatim}
DeleteAction[action->ACTION] =: BOOLEAN
\end{verbatim}\normalsize

\bd
Deletes \verb+action+ from its information set. 
As a consequence, the corresponding subtrees associated
with the action from each member of the information set are deleted.
If \verb+action+ is the last action in its information set, the
information set is deleted, and its members become terminal nodes.
Returns \verb+True+ when \verb+action+ was the last action in its
information set.
\item [See also:] \verb+Actions+, \verb+InsertAction+.
\ed

\item
\protect \large \begin{verbatim}
DeleteEmptyInfoset[infoset->INFOSET] =: BOOLEAN
\end{verbatim}\normalsize

\bd
Deletes \verb+infoset+ from its extensive form game.  An information set
may be deleted only when it has no members; otherwise, this function has
no effect.  Returns \verb+True+ when the information set was successfully
deleted.
\item [See also:] \verb+Members+, \verb+NewInfoset+.
\ed

\item
\protect \large \begin{verbatim}
DeleteFunction[function-name[argument-list]]
\end{verbatim}\normalsize

\bd
Removes the specified function from the list of user-defined functions.
\item [See also:] \verb+NewFunction+.
\ed

\item
\protect \large \begin{verbatim}
DeleteNode[node->NODE, keep->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Deletes \verb+node+ from its extensive form game.  The
subtree rooted in node \verb+keep+, which must be a child of
\verb+node+, is kept, and \verb+keep+ takes the place of \verb+node+ in
the tree.  All other subtrees descending from \verb+node+ are deleted.
The kept node \verb+keep+ is returned.  It is an error if \verb+keep+
is not a child of \verb+node+, or if \verb+keep+ and \verb+node+ are not
from the same extensive form game.
\item [See also:] \verb+DeleteTree+, \verb+InsertNode+.
\ed

\item
\protect \large \begin{verbatim}
DeleteOutcome[outcome->OUTCOME] =: LIST(NODE)
\end{verbatim}\normalsize

\bd
Removes \verb+outcome+ from its extensive
form game.  All nodes with the specified outcome attached are reset to
having no outcome attached; this is equivalent to an implicit call to
\verb+DetachOutcome+ on these nodes.  Returns the list of nodes to which
the outcome was attached.
\item [See also:] \verb+NewOutcome+.
\ed

\item
\protect \large \begin{verbatim}
DeleteTree[node->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Deletes the subtree rooted at \verb+node+.  The
node then becomes a terminal node, which is returned.
\item [See also:] \verb+DeleteNode+.
\ed

\item
\protect \large \begin{verbatim}
DetachOutcome[node->NODE] =: OUTCOME
\end{verbatim}\normalsize

\bd
Sets the outcome associated with \verb+node+ to be the
null outcome.  If there is no outcome associated with \verb+node+ this
function has no effect.  Returns the outcome which was attached to
\verb+node+, or the null outcome if no outcome was attached.
\item [See also:] \verb+AttachOutcome+, \verb+HasOutcome+, \verb+Outcome+.
\ed

\item 
\protect \large \begin{verbatim}
Divide[x->T, y->T] =: T
\end{verbatim} \normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the quotient $x / y$. 
\item [Short form:] \verb+x / y+
\item [See also:] \verb+IntegerDivide+.
\ed

\item
\protect \large \begin{verbatim}
Divide[x->INTEGER, y->INTEGER] =: RATIONAL
\end{verbatim}\normalsize

\bd
Divides \verb+y+ into \verb+x+ by forming the equivalent rational number.
\item [Short form:] \verb+x / y+
\item [See also:] \verb+IntegerDivide+.
\ed

\item
\protect \large \begin{verbatim}
Dot[x->LIST(T), y->LIST(T)] =: T
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, INTEGER, RATIONAL}
\bd
Returns the dot product of \verb+x+ and \verb+y+, where the lists are
treated as vectors.
It is an error to attempt to multiply two lists of different
lengths.
\item [Short form:] \verb%x . y%
\ed

%--E--

\item
\protect \large \begin{verbatim}
ElapsedTime[] =: FLOAT
\end{verbatim}\normalsize

\bd
If the system stopwatch is currently running, returns the
time elapsed since the stopwatch was started.  If the system stopwatch
is not running, returns the time elapsed during the last period during which
the stopwatch was running.
\item
[See also:] \verb+IsWatchRunning+, \verb+StartWatch+, \verb+StopWatch+.
\ed

\item
\protect \large \begin{verbatim}
ElimDom[support->EFSUPPORT, {strong->BOOLEAN},
        {mixed->BOOLEAN}, {time<->FLOAT},
        {traceFile<->OUTPUT}, {traceLevel->INTEGER}] =: EFSUPPORT
ElimDom[support->NFSUPPORT, {strong->BOOLEAN},
        {mixed->BOOLEAN}, {time<->FLOAT},
        {traceFile<->OUTPUT}, {traceLevel->INTEGER}] =: NFSUPPORT
\end{verbatim}\normalsize

\bd
Finds dominated strategies, or actions, as appropriate, in a 
\verb+support+.  The returned support contains only the undominated
strategies or actions; if this support is identical to the input support,
no strategies or actions were found to be dominated.  The following
optional parameters may be specified to modify the behavior of
the elimination:

\bd
\item [strong:] By default, all weakly dominated strategies or actions
are eliminated.  If this is specified \verb+True+, elimination is based
on strict dominance.
\item [mixed:] By default, elimination is done in pure strategies or
actions.  If this is specified \verb+True+, elimination is done by
examining mixtures over other strategies or actions.
\item [time:] Returns the time consumed by the elimination process.
\item [traceFile:] A file containing a log of more detailed information
on the elimination process.  By default, no logging is done.
\item [traceLevel:] An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no output
at all.
\ed
\ed

\item
\protect \large \begin{verbatim}
EnumMixedSolve[support->EFSUPPORT, {asNfg->BOOLEAN}, 
               {stopAfter->INTEGER}, {nPivots<->INTEGER}, 
               {time<->FLOAT}, {traceFile<->OUTPUT},
               {traceLevel->INTEGER}] =: LIST(BEHAV(T))
EnumMixedSolve[support->NFSUPPORT, {stopAfter->INTEGER},
               {nPivots<->INTEGER}, {time<->FLOAT},
               {traceFile<->OUTPUT},
               {traceLevel->INTEGER}] =: LIST(MIXED(T))
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the extreme points of the set of all Nash equilibria (pure or
mixed) for a two person game using \verb+support+.
The extensive form version converts
each marked subgame into its associated reduced normal form, enumerates
equilibria, and reassembles the behavioral profiles.  The normal form
version operates directly on the given normal form.

The following optional parameters may be used to modify the behavior
of the algorithm:
\bd
\item
[asNfg:] By default, this is \verb+False+.  If it is specified to be
\verb+True+, the extensive form game is solved by recursively converting
its marked subgames into normal form, solving, and reconstructing the
solution as a behavioral profile.  {\it Note that currently this algorithm
is only supported on the normal form, so this parameter
must always be specified and {\tt True}.} 
\item
[stopAfter:] By default, all equilibria are found.  This parameter may
be used to specify a maximum number of equilibria to be found.
\item
[nPivots:] Returns the number of pivots done by the
algorithm.
\item
[time:] Returns the time elapsed during the execution
of the algorithm.
\item
[traceFile:] A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no output
at all.
\ed
\item [See also:] \verb+EnumPureSolve+.
\ed

\item
\protect \large \begin{verbatim}
EnumPureSolve[support->EFSUPPORT, {asNfg->BOOLEAN},
              {stopAfter->INTEGER}, {time<->FLOAT},
              {traceFile<->OUTPUT},
              {traceLevel->INTEGER}] =: LIST(BEHAV(T))
EnumPureSolve[support->NFSUPPORT, {stopAfter->INTEGER},
              {time<->FLOAT}, {traceFile<->OUTPUT},
              {traceLevel->INTEGER}] =: LIST(MIXED(T)) 
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns all pure strategy Nash equilibria of a game using the given
\verb+support+.  The behavior
of the algorithm may be modified by the following optional parameters:
\bd
\item
[asNfg:] By default, this is \verb+False+.  If it is specified to be
\verb+True+, the extensive form game is solved by recursively converting
its marked subgames into normal form, solving, and reconstructing the
solution as a behavioral profile.
\item
[stopAfter:] By default, all equilibria are found.  This parameter may
be used to specify a maximum number of equilibria to be found.
\item
[time:] Returns the time elapsed during the execution
of the algorithm.
\item
[traceFile:] A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An integer specifying the level of detail in logging.  Higher
integers correspond to more detail; zero corresponds to no output at all.
\ed
\item
[See also:] \verb+EnumMixedSolve+.
\ed

\item
\protect \large \begin{verbatim}
Equal[x->T*, y->T*] =: BOOLEAN
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns \verb+True+ when \verb+x+ and \verb+y+ are equal.  For games,
\verb+x+ and \verb+y+ are considered equal when they refer to the same
game (but not if they refer to two different games with exactly the
same structure, payoffs, and so forth).  A null value is considered equal
to the null value, but is not equal to any non-null value.
\item
[Short form:] \verb+x = y+.
\item
[See also:] \verb+NotEqual+.
\ed

\item
\protect \large \begin{verbatim}
Exp[x->FLOAT] =: FLOAT
\end{verbatim} \normalsize

\bd
Returns the value of the function ${\rm e}^{x}$.
\item [See also:] \verb+Log+, \verb+Power+.
\ed


%--F--

\item
\protect \large \begin{verbatim}
Filter[list->NLIST(T*), by->NLIST(BOOLEAN)] =: LIST(T)
\end{verbatim} \normalsize

{\it for all types} {\tt T}
\bd
Returns a list with the same dimension structure as \verb+list+, with the
elements for which the corresponding elements of \verb+by+ are \verb+False+
removed.  It is an error if \verb+list+ and \verb+by+ do not have the same
dimensionality.
\item [See also:] \verb+Sort+.
\ed

\item
\protect \large \begin{verbatim}
Flatten[list->NLIST(T*), {levels->INTEGER}] =: LIST(T)
\end{verbatim} \normalsize

{\it for all types} {\tt T}
\bd
Returns a list with the same elements as \verb+list+, with the nesting
structure flattened.  By default, all levels are flattened, returning
a one-dimensional list; the optional parameter \verb+levels+ may be
used to limit the flattening to the topmost \verb+levels+.
\ed

\item
\protect \large \begin{verbatim}
Float[x->T] =: T
\end{verbatim} \normalsize

{\it for} {\tt T = FLOAT, INTEGER, RATIONAL}
\bd
Returns the value of \verb+x+ as type \verb+FLOAT+.
In the case where \verb+x+ is \verb+RATIONAL+ this may result in a loss
of precision.
\item [See also:] \verb+Integer+, \verb+Rational+.
\ed

\item
\protect \large \begin{verbatim}
Float[nfg->NFG(RATIONAL)] =: NFG(FLOAT)
Float[efg->EFG(RATIONAL)] =: EFG(FLOAT)
\end{verbatim} \normalsize

\bd
Returns a copy of the game \verb+nfg+ or \verb+efg+ of data type 
\verb+FLOAT+. Note that this may result in a loss of precision.  
\item [See also:] \verb+Rational+.
\ed

\item
\protect \large \begin{verbatim}
For[statement-list, boolean-expression, 
    statement-list, statement-list]
\end{verbatim}\normalsize

\bd
Defines a piece of code to be executed repeatedly.  See the section
on control structures for complete information.
\item
[See also:] \verb+While+.
\ed

%--G--

\item
\protect \large \begin{verbatim}
Game[profile->BEHAV(T)] =: EFG(T)
Game[player->EFPLAYER] =: EFG(T)
Game[support->EFSUPPORT] =: EFG(T)
Game[profile->MIXED(T)] =: NFG(T)
Game[player->NFPLAYER] =: NFG(T)
Game[support->NFSUPPORT] =: NFG(T)
Game[node->NODE] =: EFG(T)
Game[outcome->OUTCOME] =: EFG(T)
Game[strategy->STRATEGY] =: NFG(T)
\end{verbatim} \normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the game on which the parameter is defined.
\ed

\item
\protect \large \begin{verbatim}
GobitGridSolve[support->NFSUPPORT, {pxifile->TEXT},
               {minLam->FLOAT}, {maxLam->FLOAT}, 
               {delLam->FLOAT}, {powLam->INTEGER}, 
               {delp->FLOAT}, {tol->FLOAT},
               {nEvals<->INTEGER}, {time<->FLOAT}
               {traceFile<->OUTPUT},
               {traceLevel->INTEGER}] =: LIST(MIXED(FLOAT))
\end{verbatim}\normalsize

\bd
Computes the complete logistic quantal response correspondence for
a (small) two-person normal form game on the \verb+support+, for values of
$\lambda$ between $\underline{\lambda}$ and $\bar{\lambda}.$ Returns
the list of mixed profiles computed, one profile for each value of
$\lambda_t$ from lowest to highest.

The operation of the algorithm may be modified by specifying optional
parameters.  See \verb+GobitSolve+ for a description of parameters
not listed here:
\bd
\item
[delp:] Grid size for search over probability space.  Default is $0.02$ .
\item
[tol:] The tolerance on the objective function.  Values of $p$ for
which the objective function is less this value are kept.  The default
is $0.02$.  
\ed
\item [See also:] \verb+GobitSolve+.
\ed

\item
\protect \large \begin{verbatim}
GobitLambda[profile->BEHAV(FLOAT)] =: FLOAT
GobitLambda[profile->MIXED(FLOAT)] =: FLOAT
\end{verbatim}\normalsize

\bd
Returns the value of \verb+lambda+ for mixed or behavior profiles
computed by \verb+GobitSolve+ or \verb+GobitGridSolve+.  Profiles not
created by one of these algorithms have a null lambda value.
\item
[See also:] \verb+GobitGridSolve+, \verb+GobitSolve+, \verb+GobitValue+.
\ed

\item
\protect \large \begin{verbatim}
GobitSolve[start->BEHAV(FLOAT), {pxifile->TEXT},
           {minLam->FLOAT}, {maxLam->FLOAT},
           {delLam->FLOAT}, {powLam->INTEGER},
           {fullGraph->BOOLEAN}, {maxitsN->INTEGER}, {tolN->FLOAT},
           {maxits1->INTEGER}, {tol1->FLOAT}, {time<->FLOAT},
           {nEvals<->INTEGER}, {nIters<->INTEGER},
           {traceFile<->OUTPUT},
           {traceLevel->INTEGER}] =: LIST(BEHAV(FLOAT))
GobitSolve[start->MIXED(FLOAT), {pxifile->TEXT},
           {minLam->FLOAT}, {maxLam->FLOAT},
           {delLam->FLOAT}, {powLam->INTEGER},
           {fullGraph->BOOLEAN}, {maxitsN->INTEGER}, {tolN->FLOAT},
           {maxits1->INTEGER}, {tol1->FLOAT}, {time<->FLOAT},
           {nEvals<->INTEGER}, {nIters<->INTEGER},
           {traceFile<->OUTPUT},
           {traceLevel->INTEGER}] =: LIST(MIXED(FLOAT))
\end{verbatim}\normalsize

\bd 
Computes a branch of the logistic quantal response equilibrium
correspondence for a game. \verb+start+ is
used as the starting point for the computation of $\lambda_{0}$, and
the support over which \verb+start+ is defined is the support over
which the correspondence is computed.  The
behavior of the algorithm may be modified by specifying some of the
following optional parameters:
\bd
\item
[pxifile:] Generate output to this file for later retrieval and viewing by
the PXI program.  By default no output file is generated.
\item
[minLam:] Sets $\underline{\lambda}$, the minimum value of $\lambda$.  The 
default value is $\underline{\lambda}=0.01$.
\item
[maxLam:] Sets $\overline{\lambda}$, the maximum value of $\lambda$.  The
default value is $\overline{\lambda}=30.0$.
\item
[delLam:] Sets the constant $\delta$ used in incrementing $\lambda$.  The
default value is $\delta=0.01$.
\item
[powLam:] Sets the exponent $a$ used in incrementing $\lambda$.  The default
value is $a=1$, producing geometric incrementing.  Setting $a=0$ corresponds
to linear incrementing.
\item
[fullGraph:] If \verb+True+, the list of behavioral strategy profiles
returned contains the full sequence of profiles computed from each successive
value of $\lambda$.  The default value is \verb+False+, in which case only
the profile for the last value of $\lambda$ computed is returned.
\item
[maxitsN:] Sets the maximum number of iterations for the $n$-dimensional
optimization routine.  The default value is $200$.
\item
[tolN:] Sets the tolerance for the $n$-dimensional optimization routine.
The default is 1.0e-10.
\item
[maxits1:] Sets the maximum number of iterations for the 1-dimensional
optimization routine.  The default is $100$.
\item
[tol1:] Sets the tolerance for the 1-dimensional optimization routine.
The default is 2.0e-10.
\item
[time:] Returns the amount of time consumed by the
algorithm.
\item
[nEvals:] Returns the number of function evaluations
performed by the algorithm.
\item
[nIters:] Returns the number of iterations performed
by the algorithm.
\item
[traceFile:] A file containing a log of more detailed information on
the execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An interger specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to
no output at all.
\ed

\item
[Note:] The extensive form version disregards any marked
subgames.
\item [See also:] \verb+GobitGridSolve+.
\ed

\item
\protect \large \begin{verbatim}
GobitValue[profile->BEHAV(FLOAT)] =: FLOAT
GobitValue[profile->MIXED(FLOAT)] =: FLOAT
\end{verbatim}\normalsize

\bd
Returns the value of the Gobit objective function for mixed or behavior
profiles computed by \verb+GobitSolve+ or \verb+GobitGridSolve+.  The Gobit
value for profiles not created by these algorithms is null.
\item
[See also:] \verb+GobitGridSolve+, \verb+GobitLambda+, \verb+GobitSolve+.
\ed

\item
\protect \large \begin{verbatim}
Greater[x->T, y->T] =: BOOLEAN
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, INTEGER, RATIONAL}
\bd
Returns \verb+True+ when \verb+x+ is (strictly) greater than \verb+y+.
\item
[Short form:] \verb+x > y+
\item
[See also:] \verb+GreaterEqual+, \verb+Less+, \verb+LessEqual+.
\ed

\item
\protect \large \begin{verbatim}
Greater[x->TEXT, y->TEXT] =: BOOLEAN
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when the string \verb+x+ is lexicographically (strictly)
greater than the string \verb+y+, using the native character set of the 
achine.
\item
[Short form:] \verb+x > y+
\item
[See also:] \verb+GreaterEqual+, \verb+Less+, \verb+LessEqual+.
\ed

\item
\protect \large \begin{verbatim}
GreaterEqual[x->T, y->T] =: BOOLEAN
\end{verbatim}\normalsize

{\it for} {\tt T + FLOAT, INTEGER, RATIONAL}
\bd
Returns \verb+True+ when \verb+x+ is at least as large as \verb+y+.
\item
[Short form:] \verb+x >= y+
\item
[See also:] \verb+Greater+, \verb+Less+, \verb+LessEqual+.
\ed

\item
\protect \large \begin{verbatim}
GreaterEqual[x->TEXT, y->TEXT] =: BOOLEAN
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when the string \verb+x+ is lexicographically greater than
or equal to the string \verb+y+, using the native character set of the
machine.
\item
[Short form:] \verb+x >= y+
\item
[See also:] {\tt Greater}, {\tt Less}, {\tt LessEqual}.
\ed

%--H--


\item
\protect \large \begin{verbatim}
Help[x->TEXT] =: LIST(TEXT)
\end{verbatim}\normalsize

\bd 
Returns a list of all function names or function prototypes
matching \verb+x+.  If \verb+x+ is an exact match to a function name,
a list of corresponding function prototypes is returned.  \verb+x+ can
also contain the regular-expression style wildcards
\verb+*+ and \verb+?+.  In this
case, if there is not an exact match, a list of function names
matching \verb+x+ is returned.
\item
[See also:] \verb+HelpVars+, \verb+Manual+.
\ed

\item
\protect \large \begin{verbatim}
HelpVars[x->TEXT] =: LIST(TEXT)
\end{verbatim}\normalsize

\bd 
Returns a list of all variables matching \verb+x+.  \verb+x+ can
contain regular-expression style wildcards \verb+*+ and \verb+?+. 
In this case,
if there is not an exact match, a list of variables matching \verb+x+
is returned.
\item [See also:] \verb+Help+.
\ed

%--I--

\item 
\protect \large \begin{verbatim}
If[boolean-expression, statement-list]
If[boolean-expression, statement-list, statement-list]
\end{verbatim} \normalsize
  
\bd
Defines a block of statements to be executed under certain conditions.
See the section on control structures for complete information. 
\ed


\item
\protect \large \begin{verbatim}
Include[file->TEXT]
\end{verbatim}\normalsize

\bd
Includes the commands in the specified file as commands
in the running GCL program.  The program treats the command as if it
were replaced by the contents of the file.  \verb+Include+ may only be used
at the top level, that is, it cannot be used inside of \verb+NewFunction+
or flow control structures.
\ed

\item
\protect \large \begin{verbatim}
Index[list->NLIST(T*), x->T*] =: LIST(T)
\end{verbatim} \normalsize

{\it for all types} {\tt T}
\bd
Returns the list of indices in \verb+list+ where \verb+x+ appears.
\ed

\item
\protect \large \begin{verbatim}
Infoset[action->ACTION*] =: INFOSET
\end{verbatim} \normalsize

\bd
Returns the information set to which \verb+action+ belongs.  The null
action is assumed to belong to the null information set.
\item [See also:] \verb+Actions+.
\ed

\item
\protect \large \begin{verbatim}
Infoset[node->NODE*] =: INFOSET
\end{verbatim}\normalsize

\bd
Returns the information set to which \verb+node+
belongs.  All nonterminal nodes belong to an information set. 
Terminal nodes, and the null node, belong to the null information set.
\item [See also:] \verb+Members+.
\ed

\item
\protect \large \begin{verbatim}
InfosetProb[profile->BEHAV(T), infoset->INFOSET*] =: T
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the probability of reaching \verb+infoset+ when all players
follow \verb+profile+.  The probability of reaching the null information
set is defined to be null.  It is an error if \verb+profile+ and
\verb+infoset+ are not defined on the same extensive form game.
\item
[See also:] \verb+ActionValue+, \verb+Belief+, \verb+NodeValue+,
\verb+RealizProb+.
\ed

\item
\protect \large \begin{verbatim}
Infosets[player->EFPLAYER] =: LIST(INFOSET)
\end{verbatim}\normalsize

\bd
Returns the list of information sets at which 
\verb+player+ has the decision.
\item [See also:] \verb+Player+.
\ed

\item
\protect \large \begin{verbatim}
Input[file->TEXT] =: INPUT
\end{verbatim}\normalsize

\bd
Opens a new input stream for reading from the file \verb+text+.  An
error occurs if the file is not able to be opened.
\item
[See also:]  \verb+Output+, \verb+Read+.
\ed

\item
\protect \large \begin{verbatim}
Insert[list<->NLIST(T*), x->T*, {n->INTEGER}] =: LIST(T)
Insert[list<->NLIST(T*), x->NLIST(T*), {n->INTEGER}] =: LIST(T) 
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Inserts the element \verb+x+ into \verb+list+.  If \verb+n+ is
unspecified, \verb+x+ is appended to \verb+list+; otherwise, \verb+x+
is inserted as the \verb+n+th element.  It is an error if \verb+n+ is
nonpositive, or if \verb+n+ is greater than the length of \verb+list+.
\item [See also:] \verb+Remove+.
\ed

\item
\protect \large \begin{verbatim}
InsertAction[infoset->INFOSET, {at->ACTION}] =: ACTION
\end{verbatim}\normalsize

\bd
Inserts a new action into \verb+infoset+ before the action \verb+at+.  
If \verb+at+ is not specified, the new action is appended to \verb+infoset+'s
actions.
The corresponding new branch is created for
each node belonging to \verb+infoset+.  Returns the newly created action.
\item
[See also:] \verb+Actions+, \verb+DeleteAction+.
\ed

\item
\protect \large \begin{verbatim}
InsertNode[node->NODE, infoset->INFOSET] =: NODE
\end{verbatim}\normalsize

\bd
Inserts a new node in the tree at the location of \verb+node+.  The
new node is made a member of \verb+infoset+, and the
corresponding number of branches are created from the new node.  \verb+node+
becomes the first child of the new node.  Returns the new node.
\item [See also:] \verb+AppendNode+, \verb+NewInfoset+.
\ed

\item
\protect \large \begin{verbatim}
Integer[x->T] =: INTEGER
\end{verbatim} \normalsize

{\it for} {\tt T = FLOAT, INTEGER, RATIONAL}
\bd
Converts \verb+x+ into a value of type \verb+INTEGER+.
\item [See also:] \verb+Float+, \verb+Rational+.
\ed

\item 
\protect \large \begin{verbatim}
IntegerDivide[x->INTEGER, y->INTEGER] =: INTEGER
\end{verbatim} \normalsize

\bd
Returns the quotient $x / y$, rounded to the next integer
towards zero.  It is an error to attempt to divide by zero.
\item [Short form:] \verb%x DIV y%
\item [See also:] \verb+Divide+, \verb+Modulus+.
\ed


\item
\protect \large \begin{verbatim}
IsConstSum[efg->EFG(T)] =: BOOLEAN
IsConstSum[nfg->NFG(T)] =: BOOLEAN
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns \verb+True+ when the game \verb+efg+ or \verb+nfg+ is constant sum.
\ed

\item
\protect \large \begin{verbatim}
IsKnownNash[profile->MIXED(T)] =: BOOLEAN
IsKnownNash[profile->BEHAV(T)] =: BOOLEAN
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns \verb+True+ when \verb+profile+
is known by Gambit to be a Nash equilibrium of the
corresponding game.  If \verb+profile+ is complete (probabilities sum to
one for every player, and every information set), then there is a
definitive test for Nash equilibrium.  However if the profile is
incomplete (i. e., it does not specify actions at off the equilibrium
path information sets), then it is possible that a profile (or set
of all completions of the profile) may be Nash, but \verb+IsKnownNash+
returns \verb+False+, because it is not known by Gambit to be Nash.
If the answer is not known to Gambit, then \verb+IsKnownNotNash+ will also
return \verb+False+.
\item [See also:] \verb+IsKnownNotNash+, \verb+IsKnownStrictNash+.
\ed

\item
\protect \large \begin{verbatim}
IsKnownNotNash[profile->MIXED(T)] =: BOOLEAN
IsKnownNotNash[profile->BEHAV(T)] =: BOOLEAN
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd 
Returns \verb+True+ if the \verb+Profile+
is known by Gambit not to be a Nash equilibrium of the
corresponding game.  
\item
[See also:] \verb+IsKnownNash+.
\ed

\item
\protect \large \begin{verbatim}
IsKnownNotPerfect[profile->MIXED(T)] =: BOOLEAN
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns \verb+True+ if \verb+profile+
is known by Gambit not to be a perfect Nash equilibrium.
\item [See also:] \verb+IsKnownPerfect+.
\ed

\item
\protect \large \begin{verbatim}
IsKnownNotSequential[profile->BEHAV(T)] =: BOOLEAN
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns \verb+True+ if \verb+profile+
is known by Gambit not to be a sequential Nash
equilibrium.
\item [See also:] \verb+IsKnownSequential+.
\ed

\item
\protect \large \begin{verbatim}
IsKnownNotStrictNash[profile->BEHAV(T)] =: BOOLEAN
IsKnownNotStrictNash[profile->MIXED(T)] =: BOOLEAN
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns \verb+True+ if \verb+profile+ is known by Gambit not to be
a strict Nash equilibrium.
\item [See also:] \verb+IsKnownStrictNash+.
\ed

\item
\protect \large \begin{verbatim}
IsKnownNotSubgamePerfect[profile->BEHAV(T)] =: BOOLEAN
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns \verb+True+ if \verb+profile+
is known by Gambit not to be a subgame perfect Nash equilibrium.
\item [See also:] \verb+IsKnownSubgamePerfect+.
\ed

\item
\protect \large \begin{verbatim}
IsKnownPerfect[profile->MIXED(T)] =: BOOLEAN
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd 
Returns \verb+True+ if \verb+profile+
is known by Gambit to be a perfect Nash equilibrium, and \verb+False+
otherwise.  There is currently no definitive test in Gambit for
whether an arbitrary profile is perfect, so it is possible for a
perfect equilibrium to return \verb+False+.  However some of the
algorithms (notably \verb+LcpSolve+) will only return perfect
equilibria, which are marked as such.  
\item [See also:] \verb+IsKnownNotPerfect+.
\ed

\item
\protect \large \begin{verbatim}
IsKnownSequential[profile->BEHAV(T)] =: BOOLEAN
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd 
Returns \verb+True+ if \verb+profile+
is known by Gambit to be an approximation to a
sequential Nash equilibrium, and \verb+False+ otherwise.  There is
currently no definitive test in Gambit for whether an arbitrary
profile is sequential.  However any Nash equilibrium of an extensive
form game which is computed via the \verb+LiapSolve+ or
\verb+GobitSolve+ algorithms is sequential.
\item [See also:] \verb+IsKnownNotSequential+.
\ed

\item
\protect \large \begin{verbatim}
IsKnownStrictNash[profile->BEHAV(T)] =: BOOLEAN
IsKnownStrictNash[profile->MIXED(T)] =: BOOLEAN
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns \verb+True+ if \verb+profile+ is known by Gambit to be a strict
Nash equilibrium of the corresponding game.  If \verb+profile+ is
complete, there is a definitive test for strict Nash equilibrium.
However, if the profile is incomplete,then it is possible that a profile
(or the set of all completions of the profile) may be strict Nash, but
\verb+IsKnownStrictNash+ returns \verb+False+.  If the answer is not
known to Gambit, then \verb+IsKnownNotStrictNash+ also returns \verb+False+.
\item [See also:] \verb+IsKnownNash+, \verb+IsKnownNotStrictNash+.
\ed

\item
\protect \large \begin{verbatim}
IsKnownSubgamePerfect[profile->BEHAV](T) =: BOOLEAN
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns \verb+True+ if \verb+profile+
is known by Gambit to be a subgame perfect Nash
equilibrium.  There is currently no
definitive test in Gambit for whether an arbitrary profile is subgame
perfect.  However, any Nash equilibrium of an extensive form game which
is computed when all subgames are marked will only return a subgame
perfect equilibrium.  
\item [See also:] \verb+IsKnownNotSubgamePerfect+.
\ed

\item
\protect \large \begin{verbatim}
IsPerfectRecall[efg->EFG(T)] =: BOOLEAN
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd 
Returns \verb+True+ if \verb+efg+ is a game of perfect recall.
\ed


\item
\protect \large \begin{verbatim}
IsPredecessor[node->NODE, of->NODE] =: BOOLEAN
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when \verb+node+ is a predecessor
in the tree of the node \verb+of+.  A node is considered its own predecessor.
\item [See also:] \verb+IsSuccessor+.
\ed

\item
\protect \large \begin{verbatim}
IsRoot[node->NODE] =: BOOLEAN
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when \verb+node+ is the root node of its
extensive form.
\item [See also:] \verb+Parent+.
\ed

\item
\protect \large \begin{verbatim}
IsSuccessor[node->NODE, from->NODE] =: BOOLEAN
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when \verb+node+ is a successor
in the tree of the node \verb+from+.  A node is considered its own successor.
\item [See also:] \verb+IsPredecessor+.
\ed

\item
\protect \large \begin{verbatim}
IsWatchRunning[] =: BOOLEAN
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when the system stopwatch is currently running.
\item
[See also:] \verb+ElapsedTime+, \verb+StartWatch+, \verb+StopWatch+.
\ed


%--J--

%--K--

%--L--

\item
\protect \large \begin{verbatim}
LcpSolve[support->EFSUPPORT, {asNfg->BOOLEAN}, {stopAfter->INTEGER},
         {nPivots<->INTEGER}, {time<->FLOAT}, {traceFile<->OUTPUT},
         {traceLevel->INTEGER}] =: LIST(BEHAV(T))
LcpSolve[support->NFSUPPORT, {stopAfter->INTEGER},
         {nPivots<->INTEGER}, {time<->FLOAT}, {traceFile<->OUTPUT},
         {traceLevel->INTEGER}] =: LIST(MIXED(T))
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Solves the game as a linear complementarity problem, using the
Lemke-Howson algorithm for normal form games, and the
Koller-Megiddo-Stengel sequence form for extensive form games.  


The behavior of the algorithm may be modified by the following
optional parameters:
\bd
\item
[asNfg:] By default, extensive forms are solved by the sequence form.
By setting this parameter to \verb+True+, each marked subgame of the extensive
form is converted to its corresponding reduced normal form, solved
via Lemke-Howson, and the mixed strategy solutions converted back into
behavioral profiles.
\item
[stopAfter:] Specifies the maximum number of equilibria to find.  If
not specified, the default value is zero, which means that all
equilibria reachable by the algorithm are to be found.
\item
[nPivots:] Returns the total number of pivots. 
\item
[time:] Returns the elapsed time for the operation.
\item
[traceFile:] A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no
logging at all.
\ed
\item [See also:] \verb+LpSolve+.
\ed

\item
\protect \large \begin{verbatim}
Length[list->LIST(T*)] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of elements in \verb+list+.
\item
[See also:] {\tt NthElement}.
\ed

\item
\protect \large \begin{verbatim}
Less[x->T, y->T] =: BOOLEAN
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, INTEGER, RATIONAL}
\bd
Returns \verb+True+ when \verb+x+ is (strictly) less than \verb+y+.
\item [Short form:] \verb+x < y+
\item [See also:] \verb+Greater+, \verb+GreaterEqual+, \verb+LessEqual+.
\ed

\item
\protect \large \begin{verbatim}
Less[x->TEXT, y->TEXT] =: BOOLEAN
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when the string \verb+x+ is lexicographically (strictly)
less than
the string \verb+y+, using the native character set of the machine.
\item [Short form:] \verb+x < y+
\item [See also:] \verb+Greater+, \verb+GreaterEqual+, \verb+LessEqual+.
\ed

\item
\protect \large \begin{verbatim}
LessEqual[x->T, y->T] =: BOOLEAN
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, INTEGER, RATIONAL}
\bd
Returns \verb+True+ when \verb+x+ is no more than \verb+y+.
\item [Short form:] \verb+x <= y+
\item [See also:] \verb+Greater+, \verb+GreaterEqual+, \verb+Less+.
\ed

\item
\protect \large \begin{verbatim}
LessEqual[x->TEXT, y->TEXT] =: BOOLEAN
\end{verbatim}\normalsize

\bd
Returns \verb+True+ when the string \verb+x+ is lexicographically less than
or equal to the string \verb+y+, using the native character set of the machine.
\item [Short form:] \verb+x <= y+
\item [See also:] \verb+Greater+, \verb+GreaterEqual+, \verb+Less+.
\ed

\item
\protect \large \begin{verbatim}
LiapSolve[start->BEHAV(FLOAT), {asNfg->BOOLEAN},
          {stopAfter->INTEGER}, {nTries->INTEGER},
          {maxitsN->INTEGER}, {tolN->FLOAT},
          {maxits1->INTEGER}, {tol1->FLOAT},
          {time<->FLOAT}, {nEvals<->INTEGER},
          {traceFile<->OUTPUT,
          {traceLevel->INTEGER}] =: LIST(BEHAV(FLOAT))
LiapSolve[start->MIXED(FLOAT), 
          {stopAfter->INTEGER}, {nTries->INTEGER},
          {maxitsN->INTEGER}, {tolN->FLOAT},
          {maxits1->INTEGER}, {tol1->FLOAT},
          {time<->FLOAT}, {nEvals<->INTEGER},
          {traceFile<->OUTPUT, 
          {traceLevel->INTEGER}] =: LIST(MIXED(FLOAT))
\end{verbatim}\normalsize


\bd 
Searches for a Nash equilibrium by minimizing a Lyapunov function
which is zero exactly at Nash equilibria.  The algorithm starts from
the initial starting point determined by the parameter \verb+start+.
The algorithm is not guaranteed to find a Nash equilibrium from any
fixed starting point.  The algorithm thus incorporates the capability
of restarting.  If a Nash equilibrium is not found, it will keep
searching from new randomly chosen starting points until a Nash
equilibrium has been found or the maximum number of tries (parameter
\verb+nTries+) is exceeded, whichever comes first.  The list of
solutions found is returned.

The behavior of the algorithm may be modified by specifying the following
optional parameters:
\bd
\item
[asNfg:] By default, extensive forms are solved in the extensive form.
By setting this parameter to \verb+True+, each marked subgame of the
extensive form is converted to its corresponding reduced normal form game,
solved, and the overall behavioral profile reconstructed from these
solutions.
\item
[nTries:] Sets the maximum number of attempts at finding an
equilibrium. Default is 10.
\item
[stopAfter:] Sets the number of equilibria to find.  Default is 1.
\item
[maxits1:] Sets the maximum number of iterations in the
1-dimensional line search.  Default is 100.
\item
[maxitsN:] Sets the maximum number of iterations in the
n-dimensional optimization.  Default is 10.
\item
[tolN:] Sets the tolerance for the n-dimensional optimization
routine.  Default is 1.0e-10.
\item
[tol1:] Sets the tolerance for the 1-dimensional line search.
Default is 2.0e-10.
\item
[time:] Returns the elapsed time for the operation.
\item
[nEvals:] Returns the number of function evaluations for the operation.
\item
[traceFile:] A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no output
at all.
\ed
\ed

\item
\protect \large \begin{verbatim}
LiapValue[profile->MIXED(T)] =: T
LiapValue[profile->BEHAV(T)] =: T
\end{verbatim} \normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd 
Returns the Lyapunov function value for \verb+profile+.
This value is zero exactly when the
profile is a Nash equilibrium.
\ed

\item
\protect \large \begin{verbatim}
List[x->T, {length->INTEGER}] =: LIST(T)
List[x->LIST(T), {length->INTEGER}] =: LIST(LIST(T))
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Creates a new list of \verb+length+ elements, each equal to \verb+x+.
If \verb+length+ is unspecified, it defaults to 1.
\ed

\item
\protect \large \begin{verbatim}
List[x->T, {length->INTEGER}, {delta->T}] =: LIST(T)
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, INTEGER, RATIONAL}
\bd
Creates an initialized list of \verb+length+ elements, whose $i^{th}$
entry is \verb%x + (i * delta)%.  If \verb+length+ is unspecified,
it defaults to 1; if \verb+delta+ is unspecified, it defaults to 0.
\ed

\item
\protect \large \begin{verbatim}
LoadEfg[file->TEXT] =: EFG(T)
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Loads an extensive form game from an external savefile.
An error occurs if the file cannot be opened, or if the file does
not contain a valid extensive form savefile.
\item [See also:] \verb+SaveEfg+.
\ed

\item
\protect \large \begin{verbatim}
LoadNfg[file->TEXT] =: NFG(T)
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Loads a normal form game from an external savefile.
An error occurs if the file cannot be opened, or if the file does not 
contain a valid normal form savefile.
\item [See also:] \verb+SaveNfg+.
\ed

\item
\protect \large \begin{verbatim}
Log[x->FLOAT] =: FLOAT
\end{verbatim} \normalsize

\bd
Computes the natural logarithm of \verb+x+.  An error occurs if
\verb+x+ is nonpositive.
\item [See also:] \verb+Exp+, \verb+Power+.
\ed

\item
\protect \large \begin{verbatim}
LpSolve[support->EFSUPPORT, {asNfg->BOOLEAN},
        {nPivots<->INTEGER}, {time<->FLOAT},
        {traceFile<->OUTPUT},
        {traceLevel->INTEGER}] =: LIST(BEHAV(T))
LpSolve[support->NFSUPPORT, {nPivots<->INTEGER},
        {time<->FLOAT}, {traceFile<->OUTPUT},
        {traceLevel->INTEGER}] =: LIST(MIXED(T))
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Solves a two-person, constant-sum game for a Nash equilibrium as a linear
program.  For extensive form games, the Koller-Megiddo-Stengel
sequence form is used; games not of perfect recall return the empty
list of solutions.

The behavior of the algorithm may be modified by the following optional
parameters:
\bd
\item
[asNfg:] By default, extensive forms are solved by the sequence form.
By setting this parameter to \verb+True+, each marked subgame of the
extensive form is converted to its corresponding reduced normal form,
solved as a linear program, and the mixed strategy solutions converted back
into behavioral profiles.
\item
[nPivots:] Returns the total number of pivots.
\item
[time:] Returns the elapsed time for the operation.
\item
[traceFile:] A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to no
output at all.
\ed
\item [See also:] \verb+LcpSolve+.
\ed

%--M--

\item
\protect \large \begin{verbatim}
Manual[x->TEXT] =: TEXT
\end{verbatim} \normalsize

\bd
Returns the manual entry for the function \verb+x+.  If there is no
entry for \verb+x+, the empty string is returned. 
\item [See also:] \verb+Help+, \verb+HelpVars+.
\ed

\item
\protect \large \begin{verbatim}
MarkSubgame[node->NODE] =: BOOLEAN
\end{verbatim} \normalsize

\bd
Mark \verb+node+ as being the root of a subgame for use in later computation.
Only nodes which are roots of subgames may be marked.  Returns \verb+True+
if \verb+node+ was marked as a subgame (i.e., if it is the root of a subgame).
\item [See also:] \verb+MarkedSubgames+, \verb+Subgames+,
\verb+UnmarkSubgame+.
\ed


\item
\protect \large \begin{verbatim}
MarkedSubgames[efg->EFG(T)] =: LIST(NODE)
\end{verbatim} \normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the list of nodes currently marked as roots of subgames in
\verb+efg+.  The list is ordered such that all children of a node
that appear in the list appear before the node itself.
\item [See also:] \verb+MarkSubgame+, \verb+Subgames+, \verb+UnmarkSubgame+.
\ed

\item
\protect \large \begin{verbatim}
Members[infoset->INFOSET*] =: LIST(NODE)
\end{verbatim}\normalsize

\bd
Returns the list of nodes which are members of \verb+infoset+.  If
\verb+infoset+ is null, the empty list is returned.
\item [See also:] \verb+Infoset+.
\ed

\item
\protect \large \begin{verbatim}
MergeInfosets[infoset1->INFOSET,
              infoset2->INFOSET] =: INFOSET
\end{verbatim}\normalsize

\bd
Moves all the nodes from \verb+infoset2+ into \verb+infoset1+.
It is an error if the number of actions is not the same at the
two information sets, or if the information sets are not from the
same extensive form game.  \verb+infoset1+ is returned.
\ed

\item 
\protect \large \begin{verbatim}
Minus[x->T, y->T] =: T
\end{verbatim} \normalsize

{\it for} {\tt T = FLOAT, INTEGER, RATIONAL, MIXED, BEHAV}
\bd
Returns the difference $x - y$.
\item [Short form:] \verb+x - y+
\ed

\item
\protect \large \begin{verbatim}
Mixed[support->NFSUPPORT, value->LIST(LIST(T))] =: MIXED(T)
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns a mixed strategy profile over \verb+support+ with the values
specified by \verb+value+.  It is an error if the dimensions of
\verb+value+ do not match those of \verb+support+.
\item [See also:] \verb+Behav+, \verb+Centroid+.
\ed

\item
\protect \large \begin{verbatim}
Mixed[profile->BEHAV(T)] =: MIXED(T)
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Converts \verb+profile+ to the equivalent mixed strategy profile on the
associated normal form game.  It is an error if there is no associated
normal form game.
\item [See also:] \verb+Behav+.
\ed

\item
\protect \large \begin{verbatim}
Modulus[x->INTEGER, y->INTEGER] =: INTEGER
\end{verbatim}\normalsize

\bd
Computes the remainder from dividing \verb+y+ into \verb+x+.  It is an
error if \verb+y+ is zero.
\item [Short form:] \verb+x MOD y+
\item [See also:] \verb+IntegerDivide+.
\ed


\item
\protect \large \begin{verbatim}
MoveTree[from->NODE, to->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Moves the subtree rooted at \verb+from+ to
the terminal node \verb+to+.  \verb+from+ becomes a terminal node.
Returns \verb+to+.  It is an error if \verb+to+ is not a terminal
node, or if \verb+from+ and \verb+to+ are not from the same extensive
form game.
\item [See also:] \verb+CopyTree+.
\ed

%--N--

\item
\protect \large \begin{verbatim}
Name[x->T] =: TEXT
\end{verbatim}\normalsize

{\it for} {T = ACTION*, EFG, EFPLAYER*, INFOSET*, NFG, NFPLAYER*,
NODE*, OUTCOME*, STRATEGY*} 
\bd
Returns the name of \verb+x+.  The name of a null object is defined
to be the empty string.
\item
[See also:] \verb+SetName+.
\ed

\item 
\protect \large \begin{verbatim}
Negate[x->T] =: T
\end{verbatim} \normalsize

{\it for} {\tt T = FLOAT, INTEGER, RATIONAL}
\bd
Returns $-x$.
\item
[Short form:] \verb+-x+
\ed

\item
\protect \large \begin{verbatim} 
NewEfg[{rational->BOOLEAN}, {players->LIST(TEXT)}, {name->TEXT}] =: EFG(T)
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Creates a new extensive form game.  By default, the
outcomes and probabilities associated with the game will be stored as
{\tt FLOAT}.  If the \verb+rational+ parameter is specified and is \verb+True+,
these values will be stored as {\tt RATIONAL}.  The default extensive form
game has no players (other than the chance player) defined on it; the
optional parameter \verb+players+ specifies a list of players to be
created and the names to be assigned to them.  The parameter \verb+name+
specifies the name of the game; by default, the game is named
with the empty string.  Returns the newly created game.
\ed

\item   
\protect \large \begin{verbatim}
NewFunction[name[argument-list], body]
\end{verbatim}\normalsize

\bd
Creates a new function.  The function may be called exactly
as if it were a predefined function of the command language.  See the
section on user-defined functions for more detailed information.
\item [See also:] \verb+DeleteFunction+.
\ed

\item
\protect \large \begin{verbatim} 
NewInfoset[player->EFPLAYER, actions->INTEGER,
            {name->TEXT}] =: INFOSET
\end{verbatim}\normalsize

\bd
Creates a new information set belonging to \verb+player+, with
\verb+actions+ actions.  The optional
parameter \verb+name+ allows a name to be specified for the information
set; by default it is labeled by the empty string.  It is an error if
\verb+actions+ is not positive.  The newly created
information set is returned.
\item [See also:] \verb+DeleteEmptyInfoset+.
\ed

\item
\protect \large \begin{verbatim}
NewNfg[dim->LIST(INTEGER), {rational->BOOLEAN}, {name->TEXT}] =: NFG(T)
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Creates a new normal form game with dimensionality \verb+dim+.
By default, the payoffs and probabilities associated with the game will
be stored as {\tt FLOAT}.  If the \verb+rational+ parameter is specified
and is \verb+True+, these values will be stored as {\tt RATIONAL}.
No initialization of the payoffs of the game is done.
The parameter \verb+name+ specifies the name of the game; by default,
the game is named with the empty string.
Returns the newly created game.
\ed

\item
\protect \large \begin{verbatim} 
NewOutcome[efg->EFG(T), {name->TEXT}] =: OUTCOME
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Defines a new outcome in the extensive form game \verb+efg+.
The new outcome specifies payoffs of zero for all players.
By default the outcome is named with the empty string; the optional parameter
\verb+name+, if specified, gives the name of the new outcome.  Returns the
newly created outcome.
\item [See also:] \verb+AttachOutcome+, \verb+DeleteOutcome+,
\verb+DetachOutcome+.
\ed

\item
\protect \large \begin{verbatim}
NewPlayer[efg->EFG(T), {name->TEXT}] =: EFPLAYER 
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Defines a new player in the extensive form game \verb+efg+.
By default the player is named with the empty string; the optional parameter
\verb+name+, if specified, gives the name of the new player.  Returns the
newly created player.
\ed

\item
\protect \large \begin{verbatim}
NextSibling[node->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Returns the next sibling of \verb+node+.  If \verb+node+ has no next
sibling, the null node is returned.
\item [See also:] \verb+PriorSibling+.
\ed

\item
\protect \large \begin{verbatim}
Nfg[efg->EFG(T), {time<->FLOAT}] =: NFG(T)
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Creates and returns the (structural) reduced normal form game equivalent
to the extensive form game \verb+efg+.  The optional parameter \verb+time+,
if specified, contains upon completion the amount of time consumed by
the transformation.
\ed

\item
\protect \large \begin{verbatim}
NodeValue[profile->BEHAV(T), player->EFPLAYER, node->NODE] =: T
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the expected payoff to \verb+player+ at \verb+node+, given
that all players are following \verb+profile+.
\item [See also:] \verb+ActionValue+, \verb+Belief+, \verb+InfosetProb+,
\verb+RealizProb+.
\ed

\item
\protect \large \begin{verbatim}
Not[x->BOOLEAN] =: BOOLEAN
\end{verbatim}\normalsize

\bd
Returns the boolean inverse of \verb+x+.
\item [Short forms:] \verb+NOT x+, \verb+!x+.
\ed

\item
\protect \large \begin{verbatim}
NotEqual[x->T, y->T] =: BOOLEAN
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns \verb+True+ when the values of \verb+x+ and \verb+y+ are
not equal.
\item [Short form:] \verb+x != y+.
\item [See also:] \verb+Equal+.
\ed

\item
\protect \large \begin{verbatim}
NthChar[text->TEXT, n->INTEGER] =: TEXT
\end{verbatim}\normalsize

\bd
Returns a text string of length 1 containing the \verb+n+th
character from \verb+text+.  By convention, the first character
in a string is indexed by 1.  It is an error if \verb+n+ is nonpositive,
or if \verb+n+ is greater than the length of \verb+text+.
\item [Short forms:] \verb+text[[n]]+, \verb+text#n+.
\item [See also:] \verb+NumChars+.
\ed

\item
\protect \large \begin{verbatim} 
NthChild[node->NODE, n->INTEGER] =: NODE
\end{verbatim}\normalsize

\bd
Returns the \verb+n+th child of \verb+node+.
By convention, the first child of a node is indexed by 1.
It is an error if \verb+n+ is nonpositive, or if \verb+n+ is greater
than the number of children of \verb+node+.
\item [Short form:] \verb+node#n+.
\item [See also:] \verb+Children+.
\ed

\item
\protect \large \begin{verbatim}
NthElement[list->NLIST(T), n->INTEGER] =: T 
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns the \verb+n+th element of \verb+list+.
By convention, the first element of a list is indexed by 1.
It is an error if \verb+n+ is nonpositive, or if \verb+n+ is greater
than the number of elements in \verb+list+.
\item [Short form:] \verb+list[[n]]+, \verb+list_n+.
\item [See also:] \verb+Length+.
\ed

\item
\protect \large \begin{verbatim}
NumChars[text->TEXT] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of characters in \verb+text+.
\item [See also:] \verb+NthChar+.
\ed

%--O--

\item 
\protect \large \begin{verbatim}
Or[x->BOOLEAN, y->BOOLEAN] =: BOOLEAN
\end{verbatim} \normalsize
  
\bd
Returns the disjunction of \verb+x+ and \verb+y+.
\item
[Short form:] \verb+x || y+, \verb+x OR y+.
\ed

\item
\protect \large \begin{verbatim}
Outcome[node->NODE*] =: OUTCOME
\end{verbatim}\normalsize

\bd
Returns the outcome attached to \verb+node+.  If no outcome is attached
to \verb+node+, or if \verb+node+ is null, the null outcome is returned.
\item [See also:] \verb+AttachOutcome+, \verb+DetachOutcome+.
\ed

\item
\protect \large \begin{verbatim}
Outcomes[efg->EFG(T)] =: LIST(OUTCOME)
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the list of outcomes defined on \verb+efg+.
\item [See also:] \verb+DeleteOutcome+, \verb+NewOutcome+.
\ed

\item
\protect \large \begin{verbatim}
Output[file->TEXT, {append->BOOLEAN}] =: OUTPUT
\end{verbatim}\normalsize

\bd
Opens a new output stream for writing to \verb+file+.  By default,
an existing file is overwritten; specifying \verb+append+ to be \verb+True+
opens the file in append mode.  An error occurs if \verb+file+ is not
able to be opened.
\item [See also:] \verb+Input+, \verb+SetListFormat+, \verb+SetNumericFormat+,
\verb+SetTextFormat+, \verb+Write+.
\ed

%--P--

\item
\protect \large \begin{verbatim}
Parent[node->NODE*] =: NODE
\end{verbatim}\normalsize

\bd
Returns the parent of \verb+node+.  If \verb+node+ is the root node,
or if \verb+node+ is null, the null node is returned.
\item [See also:] \verb+Children+, \verb+IsRoot+.
\ed

\item
\protect \large \begin{verbatim}
Parentheses[x->T] =: T
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns the value passed in \verb+x+.  This is used to control
the order of evaluation of expressions.
\item [Short form:] \verb+(x)+
\ed

\item
\protect \large \begin{verbatim}
Payoff[outcome->OUTCOME, player->EFPLAYER] =: T
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the payoff to \verb+player+ at \verb+outcome+.
\item [See also:] \verb+SetPayoff+.
\ed

\item
\protect \large \begin{verbatim}
Payoff[profile->LIST(STRATEGY), player->NFPLAYER] =: T
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the payoff to \verb+player+ in the contingency specified by
\verb+profile+.  It is an error if \verb+player+ and the elements of
\verb+profile+ are not from the same normal form game.
\item [See also:] \verb+SetPayoff+.
\ed

\item
\protect \large \begin{verbatim}
Payoff[profile->LIST(LIST(ACTION)), player->EFPLAYER] =: T
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the payoff to \verb+player+ in an extensive form game in the
contingency specified by \verb+profile+.  It is an error if
\verb+player+ and the elements of \verb+profile+ are not from the
same extensive form game.
\ed

\item
\protect \large \begin{verbatim}
Payoff[profile->BEHAV(T), player->EFPLAYER] =: T
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the payoff to \verb+player+ in an extensive form game if all
players follow \verb+profile+.  It is an error if \verb+profile+
and \verb+player+ are not from the same extensive form game.
\ed

\item
\protect \large \begin{verbatim}
Payoff[profile->MIXED(T), player->NFPLAYER] =: T
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the payoff to \verb+player+ in a normal form game if all players
follow \verb+profile+.  It is an error if \verb+profile+ and \verb+player+
are not from the same normal form game.
\ed

\item
\protect \large \begin{verbatim}
Player[infoset->INFOSET*] =: EFPLAYER
\end{verbatim}\normalsize

\bd
Returns the player who makes the decision at \verb+infoset+.
If \verb+infoset+ is null, the null player is returned.
\item [See also:] \verb+Infosets+.
\ed

\item
\protect \large \begin{verbatim}
Players[efg->EFG(T)] =: LIST(EFPLAYER)
\end{verbatim} \normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the list of players defined on \verb+efg+.
\ed

\item
\protect \large \begin{verbatim}
Players[nfg->NFG(T)] =: LIST(NFPLAYER)
\end{verbatim} \normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the list of players defined on \verb+nfg+.
\ed

\item 
\protect \large \begin{verbatim}
Plus[x->T, y->T] =: T
\end{verbatim} \normalsize

{\it for} {\tt T = FLOAT, INTEGER, RATIONAL, MIXED, BEHAV}
\bd
Returns the sum of \verb+x+ and \verb+y+.
\item [Short form:] \verb%x + y%
\ed

\item
\protect \large \begin{verbatim}
Plus[x->TEXT, y->TEXT] =: TEXT
\end{verbatim} \normalsize

\bd
Returns the concatenation of \verb+x+ and \verb+y+.
\item [Short form:] \verb%x + y%
\ed

\item
\protect \large \begin{verbatim}
Power[x->T, y->T] =: T
\end{verbatim} \normalsize

{\it for} {\tt T = FLOAT, INTEGER}
\bd
Computes the value $x^{y}$.
\item [Short form:] \verb%x ^ y%.
\item [See also:] \verb+Exp+, \verb+Log+.
\ed

\item
\protect \large \begin{verbatim}
PriorAction[node->NODE] =: ACTION
\end{verbatim} \normalsize

\bd
Returns the action corresponding to the branch leading to \verb+node+.
If \verb+node+ is the root node, its prior action is the null action.
\ed

\item
\protect \large \begin{verbatim}
PriorSibling[node->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Returns the prior sibling of \verb+node+.  If \verb+node+ has
no prior sibling, the null node is returned.
\item [See also:] \verb+NextSibling+.
\ed


%--Q--


\item
\protect \large \begin{verbatim}
Quit
\end{verbatim}\normalsize

\bd
Exits the command language.
\ed

%--R--

\item
\protect \large \begin{verbatim}
Randomize[efg<->EFG, {seed->INTEGER}] =: EFG
\end{verbatim}\normalsize

\bd
Assigns a payoff for each outcome for each player in the
extensive form \verb+efg+ randomly chosen from the uniform distribution
between 0 and 1.  The optional parameter \verb+seed+ may be used to
set the seed of the pseudo-random number generator.  The identical game
randomized with the same seed on the same machine will always produce
the same results.
\ed

\item
\protect \large \begin{verbatim}
Randomize[nfg<->NFG, {seed->INTEGER}] =: NFG
\end{verbatim}\normalsize

\bd
Assigns a payoff for each contingency for each player in
the normal form \verb+nfg+ randomly chosen from the uniform distribution
between 0 and 1.  The optional parameter \verb+seed+ may be used to
set hte seed of the pseudo-random number generator.  The identical game
randomized with the same seed on the same machine will always produce
the same results.
\ed

\item
\protect \large \begin{verbatim}
Rational[x->T] =: RATIONAL
\end{verbatim} \normalsize

{\it for} {\tt T = FLOAT, INTEGER, RATIONAL}
\bd
Converts the value \verb+x+ to the equivalent value of
type {\tt RATIONAL}.
\item [See also:] \verb+Float+, \verb+Integer+.
\ed

\item
\protect \large \begin{verbatim}
Rational[nfg->NFG(FLOAT)] =: NFG(RATIONAL)
Rational[efg->EFG(FLOAT)] =: EFG(RATIONAL)
\end{verbatim} \normalsize

\bd
Returns a copy of the game \verb+nfg+ or \verb+efg+ of data type 
{\tt RATIONAL}. 
\item [See also:] \verb+Float+.
\ed

\item
\protect \large \begin{verbatim}
Read[input<->INPUT, x<->T] =: INPUT 
\end{verbatim}\normalsize

{\it for} {\tt T = BEHAV, BOOLEAN, FLOAT, INTEGER, MIXED, RATIONAL,
TEXT, LIST}
\bd
Reads data of type \verb+T+ from the input stream and assigns it to
\verb+x+.  If \verb+x+ is undefined, then its data type is determined
from the exposed data in the input stream.  If \verb+x+ is previously
defined, then the \verb+Read+ function will expect to find the
corresponding data type in the input stream, and a file read error
will be generated if the exposed data is of the wrong data type.  If
\verb+x+ is previously defined to be a \verb+LIST+, then \verb+Read[in,x]+
will successively read elements into each element of the list.  If the
wrong data type is found for any element of the list, a file read
error will be returned.

The ``exposed data'' in the input stream consists of the following: If
first character is a double quote (\verb+"+), then the exposed data
consists of all characters up until the next double quote.  If the
first character is a \verb+{+, then the exposed data consists of all
the characters up until the next matching \verb+}+.  Otherwise, the
exposed data consists of all characters until the next whitespace.
\item [Short form:] \verb+input >> x+
\item [See also:] \verb+Input+, \verb+Write+.
\ed

\item
\protect \large \begin{verbatim}
RealizProb[profile->BEHAV(T), node->NODE] =: T
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the realization probability for \verb+node+ given that all players
are following \verb+profile+.  It is an error if \verb+profile+ and
\verb+node+ are not from the same extensive form game.
\item [See also:] \verb+ActionValue+, \verb+Belief+, \verb+InfosetProb+,
\verb+NodeValue+.
\ed

\item
\protect \large \begin{verbatim}
Regret[profile->BEHAV(T), action->ACTION] =: T
\end{verbatim} \normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the gain to a player for deviating to \verb+action+, assuming
all players are following \verb+profile+.  The strategy profile is
a Nash equilibrium if and only if the regrets of all actions are zero.
\ed

\item
\protect \large \begin{verbatim}
Regret[profile->MIXED(T), strategy->STRATEGY] =: T
\end{verbatim} \normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the gain to a player for deviating to \verb+strategy+, assuming
all players are following \verb+profile+.  The strategy profile is
a Nash equilibrium if and only if the regrets of all strategies are
identically zero.
\ed

\item
\protect \large \begin{verbatim}
Remove[list<->NLIST(T), n->INTEGER] =: LIST(T)
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Rmoves the \verb+n+th element from \verb+list+.  A copy of the list
with the element removed is returned.  It is an error if \verb+n+
is nonpositive, or if \verb+n+ is greater than the length of \verb+list+.
\item [See also:] \verb+Insert+.
\ed

\item
\protect \large \begin{verbatim}
RemoveAction[support<->EFSUPPORT, action->ACTION] =: EFSUPPORT
\end{verbatim}\normalsize

\bd
Removes \verb+action+ from \verb+support+.  If \verb+action+ is
not in \verb+support+, there is no effect.  A copy of the modified
support is returned.  It is an error if \verb+support+ and \verb+action+
are not from the same extensive form game, or if removing \verb+action+
would result in the support containing no actions at an information set.
\item [See also:] \verb+AddAction+, \verb+Support+.
\ed

\item
\protect \large \begin{verbatim}
RemoveStrategy[support<->NFSUPPORT, strategy->STRATEGY] =: NFSUPPORT
\end{verbatim}\normalsize

\bd
Removes \verb+strategy+ from \verb+support+.  If \verb+strategy+ is not in
the support, there is no effect.  A copy of the modified support is
returned.  It is an error if \verb+support+ and \verb+strategy+ are
not from the same normal form game, or if removing \verb+strategy+
would result in the support containing no strategies for a player.
\item [See also:] \verb+AddStrategy+, \verb+Support+.
\ed

\item
\protect \large \begin{verbatim}
Reveal[infoset->INFOSET, who->LIST(EFPLAYER)] =: INFOSET
\end{verbatim}\normalsize

\bd
Reveals the list of actions at the given information
set to the indicated players, refining their information partitions at
all information sets in the extensive form game accordingly.  The list
of actions is considered as a set Thus, it is indicated to the
specified players whether the set of actions in \verb+what+ or its
complement has occurred.  If \verb+what+ is not specified, then all of
the actions in the information set are individually revealed to
the players specified.  
\ed

\item
\protect \large \begin{verbatim}
RootNode[efg->EFG(T)] =: NODE
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the root node of \verb+efg+.
\item [See also:] \verb+IsRoot+.
\ed

%--S--

\item
\protect \large \begin{verbatim}
SaveEfg[efg->EFG(T), file->TEXT] =: EFG(T)
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Writes \verb+efg+ to an external savefile \verb+file+.  It is an error
if \verb+file+ cannot be opened for writing.  Returns \verb+efg+.
\item [See also:] \verb+LoadEfg+.
\ed

\item
\protect \large \begin{verbatim}
SaveNfg[nfg->NFG(T), file->TEXT] =: NFG(T)
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Writes \verb+nfg+ to an external savefile \verb+file+.  It is an
error if \verb+file+ cannot be opened for writing.  Returns \verb+nfg+.
\item [See also:] \verb+LoadNfg+.
\ed

\item
\protect \large \begin{verbatim} 
SetActionProbs[profile<->BEHAV(T), infoset->INFOSET,
               value->LIST(T)] =: BEHAV(T) 
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Sets the components of \verb+profile+ for
information set \verb+infoset+ to be equal to \verb+values+.
Returns \verb+profile+.  It is an error if \verb+profile+ and \verb+infoset+
are not from the same extensive form game, or if the length of
\verb+value+ is not the same as the number of actions in \verb+profile+'s
support at \verb+infoset+.
\item [See also:] \verb+ActionProb+.
\ed

\item
\protect \large \begin{verbatim} 
SetChanceProbs[infoset->INFOSET, 
               probs->LIST(T)] =: INFOSET
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Sets the action probabilities for 
\verb+infoset+ to the values given in \verb+probs+.  Returns \verb+infoset+. 
An error occurs if \verb+infoset+ does not belong to the chance player.
\item [See also:] \verb+ChanceProb+.
\ed

\item
\protect \large \begin{verbatim}
SetListFormat[{braces->BOOLEAN}, {commas->BOOLEAN},
              {LF->INTEGER}, {indent->INTEGER}] =: BOOLEAN
\end{verbatim} \normalsize

\bd
Sets the formatting style for output of lists on output streams.
\bd
\item [braces:] If \verb+True+, lists are delimited by braces.
\item [commas:] If \verb+True+, elements are delimited by commas.
\item [LF:] Number of levels of list that are displayed with a line feed.
\item [indent:] Number of spaces to indent each level of a list.
\ed
\item [See also:] \verb+SetNumericFormat+, \verb+SetTextFormat+,
\verb+Write+.
\ed

\item
\protect \large \begin{verbatim}
SetName[x->T, name->TEXT] =: T
\end{verbatim}\normalsize

{\it for} {\tt T = ACTION, EFG, EFPLAYER, INFOSET, NFG, NFPLAYER,
NODE, OUTCOME, STRATEGY}
\bd
Sets the name of \verb+x+ to \verb+name+.  Returns \verb+x+.
\item [See also:] \verb+Name+.
\ed

\item
\protect \large \begin{verbatim}
SetNumericFormat[{width->INTEGER}, {precis->INTEGER},
                 {expmode->BOOLEAN}] =: BOOLEAN
\end{verbatim}\normalsize

\bd
Sets the formatting style for output of numeric types on output streams.
\bd
\item [width:] The width for a numeric field.  If the width of the
data is greater than \verb+width+, the width is overridden.  (The
default is 0.)
\item [precis:] The number of decimal places shown for floating point
numbers.
\item [expmode:] If \verb+True+, floating point numbers are printed in
exponential format.
\ed
\item [See also:] \verb+SetListFormat+, \verb+SetTextFormat+, \verb+Write+.
\ed

\item
\protect \large \begin{verbatim}
SetPayoff[outcome->OUTCOME, player->EFPLAYER, payoff->T] =: OUTCOME
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Sets the payoff of \verb+outcome+ for \verb+player+ to \verb+payoff+.
It is an error if \verb+outcome+ and \verb+player+ are not from the
same extensive form game.  Returns \verb+outcome+.
\item [See also:] \verb+Payoff+.
\ed

\item
\protect \large \begin{verbatim}
SetPayoff[profile->LIST(STRATEGY), player->NFPLAYER,
          payoff->LIST(T)] =: LIST(STRATEGY)
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Sets the payoff to \verb+player+ in the contingency specified by
\verb+profile+.  It is an error if \verb+player+ and the elements
of \verb+profile+ are not from the same normal form game.
Returns \verb+profile+.
\item [See also:] \verb+Payoff+.
\ed

\item 
\protect \large \begin{verbatim}
SetStrategyProbs[profile<->MIXED(T), player->NFPLAYER,
                 value->LIST(T)] =: MIXED(T)
\end{verbatim} \normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Sets the components of \verb+profile+ for \verb+player+ to be equal
to \verb+value+.  It is an error if \verb+profile+ and \verb+player+
are not from the same normal form game, or if the length of \verb+value+
is not the same as the number of strategies for \verb+player+ in the
support of \verb+profile+.  Returns \verb+profile+.
\item [See also:] \verb+StrategyProb+.
\ed

\item
\protect \large \begin{verbatim}
SetTextFormat[{quotes->BOOLEAN}] =: BOOLEAN
\end{verbatim} \normalsize

\bd
Sets the formatting style for output of strings on output streams.
\bd
\item [quotes:] If \verb+True+, strings are surrounded by quotes.
\ed
\item [See also:] \verb+SetListFormat+, \verb+SetNumericFormat+,
\verb+Write+.
\ed

\item
\protect \large \begin{verbatim}
SimpDivSolve[support->EFSUPPORT, {asNfg->BOOLEAN}, 
             {stopAfter->INTEGER}, {nRestarts->INTEGER}, 
             {leashLength->INTEGER}, {nEvals<->INTEGER}, 
             {time<->FLOAT}, {traceFile<->OUTPUT},
             {traceLevel->INTEGER}] =: LIST(BEHAV(T))
SimpDivSolve[support->NFSUPPORT, 
             {stopAfter->INTEGER}, {nRestarts->INTEGER}, 
             {leashLength->INTEGER}, {nEvals<->INTEGER}, 
             {time<->FLOAT}, {traceFile<->OUTPUT},
             {traceLevel->INTEGER}] =: LIST(MIXED(T))
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Computes a Nash equilibrium for a game using a simplicial subdivision
algorithm.  The list of solutions found is returned.

The behavior of the algorithm may be modified by several optional
parameters:

\bd
\item
[asNfg:] By default, this is \verb+False+.  If it is specified to be
\verb+True+, the extensive form game is solved by recursively converting
its marked subgames into normal form, solving, and reconstructing the
solution as a behavioral profile.  {\it Note that currently simplicial
subdivision is only supported on the normal form, so this parameter
must always be specified and {\tt True}.}
\item
[stopAfter:] Maximum number of equilibria to find. Default is 1.  
\item 
[nRestarts:] Number of restarts.  At each restart the mesh of the
triangulation is halved.  So this parameter determines the final mesh
by the formula $\frac{1}{2}^{ndivs}$.
\item
[leashLength:] Sets the leash length. Default is 0, which results in no
constraint, or no leash.  Note that if this parameter is set to a value
different from 0, the algorithm is no longer guaranteed to converge.
\item
[time:] Returns the elapsed time for the algorithm.
\item
[traceFile:] A file containing a log of more detailed information on the
execution of the algorithm.  By default, no logging is done.
\item
[traceLevel:] An integer specifying the level of detail in logging.
Higher integers correspond to more detail; zero corresponds to
no output at all.
\ed
\ed

\item
\protect \large \begin{verbatim}
Sort[list->LIST(T)] =: LIST(T)
\end{verbatim} \normalsize

{\it for} {\tt T = FLOAT, INTEGER, RATIONAL, TEXT}
\bd
Returns a list consisting of the elements of \verb+list+ sorted in
increasing order.
\ed

\item
\protect \large \begin{verbatim}
Sort[list->LIST(T), by->LIST(X)] =: LIST(T)
\end{verbatim} \normalsize

{\it for all types} {\tt T}, {\it for} {\tt X = FLOAT, INTEGER, RATIONAL,
TEXT}
\bd
Returns a list consisting of the elements of \verb+list+, sorted
according to the ordering of the elements of \verb+by+.  It is an
error if \verb+list+ and \verb+by+ do not have the same dimensionality.
\ed

\item
\protect \large \begin{verbatim}
StartWatch[] =: FLOAT
\end{verbatim}\normalsize

\bd
Starts the system stopwatch.  This function has no
effect if the stopwatch is already running.
Returns the amount of time since the stopwatch was started.
\item [See also:] \verb+ElapsedTime+, \verb+IsWatchRunning+, \verb+StopWatch+.
\ed

\item
\protect \large \begin{verbatim}
StopWatch[] =: FLOAT
\end{verbatim}\normalsize

\bd
Stops the system stopwatch.  If the stopwatch was not
running, this function has no effect.  Returns the amount of time
on the stopwatch.
\item [See also:] \verb+ElapsedTime+, \verb+IsWatchRunning+,
\verb+StartWatch+.
\ed

\item
\protect \large \begin{verbatim}
Strategies[player->NFPLAYER, 
           support->NFSUPPORT] =: LIST(STRATEGY)
\end{verbatim}\normalsize

\bd
Returns the list of strategies from which  \verb+player+ may choose
in \verb+support+.
\ed

\item
\protect \large \begin{verbatim}
StrategyProb[profile->MIXED(T), strategy->STRATEGY] =: T
\end{verbatim} \normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the probability that \verb+strategy+ is chosen when all
players are following \verb+profile+.  It is an error if \verb+profile+
and \verb+strategy+ are not from the same normal form game.
\item [See also:] \verb+SetStrategyProbs+.
\ed

\item
\protect \large \begin{verbatim}
Subgames[efg->EFG(T)] =: LIST(NODE)
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the list of nodes which are roots of subgames in \verb+efg+.
The ordering of the list is such that
all children of a node are listed before the node.
\item [See also:] \verb+MarkSubgame+, \verb+MarkedSubgames+, 
\verb+UnmarkSubgame+.
\ed

\item
\protect \large \begin{verbatim}
Support[efg->EFG(T)] =: EFSUPPORT
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the support of \verb+efg+.  The support contains all actions at every
information set for all players.
\item [See also:] \verb+AddAction+, \verb+RemoveAction+.
\ed

\item
\protect \large \begin{verbatim}
Support[nfg->NFG(T)] =: NFSUPPORT
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the support of \verb+nfg+.  The support contains all strategies
for all players.
\item [See also:] \verb+AddStrategy+, \verb+RemoveStrategy+.
\ed

\item
\protect \large \begin{verbatim}
Support[profile->MIXED(T)] =: NFSUPPORT
Support[profile->BEHAV(T)] =: EFSUPPORT
\end{verbatim}\normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Returns the support on which \verb+profile+ is defined.
\item [See also:] \verb+Behav+, \verb+Mixed+.
\ed

%--T--

\item
\protect \large \begin{verbatim}
Text[x->T] =: TEXT
\end{verbatim} \normalsize

{\it for} {\tt T = FLOAT, INTEGER, RATIONAL, TEXT}
\bd
Converts \verb+x+ into a text string.
\ed

\item 
\protect \large \begin{verbatim}
Times[x->T, y->T] =: T
\end{verbatim} \normalsize

{\it for} {\tt T = FLOAT, INTEGER, RATIONAL}
\bd
Computes the product of \verb+x+ and \verb+y+.
\item [Short form:] \verb+x * y+.
\ed

\item
\protect \large \begin{verbatim}
Times[x->T, y->BEHAV(T)] =: T
Times[x->T, y->MIXED(T)] =: T
\end{verbatim} \normalsize

{\it for} {\tt T = FLOAT, RATIONAL}
\bd
Computes the product of \verb+x+ and \verb+y+.
\item [Short form:] \verb+x * y+.
\ed

\item
\protect \large \begin{verbatim} 
Transpose[list->LIST(LIST(T))] := LIST(LIST(T))
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Returns the transpose of a rectangular matrix.  It is an error if \verb+list+
is not rectangular.
\ed


%--U--

\item
\protect \large \begin{verbatim}
UnAssign[x<->T] =: T
\end{verbatim}\normalsize

{\it for all types} {\tt T}
\bd
Undefines the variable \verb+x+.  Returns the
last value of the variable.
\item [See also:] \verb+Assign+, \verb+Clear+.
\ed

\item
\protect \large \begin{verbatim}
UnmarkSubgame[node->NODE] =: BOOLEAN
\end{verbatim}\normalsize

\bd
Unmark \verb+node+ as being the root of a subgame for use in later
computation.  If \verb+node+ is not marked as a subgame root, or if
\verb+node+ is the root node, this function has no effect.  Returns
\verb+True+ is \verb+node+ is a subgame root.
\item [See also:] \verb+MarkSubgame+, \verb+MarkedSubgames+,
\verb+Subgames+.
\ed

%--V--

\item
\protect \large \begin{verbatim}
Version[] =: FLOAT
\end{verbatim} \normalsize

\bd
Returns the version number of the command language.
\ed

%--W--

\item 
\protect \large \begin{verbatim}
While[boolean-expression, statement-list]
\end{verbatim} \normalsize
  
\bd
Defines a block of statements to be executed repeatedly.
See the section on control structures for complete information.
\item
[See also:] \verb+For+.
\ed

\item
\protect \large \begin{verbatim}
Write[output<->OUTPUT, x->T] =: OUTPUT  
\end{verbatim}\normalsize

{\it for} {\tt T = BEHAV, BOOLEAN, EFG, EFSUPPORT, FLOAT, INTEGER,
NFG, NFSUPPORT, MIXED, RATIONAL, STRATEGY, TEXT, LIST}
\bd
Does a formatted write of \verb+x+ to \verb+output+.
\item [Short form:] \verb+output << x+
\item [See also:] \verb+Output+, \verb+Read+, \verb+SetListFormat+,
\verb+SetNumericFormat+, \verb+SetTextFormat+.
\ed

%--X--

%--Y--

%--Z--

\end{itemize}

\newpage
\section{Sample GCL Programs}

\subsection{A GCL program to build and solve the holdout game}

The following GCL program, in the file ``holdout.gcl'' defines a user
defined function

\begin{verbatim}
  CreateHoldout[ stages->INTEGER, prob1->FLOAT, prob2->FLOAT, 
                 disc->FLOAT, b->FLOAT] =: EFG
\end{verbatim}

\noindent
which can be used to create a finite horizon version of the
``holdout'' game studied in McKelvey and Palfrey, ``Endogeneity of
alternating offers in a bargaining game,'' forthcoming, JET.  To use
the function, include the file ``holdout.gcl'' and then type
\verb+CreateHoldout[n,r1,r2,d,b]+, where \verb+n+ is the number of
stages, \verb+r1+ and \verb+r2+ are the prior probabilities that
players 1 and 2 are a low benefit type, \verb+d+ is the common
discount factor, and \verb+b+ is the common benefit of giving in to
the high type.  For example, the following sequence of commands

\begin{verbatim}
  Include["holdout.gcl"]
  e:= CreateHoldout[1, .5, .5, .9, .5]
  SaveEfg[e,"holdout1.efg"]
  e:= CreateHoldout[7, .5, .5, .9, .5]
  SaveEfg[e,"holdout7.efg"]
\end{verbatim}

\noindent
creates and saves a one stage holdout game and a seven stage holdout
game. These can be loaded by the GUI, and Figures 1 and 2 display the
resulting games, as displayed by the GUI.  The subsequent file
``eaotest.gcl'' contains a GCL program that changes the parameters
\verb+r1+ and \verb+r2+, and then solves for {\bf all} Nash equilibria
of the resulting seven stage game to check various theoretical predictions.

\begin{figure}[htp]
\psfig{figure=gclfig1.ps,height=3in,width=6in}
\caption{One stage holdout game}
\end{figure}
\begin{figure}[htp]
\psfig{figure=gclfig2.ps,height=3.5in}
\caption{Seven stage holdout game}
\end{figure}

\newpage
\noindent
This is the contents of the file "holdout.gcl" which defines the
function ``CreateHoldout[]'' used in the above programs.

{\scriptsize 
\begin{verbatim}
  //
  // A gcl program to construct a multi stage holdout game
  //

  NewFunction[MultiStageHoldout[ efg<->EFG, node->NODE, isets->LIST(ISET), \
  out->LIST(OUTCOME), stages->INTEGER, disc->FLOAT],
    // build tree
  i1:=isets[[1]];
  i2:=isets[[2]];
  AppendNode[node, i1 ];
  AppendNode[node#1, i2 ];
  If[NumActions[i1]>1, AppendNode[node#2,i2] ];
    // attach outcomes
  AttachOutcome[node#1#1, out[[1]] ]; 
  If[NumActions[i2]>1, AttachOutcome[node#1#2, out[[2]] ] ];
  If[NumActions[i1]>1, 
    AttachOutcome[node#2#1, out[[3]] ];
    If[NumActions[i2]>1, AttachOutcome[node#2#2, out[[4]] ] ];
    ];
    // recurse to next stage
  If[NumActions[i1]>1 || NumActions[i2]>1,
    If[stages>1,
      stages;
      diset := NewInfoset[Chance[efg], {"",""} , "Discount"];
      SetChanceProbs[diset,{1.0-disc,disc}];
      AppendNode[node#1#1,diset];
      MultiStageHoldout[efg,node#1#1#2,isets,out,stages-1,disc];
      ];
    ];
  ]

  NewFunction[CreateHoldout[ stages->INTEGER,
    prob1->FLOAT, prob2->FLOAT, disc->FLOAT, b->FLOAT],
  e := NewEfg[];
  n := RootNode[e];
    // create chance moves
  ciset1 := NewInfoset[Chance[e], {"High", "Lo"} , "Choose 1's type"];
  ciset2 := NewInfoset[Chance[e], {"High", "Lo"} , "Choose 2's type"];
  SetChanceProbs[ciset1,{prob1,1.0-prob1}];
  SetChanceProbs[ciset2,{prob2,1.0-prob2}];
  AppendNode[n, ciset1 ];
  AppendNode[n#1, ciset2 ];
  AppendNode[n#2, ciset2 ];
    // Define players, actions, and outcomes
  pl1 := NewPlayer[e,"Player 1"];
  pl2 := NewPlayer[e,"Player 2"];
  is1w := NewInfoset[ pl1 , {"H", "G"} ];
  is1s := NewInfoset[ pl1 , {"H"} ];
  is2w := NewInfoset[ pl2 , {"H", "G"} ];
  is2s := NewInfoset[ pl2 , {"H"} ];
  out1:= SetPayoff[NewOutcome[e],{0.0, 0.0}];
  out2:= SetPayoff[NewOutcome[e],{1.0, b}];
  out3:= SetPayoff[NewOutcome[e],{b, 1.0}];
  out4:= SetPayoff[NewOutcome[e],{b,b}];
  outs:={out1,out2,out3,out4};

    // Create multi stage games
  MultiStageHoldout[ e, n#1#1, {is1w,is2w}, outs, stages, disc];
  MultiStageHoldout[ e, n#1#2, {is1w,is2s}, outs, stages, disc];
  MultiStageHoldout[ e, n#2#1, {is1s,is2w}, outs, stages, disc];
  MultiStageHoldout[ e, n#2#2, {is1s,is2s}, outs, stages, disc];
  nonterm:=NonterminalNodes[e];
    // Make perfect recall 
  For[i:=1,i<=Length[nonterm],i:=i+1,
    p:=Player[nonterm[[i]] ];
    If[p!=Chance[e],
      Reveal[Infoset[nonterm[[i]] ],{p}]; ];
    ];	 
  e
  ]
\end{verbatim}
}

\noindent
This program solves for all equilibria of the seven stage holdout game
illustrated in Figure 2, using various parameters for the chance
moves, to check various theoretical predictions. 
{\scriptsize
\begin{verbatim}
  //
  // A gcl program to check theoretical results from McKelvey Palfrey 
  // paper "Endogeneity of Alternating Offers,"  forthcoming JET.  
  //

  // Include["holdout.gcl"]

  // First define function to compute all Nash equilibria for 
  // two person extensive form game

  NewFunction[AllNash[e<->EFG],
    n:=Nfg[e];
    s:=ElimAllDom[n,strong->True];
    m:=EnumMixedSolve[s,stopAfter->0];
    b:=Behav[m,e];
  ];

  // Create seven stage holdout game

  b:=.5;
  del:=.9;
  e:= CreateHoldout[7, .5, .5, del, b]

  // set variables to refer to the chance moves, 

  n:=RootNode[e];
  i1:=Infoset[n];
  i2:=Infoset[n#1];

  // open outfile and set output format

  o:=Output["eaotest.out"];
  SetFormat[listLF->2,precis->3,listCommas->False,listIndent->0];

  // define the constants demarcating the regions of equilibria

  R := (1.0-b)/(1.0-del*b);
  Q := (del-b) / (del*(1.0-del*b));

  o << "\nb: " << b << " del: " << del;
  o << " R: " << R << " Q: " << Q << "\n";

  // Now, check various regions to make sure they have the right 
  // kinds of equilibria predicted by the theorems.  

  o << "\nIn these regions there should be just one equilibrium,";
  o << "\nwith full alternating offers, lasting J innings:\n ";

  For[J:=2,J<=4,J:=J+1,
    r1:=(Q^J+Q^(J-1))/2.0;
    r2:=(R*Q^(J-1))/2.0;
    SetChanceProbs[i1,{1.0-r1,r1}];
    SetChanceProbs[i2,{1.0-r2,r2}];
    s:=AllNash[e];
    o << "\nJ: " << J << " r1: " << r1 << "  r2: " << r2;
    o << "\ns: " << s;
  ];

  o << "\n\nIn these regions there may be multiple equilibria. At least ";
  o << "\none should be full simultaneous offer, lasting M innings:\n";

  For[M:=3,M<=4,M:=M+1,
    r1:=(R^(M+1)+R^M)/2.0;
    r2:=r1;
    SetChanceProbs[i1,{1.0-r1,r1}];
    SetChanceProbs[i2,{1.0-r2,r2}];
    s:=AllNash[e];
    o << "\nM: " << M << " r1: " << r1 << "  r2: " << r2;
    o << "\ns: " << s;
  ];
\end{verbatim}
}

\noindent
Following is the output from running the above program:
{\scriptsize
\begin{verbatim}
  b: 0.500 del: 0.900 R: 0.909 Q: 0.808

  In these regions there should be just one equilibrium,
  with full alternating offers, lasting J innings:
 
  J: 2 r1: 0.731  r2: 0.367
  s: {
  (Behav) { { 1.000 0.000 }{ 0.288 0.712 }{ 1.000 0.000 }{ 0.000 1.000
  }{ 0.500 0.500 }{ 0.500 0.500 }{ 0.500 0.500 }{ 1.000 } }
  { { 0.138 0.862 }{ 1.000 0.000 }{ 0.000 1.000 }{ 0.500 0.500 
  }{ 0.500 0.500 }{ 0.500 0.500 }{ 0.500 0.500 }{ 1.000 } } 
  }
  J: 3 r1: 0.590  r2: 0.270
  s: {
  (Behav) { { 1.000 0.000 }{ 0.532 0.468 }{ 1.000 0.000 }{ 0.288 0.712
  }{ 1.000 0.000 }{ 0.000 1.000 }{ 0.500 0.500 }{ 1.000 } }
  { { 0.196 0.804 }{ 1.000 0.000 }{ 0.447 0.553 }{ 1.000 0.000 
  }{ 0.000 1.000 }{ 0.500 0.500 }{ 0.500 0.500 }{ 1.000 } } 
  }
  J: 4 r1: 0.477  r2: 0.198
  s: {
  (Behav) { { 1.000 0.000 }{ 0.633 0.367 }{ 1.000 0.000 }{ 0.532 0.468
  }{ 1.000 0.000 }{ 0.288 0.712 }{ 1.000 0.000 }{ 1.000 } }
  { { 0.605 0.395 }{ 1.000 0.000 }{ 0.730 0.270 }{ 1.000 0.000 
  }{ 0.701 0.299 }{ 1.000 0.000 }{ 0.000 1.000 }{ 1.000 } } 
  }

  In these regions there may be multiple equilibria. At least 
  one should be full simultaneous offer, lasting M innings:

  M: 3 r1: 0.717  r2: 0.717
  s: {
  (Behav) { { 1.000 0.000 }{ 0.321 0.679 }{ 1.000 0.000 }{ 0.000 1.000
  }{ 0.500 0.500 }{ 0.500 0.500 }{ 0.500 0.500 }{ 1.000 } }
  { { 0.602 0.398 }{ 1.000 0.000 }{ 0.000 1.000 }{ 0.500 0.500 
  }{ 0.500 0.500 }{ 0.500 0.500 }{ 0.500 0.500 }{ 1.000 } }
  (Behav) { { 0.602 0.398 }{ 1.000 0.000 }{ 0.000 1.000 }{ 0.500 0.500
  }{ 0.500 0.500 }{ 0.500 0.500 }{ 0.500 0.500 }{ 1.000 } }
  { { 1.000 0.000 }{ 0.321 0.679 }{ 1.000 0.000 }{ 0.000 1.000 
  }{ 0.500 0.500 }{ 0.500 0.500 }{ 0.500 0.500 }{ 1.000 } }
  (Behav) { { 0.679 0.321 }{ 0.569 0.431 }{ 0.313 0.687 }{ 0.000 1.000
  }{ 0.500 0.500 }{ 0.500 0.500 }{ 0.500 0.500 }{ 1.000 } }
  { { 0.679 0.321 }{ 0.569 0.431 }{ 0.313 0.687 }{ 0.000 1.000 
  }{ 0.500 0.500 }{ 0.500 0.500 }{ 0.500 0.500 }{ 1.000 } } 
  }
  M: 4 r1: 0.652  r2: 0.652
  s: {
  (Behav) { { 0.739 0.261 }{ 0.679 0.321 }{ 0.569 0.431 }{ 0.312 0.688
  }{ 0.000 1.000 }{ 0.500 0.500 }{ 0.500 0.500 }{ 1.000 } }
  { { 0.739 0.261 }{ 0.679 0.321 }{ 0.569 0.431 }{ 0.312 0.688 
  }{ 0.000 1.000 }{ 0.500 0.500 }{ 0.500 0.500 }{ 1.000 } } 
  }
\end{verbatim}
}

\newpage
\subsection{A GCL program for econometric estimation}  

This section gives a GCL program for doing maximum likelihood fits of
experimental data to the quantal response equilibrium (QRE) and one
sided error model (OSEM).  The following files define a GCL function 

\begin{verbatim}
  EGobit[filename->TEXT] 
\end{verbatim}

\noindent
which takes as input an extensive form in the file ``filename.efg'',
and experimental data from the file ``filename.agg'', and produces as
output ``filename.out'' and ``filename.pxi''.  The file
``filename.out'' contains the maximum likelihood estimates of the data
for the QRE and the OSEM models, along with 95\% confidence intervals
on the parameters of the models, $\lambda$ and $\gamma$, respectively.
The file ``filename.pxi'' contains the ``pxi'' file of the QRE
correspondence, which can be viewed and printed to a postscript file
by the separate program PXI program, written by Eugene Grayver.  

The program is illustrated on an experiment (Game 3) of Brandts and
Holt, ``Adjustment patterns and equilibrium selection in experimental
signaling games,'' IJGT 22 (1993): 279-302.  The extensive form of the
game in ``bhg3.efg'' is displayed in Figure 3:

\begin{figure}[htp]
\centerline{\psfig{figure=gclfig3.ps,height=4in,width=5in}}
\caption{Brandts Holt Experimental Game 3}
\end{figure}

\noindent
The input data file ``bhg.agg'' follows:

\begin{verbatim}
  .01 0.70 .01
  1.0 0.0  1.0 0.0  1.0 0.0 0.0  0.0 1.0 0.0 
  1
  32 1 18 21 48 2 0  4 18 0
\end{verbatim}

\noindent
The program is run by typing 

\begin{verbatim}
  Include["egobit.gcl"]
  EGobit["bhg3"]
\end{verbatim}

\noindent
Figure 4 displays the pxi file, and the following output is in
``bhg3.out'':

\begin{verbatim}
  Using Nash: (Behav) { { 1.000000 0.000000 }{ 1.000000 0.000000 } }
  { { 1.000000 0.000000 0.000000 }{ 0.000000 1.000000 0.000000 } }

  minLam: 0.010000 maxLam: 0.700000 delLam: 0.010000
  delGam: 0.001000 eps: 0.000000


    Player  Infoset   n         f       QRE      OSEM

        1      1     32      0.9697    0.9462    0.8375
        1      1      1      0.0303    0.0538    0.1625
        1      2     18      0.4615    0.6014    0.8375
        1      2     21      0.5385    0.3986    0.1625
        2      1     48      0.9600    0.6860    0.7833
        2      1      2      0.0400    0.1779    0.1083
        2      1      0      0.0000    0.1361    0.1083
        2      2      4      0.1818    0.1086    0.1083
        2      2     18      0.8182    0.7186    0.7833
        2      2      0      0.0000    0.1728    0.1083
  Lam\Gam                    0.0000    0.1078    0.6750
  Lam\Gam_lo                           0.0957    0.5590
  Lam\Gam_hi                           0.1252    0.7730
  LogLik                              -69.529   -78.295
\end{verbatim}


\newpage
\begin{figure}[htp]
\centerline{\psfig{figure=gclfig4a.ps,height=3.5in,width=5.5in}}
\vspace{.5in}
\centerline{\psfig{figure=gclfig4b.ps,height=3.25in,width=6.5in}}
\caption{BH (1993) Game 3. Graphical display of ``pxi'' file }
\end{figure}

\noindent
The program is contained in three files, whose contents follow.  First
is the contents of ``egobit.gcl'':

{\scriptsize
\begin{verbatim}
  //
  //  This gcl program estimates the principal branch of
  //  the QRE and corresponding OSEM for a given extensive 
  //  form game, finds MLE fits to experimental data 
  //  and computes 95% confidence intervals for each model. 
  //
  //  The extensive form is assumed to be in filename.efg
  //  and the data is in filename.agg.  The first line
  //  in the agg file should contain the bounds for lambda 
  //  The second line should contain an equilibrium selection 
  //  to be used by the OSEM model. The third line gives 
  //  the number of data sets
  //  for which the estimation is to be conducted.  This 
  //  should be followed by at least that many sets of data.
  //
  //  The output is put in filename.out, and the pxifile is put in
  //  filename.pxi
  //
  
  Include["egobitml.gcl"];

  NewFunction[EGobit[filename->TEXT],
    //  Load efg and open agg file for reading
    e := LoadEfg[filename&".efg"]
    in := Input[filename&".agg"]

    // read in range of lambdas for QRE estimation
    in >> min >> max >> del;

    // read in nash equilibrium selection to be used for OSEM model
    nash :=Centroid[e];
    datlist := Integer[ListForm[nash]];
    in >> nash;

    //  Load data into dat
    in >> ndat;
    dat := {};
    For[i := 1, i <= ndat, i := i+1,
      dat := dat & {datlist};
      in >> dat[[i]];
    ];

    pxi := filename&".pxi";
    out := filename&".out";

    EGobitML[e,dat,min,max,del,out,pxi,nash];
  ];
\end{verbatim}
}

\noindent
Following is the contents of ``egobitml.gcl'':

{\scriptsize
\begin{verbatim}
  //
  // A gcl program to estimate the principal branch of the 
  // QRE for an extensive form game, and find the maximum likelihood 
  // estimate of lambda for a list of aggregate experimental data
  // 
  // e is the normal form game
  // dat is a list of observations.  Each observation is in the form of  
  //    a LIST(LIST(LIST(INTEGER))), where the integers correspond to
  //    the number times the corresponding action (for that player in
  //    that information set) was chosen.  So for a 2 player game where
  //    each player has two information sets with two actions each, the 
  //    element in dat {{{43, 32}, {12, 20}}, {{15, 32}, {16, 28}}} is 
  //    used to indicate that player 1 chose the first action at the
  //    first information set 43 times, etc.  
  // min is the minimum value for Lambda used by GobitSolve[]
  // max is the maximum value for Lambda used by GobitSolve[]
  // del is the increment for Lambda used by GobitSolve[]
  // out is the name of a file in which the results will be written
  // pxi is the name of a file where the pxi file is written
  // nash is a Nash equilibrium selection that is passed for use
  //     in estimating the OSEM model 

  Include["loglike.gcl"];

  NewFunction[EGobitML[e<->EFG,dat->LIST(LIST(LIST(LIST(INTEGER)))),min->FLOAT,max->FLOAT,\
    del->FLOAT,out->TEXT,pxi->TEXT,nash->BEHAV],
    o := Output[out];
    gob := GobitSolve[e, minLam->min, maxLam->max, delLam->del,fullGraph->True, \
      pxifile->pxi];

    size := Length[gob];

    eps:=0.0000000001;
    For[i := size , i>=1 , i:=i-1,
      If[GobitValue[gob[[i]]] > eps, 
        o << "\nRemoved element: " << i << " lambda: " << GobitLambda[gob[[i]]];
        gob:=Remove[gob,i]; 
      ];
    ];
    lamlist:=GobitLambda[gob];
    size := Length[gob];

    goblist := ListForm[gob];
    exdat := Float[dat];

    numactions := Length[ListForm[nash]];
    numisets := Length[numactions];
    numplayers := Length[numisets];

    o << "\nUsing Nash: " << nash << "\n";
    o << "\nminLam: " << min << " maxLam: " << max << " delLam: " << del;

    delgam := .001;
    o << "\ndelGam: " << delgam << " eps: " << eps << "\n\n";

    gamsize := Integer[1./delgam] - 1;
    gamlist := List[delgam, gamsize, delgam];
  
    c := Centroid[e];
    n := nash
    osem := (1.0-gamlist)*c + gamlist*n;
    osemlist := ListForm[osem];

    // compute maximum likelihoods and pretty-print results to output file

    SetFormat[quote->False];

    ldat := Length[Length[Length[Length[dat]]]];

    For[ii:=1, ii<=ldat, ii:=ii+1,
      goblogl := LogLike[exdat[[ii]],gob];
      osemlogl := LogLike[exdat[[ii]], osem];
      header:="\n  Player  Infoset   n         f       QRE      OSEM\n";
      o << header;

      gobllmax := ArgMax[goblogl];
      osemllmax := ArgMax[osemlogl];
      For[i:=1, i<=numplayers, i:=i+1,
        For[j:=1, j<=numisets[[i]], j:=j+1,
          sum:=Sum[exdat[[ii]][[i]][[j]]];
          For[k:=1,k<=numactions[[i]][[j]],k:=k+1,
            nob:=exdat[[ii]][[i]][[j]][[k]];
            SetFormat[precis->0,width->7];
            o << "\n" << i << j << nob;
            SetFormat[precis->4,width->10];
            If[sum != 0.0, o << "  " << nob/sum, o << " " << 0.0];
            o << goblist[[gobllmax]][[i]][[j]][[k]];
            o << osemlist[[osemllmax]][[i]][[j]][[k]];
          ];
        ];
      ];
      LamCI := LamHiLo[goblogl, lamlist, 1.9205, gobllmax];
      GamCI := LamHiLo[osemlogl, gamlist, 1.9205, osemllmax];
      o << "\nLam\Gam                " << 0.0 <<  lamlist[[gobllmax]] << gamlist[[osemllmax]];
      o << "\nLam\Gam_lo                       " << LamCI[[1]] << GamCI[[1]];
      o << "\nLam\Gam_hi                       " << LamCI[[2]] << GamCI[[2]];
      SetFormat[precis->3, width->10];
      o << "\nLogLik                           " << goblogl[[gobllmax]] << osemlogl[[osemllmax]] << "\n";
    ];
  ];
\end{verbatim}
}

\noindent
Following is the contents of ``loglike.gcl'':

{\scriptsize
\begin{verbatim}
  //
  // Some user defined functions for maximum likelihood estimation
  // 

  // sum of components of a vector

  NewFunction[ Sum[l->LIST(FLOAT)], Dot[l,List[1.0,Length[l] ]];];

  // log likelihood of the data for a given solution
  // note that the data must be of type MIXED
  // So if data is LIST(LIST(INTEGER)), then call function by  
  // LogLik[Mixed[n,Float[data]],sol]

  NewFunction[ LogLike[dat->LIST(LIST(FLOAT)), sol->MIXED], 
    x:= dat * Log [ ListForm[sol]];
    Sum[Sum[x]];
  ];

  NewFunction[ LogLike[dat->MIXED, sol->MIXED], 
    x:= ListForm[dat] * Log [ ListForm[sol]];
    Sum[Sum[x]];
  ];

  // log likelihood of the data for a given solution
  // note that the data must be of type BEHAV
  // So if data is LIST(LIST(LIST(INTEGER))), then call function by  
  // LogLik[Behav[n,Float[data]],sol]

  NewFunction[ LogLike[dat->BEHAV, sol->BEHAV], 
    x:= ListForm[dat] * Log [ ListForm[sol]];
    Sum[Sum[Sum[x]]];
  ];

  NewFunction[ LogLike[dat->LIST(LIST(LIST(FLOAT))), sol->BEHAV], 
    x:= dat * Log [ ListForm[sol]];
    Sum[Sum[Sum[x]]];
  ];

  // This function computes confidence intervals for a solution
  // Here list is the list of likelihood values, lam is the list of parameters
  // (assumed to have the same length as list, range is 1/2 of the chi^2 value
  // (use 1.9205 for a 95% confidence interval), and llmaxind is the location of the 
  // maximum (assumed correct) 

  NewFunction[LamHiLo[list->LIST(FLOAT),lam->LIST(FLOAT),range->FLOAT,llmaxind->INTEGER], 
    newlist := list -(list[[llmaxind]]-range);
    t1:={};
    t2:={};
    llsize := Length[lam];
    For[z:=2, z<=llsize, z:=z+1,
      If[newlist[[z]]>=0.0, 
      t1:=t1&{z}; 
      t2:=t2&{lam[[z]]};];
    ];
    flag := True;
    t1:=t1-(t1[[1]]-1);
    s1:=Length[t1];
    If[s1 != t1[[s1]], flag:=False];
    lhilo:={t2[[1]],t2[[s1]]};
  ];
\end{verbatim}
}

\newpage
\bibliographystyle{chicagob}
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{gambit}
\end{document}

\newpage
\subsection{A GCL program to build the chain store game}

The following GCL program, in the file ``cs.gcl'' defines a user
defined function

\begin{verbatim}
CreateChainStore[num_stages->INTEGER,prob->FLOAT] =: EFG
\end{verbatim}

\noindent
which can be used to create a chain store game with any number of
stages (entrants) and any probability of the incumbent being tough.
To use the function, include the file ``cs.gcl'' and they type
\verb+CreateChainStore[n,p]+, where For \verb+n+ is the number of
entrants, and \verb+p+ is the probability of the incumbent being
tough. For example, 

\begin{verbatim}
Include["cs.gcl"]
e:= CreateChainStore[2,0.5]
SaveEfg[e,"cs2.efg"]
e:= CreateChainStore[3,0.5]
SaveEfg[e,"cs3.efg"]
\end{verbatim}

\noindent
creates and saves a two stage chainstore game and a three stage
chainstore game, with probability .5 of being tough. Figures 5 and 6
display the resulting games, as displayed by the GUI. 

\begin{verbatim}
//
// A gcl program to construct a n-stage chain store game
//

NewFunction[PlayerNumber[e<->EFG, p->EF_PLAYER],
list:=Players[e];
i:=1;
While[i<=NumPlayers[e] && p != list[[i]],i:=i+1;];
i;]

NewFunction[MultiStageChainStore[ efg<->EFG, node->NODE, strong->BOOLEAN, list->LIST],
// build tree
inc_iset:=list[[1]];
ent_iset:=list[[2]];
incumbent:=Player[inc_iset];
entrant:=Player[ent_iset];
AppendNode[node, ent_iset ];
AppendNode[node#1, inc_iset ];
AppendNode[node#2, NewInfoset[incumbent,{""} ] ];
// attach outcomes 
AttachOutcome[node#1#1,NewOutcome[efg]];
AttachOutcome[node#1#2,NewOutcome[efg]];
AttachOutcome[node#2#1,NewOutcome[efg]];
pay:=Payoff[Outcome[node#1#1]];
entnum:=PlayerNumber[efg,entrant];
incnum:=PlayerNumber[efg,incumbent];
a:=0.5;b:=0.5;
pay[[ entnum ]]:=b-1.;
pay[[ incnum ]]:=-1.;
If[strong, pay[[ incnum ]] := 0.;];
SetPayoff[Outcome[node#1#1],pay];
pay[[ entnum ]]:=b;
pay[[ incnum ]]:=0.;
If[strong, pay[[ incnum ]] := -1.;];
SetPayoff[Outcome[node#1#2],pay];
pay[[ entnum ]]:=0.;
pay[[ incnum ]]:=a;
SetPayoff[Outcome[node#2#1],pay];
// recurse down the tree
list:=Remove[list,2];
If[Length[list] > 1,
  MultiStageChainStore[efg, node#1#1, strong, list];
  MultiStageChainStore[efg, node#1#2, strong, list];
  MultiStageChainStore[efg, node#2#1, strong, list];
  ];
]

NewFunction[CreateChainStore[ num_stages->INTEGER, prob -> FLOAT],
e := NewEfg[];
n := RootNode[e];
iset := NewInfoset[Chance[e], {"Strong", "Weak"} , "Chance move"];
AppendNode[n, iset ];
inc := NewPlayer[e,"Incumbent"];
isinc := NewInfoset[ inc , {"Fight", "Aquiesce"} ];
lpl := { inc };
lisets := { isinc }; 
For[i:=1,i<=num_stages,i:=i+1,
  lpl := lpl & { NewPlayer[e,"Entrant"&Text[i]] };
  lisets := lisets & {NewInfoset[lpl[[i+1]],  {"Enter", "Out"}] };
  ];
MultiStageChainStore[ e, n#1, True, lisets];
MultiStageChainStore[ e, n#2, False, lisets];

nonterm:=NonterminalNodes[e];
For[i:=1,i<=Length[nonterm],i:=i+1,
  If[Player[ nonterm[[i]] ]!=Chance[e],
    Reveal[Infoset[nonterm[[i]] ],lpl]; ];
  ];	
Reveal[iset,{inc}];
e;
];

\end{verbatim}

\newpage
\begin{figure}[h]
\centerline{\psfig{figure=gclfig5.ps,height=4in}}
\caption{Two stage chain store game}
\end{figure}

\newpage
\begin{figure}[h]
\centerline{\psfig{figure=gclfig6.ps,height=6in}}
\caption{Three stage chain store game}
\end{figure}

