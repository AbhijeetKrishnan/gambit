%
% FILE: gclman.tex -- source for GCL manual
%
% $Id$
%
\documentstyle[widetext,chicagob]{article}
\renewcommand{\baselinestretch}{.9}
\newcommand{\bd}{\begin{description}}
\newcommand{\ed}{\end{description}}
\begin{document}

\title{GAMBIT COMMAND LANGUAGE\thanks{This is part of the Gambit
Project, which was funded in part by National Science Foundation
grants SBR-9308637 to the California Institute of Technology and
SBR-9308862 to the University of Minnesota.}}

\author{Richard D. McKelvey\\California Institute of
Technology
\and
Andrew McLennan\\University of
Minnesota
\and 
Theodore Turocy\\Northwestern University
}

\date{Version 0.91\\ \today\\ \jobname.tex}

\maketitle

\tableofcontents

\section{Introduction}

This document describes the Gambit Command Language (GCL).  Gambit is
a computer program that allows one to build, manipulate, and solve
finite extensive and normal form games. The GCL provides a method of
directing the operation of Gambit that is analagous to that of a high
level general purpose programming language.

The general purpose of the GCL is to provide a simple, but powerful
and flexible language by which one can perform complicated or
repetitive operations and procedures on games in extensive or normal
form.  The language has facilities for building and editing an
extensive or normal form game, converting back and forth between the
extensive and normal form representations, and then solving the
resulting game for various equilibria of interest. Flow
control statements allow for repetitive operations (such as
investigating games as one changes various parameters) or conditional
operations.

\section{Acknowledgements}

The Gambit Project is a project for the development of computer code
for the solution of extensive and normal form games.  The software
developed under the project is public domain.  The Gambit Project is
funded in part by National Science Foundation grants SBR-9308637 to
the California Institute of Technology and SBR-9308862 to the
University of Minnesota.

Numerous students at Caltech and the University of Minnesota have
contributed to the Gambit Command Language and to the Gambit Project
more generally: Among these are Bruce Bell, Anand Chelian, Nelson
Escobar, Eugene Grayver, Todd Kaplan, Brian Trotter, and Gary Wu.  We
are particularly grateful to Gary Wu for his work on the stack machine
used by the command language, to Bruce Bell and Nelson Escobar for
work on data structures, and to Rob Weber for help in compiling this
manual and testing parts of the language.  We are also grateful to
Eugene Grayver for his extensive work on the related GUI, and for
setting up our Web site.

\section{Installation}

All of the gambit files can be found at the Gambit World Wide Web site
at 

\begin{verbatim}
http://www.hss.caltech.edu/~gambit/Gambit.html
\end{verbatim} 

\noindent Instructions on downoading and installation as well as a
list of platforms supported can be obtained there.  Source code is
also available at the same location. 

Once the program is installed, the gcl can be run by typing \verb+gcl+
at the command line prompt.  You will then receive the GCL prompt 

\begin{verbatim}
GCL1:
\end{verbatim}

\noindent The interpreter is ready for your first command.


\section{Technical support and bug reports}

User feedback is an important part of Gambit's development cycle.
Our design choices have been motivated in large part by our experiences
and by some of the potential uses of the software we have imagined.
But this is by no means complete, and so we are eager to hear from
you, Gambit's users, to find out what features are particularly
useful, and in what areas future releases might be improved.

The authors may be contacted via email at {\tt gambit@hss.caltech.edu}.
This address will forward a copy of your message to the development team.
While a personal reply may not always be possible, we will read all
correspondence and apply as many suggestions as possible to our future
releases.

Although we have made every effort to ensure the reliability and correctness of the
code, it is certain that errors of varying degrees of severity exist.
(However, as the saying goes, no undiscovered bugs have been found yet.)  If you
experience problems with the software,
send us email at {\tt gambit@hss.caltech.edu} describing your problem.

When reporting a bug, it is important to include the following information:

\begin{itemize}
\item the version number
\item the platform(s) on which the problem occurred
\item as complete a description of the circumstances of the problem as possible, including a sequence of steps which reproduces the problem
\end{itemize}
 
\noindent Without this information, it will be difficult for us to identify the source of the
problem to correct it.

At this time, no formal technical support mechanism exists for Gambit.
As time permits, we will make every effort to answer any and all questions
pertaining to the program an its documentation.

We hope you will find Gambit a useful tool for research and instruction.


\section{Basic concepts}

The design motifs for GCL come from two principal families of programming
languages.  The first is traditional imperative programming languages
such as Pascal, C, and Modula-3.  In particular, the GCL's concept of
types draws heavily from these languages, although the number of
predefined types in GCL is much larger due to the specialized nature of
the language.  The second is more specialized programming languages such
as Mathematica, from which the GCL's grammar is partially drawn.  Users
with experience using any of these languages should find the GCL easy to
learn; however, no programming experience is necessary to begin using the
language effectively.

\subsection{Statements}

A GCL program consists of a series of statements.  A statement is
typically an expression built up out of function calls.  A statement
is terminated by a linefeed or by a semicolon.  The GCL interpreter
reports the value of each expression evaluated unless the semicolon is
present. Statements can be continued for more than one line by using
the continuation character, \verb+\+.   

\subsection{Types}

The built-in data types for the GCL are the following:  

\medskip

\begin{tabular} {|l||l|} \hline
Type name	& Description \\ \hline
{\tt BOOL} 	& boolean \\
{\tt INTEGER} 	& integer \\ 
{\tt FLOAT} 	& floating-point number \\
{\tt RATIONAL} 	& rational number with arbitrary precision \\
{\tt TEXT}	& string of arbitrary length \\
{\tt OUTPUT}	& output stream \\ \hline
{\tt EFG}	& extensive form game \\
{\tt EFPLAYER}	& a player in an extensive form game \\
{\tt NODE}	& a node in an extensive form game \\ 
{\tt INFOSET}	& an information set in an extensive form game \\
{\tt ACTION}	& an action at an information set \\
{\tt OUTCOME}	& an outcome in an extensive form game \\
{\tt EFSUPPORT}	& a support of actions in an extensive form game \\
{\tt BEHAV}	& a behavioral strategy profile for an extensive form game \\ \hline
{\tt NFG}	& normal form game \\
{\tt NFPLAYER}	& a player in a normal form game \\
{\tt STRATEGY}	& a strategy in a normal form game \\
{\tt NFSUPPORT}	& a support of strategies in a normal form game \\
{\tt MIXED}	& a mixed strategy profile for a normal form game \\ \hline
{\tt LIST}	& a list of objects \\ \hline
\end{tabular}

\medskip

The remainder of this section details the rules concerning the types
{\tt BOOL}, {\tt INTEGER}, {\tt FLOAT}, {\tt RATIONAL}, {\tt TEXT}, and
{\tt OUTPUT}, as well as general rules for typing.  The extensive form
and normal form types, and their related types, are detailed later in
special sections.

\subsubsection{Boolean}

The {\tt BOOL} type represents boolean values, that is to say, ``true'' and
``false''.  The command language predefines two constant values to
represent these, {\tt True} and {\tt False}.

\subsubsection{Integer}

The {\tt INTEGER} type may contain integer values.  It is implemented
as the machine's long integer type, which is typically at least 32
bits in modern machines.  Thus, there is a danger, however small, of
overflow or underflow in computations involving these numbers.

\subsubsection{Float}

The {\tt FLOAT} type may contain floating point values.  It is implemented
as the machine's double-precision floating point type.  These numbers
are imprecise; for example, operations usually associated with being inverses
of each other may not be with floating point numbers.  For more precise
computations, the {\tt RATIONAL} type is available, although these may
sometimes be bulky and slow.

\subsubsection{Rational}

The {\tt RATIONAL} type is a ratio of two arbitrary-length integers.
This data type is capable of precisely representing any rational
number.  However, they are slow, and output from them may be
unreadably large.  Rational numbers are formed from two integers using
the {\tt /} operator, described below.

\subsubsection{Text}

The {\tt TEXT} type is used to store text strings, typically labels
for parts of games.  It is generally encouraged to label various elements
of games in the command language for ease of identification; however it
is not required.  To specify a {\tt TEXT} constant, surround the
text with double-quote characters ({\tt "}).  Constants may not span
more than one input line.

\subsubsection{Output}

The {\tt OUTPUT} type is a reference to an output stream, generally a file
on disk.  Its principal use is as a logging file for formatting output
from an extended command language job.

\subsubsection{List}

Variables of any type can be contained in lists of arbitrary length.
Variables of type {\tt LIST} are defined similarly to the above
variables, except that the expression to the right of the {\tt ":="}
symbol contains a vector of variables of the same type enclosed in
curly braces and separated by commas.  For example, the following is a
list containing the first five integers:

\begin{verbatim}
{ 1, 2, 3, 4, 5 }
\end{verbatim}

\noindent In the same manner, lists of any type may be created and manipulated.
Lists may be nested to any depth; however, the type of all the elements
of the list and any sublists must always be the same.  Hence

\begin{verbatim}
{ 3, { 4, 6 }, 23 }
\end{verbatim}

\noindent is a legal list, since all the elements are of type 
{\tt INTEGER}, but

\begin{verbatim}
{ 3, { 4.2, 5.7 }, 23 }
\end{verbatim}

\noindent is not, since the second element is a {\tt LIST(FLOAT)}.

Lists are distinct in type from each other and from their scalar equivalents.
That is to say, {\tt LIST(INTEGER)} is not the same time as
{\tt LIST(FLOAT)}, nor is it the same type as {\tt INTEGER}.

\subsection{Variables}

A variable stores one object of the corresponding data type
To create a user defined variable, or to give
a new value to an existing variable, one can use the built-in
function,
\verb+Assign+, which has the syntax:
\begin{verbatim}
Assign[x<->T, y->T]
\end{verbatim}

\noindent (How to read a function's declaration is described in more
detail in the section of function calls.  For now, suffice it to say that
{\tt Assign} takes two parameters, the first of which is a variable and
the second a value of the same type as the variable.)  The {\tt Assign}
function also has an infix operator form, written {\tt :=}.  So, to assign
the {\tt INTEGER} value 1 to the variable {\tt x}, one could write

\begin{verbatim}
Assign[x, 1]
\end{verbatim}

\noindent or equivalently, and more compactly,

\begin{verbatim}
x := 1
\end{verbatim}

The {\tt Assign} function can be used to either create a new variable or
modify an existing one.  However, it cannot be used to change the type
of a variable.  Consider the calls

\begin{verbatim}
Assign[y, 2]
Assign[y, 3.0]
\end{verbatim}

\noindent The first call defines {\tt y} to be of type {\tt INTEGER}.  The
second call, then, is interpreted as {\tt Assign[INTEGER, FLOAT]}, which does
not match the definition of {\tt Assign}.

An existing variable may be deleted by the use of the {\tt UnAssign} function

\begin{verbatim}
UnAssign[x<->T] =: T
\end{verbatim}

\noindent After this is called on a variable, the variable is no longer
defined.  A subsequent call of {\tt Assign} may redefine the variable to
be of any type.

\subsection{Errors}

Sometimes, programs contain errors.  The interpreter is able to detect
errors which violate rules of the language, and reports information
about the error so the user can correct it.  There are two main
classes of errors which may arise in GCL programs, parse errors and
run time errors.

A parse error occurs when the GCL interpreter cannot determine the
meaning of a statement, because it does not conform to the grammatical
rules of the language.  This most frequently occurs when braces,
brackets, or quotation marks fail to match up or when punctuation is
missing.  When it encounters a parse error, the GCL interpreter will
display an error message giving the filename and line number of the
error and the point at which it determined an error it occurred.

A run time error occurs when a statement which obeys the grammatical
rules of the language violates another rule of the language during its
execution.  Examples of this type of error include attempting to use a
variable name which is not defined, and using a value of one type
where another type was expected.  Also, builtin functions may generate
this type of error on invalid inputs.  A run time error will result in
termination of the GCL at the point where the error occurs, ith a
message indicating the type of error encountered.  However, no line
number is given for run time errors.  


\subsection{Function calls}

A function call consists of the name of a function, and a list of parameters
upon which the function is to operate.  Functions return a value, which
may in turn be used as a parameter to another function call, allowing more
complex computations to be expressed.

A simple example of a function call is

\begin{verbatim}
Plus[x->1, y->2]
\end{verbatim}

This calls the function named {\tt Plus}, with parameter \verb+x+ set to
the value 1 and \verb+y+ set to the value 2.  Since {\tt Plus} is the function
for addition of two integers, the value returned would be, as you might
expect, 3.

In the addition example above, we called a function which is listed in
the function reference as

\begin{verbatim}
Plus[x->INTEGER, y->INTEGER] =: INTEGER
\end{verbatim}

\noindent This listing of a function is called its {\it prototype}.  
It contains the function's name, its list of parameters, and its return
value.  In this case, the function {\tt Plus} takes two parameters, the
first named \verb+x+ and taking a value of type {\tt INTEGER} and the
second named \verb+y+ and taking a value of type {\tt INTEGER}, and
returns a value of type {\tt INTEGER}.

Because the parameters have explicit names, it is possible to rearrange
the order in which parameters are listed when a function is called.
Thus, we could write out sample call equivalently as

\begin{verbatim}
Plus[y->2, x->1]
\end{verbatim}

\noindent and achieve the same effect.

Explicitly specifying the formal names for parameters all the time
will prove tedious and can hinder readability.  For these reasons, it is
also legal to specify parameters without their associated formal names.
These are called passing {\it anonymous} parameters.  Our addition
example could thus also be written

\begin{verbatim}
Plus[1, 2]
\end{verbatim}

In not specifying the formal names, however, function calls are restricted
to specifying parameters in exactly the same order as listed in the function
prototype.  In our example, the GCL interpreter would have no way of
distinguishing whether we meant 1 to be the value of \verb+x+ or the
value of \verb+y+, and vice versa.  While in the case of addition we may
flip the values of the parameters without having an effect on the result,
in general this is not the case.

It is permitted to mix the two styles of parameter specification, subject
to the following rules:

\begin{itemize}
\item All anonymous parameters must be specified before any named parameters
\item No parameters may be omitted in the anonymous parameter list.  If
$k$ parameters are specified anonymously, they must match one-for-one the
first $k$ parameters in the function's prototype.
\item Once a named parameter has been specified, all succeeding parameters
must be named, even if the first named parameter appeared in the same
place in the parameter list as it does in the prototype.
\end{itemize}

\noindent Therefore, it would be legal to write

\begin{verbatim}
Plus[1, y->2]
\end{verbatim}

\noindent but

\begin{verbatim}
Plus[x->1, 2]
\end{verbatim}

\noindent is illegal since it violates the third condition.

To be more precise, the function {\tt Plus} comes in several different
variations listed in the function reference:

\begin{verbatim}
Plus[x->INTEGER, y->INTEGER] =: INTEGER
Plus[x->FLOAT, y->FLOAT] =: FLOAT
Plus[x->RATIONAL, y->RATIONAL] =: RATIONAL
Plus[x->TEXT, y->TEXT] =: TEXT
Plus[x->LIST(T), y->LIST(T) =: LIST(T)
Plus[x->MIXED, y->MIXED] =: MIXED
Plus[x->BEHAV, y->BEHAV] =: BEHAV
\end{verbatim}

\noindent In fact, not all the versions of {\tt Plus} implement addition;
for example, the {\tt TEXT} version concatenates two strings.  This is a
good example of function {\it overloading}.  This means that one function
name may have several possible parameter lists, sometimes called
{\it signatures}.  The GCL interpreter is capable of determining which
version of the function to use by analyzing the names and types of the
parameters used.

Since a function may have multiple signatures, it is conceivable that
a function call might be ambiguous, in the sense that its parameters match
more than one signature for that function.  However, no function call that
is complete may be ambiguous from the way that signatures have been
chosen for the predefined functions.  Any function call flagged by the
interpreter as ambiguous must be missing at least one parameter.

Some functions have parameters which are optional, in the sense that they
need not be specified in order to call the function.  These parameters
are indicated in the function's prototype by being surrounded by curly
braces.  (Note that these braces should not be included in the function
call when specifying an optional parameter.)  If an optional parameter
is left unspecified in a function call, a default value is assumed, as
given in the function's documentation.

For a function, all required parameters always precede any optional
parameters.  Optional parameters may also be specified anonymously,
subject to the above rules on parameter specification.

All parameters so far have been passed by {\it value}, that is, a copy
of the value of the parameter is given to the function to which it is passed.
These parameters may not be modified by the function.  It is also possible
to have parameters to a function passed by {\it reference}.  This means
that the function does not receive a copy of the value, but rather the
memory location of the value itself.  Thus, the function may modify
the value of a parameter passed by reference.

The symbol for passing a parameter by reference, both in a function's
prototype and in a function call, is {\tt <->}.  Constants may not be
passed by reference.  Reference parameters may be specified anonymously
just like a value parameter, subject to the usual rules.  It is a run-time
error to attempt to pass a value to a reference parameter, or vice versa.

\subsection{Aliases for function calls}

There are several functions which are so commonly used that special
``short'' forms are defined for them.  Most of these are the
standard arithmetic and logic operators, for which the usual binary
infix or unary prefix notations are supported.  Our addition example
may more familiarly be written

\begin{verbatim}
1 + 2
\end{verbatim}

\noindent which expression is converted to the ``long form'' function
call by the interpreter.  Note that formal names may not be specified
in a ``short form'' call, and the order of parameters is therefore
significant.

Here is a list of the functions thus abbreviated, and their ``short form''
equivalents:

\medskip

{\tt
\begin{tabular}{lp{4in}}
And[x, y]		& x \&\& y, x AND y \\
Assign[x, y]		& x := y \\
Divide[x, y]		& x / y or x DIV y \\
Equal[x, y]		& x = y \\
Greater[x, y]		& x > y \\
GreaterEqual[x, y]	& x >= y \\
Less[x, y]		& x < y \\
LessEqual[x, y]		& x <= y \\
Minus[x, y]		& x - y \\
Modulus[x, y]		& x \% y, x MOD y \\
Not[x]			& NOT x, !x \\
NotEqual[x, y]		& x != y \\
NthChar[text, n]	& text[[n]] \\
NthChild[node, n]	& node\#n \\ 
NthElement[list, n]	& list[[n]] \\
Or[x, y]		& x || y, x OR y \\
Paren[x]		& (x) \\ 
Plus[x, y]		& x + y \\
Times[x, y]		& x * y \\
\end{tabular}
}

When functions are written in their canonical forms, no ambiguity
arises in the order of evaluation: In order to evaluate a function,
all arguments must be evaluated first.  Arguments are evaluated from
left-to-right as specified in the function call.
This leads to a recursive structure of evaluation,
which stops only when an argument being evaluated is a constant
function (i. e., a function with no arguments).

When short form forms are used, then ambiguity can arise in the
intended order of evaluation.  For example, the statement \verb&a + b * c&,
could be meant as \verb+Plus[a,Times[b,c]]+ or as
\verb+Times[Plus[a,b],c]+.  In order to resolve such ambiguities, all
functions that have a short form representation are given an order of
precedence.  When a statement is parsed by the GCL, it is first
scanned from left to right, replacing each short form expression at the
top level of precedence with its canonical form.  Then it is scanned
again replacing each short form expression at the second level of
precedence with its canonical form, and so on, until all short form
expressions have been eliminated.  

The order of precedence for built-in functions is as follows:
\bd
\item
\verb+()+
\item
\verb+:=+
\item
\verb+||+
\item
\verb+&&+
\item
\verb+NOT+
\item
\verb+= != < <= > >=+
\item
\verb&+ -&
\item
\verb+* / DIV MOD+
\item
\verb&(unary) + -&
\item
\verb+[[ ]]+
\ed

Thus, the statement \verb&a + b * c& would become 
\begin{verbatim}
Plus[a,b*c]
Plus[a,Times[b,c]]
\end{verbatim}

\noindent
On the other hand, the statement \verb&( a + b ) * c& would become 
\begin{verbatim}
Paren[a+b]*c
Paren[Plus[a,b]]*c
Times[Paren[Plus[a,b]],c]
\end{verbatim}

\noindent
which, since \verb+Paren+ is just the identity mapping, is equivalent to
\begin{verbatim}
Times[Plus[a,b],c]
\end{verbatim}

\medskip

\subsection{Flow control structures}

The GCL contains three functions which allow flow control within a
program.  Flow control functions differ from other functions in that
when they are evaluated, the list of visible functions does not
change.

\medskip

\begin{tabular}{lp{4in}}
If[BOOL, & \\
\{series of commands\}] & Evaluates the BOOL expression
once. If it evaluates to True, the series of commands are performed.
Each command must be followed by a semi-colon or carriage return.  If
the BOOL evaluates to FALSE, none of the commands are performed.\\
If[BOOL, & \\
\{series of commands\}, & \\
\{series of commands\}] & Evaluates the BOOL expression
once. If it evaluates to True, the first series of commands are
performed.  Each command must be followed by a semi- colon or carriage
return.  If the BOOL evaluates to FALSE, the second series of
commands are performed. \\
While[BOOL, &\\
\{series of commands\}] & Evaluates the BOOL
expression or variable.  As long as it evaluates to True, the series
of commands are performed.  Each command must be followed by a
semi-colon or carriage return.  If the BOOL evaluates to FALSE, the
loop ends without performing the commands.\\
NOTE: & The While command functions as a
loop.  That is, it continues to perform the series of commands as long
as the expression evaluates to True.  The If statement, however, only
performs the series of commands once if the expression evaluates to
True.\\
For[\{expressions\}, & \\
\{expression\}, & \\
\{expressions\}, & \\
\{statements\}] & Evaluates the first set of expressions as initialization;
afterwards, so long as the second parameter (which must evaluate to a 
BOOL value) remains True, executes the statement body followed by the
third parameter expressions in a fashion similar to the While command.
\end{tabular}

\section{Advanced topics}

\subsection{Including files}

The function {\tt Include[TEXT]} is used to insert the contents of the file
given into the input stream, as if they had been typed directly by the user.
This can be particularly useful in conjunction with user defined functions, in that
a library of useful functions can be constructed and included into the program
easily.

The {\tt Include} directive may only appear at the ``top level'' of the
program.  That is to say, it cannot be used inside a loop, function declaration, or expression.  However, files may be nested arbitrarily deep using
{\tt Include}, so you can include a file which in turn includes other files.
  
\subsection{User defined functions}

As GCL programs become more and more complex, frequently there are complicated
operations which must be performed repeatedly.  The command language therefore
supports user-defined functions, which allow for defining sections of code
which may be called later.

A new function can be created using the function
\verb+NewFunction+.  For example, one might define a function to compute
the absolute value of an {\tt INTEGER} as such:

\begin{verbatim}
NewFunction[Abs[n->INTEGER],
                 If[n > 0, n, If[n < 0, -n, 0]]]
\end{verbatim}

\noindent After defining the \verb+Abs+ function, it may be called in exactly
the same way a system-supplied predefined function may.  The return value
of the function is the value of the last statement executed. 

Parameter type matching rules apply to user defined functions in exactly the
same way as to predefined functions.  From the function's point of view,
the parameter list is a list of variables on which assignments are
automatically done at the beginning of the function execution.  So, taking
the \verb+Abs+ example above, in executing the call

\begin{verbatim}
Abs[42]
\end{verbatim}

\noindent an assignment \verb+n := 42+ is implicitly performed before the
body of the function is executed.

It is also possible to pass variables by ``reference'' to a user-defined
function in the same way as a predefined function.  In this case, the
function's ``local'' variable is stored in the same physical location in the
computer, and modifying the value locally also takes effect on the variable
passed to the function.  For example, it might
be useful instead to define \verb+Abs+ as:

\begin{verbatim}
NewFunction[Abs[n<->INTEGER],
		 If[n > 0, n, If[n < 0, n := -n, 0]]]
\end{verbatim}

\noindent in which case the function would still return the absolute value
of \verb+n+, but also modify the variable passed to \verb+n+ to be the
absolute value of the input \verb+n+.  So,

\begin{verbatim}
q := -37;
Abs[q]
\end{verbatim}

\noindent would result in the variable \verb+q+ containing the value 37
at the conclusion of execution.

Each function has its own ``scope'', or set of variables.  Within a function
body, the only variables which are visible are those which are declared
in the parameter list of the function (this is \verb+n+ in the \verb+Abs+
example above), and those which are created during the function's execution.
That is, no ``global'' or outside variables may be accessed directly by the
function.  For example, if the user typed in the following:

\begin{verbatim}
i := 4;
NewFunction[FooFunc[x->INTEGER], x * i]
\end{verbatim}

\noindent later execution of the \verb+FooFunc+ would yield an ``undefined
variable i'' error message, since \verb+i+ is never defined within the
function.  If instead \verb+FooFunc+ had been defined as follows:

\begin{verbatim}
NewFunction[FooFunc[x->INTEGER], i := 13, x * i]
\end{verbatim}

\noindent \verb+FooFunc+ would always return 13 times the value of the
parameter \verb+x+, since the value of \verb+i+ inside \verb+FooFunc+ is
always 13, regardless of the value of \verb+i+ outside of the function.


\subsection{Extensive forms}

\subsubsection{Creating a new extensive form}

The function {\tt NewEfg[]} can be used to create a new extensive form game.
In order to do anything with it, a variable should be created to be
the new extensive form game.  Thus, the command

\begin{verbatim}
e := NewEfg[]
\end{verbatim}

\noindent will create a new extensive form game stored in \verb+e+.  The game 
is a trivial game with only one node, a \verb+root node+, and one
player, \verb+chance+.  By default, the game will have its data stored
as \verb+FLOAT+.  You can create a game whose data is \verb+RATIONAL+,
and which has two players, named \verb+Fred+ and \verb+Alice+  by
specifying 


\begin{verbatim}
e := NewEfg[True, {"Fred", "Alice"} ]
\end{verbatim}

\subsubsection{Modifying an extensive form}

The extensive form game editing functions can be used to build up any
valid extensive form game from a trivial game.  The following sequence
of commands builds the game tree for a simple poker game as described
in \cite{Mye:91}

\begin{verbatim}
e := NewEfg[];
n := RootNode[e];
deal := NewInfoset[ Chance[e], {"Red", "Black"}];
AppendNode[n, deal];
fred := NewPlayer[e,"Fred"];
fredred := NewInfoset[ fred , {"Raise", "Fold"} ];
fredblack := NewInfoset[ fred , {"Raise", "Fold"} ];
AppendNode[n#1, fredred];
AppendNode[n#2, fredblack];
alice := NewPlayer[e,"Alice"];
alicemove := NewInfoset[ alice , {"Meet", "Pass"} ];
AppendNode[n#1#1, alicemove]; 
AppendNode[n#2#1, alicemove]; 
\end{verbatim}

\noindent Outcomes can be defined and attached:

\begin{verbatim}
ante := 1.00;
raise := 1.00;
win := SetPayoff[NewOutcome[e, "Win"],{ante,-ante}];
winbig := SetPayoff[NewOutcome[e, "Win Big"],{ante+raise,-ante-raise}];
lose := SetPayoff[NewOutcome[e, "Lose"],{-ante,ante}];
losebig := SetPayoff[NewOutcome[e, "Lose Big"],{-ante-raise,ante+raise}];
AttachOutcome[n#1#1#1,winbig];
AttachOutcome[n#1#1#2,win];
AttachOutcome[n#1#2,lose];
AttachOutcome[n#2#1#1,losebig];
AttachOutcome[n#2#1#2,win];
AttachOutcome[n#2#2,lose];
\end{verbatim}

\subsubsection{Saving and loading extensive forms}

Once an extensive form game has been constructed, it can be saved by
the command 

\begin{verbatim}
SaveEfg[e, "filename.efg" ]
\end{verbatim}

\noindent where \verb+e+ is the extensive form game, and \verb+filename.efg+ is
the filename of the file to be created.  It is recommended that the
filename extension \verb+.efg+ be used when saving extensive form
games, as the Gambit graphics user interface recognizes this extension
as containing extensive form games.  Once an extensive form game has
been saved to an external file, it can be loaded by the command
\verb+LoadEfg+, as follows:

\begin{verbatim}
e := LoadEfg["filename.efg" ]
\end{verbatim}

\subsection{Normal forms}

\subsubsection{Creating a new normal form}

The function \verb+NewNfg[]+ is used to create a new normal form game.
In order to do anything with it, a variable should be created to be
the new extensive form game.  Thus, the command

\begin{verbatim}
n := NewNfg[{3,2,2}]
\end{verbatim}

\noindent 
will create a new normal form game stored in \verb+n+, with three players, where
the first player has three strategies, and the second and third
players each have two strategies.  The game has zero payoffs in each
strategy profile.  By default, the game will have its data stored in
\verb+FLOAT+.  You can create a game whose data is \verb+RATIONAL+
by specifying the parameter \verb+rational+ to be \verb+True+.

\subsubsection{Creating a normal form from an extensive form}

A normal form game can also be created from an extensive form game.
If \verb+e+ is an extensive form game, then the command 

\begin{verbatim}
n := Nfg[e]
\end{verbatim}

\noindent
will create a normal form game \verb+n+ which is the reduced normal
form game associated with the extensive form game \verb+e+.  As long
as the game \verb+n+ is not edited, then the GCL will ``remember'' the
extensive form game that \verb+n+ is associated with.  Any mixed
strategy solutions computed on the normal form game \verb+n+ can be
converted back to a behavior strategy of the game \verb+e+ by using
the command \verb+Behav+.  Thus

\begin{verbatim}
n := Nfg[e];
m := LcpSolve[n];
i :=1;
b := {};
While[ i<=Length[m],
  b := b +{ Behav[m[[i]],e] };
  i:=i+1;
  ];
b
\end{verbatim}

\noindent
will convert the game \verb+e+ to reduced normal form, solve it using
the LcpSolve algorithm, and then convert all mixed profiles found back
to behavior profiles, and display the list, \verb+b+ of behavior
profiles found. 
  
\subsubsection{Modifying a normal form}

The normal form game payoff editing functions can be used to build up any
valid normal form game from a trivial game.  Thus, the command

\begin{verbatim}
SetPayoff[n,{2,1,2},{3.0,4.0,1.5}]
\end{verbatim}

\noindent
changes the payoff for the strategy profile in which player one adopts
his second strategy, player 2 adopts her first strategy and player
three adopts his second strategy to the vector \verb+(3.0,4.0,1.5)+,
meaning that player one's payoff is \verb+3.0+, the second player's
payoff is \verb+4.0+ and the third player's payoff is \verb+1.5+.

\subsubsection{Saving and loading normal forms}

Once an normal form game has been constructed, it can be saved in a
similar way to an extensive form game.  The command 

\begin{verbatim}
SaveNfg[n, "filename.nfg" ]
\end{verbatim}

\noindent
will save the normal form game \verb+n+ to the file
\verb+filename.nfg+.  It is recommended that the
filename extension \verb+.nfg+ be used when saving normal form games, as
the Gambit Graphics user interface recognizes this extension as
containing normal form games.  Once a noirmal form game has been
saved to an external file, it can be loaded by the command
\verb+LoadNfg+, as follows:

\begin{verbatim}
n := LoadNfg["filename.nfg" ]
\end{verbatim}

\section{Solving games}

\subsection{Enum}

The two {\tt Enum} functions can be used to enumerate the pure or
mixed Nash equilibria for a normal form game. 

The {\tt EnumPureSolve} function enumerates all pure strategy Nash
equilibria in the support of a normal form game.  This
algorithm simply investigates all pure strategy profiles, checking
each for the Nash equilibrium conditions.  By default, the algorithm
finds all pure strategy Nash equilibrium.  Optionally it can be set to
find the first \verb+k+ Nash equilibria.  This algorithm will work on
any normal form game.  

The {\tt EnumMixedSolve} function enumerates all Nash equilibria (pure and
mixed) for a given support of a two person normal form
game.  More precisely, it finds the set of extreme points of the
components of the set of Nash equilibria.  The procedure is to
enumerate the set of complementary basic feasible solutions. (See, eg
\cite[1964]{Man:64}.)  By default, all equilibria are found.
Optionally, it can be set to find the first \verb+k+ equilibria.  
This algorithm works only on two-person normal form games.  

\subsection{Gobit}

The {\tt GobitSolve} function computes a branch of the logistic
quantal response equilibrium correspondence (as described in
\cite{McKPal:95a} for normal form games, and in
\cite{McKPal:95b} for extensive form games.  The branch is
computed for values of $\lambda$ between $\underline{\lambda}$ and
$\bar{\lambda}.$ The algorithm starts at $\lambda_0 =
\underline{\lambda}$ if $\delta>0,$ or $\lambda_0 = \bar{\lambda}$ if
$\delta<0$. It then increments according to the formula
$$
\lambda_{t+1} = \lambda_t +\delta \lambda_t^a,
$$ 
where $\underline\lambda,$ $\bar\lambda,$ $\delta,$ and $a$ are
parameters that can be specified.  In the computation for the first value of
$\lambda_0$, the algorithm begins its search for a solution at a user
specified starting point.  At each
successive value of $\lambda_t,$ the algorithm begins its search at
the point found in step $t - 1.$ 

The {\em principal branch} of the logistic quantal response
equilibrium mapping is the branch that is connected to the centroid of
the game at $\lambda = 0$.  This branch can be computed by setting
$\lambda_0$ sufficiently small.  As discussed in McKelvey and Palfrey,
for generic normal form games, the principal branch of the quantal
response equilibrium correspondence converges to a unique selection
from the set of Nash equilibria as $\lambda$ goes to infinity.
Similarly, for generic extensive form games, the principal branch of
the quantal response mapping converges to a unique selection from the
set of sequential equilibria as $\lambda$ goes to infinity.  Hence, in
extensive form games, this algorithm can be used to compute an
approximation to a sequential equilibrium.

The {\tt GobitGridSolve} function performs a grid search to compute
the {\em complete} logistic quantal response correspondence.  Points
are evaluated in terms of the value of an objective function, that
measures the distance between the original point, and the best
response to the best response (under the logistic best response
function.)  Points that are close (within 'tol') to being fixed points
are kept, others are discarded.  Values of the probabilities are
evaluated on a grid of mesh 'delp.'  This procedure is very
computationally intensive, and is only feasible for small two-person
normal form games.

\subsection{Linear Complementarity Program}

The {\tt LcpSolve} function formulates and solves the game as a linear
complementarity problem.  This algorithm works for two person
games in either extensive or normal form.  
 
For a normal form game, the game is solved via the Lemke-Howson
Algorithm.  (See, eg.,
\cite{LemHow:64}) using lexicographic rule for insuring
termination, as developed in \cite{Eav:71}.  This algorithm can also
be used to find the set of {\em accessible} Nash equilibria, by
tracing out the pattern of connectedness of the complemenary basic
feasible solutions, as described in \cite{Sha:74}.  The set of
accessible equilibria is frequently the same as the set of all Nash
equilibria, but this is not always so.

For an extensive form game, this algorithm implements Koller, Megiddo
and von Stengel's {\em sequence form} (\cite{KolMegSte:94}. The
sequence form is a formulation of the set of Nash equilibria as the
solution to a non linear complementarity problem in variables that
correspond to ``sequences'' in the extensive form, which they show can
be solved by Lemke's algorithm for Linear complementarity problems.
The method has nice properties in terms of its computational
complexity, as it only grows linearly in the size of the extensive
form game.  

\subsection{Lyapunov Function}

The {\tt LiapSolve} function finds Nash equilibria via the Lyapunov
function method described in \cite{McK:91}.  This method works on
either the extensive or normal form.  This algorithm casts the problem
as a function minimization problem by use of a Lyapunov function for
Nash equilibria.  This is a continuously differentiable non negative
function whose zeros coincide with the set of Nash equilibria of the
game.  A standard descent algorithm is used to find a constrained
local minimum of the function from any given starting location.  Since
a local minimum need not be a global minimum (with value 0,) the
algorithm is not guaranteed to find a Nash equilibrium from any fixed
starting point.  The algorithm thus incorporates the capability of
restarting.  The algorithm starts from the initial starting point
determined by the parameter 'start'.  If a Nash equilibrium is not
found, it will keep searching from new randomly chosen starting points
until a Nash equilibrium has been found or the maximum number of tries
(parameter 'ntries') is exceeded, whichever comes first.

\subsection{Linear Program}

Finds the minmimax solution (a Nash equilibrium) for a two person
constant-sum game in normal form, by solving it as a Linear Program.

\subsection{Simpicial Subdivision}

Computes a Nash equilibrium to a n-person normal form game based on a
simplicial subdivision algorithm.  The algorithm implemented is that
of \cite{VTH:1987}.  The algorithm is a simplicial subdivision
algorithm which can start at any point in the simplex.  The algorithm
starts with a given grid size, follows a path of almost completely
labeled subsimplexes, and converges to a completely labeled
sub-simplex that approximates the solution.  Additional accuracy is
obtained by refining the grid size and restarting from the previously
found point.  The idea is that by restarting at a close approximation
to the solution, each successive increase in accuracy will yield a
short path, and hence be quick.

In its pure form, the algorithm is guaranteed to find at least one
mixed strategy equilibrium to any n-person game.  Experience shows
that the algorithm works well, and is acceptably fast for many
moderate size problems.  But in some examples it can be quite slow.
The reason for this is that sometimes after restarting with a refined
grid size, even though the starting point is a good approximation to
the solution, the algorithm will go to the boundary of the simplex
before converging back to a point that is close to the original
starting point.  When this occurs, each halving of the grid size will
take twice as long to converge as the previous grid size.  If a high
degree of accuracy is required, or if the normal form is large, this
can result in the algorithm taking a long time to converge.

In order to combat the above difficulty, a parameter 'leash' has been
added to the algorithm which places a limit on the distance which the
algorithm can wander from the restart point. (Setting this parameter
to 0 results in no limit, and gives the pure form of the algorithm.)
With this parameter set to a non trivial value, the algorithm is no
longer guaranteed to converge, and setting small values of the
parameter will sometimes yield lack of convergence.  However,
experience shows that values of the parameter on the order of 10
generally do not destroy convergence, and yield much faster
convergence.

\section{Function Reference, by Category}

This section contains a list of functions, organized by
category.  For a description of each function, and the arguments,
refer to the following, alphabetically organized, section.

\subsection{General Functionality}

\begin{verbatim}
Assign[x<->T, y->T] =: T
Include[file->TEXT]
NewFunction[name[argument-list], body]
Quit
UnAssign[x<->T] =: T
\end{verbatim}

\subsection{Flow Control}

\begin{verbatim}
For[start, test, incr, body]
If[condition, t, f]
While[test, statements]
\end{verbatim}

\subsection{Lists}

\begin{verbatim}
Contains[list->LIST(T), x->T] =: BOOL
Length[list->LIST(T)] =: INTEGER
NthElement[list->LIST(T),n->INTEGER] =: T 
Plus[x->LIST(T), y->LIST(T)] =: LIST(T)
Remove[list->LIST(T), n->INTEGER] =: LIST(T)
\end{verbatim}

\subsection{String Functions}

\begin{verbatim}
Greater[x->TEXT, y->TEXT] =: BOOL
GreaterEqual[x->TEXT, y->TEXT] =: BOOL
Length[text->TEXT] =: INTEGER
Less[x->TEXT, y->TEXT] =: BOOL
LessEqual[x->TEXT, y->TEXT] =: BOOL
NthChar[text->TEXT, n->INTEGER] =: TEXT
Plus[x->TEXT, y->TEXT] =: TEXT
\end{verbatim}


\subsection{Input and Output}

\begin{verbatim}
LoadEfg[file->TEXT] =: EFG
LoadNfg[file->TEXT] =: NFG
Output[file->TEXT] =: OUTPUT
SaveEfg[efg<->EFG, file->TEXT] =: EFG
SaveNfg[nfg<->NFG, file->TEXT] =: NFG
SaveNfg[support->NFSUPPORT, file->TEXT] =: NFSUPPORT
SetFormat[{width->INTEGER}, {precis->INTEGER}, 
          {expmode->BOOL}, {quoted->BOOL}] =: OUTPUT
Write[output->OUTPUT, x->BEHAV] =: OUTPUT
Write[output->OUTPUT, x->BOOL] =: OUTPUT 
Write[output->OUTPUT, x<->EFG] =: OUTPUT
Write[output->OUTPUT, x->FLOAT] =: OUTPUT
Write[output->OUTPUT, x->INTEGER] =: OUTPUT
Write[output->OUTPUT, x->MIXED] =: OUTPUT
Write[output->OUTPUT, x<->NFG] =: OUTPUT
Write[output->OUTPUT, x->RATIONAL] =: OUTPUT
Write[output->OUTPUT, x->TEXT] =: OUTPUT
\end{verbatim}

\subsection{Logic}

\begin{verbatim}
And[x->BOOL, y->BOOL] =: BOOL
Equal[x->T, y->T] =: BOOL
Not[x->BOOL] =: BOOL
NotEqual[x->T, y->T] =: BOOL
Or[x->BOOL, y->BOOL] =: BOOL
\end{verbatim}

\subsection{Arithmetic}

\begin{verbatim}
Divide[x->FLOAT, y->FLOAT] =: FLOAT
Divide[x->RATIONAL, y->RATIONAL] =: RATIONAL
Exp[x->FLOAT] =: FLOAT
Greater[x->FLOAT, y->FLOAT] =: BOOL
Greater[x->INTEGER, y->INTEGER] =: BOOL
Greater[x->RATIONAL, y->RATIONAL] =: BOOL
GreaterEqual[x->FLOAT, y->FLOAT] =: BOOL
GreaterEqual[x->INTEGER, y->INTEGER] =: BOOL
GreaterEqual[x->RATIONAL, y->RATIONAL] =: BOOL
IntegerDivide[x->INTEGER, y->INTEGER] =: INTEGER
Less[x->FLOAT, y->FLOAT] =: BOOL
Less[x->INTEGER, y->INTEGER] =: BOOL
Less[x->RATIONAL, y->RATIONAL] =: BOOL
LessEqual[x->FLOAT, y->FLOAT] =: BOOL
LessEqual[x->INTEGER, y->INTEGER] =: BOOL
LessEqual[x->RATIONAL, y->RATIONAL] =: BOOL
Log[x->FLOAT] =: FLOAT
Minus[x->FLOAT, y->FLOAT] =: FLOAT
Minus[x->INTEGER, y->INTEGER] =: INTEGER
Minus[x->RATIONAL, y->RATIONAL] =: RATIONAL
Minus[x->MIXED, y->MIXED] =: MIXED
Minus[x->BEHAV, y->BEHAV] =: BEHAV
Modulus[x->INTEGER, y->INTEGER] =: INTEGER
Negate[x->FLOAT] =: FLOAT
Negate[x->INTEGER] =: INTEGER
Negate[x->RATIONAL] =: RATIONAL
Paren[x->T] =: T
Plus[x->FLOAT, y->FLOAT] =: FLOAT
Plus[x->INTEGER, y->INTEGER] =: INTEGER
Plus[x->RATIONAL, y->RATIONAL] =: RATIONAL
Plus[x->MIXED, y->MIXED] =: MIXED
Plus[x->BEHAV, y->BEHAV] =: BEHAV
Times[x->FLOAT, y->FLOAT] =: FLOAT
Times[x->INTEGER, y->INTEGER] =: INTEGER
Times[x->RATIONAL, y->RATIONAL] =: RATIONAL
Times[x->FLOAT, y->MIXED] =: MIXED
Times[x->MIXED, y->FLOAT] =: MIXED
Times[x->RATIONAL, y->MIXED] =: MIXED
Times[x->MIXED, y->RATIONAL] =: MIXED
Times[x->FLOAT, y->BEHAV] =: BEHAV
Times[x->BEHAV, y->FLOAT] =: BEHAV
Times[x->RATIONAL, y->BEHAV] =: BEHAV
Times[x->BEHAV, y->RATIONAL] =: BEHAV
\end{verbatim}

\subsection{Extensive Form Manipulation}

\begin{verbatim}
AppendAction[infoset->INFOSET] =: ACTION
AppendNode[node->NODE, infoset->INFOSET] =: NODE
AttachOutcome[node->NODE, outcome->OUTCOME] =: OUTCOME
Behav[efg<->EFG, {list->LIST(LIST(LIST(FLOAT)))}] =: BEHAV
Behav[efg<->EFG, {list->LIST(LIST(LIST(RATIONAL)))}] =: BEHAV
CopyTree[from->NODE, to->NODE] =: NODE
DeleteAction[infoset->INFOSET, action->ACTION] =: ACTION
DeleteNode[node->NODE, keep->NODE] =: NODE
DeleteOutcome[outc->OUTCOME] =: BOOL
DeleteTree[node->NODE] =: NODE
DetachOutcome[node->NODE] =: NODE
InsertAction[infoset->INFOSET, at->ACTION] =: ACTION
InsertNode[node->NODE, infoset->INFOSET] =: NODE
%JoinInfoset[node->NODE, infoset->INFOSET] =: NODE
LeaveInfoset[node->NODE] =: INFOSET
MergeInfosets[infoset1->INFOSET,
               infoset2->INFOSET] =: INFOSET
MoveTree[from->NODE, to->NODE] =: NODE
NewEfg[{rational->BOOL}, {players->LIST(TEXT)}] =: EFG
NewInfoset[player->EFPLAYER, actions->LIST(TEXT),
           {name->TEXT}] =: INFOSET
NewInfoset[player->EFPLAYER, actions->INTEGER,
           {name->TEXT}] =: INFOSET
NewOutcome[efg<->EFG, {name->TEXT}] =: OUTCOME
NewPlayer[efg<->EFG, {name->TEXT}] =: EFPLAYER 
NewSupport[efg<->EFG] =: EFSUPPORT
RandomEfg[efg<->EFG, {seed->INTEGER}] =: EFG
Reveal[infoset->INFOSET, who->LIST(EFPLAYER))] =: INFOSET
SetChanceProbs[infoset->INFOSET, probs->LIST(FLOAT)] =: INFOSET
SetChanceProbs[infoset->INFOSET, probs->LIST(RATIONAL)] =: INFOSET
SetComponent[mixed<->MIXED, player->PLAYER, list->LIST(T)] =: MIXED 
SetComponent[behav<->BEHAV, infoset->INFOSET, list->LIST(T)] =: BEHAV 
SetName[x->ACTION, name->TEXT] =: ACTION
SetName[x<->EFG, name->TEXT] =: EFG
SetName[x->INFOSET, name->TEXT] =: INFOSET
SetName[x->NODE, name->TEXT] =: NODE
SetName[x->OUTCOME, name->TEXT] =: OUTCOME
SetName[x->PLAYER, name->TEXT] =: PLAYER
SetPayoff[outcome->OUTCOME, payoff->LIST(FLOAT)] =: OUTCOME
SetPayoff[outcome->OUTCOME, payoff->LIST(RATIONAL)] =: OUTCOME
SetPayoff[node->NODE, payoff->LIST(FLOAT)] =: OUTCOME
SetPayoff[node->NODE, payoff->LIST(RATIONAL)] =: OUTCOME
\end{verbatim}

\subsection{Normal Form Manipulation}

\begin{verbatim}
AddStrategy[support->NFSUPPORT, strategy->STRATEGY] =: NFSUPPORT
Mixed[nfg<->NFG, list->LIST(LIST(FLOAT))] =: MIXED
Mixed[nfg<->NFG, list->LIST(LIST(RATIONAL))] =: MIXED
Mixed[support->NFSUPPORT, {list->LIST(LIST(FLOAT))}] =: MIXED
Mixed[support->NFSUPPORT, {list->LIST(LIST(RATIONAL))}] =: MIXED
NewNfg[dim->LIST(INTEGER), {rational->BOOL}] =: NFG
NewSupport[nfg<->NFG] =: NFSUPPORT
RandomNfg[nfg<->NFG, {seed->INTEGER}] =: NFG
RemoveStrategy[support->NFSUPPORT, strategy->STRATEGY] =: NFSUPPORT
SetName[x<->NFG, name->TEXT] =: NFG
SetPayoff[list->LIST(INTEGER), payoffs->LIST(FLOAT)] =: LIST(INTEGER)
SetPayoff[list->LIST(INTEGER), payoffs->LIST(RATIONAL)] =: LIST(INTEGER)
\end{verbatim}

\subsection{Conversions}

\begin{verbatim}
Float[x->INTEGER] =: FLOAT
Float[x->FLOAT] =: FLOAT
Float[x->RATIONAL] =: FLOAT
List[mixed->MIXED] =: LIST(LIST(T))
List[behav->BEHAV] =: LIST(LIST(LIST(T)))
Nfg[efg<->EFG, {time<->FLOAT}] =: NFG
Rational[x->INTEGER] =: RATIONAL
Rational[x->FLOAT] =: RATIONAL
Rational[x->RATIONAL] =: RATIONAL
Text[x->INTEGER] =: TEXT
Text[x->FLOAT] =: TEXT
Text[x->RATIONAL] =: TEXT
Text[x->TEXT] =: TEXT
\end{verbatim}

\subsection{Solving and analyzing games}

\begin{verbatim}
Behav[mixed->MIXED] =: BEHAV
%ElimAllDom[nfg<->NFG | support->NFSUPPORT, {strong->BOOL}, 
%   {time<->FLOAT}] =: NFSUPPORT 
ElimDom[nfg<->NFG | support->NFSUPPORT, {strong->BOOL}, 
   {time<->FLOAT}] =: NFSUPPORT 
EnumMixedSolve[nfg<->NFG | support->NFSUPPORT, {stopAfter->INTEGER},
               {nPivots<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
EnumPureSolve[nfg<->NFG | support->NFSUPPORT, {stopAfter->INTEGER}, 
              {time<->FLOAT}] =: LIST(MIXED) 
GobitSolve[efg<->EFG | start->BEHAV, {pxifile->TEXT},
           {minLam->FLOAT}, {maxLam->FLOAT},
           {delLam->FLOAT}, {powLam->INTEGER},
           {fullGraph->BOOL}, {maxitsN->INTEGER}, {tolN->FLOAT},
           {maxits1->INTEGER}, {tol1->FLOAT}, {time<->FLOAT},
           {nEvals<->INTEGER}, {nIters<->INTEGER}] =: LIST(BEHAV)
GobitSolve[nfg<->NFG | start->MIXED, {pxifile->TEXT},
           {minLam->FLOAT}, {maxLam->FLOAT},
           {delLam->FLOAT}, {powLam->INTEGER},
           {fullGraph->BOOL}, {maxitsN->INTEGER}, {tolN->FLOAT},
           {maxits1->INTEGER}, {tol1->FLOAT}, {time<->FLOAT},
           {nEvals<->INTEGER}, {nIters<->INTEGER}] =: LIST(MIXED)
GobitGridSolve[nfg<->NFG | support->NFSUPPORT, {pxifile->TEXT},
              {minLam->FLOAT}, {maxLam->FLOAT}, 
              {delLam->FLOAT}, {powLam->INTEGER}, 
              {delp->FLOAT}, {tol->FLOAT},
              {nEvals<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
LcpSolve[efg<->EFG, {stopAfter->INTEGER},
         {nPivots<->INTEGER}, {time<->FLOAT}] =: LIST(BEHAV)
LcpSolve[nfg<->NFG | support->NFSUPPORT, {stopAfter->INTEGER},
         {nPivots<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
LiapSolve[efg<->EFG | start->BEHAV, 
          {stopAfter->INTEGER}, {nTries->INTEGER},
          {maxitsN->INTEGER}, {tolN->FLOAT},
          {maxits1->INTEGER}, {tol1->FLOAT},
          {time<->FLOAT}, {nEvals<->INTEGER}] =: LIST(BEHAV)
LiapSolve[nfg<->NFG | start->MIXED, 
          {stopAfter->INTEGER}, {nTries->INTEGER},
          {maxitsN->INTEGER}, {tolN->FLOAT},
          {maxits1->INTEGER}, {tol1->FLOAT},
          {time<->FLOAT}, {nEvals<->INTEGER}] =: LIST(MIXED)
LpSolve[ nfg<->NFG | support->NFSUPPORT, {nPivots<->INTEGER},
        {time<->FLOAT}] =: LIST(MIXED)
SetOptions[alg->TEXT, param->TEXT, value->T] =: T
SimpDivSolve[nfg<->NFG | support->NFSUPPORT, {stopAfter->INTEGER}, 
             {nRestarts->INTEGER}, {leashLength->INTEGER},
             {nEvals<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
\end{verbatim}

\subsection{Getting Information}

\begin{verbatim}
Actions[infoset->INFOSET] =: LIST(ACTION)
Centroid[efg<->EFG | support->EFSUPPORT] =: BEHAV
Centroid[nfg<->NFG | support->NFSUPPORT] =: MIXED
Chance[efg<->EFG] =: EFPLAYER
ChanceProbs[infoset->INFOSET] =: LIST(T)
HasOutcome[node->NODE] =: BOOL
Infoset[node->NODE] =: INFOSET
Infosets[player->EFPLAYER] =: LIST(INFOSET)
IsPredecessor[node->NODE, of->NODE] =: BOOL
IsRoot[node->NODE] =: BOOL
IsSuccessor[node->NODE, from->NODE] =: BOOL
LastAction[node->NODE] =: ACTION
Members[infoset->INFOSET] =: LIST(NODE)
Name[x->ACTION] =: TEXT
Name[x<->EFG] =: TEXT
Name[x->EFPLAYER] =: TEXT
Name[x->INFOSET] =: TEXT
Name[x<->NFG] =: TEXT
Name[x->NFPLAYER] =: TEXT
Name[x->NODE] =: TEXT
Name[x->OUTCOME] =: TEXT
Name[x->STRATEGY] =: TEXT
NextSibling[node->NODE] =: NODE
Nodes[efg<->EFG] =: LIST(NODE)
NonterminalNodes[efg<->EFG] =: LIST(NODE)
NthChild[node->NODE, n->INTEGER] =: NODE
NumActions[infoset->INFOSET] =: INTEGER
NumChildren[node->NODE] := INTEGER
NumInfosets[player->EFPLAYER] =: INTEGER
NumMembers[infoset->INFOSET] =: INTEGER
NumNodes[efg<->EFG] =: INTEGER
NumOutcomes[efg<->EFG] =: INTEGER
NumPlayers[efg<->EFG] =: INTEGER
NumPlayers[nfg<->NFG] =: INTEGER
NumStrats[player->NFPLAYER, {support->NFSUPPORT}] =: INTEGER
Outcome[node->NODE] =: OUTCOME
Outcomes[efg<->EFG] =: LIST(OUTCOME)
Parent[node->NODE] =: NODE
Payoff[outcome->OUTCOME] =: LIST(T)
Payoff[strategy->BEHAV] =: LIST(T)
Payoff[strategy->MIXED] =: LIST(T)
Player[infoset->INFOSET] =: EFPLAYER
Player[node->NODE] =: EFPLAYER
Players[efg<->EFG] =: LIST(EFPLAYER)
Players[nfg<->NFG] =: LIST(NFPLAYER)
PriorSibling[node->NODE] =: NODE
RealizProbs[strategy->BEHAV] =: LIST(T)
RootNode[efg<->EFG] =: NODE
TerminalNodes[efg<->EFG] =: LIST(NODE)
\end{verbatim}

\subsection{Timing}

\begin{verbatim}
ElapsedTime[] =: FLOAT
IsWatchRunning[] =: BOOL
StartWatch[] =: FLOAT
StopWatch[] =: FLOAT
\end{verbatim}


\section{Function Reference, Alphabetical}

The following is a list of procedures with the operations that they
perform in the Gambit Command Language:

Variable types in all capital letters indicate the type of the
required parameter or return value of the procedure.

The symbol {\tt "=:"} to the right of a procedure specifies the type
of the return value (if any exists) produced by the procedure.

Paremeters enclosed in brackets {\tt "\{ \}"} represent optional
parameters which are not necessary for the procedure to function.

\begin{itemize}

%--A--

\item
\protect \large \begin{verbatim} 
Actions[infoset->INFOSET] =: LIST(ACTION)
\end{verbatim}\normalsize

\bd
Returns the list of actions available at the information set
\verb+infoset+.
\item
[See also:] {\tt AppendAction}, {\tt DeleteAction}, {\tt InsertAction},
{\tt NumActions}.
\ed

\item
\protect \large \begin{verbatim}
ActionValues[strategy->BEHAV, infoset->INFOSET] =: LIST(FLOAT)
ActionValues[strategy->BEHAV, infoset->INFOSET] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns the list of values at information set \verb+infoset+ for each
action for the player making the decision at \verb+infoset+, assuming that
all players obey the behavioral strategy profile \verb+strategy+.
\item
[See also:] {\tt Beliefs}, {\tt InfosetProbs}, {\tt NodeValues},
{\tt RealizProbs}.
\ed

\item
\protect \large \begin{verbatim}
AddStrategy[support->NFSUPPORT, strategy->STRATEGY] =: NFSUPPORT
\end{verbatim}\normalsize

\bd
Adds the strategy \verb+strategy+ to the
strategies in the support \verb+support+.  If \verb+strategy+ is already in the
support, no action is taken.  The modified support is returned.
\item
[See also:] {\tt NewSupport}, {\tt RemoveStrategy}.
\ed

\item 
\protect \large \begin{verbatim}
And[x->BOOL, y->BOOL] =: BOOL
\end{verbatim} \normalsize

\bd
Computes the logical conjunction of \verb+x+ and \verb+y+.
\item
[Short forms:] \verb+x && y+, \verb+x AND y+.
\ed


\item
\protect \large \begin{verbatim}
AppendAction[infoset->INFOSET] =: ACTION
\end{verbatim}\normalsize

\bd
Adds an action into the information set \verb+infoset+,
as the last action.  Returns the newly created action.
\item
[See also:] {\tt Actions}, {\tt DeleteAction}, {\tt InsertAction},
{\tt NumActions}.
\ed


\item
\protect \large \begin{verbatim} 
AppendNode[node->NODE, infoset->INFOSET] =: NODE
\end{verbatim}\normalsize

\bd
Places \verb+node+ into the information set
\verb+infoset+.  The result is \verb+node+ becomes a decision node,
with number of branches equal to the number of actions in \verb+infoset+.
Returns the first child of \verb+node+.
\item
[See also:] {\tt InsertNode}, {\tt NewInfoset}.
\ed

\item 
\protect \large \begin{verbatim}
Assign[x<->T, y->T] =: T
\end{verbatim} \normalsize

\bd
Assigns the value \verb+y+ to the variable referred to by
\verb+x+.  Returns the value assigned.
\item
[Short form:] \verb+x := y+
\item
[See also:] {\tt UnAssign}.
\ed

\item
\protect \large \begin{verbatim} 
AttachOutcome[node->NODE, outcome->OUTCOME] =: OUTCOME
\end{verbatim}\normalsize

\bd
Attaches the outcome \verb+outcome+ to the node \verb+node+.
Returns the outcome attached.  Note that nonterminal nodes may have
attached outcomes.
\item
[See also:] {\tt DetachOutcome}, {\tt HasOutcome}, {\tt Outcome}.
\ed

%--B--


\item
\protect \large \begin{verbatim}
Behav[efg<->EFG, list->LIST(LIST(LIST(T)))] =: BEHAV
\end{verbatim}\normalsize

\bd
Creates a behavioral profile for the game \verb+efg+ with values equal
to that in \verb+list+.  
\item
[See also:] {\tt Mixed}.
\ed

\item
\protect \large \begin{verbatim}
Behav[mixed->MIXED, efg<->EFG] =: BEHAV
\end{verbatim}\normalsize

\bd
Converts the mixed profile \verb+mixed+ to the equivalent
behavioral profile on the associated extensive form game \verb+efg+.
\ed

\item
\protect \large \begin{verbatim}
Beliefs[strategy->BEHAV] =: LIST(FLOAT)
Beliefs[strategy->BEHAV] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns a list of the conditional probabilities of
being at a node given that a player knows he is in that node's information
set, if all players are playing the behavioral strategy profile
\verb+strategy+.  The list is ordered according to the prefix-traversal
order of the game tree, the same order in which the list of nodes is
returned by {\tt Nodes}.
\ed


%--C--

\item
\protect \large \begin{verbatim} 
Centroid[efg<->EFG | support->EFSUPPORT] =: BEHAV
\end{verbatim}\normalsize

\bd
Returns a behavioral profile for the extensive form
support \verb+efg+ initialized to the centroid, that is, the behavioral
profile in which all actions at each information set are equally
likely to be chosen.  If \verb+efg+ is specified, the support is the
full support.  
\ed

\item
\protect \large \begin{verbatim}
Centroid[nfg<->NFG | support->NFSUPPORT] =: MIXED
\end{verbatim}\normalsize

\bd
Returns a mixed profile over the support \verb+support+
initialized to the centroid, that is, the mixed profile in which 
all strategies in the support for each player are equally likely to be
chosen, and all strategies not in the support are chosen with probability
zero.  If \verb+nfg+ is specified, the support is the full support.  
\ed

\item
\protect \large \begin{verbatim}
Chance[efg<->EFG] =: EFPLAYER
\end{verbatim}\normalsize

\bd
Returns the chance, or nature, player defined on the
extensive form game \verb+efg+.  Each extensive form has exactly one
chance player predefined, and it is not possible to define any additional
chance players.
\ed

\item
\protect \large \begin{verbatim}
ChanceProbs[infoset->INFOSET] =: LIST(FLOAT)
ChanceProbs[infoset->INFOSET] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns the vector of probabilities over the actions at
information set \verb+infoset+ as a list.  A run-time error results if
the given information set does not belong to the chance player.
\ed

\item
\protect \large \begin{verbatim}
Contains[list->LIST(T), x->T] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the value \verb+x+ is contained in the list
\verb+list+.
\item
[See also:] {\tt Length}, {\tt Subscript}.
\ed

\item
\protect \large \begin{verbatim}
CopyTree[from->NODE, to->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Copies the subtree rooted at \verb+from+ to the terminal
node \verb+to+ in the same extensive form game.  The nodes in the
copied subtree belong to the same information sets as their counterparts in
the original subtree.  Returns the node \verb+to+.
\item
[See also:] {\tt MoveTree}, {\tt Reveal}.
\ed

%--D--

\item
\protect \large \begin{verbatim}
DeleteAction[infoset->INFOSET, action->ACTION] =: INFOSET
\end{verbatim}\normalsize

\bd
Deletes the action \verb+action+ from the information set
\verb+infoset+.  As a consequence, the corresponding subtrees associated
with the action from each member of the information set are deleted.
Returns the information set.
\item
[See also:] {\tt Actions}, {\tt AppendAction}, {\tt InsertAction},
{\tt NumActions}.
\ed

\item
\protect \large \begin{verbatim}
DeleteNode[node->NODE, keep->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Deletes the node \verb+node+ from the tree.  The
subtree rooted in node \verb+keep+, which must be a child of
\verb+node+, is kept, and \verb+keep+ takes the place of \verb+node+ in
the tree.  All other subtrees descending from \verb+node+ are deleted.
The kept node \verb+keep+ is returned.
\item
[See also:] {\tt DeleteTree}, {\tt InsertNode}.
\ed

\item
\protect \large \begin{verbatim}
DeleteOutcome[outcome->OUTCOME] =: BOOL
\end{verbatim}\normalsize

\bd
Removes the outcome \verb+outcome+ from its extensive
form game.  All nodes with the specified outcome attached are reset to
having no outcome attached; this is equivalent to an implicit call to
{\tt DetachOutcome} on these nodes.  Returns \verb+True+ on success.
\item
[See also:] {\tt NewOutcome}.
\ed

\item
\protect \large \begin{verbatim}
DeleteTree[node->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Deletes the subtree rooted at the node \verb+node+.  The
node then becomes a terminal node, which is returned.
\item
[See also:] {\tt DeleteNode}.
\ed

\item
\protect \large \begin{verbatim}
DetachOutcome[node->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Sets the outcome associated with \verb+node+ to be the
null outcome.  If there is no outcome associated with \verb+node+ no
action is taken.  Returns \verb+node+.
\item
[See also:] {\tt AttachOutcome}, {\tt Outcome}.
\ed

\item 
\protect \large \begin{verbatim}
Divide[x->FLOAT, y->FLOAT] =: FLOAT
Divide[x->RATIONAL, y->RATIONAL] =: RATIONAL
\end{verbatim} \normalsize

\bd
Returns the quotient $x / y$. 
\item
[Short form:] \verb+x / y+
\item
[See also:] {\tt IntegerDivide}
\ed

%--E--

\item
\protect \large \begin{verbatim}
ElapsedTime[] =: FLOAT
\end{verbatim}\normalsize

\bd
If the system stopwatch is currently running, returns the
time elapsed since the stopwatch was started.  If the system stopwatch
is not runnign, returns the time elapsed during the last period during which
the stopwatch was running.
\item
[See also:] {\tt IsWatchRunning}, {\tt StartWatch}, {\tt StopWatch}.
\ed

%\item
%\protect \large \begin{verbatim}
%ElimAllDom[nfg<->NFG | support->NFSUPPORT, {strong->BOOL}, 
%        {time<->FLOAT} =: NFSUPPORT
%\end{verbatim} \normalsize
%
%\bd
%Successively eliminates dominated strategies in a support
%\verb+support+ of a normal form game, returning the final support.  
%\item
%[Seealso:] {\tt ElimDom}
%\ed

\item
\protect \large \begin{verbatim}
ElimDom[nfg<->NFG | support->NFSUPPORT, {strong->BOOL}, 
        {time<->FLOAT} =: NFSUPPORT
\end{verbatim} \normalsize

\bd
Finds dominated strategies in a support \verb+support+ of a normal
form game.  By default, all weakly dominated strategies are eliminated;
if the optional parameter \verb+strong+ is specified and is \verb+True+,
only strongly dominated strategies are eliminated.  Returns a new support
containing only the undominated strategies.  If the returned support
is equal to the input support \verb+support+, no dominated strategies were
found.  The optional parameter \verb+time+, if specified, upon completion
contains the amount of time consumed by the elimination.  (Note that in
the current implementation, only strategies that are dominated by
other {\em pure} strategies are eliminated.)  
\ed

\item
\protect \large \begin{verbatim}
EnumMixedSolve[nfg<->NFG | support->NFSUPPORT, {stopAfter->INTEGER},
               {nPivots<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
\end{verbatim}\normalsize

\bd
Returns the extreme points of the set of all Nash equilibria (pure or
mixed) for a given support, \verb+support+, of a two person normal form
game.  By default, all equilibria are found; the optional parameter
\verb+stopAfter+ may be used to specify a maximum number of
equilibria.  Upon completion, \verb+nPivots+ returns the number of
pivots done by the algorithm, and
\verb+time+ returns the amount of time consumed by the function.
\item
[See also:] {\tt EnumPureSolve}.
\ed

\item
\protect \large \begin{verbatim}
EnumPureSolve[nfg<->NFG | support->NFSUPPORT, {stopAfter->INTEGER}, 
              {time<->FLOAT}] =: LIST(MIXED) 
\end{verbatim}\normalsize

\bd
Returns all pure strategy Nash equilibria in the support, \verb+support+,
of a normal form game.  By default, all equilibria are found; the optional
parameter \verb+stopAfter+ may be used to specify a maximum number of
equilibria.  Upon completion, \verb+time+ returns the amount of time
consumed by the function. 
\item
[See also:] {\tt EnumMixedSolve}.
\ed

\item
\protect \large \begin{verbatim}
Equal[x->T, y->T] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the two objects \verb+x+ and \verb+y+ are
equal.
\item
[Short form:] \verb+x = y+.
\item
[See also:] {\tt NotEqual}.
\ed

\item
\protect \large \begin{verbatim}
Exp[x->FLOAT] =: FLOAT
\end{verbatim} \normalsize

\bd
Returns the value of the function ${\rm e}^{x}$ for the
value \verb+x+.
\item
[See also:] {\tt Log}.
\ed


%--F--

\item
\protect \large \begin{verbatim}
Float[x->INTEGER] =: FLOAT
Float[x->FLOAT] =: FLOAT
Float[x->RATIONAL] =: FLOAT
\end{verbatim} \normalsize

\bd
Returns the value \verb+x+ as a value of type {\tt FLOAT}.
In the case where \verb+x+ is {\tt RATIONAL}, this may result in a loss
of precision.
\item
[See also:] {\tt Rational}.
\ed

\item
\protect \large \begin{verbatim}
For[start, test, incr, body]
\end{verbatim}\normalsize

\bd
Executes $start$, then repeatedly evaluates $body$ and $incr$
until $test$ fails to give $True$.
\item
[See also:] \verb+While+.
\ed

%--G--

\item
\protect \large \begin{verbatim}
GobitSolve[efg<->EFG | start->BEHAV, {pxifile->TEXT},
           {minLam->FLOAT}, {maxLam->FLOAT},
           {delLam->FLOAT}, {powLam->INTEGER},
           {fullGraph->BOOL}, {maxitsN->INTEGER}, {tolN->FLOAT},
           {maxits1->INTEGER}, {tol1->FLOAT}, {time<->FLOAT},
           {nEvals<->INTEGER}, {nIters<->INTEGER}] =: LIST(BEHAV)
GobitSolve[nfg<->NFG | start->MIXED, {pxifile->TEXT},
           {minLam->FLOAT}, {maxLam->FLOAT},
           {delLam->FLOAT}, {powLam->INTEGER},
           {fullGraph->BOOL}, {maxitsN->INTEGER}, {tolN->FLOAT},
           {maxits1->INTEGER}, {tol1->FLOAT}, {time<->FLOAT},
           {nEvals<->INTEGER}, {nIters<->INTEGER}] =: LIST(MIXED)
\end{verbatim}\normalsize

\bd 
Computes a branch of the logistic quantal response equilibrium
correspondence.  The first version computes for an extensive form
game, and the second version for a normal form game.  \verb+start+ is
used as the starting point for the computation of $\lambda_{0}$.  The
behavior of the algorithm may be modified by specifying some of the
following optional parameters:
\bd
\item
[pxifile:] Generate output to this file for later retrieval and viewing by
the PXI program.  By default no output file is generated.
\item
[minLam:] Sets $\underline{\lambda}$, the minimum value of $\lambda$.  The 
default value is $\underline{\lambda}=0.01$.
\item
[maxLam:] Sets $\overline{\lambda}$, the maximum value of $\lambda$.  The
default value is $\overline{\lambda}=30.0$.
\item
[delLam:] Sets the constant $\delta$ used in incrementing $\lambda$.  The
default value is $\delta=0.01$.
\item
[powLam:] Sets the exponent $a$ used in incrementing $\lambda$.  The default
value is $a=1$, producing geometric incrementing.  Setting $a=0$ corresponds
to linear incrementing.
\item
[fullGraph:] If \verb+True+, the list of behavioral strategy profiles
returned contains the full sequence of profiles computed from each successive
value of $\lambda$.  The default value is \verb+False+, in which case only
the profile for the last value of $\lambda$ computed is returned.
\item
[maxitsN:] Sets the maximum number of iterations for the $n$-dimensional
optimization routine.  The default value is $200$.
\item
[tolN:] Sets the tolerance for the $n$-dimensional optimization routine.
The default is $1.0^{-10}$.
\item
[maxits1:] Sets the maximum number of iterations for the 1-dimensional
optimization routine.  The default is $100$.
\item
[tol1:] Sets the tolerance for the 1-dimensional optimization routine.
The default is $2.0^{-10}$.
\item
[time:] Upon completion, contains the amount of time consumed by the
algorithm.
\item
[nEvals:] Upon completion, contains the number of function evaluations
performed by the algorithm.
\item
[nIters:] Upon completion, contains the number of iterations performed
by the algorithm.
\ed
\ed

\item
\protect \large \begin{verbatim}
GobitGridSolve[nfg<->NFG | support->NFSUPPORT, {pxifile->TEXT},
              {minLam->FLOAT}, {maxLam->FLOAT}, 
              {delLam->FLOAT}, {powLam->INTEGER}, 
              {delp->FLOAT}, {tol->FLOAT},
              {nEvals<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
\end{verbatim}\normalsize

\bd
Computes the complete logistic quantal response correspondence for a
(small) two-person normal form game, for values of $\lambda$ between
$\underline{\lambda}$ and $\bar{\lambda}.$ 

\item
[Return value:] The List of Mixed (or Behavior) profiles found -- one
profile for each value of $\lambda_t$, from lowest to highest. 

\item
[Required parameters:]\hfil\null
	
\bd
\item  
[nfg:] The two person game in normal form which is to be operated on.
\ed

\item
[Optional parameters:]  See GobitSolve[] for additional parameters.

\bd
\item
[delp:] Grid size for search over probability space.  Default is $0.02$ .
\item
[tol:] The tolerance on the objective function.  Values of $p$ for
which the objective function is less this value are kept.  The default
is $0.02$.  
\ed
\ed

\item
\protect \large \begin{verbatim}
Greater[x->INTEGER, y->INTEGER] =: BOOL
Greater[x->FLOAT, y->FLOAT] =: BOOL
Greater[x->RATIONAL, y->RATIONAL] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the value of \verb+x+ is greater than
that of \verb+y+.
\item
[Short form:] \verb+x > y+
\item
[See also:] {\tt GreaterThan}, {\tt Less}, {\tt LessEqual}.
\ed

\item
\protect \large \begin{verbatim}
Greater[x->TEXT, y->TEXT] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the string \verb+x+ is lexicographically greater than
the string \verb+y+, using the native character set of the machine.
\item
[Short form:] \verb+x > y+
\item
[See also:] {\tt GreaterThan}, {\tt Less}, {\tt LessEqual}.
\ed

\item
\protect \large \begin{verbatim}
GreaterEqual[x->INTEGER, y->INTEGER] =: BOOL
GreaterEqual[x->FLOAT, y->FLOAT] =: BOOL
GreaterEqual[x->RATIONAL, y->RATIONAL] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the value of \verb+x+ is at least that of
\verb+y+.
\item
[Short form:] \verb+x >= y+
\item
[See also:] {\tt Greater}, {\tt Less}, {\tt LessEqual}.
\ed

\item
\protect \large \begin{verbatim}
GreaterEqual[x->TEXT, y->TEXT] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the string \verb+x+ is lexicographically greater than
or equal to the string \verb+y+, using the native character set of the
machine.
\item
[Short form:] \verb+x >= y+
\item
[See also:] {\tt Greater}, {\tt Less}, {\tt LessEqual}.
\ed

%--H--


\item
\protect \large \begin{verbatim}
HasOutcome[node->NODE] =: BOOL
\end{verbatim} \normalsize

\bd
Returns whether the node \verb+node+ currently has an outcome associated
with it.
\item
[See also:] {\tt AttachOutcome}, {\tt DetachOutcome}, {\tt Outcome}.
\ed

%--I--

\item 
\protect \large \begin{verbatim}
If[condition, statements]
If[condition, statements, alternative]
\end{verbatim} \normalsize
  
\bd
If antecedent is True, evaluates $t$.  If
antecedent is false, evaluates $f$. 
\ed


\item
\protect \large \begin{verbatim}
Include[file->TEXT]
\end{verbatim}\normalsize

\bd
Includes the commands in the specified file as commands
in the running GCL program.  The program treats the command as if it
were replaced by the contents of the file.  \verb+Include+ may only be used
at the ``top level'', that is, it cannot be used inside of \verb+NewFunction+
or flow control structures.
\ed

\item
\protect \large \begin{verbatim}
Infoset[node->NODE] =: INFOSET
\end{verbatim}\normalsize

\bd
Returns the information set to which the node \verb+node+
belongs.  All nonterminal nodes belong to an information set.  Terminal
nodes belong to an information set, and a call to this function using
a terminal node will result in a run-time error.
\ed

\item
\protect \large \begin{verbatim}
InfosetProbs[strategy->BEHAV] =: LIST(FLOAT)
InfosetProbs[strategy->BEHAV] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns a (nested) list of the probabilities of reaching all information
sets in an extensive form game, given that all players obey the
behavioral strategy profile \verb+strategy+.  The $i$th element
in the list returned is a list of the probabilities for the information
sets owned by player $i$.
\item
[See also:] {\tt ActionValues}, {\tt Beliefs}, {\tt NodeValues},
{\tt RealizProbs}.
\ed

\item
\protect \large \begin{verbatim}
Infosets[player->EFPLAYER] =: LIST(INFOSET)
\end{verbatim}\normalsize

\bd
Returns the list of information sets at which player
\verb+player+ has the decision.
\ed

\item
\protect \large \begin{verbatim}
InsertAction[infoset->INFOSET, at->ACTION] =: ACTION
\end{verbatim}\normalsize

\bd
Inserts a new action into the information set \verb+infoset+
before the action \verb+at+.  The corresponding new branch is created for
each node belonging to the information set.  Returns the newly created action.
\item
[See also:] {\tt Actions}, {\tt AppendAction}, {\tt DeleteAction},
{\tt NumActions}.
\ed

\item
\protect \large \begin{verbatim}
InsertNode[node->NODE, infoset->INFOSET] =: NODE
\end{verbatim}\normalsize

\bd
Inserts a new node in the tree at the location of
node \verb+node+.  The
new node is placed in the information set \verb+infoset+, and the
corresponding number of branches are created from the new node.  \verb+node+
becomes the first child of the new node.  Returns the new node.
\item
[See also:] {\tt AppendNode}, {\tt NewInfoset}.
\ed

\item 
\protect \large \begin{verbatim}
IntegerDivide[x->INTEGER, y->INTEGER] =: INTEGER
\end{verbatim} \normalsize

\bd
Returns the quotient $x / y$, rounded to the next integer
towards zero.
\item
[Short form:] \verb%x DIV y%
\item
[See also:] \verb+Modulus+.
\ed

\item
\protect \large \begin{verbatim}
IsPredecessor[node->NODE, of->NODE] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the node \verb+node+ is a predecessor
in the tree of the node \verb+of+.  For the purposes of this function,
a node is considered its own predecessor.
\item
[See also:] {\tt IsSuccessor}.
\ed

\item
\protect \large \begin{verbatim}
IsRoot[node->NODE] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the node \verb+node+ is the root node of its
extensive form.
\item
[See also:] {\tt Parent}.
\ed

\item
\protect \large \begin{verbatim}
IsSuccessor[node->NODE, from->NODE] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the node \verb+node+ is a successor
in the tree of the node \verb+from+.  For the purposes of this function,
a node is considered its own successor.
\item
[See also:] {\tt IsPredecessor}.
\ed

\item
\protect \large \begin{verbatim}
IsWatchRunning[] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the system stopwatch is currently running.
\item
[See also:] {\tt ElapsedTime}, {\tt StartWatch}, {\tt StopWatch}.
\ed

%--J--

% Not yet implemented
%\item
%\protect \large \begin{verbatim}
%JoinInfoset[node->NODE, infoset->INFOSET] =: NODE
%\end{verbatim}\normalsize
%
%\bd
%Makes the node \verb+node+ a member of the information set
%\verb+infoset+.  If the previous information set of \verb+node+ was
%a singleton (i.e., it contained only \verb+node+), it is removed from the
%extensive form.  It is a run-time error if the number of actions at the
%information set does not match the number of branches at the node.
%Returns the node \verb+node+.
%\item
%[See also:] {\tt LeaveInfoset}, {\tt MergeInfosets}.
%\ed

%--K--

%--L--

\item
\protect \large \begin{verbatim} 
LastAction[node->NODE] =: ACTION
\end{verbatim}\normalsize

\bd
Returns the action corresponding to the branch leading to
the node \verb+node+.  It is a run-time error if the node \verb+node+ is
the root node of the tree and thus has no such action.
\ed

\item
\protect \large \begin{verbatim}
LcpSolve[efg<->EFG | support->EFSUPPORT, {stopAfter->INTEGER},
         {nPivots<->INTEGER}, {time<->FLOAT}] =: LIST(BEHAV)
LcpSolve[nfg<->NFG | support->NFSUPPORT, {stopAfter->INTEGER},
         {nPivots<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
\end{verbatim}\normalsize

\bd
Solves the game as a Linear Complementarity Problem, using the
Lemke-Howson Algorithm for normal form games, and the
Koller-Meggiddo-Stengel Sequence form for extensive form games.  

\item
[Required parameters:]\hfil\null

\bd
\item
[nfg:] The game in normal form for which the solution is to be
searched.
\item
[efg:] The game in normal form for which the solution is to be
searched.
\item
[support:] The support for which the game is to be solved. 
\ed

\item
[Optional parameters:]\hfil\null

\bd
\item
[stopAfter:] Specifies the maximum number of equilibria to find.  If
not specified, the default value is zero, which means that all
equilibria reachable by the algorithm are to be found.
\item
[nPivots:] The total number of pivots. 
\item
[time:] Returns the elapsed time for the operation.
\ed
\ed

\item
\protect \large \begin{verbatim}
LeaveInfoset[node->NODE] =: INFOSET
\end{verbatim}\normalsize

\bd
Removes the node \verb+node+ from the information set to
which it currently belongs and places it in a newly created
singleton information set belonging to the same player.  If \verb+node+
is already the only member of its information set, no action is taken.
Returns information set to which \verb+node+ belongs upon completion.
\item
[See also:] {\tt JoinInfoset}, {\tt MergeInfosets}.
\ed

\item
\protect \large \begin{verbatim}
Length[text->TEXT] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of characters in the text string
\verb+text+.
\item
[See also:] {\tt NthChar}.
\ed

\item
\protect \large \begin{verbatim}
Length[list->LIST(T)] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of elements in the list \verb+list+.
\item
[See also:] {\tt NthElement}.
\ed

\item
\protect \large \begin{verbatim}
Less[x->INTEGER, y->INTEGER] =: BOOL
Less[x->FLOAT, y->FLOAT] =: BOOL
Less[x->RATIONAL, y->RATIONAL] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whehter the value of \verb+x+ is less than that of
\verb+y+.
\item
[Short form:] \verb+x < y+
\item
[See also:] {\tt Greater}, {\tt GreaterEqual}, {\tt LessEqual}.
\ed

\item
\protect \large \begin{verbatim}
Less[x->TEXT, y->TEXT] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the string \verb+x+ is lexicographically less than
the string \verb+y+, using the native character set of the machine.
\item
[Short form:] \verb+x < y+
\item
[See also:] {\tt Greater}, {\tt GreaterEqual}, {\tt LessEqual}.
\ed

\item
\protect \large \begin{verbatim}
LessEqual[x->INTEGER, y->INTEGER] =: BOOL
LessEqual[x->FLOAT, y->FLOAT] =: BOOL
LessEqual[x->RATIONAL, y->RATIONAL] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the value of \verb+x+ is no more than that
of \verb+y+.
\item
[Short form:] \verb+x <= y+
\item
[See also:] {\tt Greater}, {\tt GreaterEqual}, {\tt Less}.
\ed

\item
\protect \large \begin{verbatim}
LessEqual[x->TEXT, y->TEXT] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the string \verb+x+ is lexicographically less than
the string \verb+y+, using the native character set of the machine.
\item
[Short form:] \verb+x <= y+
\item
[See also:] {\tt Greater}, {\tt GreaterEqual}, {\tt Less}.
\ed

\item
\protect \large \begin{verbatim}
LiapSolve[efg<->EFG | start->BEHAV, 
          {stopAfter->INTEGER}, {nTries->INTEGER},
          {maxitsN->INTEGER}, {tolN->FLOAT},
          {maxits1->INTEGER}, {tol1->FLOAT},
          {time<->FLOAT}, {nEvals<->INTEGER}] =: LIST(BEHAV)
LiapSolve[nfg<->NFG | start->MIXED, 
          {stopAfter->INTEGER}, {nTries->INTEGER},
          {maxitsN->INTEGER}, {tolN->FLOAT},
          {maxits1->INTEGER}, {tol1->FLOAT},
          {time<->FLOAT}, {nEvals<->INTEGER}] =: LIST(MIXED)
\end{verbatim}\normalsize


\bd
Searches for a Nash by minimizing a Lyapunov function which is zero
exactly at Nash equilibria.  The algorithm starts from the initial
starting point determined by the parameter 'start'.  The algorithm is
not guaranteed to find a Nash equilibrium from any fixed starting
point.  The algorithm thus incorporates the capability of restarting.
If a Nash equilibrium is not found, it will keep searching from new
randomly chosen starting points until a Nash equilibrium has been
found or the maximum number of tries (parameter 'ntries') is exceeded,
whichever comes first.
\item
[Return value:] Returns the list of solutions found.
\item
[Required parameters:] Exactly one of the following \hfil\null

\bd
\item
[nfg:] The game in normal form for which the Liapunov solution is to
be found.
\item
[efg:] The game in extensive form for which the Liapunov solution is
to be found.
\ed

\item
[Optional parameters:]\hfil\null

\bd
\item
[start:] Sets the starting profile for the descent algorithm.  The
default is the centroid.
\item
[nTries:] Sets the maximum number of attempts at finding each
equilibrium. Default is 10
\item
[stopAfter:] Sets the number of equilibria to find.  Has a default
value of 1.  
\item
[maxits1:] Sets the maximum number of iterations in the
1-dimensional line search.  Default is 100.
\item
[maxitsN:] Sets the maximum number of iterations in the
n-dimensional optimization.  
\item
[tolN:] Sets the tolerance for the n-dimensional optimization
routine.  Default is 1.0e-10.
\item
[tol1:] Sets the tolerance for the 1-dimensional line search.
Default is 2.0e-10.
\item
[time:] Returns the elapsed time for the operation.
\item
[nEvals:] Returns the number of function evaluations for the operation.
\ed
\ed



\item
\protect \large \begin{verbatim}
List[mixed->MIXED] =: LIST(LIST(T))
List[behav->BEHAV] =: LIST(LIST(LIST(T)))
\end{verbatim}\normalsize

\bd 
Returns the probabilities of each strategy for each player for a
mixed strategy profile, or the probabilities of each action at each
information of each player for a behavior strategy profile.  The
ordering of information sets is in indexed traversal order.  The type
\verb+T+ of the list is the same as the type of \verb+behav+ or
\verb+mixed+.
\item
[See also:] {\tt Behav, Mixed}.
\ed

\item
\protect \large \begin{verbatim}
LoadEfg[file->TEXT] =: EFG
\end{verbatim}\normalsize

\bd
Loads an extensive form game from an external savefile
and returns the game.
\item
[See also:] {\tt SaveEfg}.
\ed

\item
\protect \large \begin{verbatim}
LoadNfg[file->TEXT] =: NFG
\end{verbatim}\normalsize

\bd
Loads a normal form game from an external savefile
and returns the game.  
\item
[See also:] {\tt SaveNfg}.
\ed

\item
\protect \large \begin{verbatim}
Log[x->FLOAT] =: FLOAT
\end{verbatim} \normalsize

\bd
Computes the natural logarithm of \verb+x+.
\item
[See also:] {\tt Exp}.
\ed

\item
\protect \large \begin{verbatim}
LpSolve[ nfg<->NFG | support->NFSUPPORT, {nPivots<->INTEGER},
        {time<->FLOAT}] =: LIST(MIXED)
\end{verbatim}\normalsize

\bd
Finds the minmimax solution (a Nash equilibrium) for a
two person constant-sum game, by solving it as a Linear Program.
\item
[Required parameters:]
\bd
\item
[nfg:] The game in normal form for which the solutions are to be found.  
\ed

\item
[Optional parameters:]\hfil\null

\bd
\item[nPivots:] Number of pivots. 
\item[time:] Elapsed time for the operation.
\ed
\ed

%--M--

\item
\protect \large \begin{verbatim}
Members[infoset->INFOSET] =: LIST(NODE)
\end{verbatim}\normalsize

\bd
Returns the list of nodes which are members of the information
set \verb+infoset+.
\ed

\item
\protect \large \begin{verbatim}
MergeInfosets[infoset1->INFOSET,
              infoset2->INFOSET] =: INFOSET
\end{verbatim}\normalsize

\bd
Moves all the nodes from \verb+infoset2+ into \verb+infoset1+.
It is a run-time error if the number of actions is not the same at the
two information sets.  \verb+infoset2+ is deleted from the extensive form,
and \verb+infoset1+ is returned.
\ed

\item 
\protect \large \begin{verbatim}
Minus[x->INTEGER, y->INTEGER] =: INTEGER
Minus[x->FLOAT, y->FLOAT] =: FLOAT
Minus[x->RATIONAL, y->RATIONAL] =: RATIONAL
Minus[x->MIXED, y->MIXED] =: MIXED
Minus[x->BEHAV, y->BEHAV] =: BEHAV
\end{verbatim} \normalsize

\bd
Returns the difference $x - y$.
\item
[Short form:] \verb+x - y+
\ed


\item
\protect \large \begin{verbatim}
Mixed[nfg<->NFG | support->NFSUPPORT, list->LIST(LIST(T))] =: MIXED
\end{verbatim}\normalsize

\bd
Creates a mixed profile attached for the normal form game \verb+nfg+
with values given by list.  
\item
[See also:] {\tt Behav}.
\ed


\item
\protect \large \begin{verbatim}
Modulus[x->INTEGER, y->INTEGER] =: INTEGER
\end{verbatim}\normalsize

\bd
Computes the remainder from dividing \verb+y+ into \verb+x+.
\item
[Short form:] \verb+x MOD y+
\item
[See also:] {\tt Divide}.
\ed


\item
\protect \large \begin{verbatim}
MoveTree[from->NODE, to->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Moves the subtree rooted at \verb+from+ to
the terminal node \verb+to+.  \verb+from+ becomes a terminal node.
Returns \verb+to+.
\item
[See also:] {\tt CopyTree}.
\ed

%--N--

\item
\protect \large \begin{verbatim}
Name[x->ACTION] =: TEXT
Name[x<->EFG] =: TEXT
Name[x->EFPLAYER] =: TEXT
Name[x->INFOSET] =: TEXT
Name[x<->NFG] =: TEXT
Name[x->NFPLAYER] =: TEXT
Name[x->NODE] =: TEXT
Name[x->OUTCOME] =: TEXT
Name[x->STRATEGY] =: TEXT
\end{verbatim}\normalsize

\bd
Returns the name of the object \verb+x+.
\item
[See also:] {\tt SetName}.
\ed

\item 
\protect \large \begin{verbatim}
Negate[x->FLOAT] =: FLOAT
Negate[x->INTEGER] =: INTEGER
Negate[x->RATIONAL] =: RATIONAL
\end{verbatim} \normalsize

\bd
Returns $-x$.
\item
[Short form:] \verb+-x+
\ed


\item
\protect \large \begin{verbatim} 
NewEfg[{rational->BOOL}, {players->LIST(TEXT)}] =: EFG
\end{verbatim}\normalsize

\bd
Creates a new extensive form game.  By default, the
outcomes and probabilities associated with the game will be stored as
{\tt FLOAT}.  If the \verb+rational+ parameter is specified and is \verb+True+,
these values will be stored as {\tt RATIONAL}.  The default extensive form
game has no players (other than the chance player) defined on it; the
optional parameter \verb+players+ specifies a list of players to be
created and the names to be assigned to them.  Returns the newly created
game.
\ed

\item   
\protect \large \begin{verbatim}
NewFunction[name[argument-list], body]
\end{verbatim}\normalsize

\bd
Creates a new function.  The function may be called exactly
as if it were a predefined function of the command language.  See the
section on user-defined functions for more detailed information.
\ed

\item
\protect \large \begin{verbatim} 
NewInfoset[player->EFPLAYER, actions->LIST(TEXT),
            {name->TEXT}] =: INFOSET
NewInfoset[player->EFPLAYER, actions->INTEGER,
            {name->TEXT}] =: INFOSET
\end{verbatim}\normalsize

\bd
Creates a new information set belonging to \verb+player+.
If the integer version of \verb+actions+ is used, the information set
will contain that number of actions, each named with the empty string.
Alternatively, the list version of \verb+actions+ causes the information
set to have the same number of actions as the list has elements, with
the actions named by the corresponding element in the list.  (In either
case, the number of actions specified must be positive.)  The optional
parameter \verb+name+ allows a name to be specified for the information
set; by default it is labeled by the empty string.  The newly created
information set is returned.
\ed

\item
\protect \large \begin{verbatim}
NewNfg[dim->LIST(INTEGER), {rational->BOOL}] =: NFG
\end{verbatim}\normalsize

\bd
Creates a new normal form game with dimensionality \verb+dim+.
By default, the payoffs and probabilities associated with the game will
be stored as {\tt FLOAT}.  If the \verb+rational+ parameter is specified
and is \verb+True+, these values will be stored as {\tt RATIONAL}.
No initialization of the payoffs of the game is done.
Returns the newly created game.
\ed

\item
\protect \large \begin{verbatim} 
NewOutcome[efg<->EFG, {name->TEXT}] =: OUTCOME
\end{verbatim}\normalsize

\bd
Defines a new outcome in the extensive form game \verb+efg+.
By default the outcome is named with the empty string; the optional parameter
\verb+name+, if specified, gives the name of the new outcome.  Returns the
newly created outcome.
\item
[See also:] {\tt DeleteOutcome}.
\ed

\item
\protect \large \begin{verbatim}
NewPlayer[efg<->EFG, {name->TEXT}] =: EFPLAYER 
\end{verbatim}\normalsize

\bd
Defines a new player in the extensive form game \verb+efg+.
By default the player is named with the empty string; the optional parameter
\verb+name+, if specified, gives the name of the new player.  Returns the
newly created player.
\ed

\item
\protect \large \begin{verbatim}
NewSupport[efg<->EFG] =: EFSUPPORT
\end{verbatim}\normalsize

\bd
Creates and returns a new support on the extensive form
game \verb+nfg+.  The support contains all actions at every
information set for all players.
\ed

\item
\protect \large \begin{verbatim}
NewSupport[nfg<->NFG] =: NFSUPPORT
\end{verbatim}\normalsize

\bd
Creates and returns a new support on the normal form
game \verb+nfg+.  The support contains all strategies for all players.
\item
[See also:] {\tt AddStrategy}, {\tt RemoveStrategy}.
\ed

\item
\protect \large \begin{verbatim}
NextSibling[node->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Returns the next sibling of the node \verb+node+.
\item
[See also:] {\tt PriorSibling}.
\ed

\item
\protect \large \begin{verbatim}
Nfg[efg<->EFG, {time<->FLOAT}] =: NFG
\end{verbatim}\normalsize

\bd
Creates and returns the reduced normal form game equivalent
to the extensive form game \verb+efg+.  The optional parameter \verb+time+,
if specified, contains upon completion the amount of time consumed by
the transformation.
\ed

\item
\protect \large \begin{verbatim} 
Nodes[efg<->EFG] =: LIST(NODE)
\end{verbatim}\normalsize

\bd
Returns the list of nodes in the extensive form game
\verb+efg+ in prefix-traversal order of the tree.
\item
[See also:] {\tt NonterminalNodes}, {\tt NumNodes}, {\tt TerminalNodes}.
\ed

\item
\protect \large \begin{verbatim}
NodeValues[strategy->BEHAV, player->EFPLAYER] =: LIST(FLOAT)
NodeValues[strategy->BEHAV, player->EFPLAYER] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns a list containing the expected payoff to the player \verb+player+
at each node in an extensive form game, given that all players are obeying
the behavioral strategy profile \verb+strategy+.  The list is ordered
in the prefix traversal order of the tree, the same order as returned
by the function {\tt Nodes}.
\item
[See also:] {\tt ActionValues}, {\tt Beliefs}, {\tt InfosetProbs},
{\tt RealizProbs}.
\ed

\item
\protect \large \begin{verbatim} 
NonterminalNodes[efg<->EFG] =: LIST(NODE)
\end{verbatim}\normalsize

\bd
Returns the list of nonterminal nodes in the extensive form
game \verb+efg+ in prefix-traversal order of the tree.
\item
[See also:] {\tt Nodes}, {\tt NumNodes}, {\tt TerminalNodes}.
\ed

\item
\protect \large \begin{verbatim}
Not[x->BOOL] =: BOOL
\end{verbatim}\normalsize

\bd
Returns the boolean inverse of \verb+x+.
\item
[Short forms:] \verb+NOT x+, \verb+!x+.
\ed

\item
\protect \large \begin{verbatim}
NotEqual[x->T, y->T] =: BOOL
\end{verbatim}\normalsize

\bd
Returns whether the values of \verb+x+ and \verb+y+ are
not equal.
\item
[Short form:] \verb+x != y+.
\item
[See also:] {\tt Equal}.
\ed

\item
\protect \large \begin{verbatim}
NthChar[text->TEXT, n->INTEGER] =: TEXT
\end{verbatim}\normalsize

\bd
Returns a text string of length 1 containing the \verb+n+th
character from the string \verb+text+.  By convention, the first character
in a string is indexed by 1.
\item
[Short form:] \verb+text[[n]]+.
\item
[See also:] {\tt Length}.
\ed

\item
\protect \large \begin{verbatim} 
NthChild[node->NODE, n->INTEGER] =: NODE
\end{verbatim}\normalsize

\bd
Returns the \verb+n+th child of the node \verb+node+.
By convention, the first child of a node is indexed by 1.
\item
[Short form:] \verb+node#n+.
\item
[See also:] {\tt NumChildren}.
\ed

\item
\protect \large \begin{verbatim}
NthElement[list->LIST(T), n->INTEGER] =: T 
\end{verbatim}\normalsize

\bd
Returns the \verb+n+th element of the list \verb+list+.
By convention, the first element of a list is indexed by 1.
\item
[Short form:] \verb+list[[n]]+.
\item
[See also:] {\tt Length}.
\ed

\item
\protect \large \begin{verbatim}
NumActions[infoset->INFOSET] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of actions defined at the information
set \verb+infoset+.
\item
[See also:] {\tt Actions}.
\ed

\item
\protect \large \begin{verbatim}
NumChildren[node->NODE] := INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of children of the node \verb+node+.
\item
[See also:] {\tt NthChild}.
\ed

\item
\protect \large \begin{verbatim}
NumInfosets[player->EFPLAYER] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of information sets belonging to the
player \verb+player+.
\item
[See also:] {\tt Infosets}.
\ed

\item
\protect \large \begin{verbatim}
NumMembers[infoset->INFOSET] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of nodes belonging to the information
set \verb+infoset+.
\item
[See also:] {\tt Members}.
\ed

\item
\protect \large \begin{verbatim}
NumNodes[efg<->EFG] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of nodes in the tree of the extensive form
game \verb+efg+.
\item
[See also:] {\tt Nodes}.
\ed

\item
\protect \large \begin{verbatim}
NumOutcomes[efg<->EFG] =: INTEGER
\end{verbatim} \normalsize

\bd
Returns the number of outcomes defined on the extensive from
game \verb+efg+.
\item
[See also:] {\tt Outcomes}.
\ed

\item
\protect \large \begin{verbatim}
NumPlayers[efg<->EFG] =: INTEGER
\end{verbatim} \normalsize

\bd
Returns the number of players defined on the extensive form
game \verb+efg+.
\item
[See also:] {\tt Players}.
\ed

\item
\protect \large \begin{verbatim}
NumPlayers[nfg<->NFG] =: INTEGER
\end{verbatim} \normalsize

\bd
Returns the number of players defined on the normal form
game \verb+nfg+.
\item
[See also:] {\tt Players}.
\ed

\item
\protect \large \begin{verbatim}
NumStrats[player->NFPLAYER, {support->NFSUPPORT}] =: INTEGER
\end{verbatim}\normalsize

\bd
Returns the number of strategies for the player \verb+player+
in a normal form game.  By default, the total number of strategies is
returned; if \verb+support+ is specified, the number of strategies
for \verb+player+ in that support is returned instead.
\ed

%--O--

\item 
\protect \large \begin{verbatim}
Or[x->BOOL, y->BOOL] =: BOOL
\end{verbatim} \normalsize
  
\bd
Returns the disjunction of \verb+x+ and \verb+y+.
\item
[Short form:] \verb+x || y+, \verb+x OR y+.
\ed

\item
\protect \large \begin{verbatim}
Outcome[node->NODE] =: OUTCOME
\end{verbatim}\normalsize

\bd
Returns the outcome attached to the node \verb+node+.
\item
[See also:] {\tt AttachOutcome}, {\tt DetachOutcome}.
\ed

\item
\protect \large \begin{verbatim}
Outcomes[efg<->EFG] =: LIST(OUTCOME)
\end{verbatim}\normalsize

\bd
Returns the list of outcomes defined on the extensive form
game \verb+efg+.
\item
[See also:] {\tt DeleteOutcome}, {\tt NewOutcome}, {\tt NumOutcomes}.
\ed

\item
\protect \large \begin{verbatim}
Output[file->TEXT] =: OUTPUT
\end{verbatim}\normalsize

\bd
Opens a new output stream for writing to the file \verb+text+.
\item
[See also:] {\tt SetFormat}, {\tt Write}.
\ed

%--P--

\item
\protect \large \begin{verbatim}
Paren[x->T] =: T
\end{verbatim}\normalsize

\bd
Returns the value passed in \verb+x+.  This is used to control
the order of evaluation of expressions.
\item
[Short form:] \verb+(x)+
\ed

\item
\protect \large \begin{verbatim}
Parent[node->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Returns the parent node of \verb+node+.
\item
[See also:] {\tt IsRoot}.
\ed

\item
\protect \large \begin{verbatim}
Payoff[outcome->OUTCOME] =: LIST(FLOAT)
Payoff[outcome->OUTCOME] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns the payoffs associated with outcome \verb+outcome+
as a list.
\item
[See also:] {\tt SetPayoff}.
\ed

\item
\protect \large \begin{verbatim}
Payoff[nfg<->NFG, list->LIST(INTEGER)] =: LIST(FLOAT)
Payoff[nfg<->NFG, list->LIST(INTEGER)] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns the list of payoffs to all players in the normal form game
\verb+nfg+ in the contingency specified by \verb+list+.
\item
[See also:] {\tt SetPayoff}.
\ed

\item
\protect \large \begin{verbatim}
Payoff[strategy->BEHAV] =: LIST(FLOAT)
Payoff[strategy->BEHAV] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns the payoffs to each player in an extensive form game
if players follow the behavioral strategy profile \verb+strategy+.
\ed

\item
\protect \large \begin{verbatim}
Payoff[strategy->MIXED] =: LIST(FLOAT)
Payoff[strategy->MIXED] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns the payoffs to each player in a normal form game
if players follow the mixed strategy profile \verb+strategy+.
\ed

\item
\protect \large \begin{verbatim}
Player[infoset->INFOSET] =: EFPLAYER
\end{verbatim}\normalsize

\bd
Returns the player who makes the decision at the information
set \verb+infoset+.
\ed

\item
\protect \large \begin{verbatim}
Player[node->NODE] =: EFPLAYER
\end{verbatim}\normalsize

\bd
Returns the player who makes the decision at the node
\verb+node+.
\ed

\item
\protect \large \begin{verbatim}
Players[efg<->EFG] =: LIST(EFPLAYER)
\end{verbatim} \normalsize

\bd
Returns the list of players defined on the extensive form
game \verb+efg+.
\item
[See also:] {\tt NumPlayers}.
\ed

\item
\protect \large \begin{verbatim}
Players[nfg<->NFG] =: LIST(NFPLAYER)
\end{verbatim} \normalsize

\bd
Returns the list of players defined on the normal form
game \verb+nfg+.
\item
[See also:] {\tt NumPlayers}.
\ed

\item 
\protect \large \begin{verbatim}
Plus[x->INTEGER, y->INTEGER] =: INTEGER
Plus[x->FLOAT, y->FLOAT] =: FLOAT
Plus[x->RATIONAL, y->RATIONAL] =: RATIONAL
Plus[x->MIXED, y->MIXED] =: MIXED
Plus[x->BEHAV, y->BEHAV] =: BEHAV
\end{verbatim} \normalsize

\bd
Returns the sum of \verb+x+ and \verb+y+.
\item
[Short form:] \verb%x + y%
\ed

\item
\protect \large \begin{verbatim}
Plus[x->LIST(T), y->LIST(T)] =: LIST(T)
\end{verbatim}\normalsize

\bd
Returns the concatenation of the lists \verb+x+ and \verb+y+.
\item
[Short form:] \verb%x + y%
\ed

\item 
\protect \large \begin{verbatim}
Plus[x->TEXT, y->TEXT] =: TEXT
\end{verbatim} \normalsize

\bd
Returns the concatenation of the text strings \verb+x+
and \verb+y+.
\item
[Short form:] \verb%x + y%
\ed

\item
\protect \large \begin{verbatim}
PriorSibling[node->NODE] =: NODE
\end{verbatim}\normalsize

\bd
Returns the prior sibling of the node \verb+node+ in its
game tree.
\item
[See also:] {\tt NextSibling}.
\ed


%--Q--


\item
\protect \large \begin{verbatim}
Quit
\end{verbatim}\normalsize

\bd
Exits the command language.
\ed

%--R--

\item
\protect \large \begin{verbatim}
RandomEfg[efg<->EFG, {seed->INTEGER}] =: EFG
\end{verbatim}\normalsize

\bd
Assigns a payoff for each outcome for each player in the
extensive form \verb+efg+ randomly chosen from the uniform distribution
between 0 and 1.  The optional parameter \verb+seed+ may be used to
set the seed of the pseudo-random number generator.  The identical game
randomized with the same seed on the same machine will always produce
the same results.
\ed

\item
\protect \large \begin{verbatim}
RandomNfg[nfg<->NFG, {seed->INTEGER}] =: NFG
\end{verbatim}\normalsize

\bd
Assigns a payoff for each contingency for each player in
the normal form \verb+nfg+ randomly chosen from the uniform distribution
between 0 and 1.  The optional parameter \verb+seed+ may be used to
set hte seed of the pseudo-random number generator.  The identical game
randomized with the same seed on the same machine will always produce
the same results.
\ed

\item
\protect \large \begin{verbatim}
Rational[x->INTEGER] =: RATIONAL
Rational[x->FLOAT] =: RATIONAL
Rational[x->RATIONAL] =: RATIONAL
\end{verbatim} \normalsize

\bd
Converts the value \verb+x+ to the equivalent value of
type {\tt RATIONAL}.
\item
[See also:] {\tt Float}.
\ed

\item
\protect \large \begin{verbatim}
RealizProbs[strategy->BEHAV] =: LIST(FLOAT)
RealizProbs[strategy->BEHAV] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
Returns the list of realization probabilities for the
nodes in an extensive form given that the players are using the behavioral
strategy profile \verb+strategy+.  The list is ordered in the prefix-traversal
of the nodes in the tree, the same order in which the {\tt Nodes} function
returns the nodes in the tree.
\ed

\item
\protect \large \begin{verbatim}
Remove[list->LIST(T), n->INTEGER] =: LIST(T)
\end{verbatim}\normalsize

\bd
Returns a new list consisting of the elements of list
\verb+list+ with the \verb+n+th element removed.  {\tt Remove} does not
modify the input list \verb+list+.
\ed

\item
\protect \large \begin{verbatim}
RemoveStrategy[support->NFSUPPORT, strategy->STRATEGY] =: NFSUPPORT
\end{verbatim}\normalsize

\bd
Removes the strategy \verb+strategy+ from the
support \verb+support+.  If \verb+strategy+ is not in the support,
no action is taken.  Returns the modified support.
\item
[See also:] {\tt AddStrategy}, {\tt NewSupport}.
\ed

\item
\protect \large \begin{verbatim}
Reveal[infoset->INFOSET, who->LIST(EFPLAYER)] =: INFOSET
\end{verbatim}\normalsize

\bd
Reveals the list of actions at the given information
set to the indicated players, refining their information partitions at
all information sets in the extensive form game accordingly.  The list
of actions is considered as a set Thus, it is indicated to the
spceified players whether the set of actions in \verb+what+ or its
complement has occurred.  If \verb+what+ is not specified, then all of
the actions in the information set are individually revealed to
the players specified.  
\ed


\item
\protect \large \begin{verbatim}
RootNode[efg<->EFG] =: NODE
\end{verbatim}\normalsize

\bd
Returns the root node of the extensive form game \verb+efg+.
\item
[See also:] {\tt IsRoot}.
\ed

%--S--

\item
\protect \large \begin{verbatim}
SaveEfg[efg<->EFG, file->TEXT] =: EFG
\end{verbatim}\normalsize

\bd
Writes the extensive form game \verb+efg+ to an external
save file.  Returns \verb+efg+.
\item
[See also:] {\tt LoadEfg}.
\ed

\item
\protect \large \begin{verbatim}
SaveNfg[nfg<->NFG, file->TEXT] =: NFG
\end{verbatim}\normalsize

\bd
Writes the normal form game \verb+nfg+ to an external
save file.  Returns \verb+nfg+.
\item
[See also:] {\tt LoadNfg}.
\ed

\item
\protect \large \begin{verbatim}
SaveNfg[support->NFSUPPORT, file->TEXT] =: NFSUPPORT
\end{verbatim}\normalsize

\bd
Writes a normal form game using the strategies in \verb+support+ as the full support
of the game.  Returns \verb+support+.
\item
[See also:] {\tt LoadNfg}.
\ed

\item
\protect \large \begin{verbatim} 
SetComponent[behav<->BEHAV, infoset->INFOSET, list->LIST(T)] =: BEHAV 
\end{verbatim}\normalsize

\bd
Sets the componensts of a behavior profile \verb+behav+ for
information set \verb+infoset+ to be equal to the values in \verb+list+.
Returns \verb+behav+. 
\ed

\item
\protect \large \begin{verbatim} 
SetComponent[mixed<->MIXED, player->PLAYER, list->LIST(T)] =: MIXED 
\end{verbatim}\normalsize

\bd
Sets the componensts of a mixed profile \verb+mixed+ for player
\verb+player+ to be equal to the values in \verb+list+.
Returns \verb+mixed+. 
\ed

\item
\protect \large \begin{verbatim} 
SetChanceProbs[infoset->INFOSET, probs->LIST(FLOAT)] =: INFOSET
SetChanceProbs[infoset->INFOSET, probs->LIST(RATIONAL)] =: INFOSET
\end{verbatim}\normalsize

\bd
Sets the action probabilities for the information set
\verb+infoset+ to the values given in \verb+probs+.  This is only
meaninful for nodes in information sets belonging to the chance
player.  Returns \verb+infoset+. 
\item
[See also:] {\tt ChanceProbs}.
\ed


\item
\protect \large \begin{verbatim}
SetFormat[{width->INTEGER}, {precis->INTEGER}, 
          {expmode->BOOL}, {quoted->BOOL} ] =: BOOL
\end{verbatim}\normalsize

\bd 
Sets the formatting style for output on output streams.
\verb+width+ sets the width of the field for floating point numbers,
\verb+precis+ sets the number of decimal places shown for floating
point numbers, and \verb+expmode+ sets whether output is in
exponential format or not.  Finally, \verb+quoted+ determines whether
quotes are printed before and after text strings.
\item
[See also:] {\tt Write}.
\ed

\item
\protect \large \begin{verbatim}
SetName[x->ACTION, name->TEXT] =: ACTION
SetName[x<->EFG, name->TEXT] =: EFG
SetName[x->EFPLAYER, name->TEXT] =: EFPLAYER
SetName[x->INFOSET, name->TEXT] =: INFOSET
SetName[x<->NFG, name->TEXT] =: NFG
SetName[x->NFPLAYER, name->TEXT] =: NFPLAYER
SetName[x->NODE, name->TEXT] =: NODE
SetName[x->OUTCOME, name->TEXT] =: OUTCOME
SetName[x->STRATEGY, name->TEXT] =: STRATEGY
\end{verbatim}\normalsize

\bd
Sets the name of the object \verb+x+ to \verb+name+.
Returns the object \verb+x+.
\item
[See also:] {\tt Name}.
\ed

\item
\protect \large \begin{verbatim}
SetPayoff[node->NODE, payoff->LIST(FLOAT)] =: OUTCOME
SetPayoff[node->NODE, payoff->LIST(RATIONAL)] =: OUTCOME
\end{verbatim}\normalsize

\bd
Creates a new outcome, attaches it to the node \verb+node+, and sets
the payoffs for this outcome to the values specified in list.  If
there is already an outcome attached to the node, it is detatched, but
not deleted.  Returns the new outcome attached to the node.  
\item
[See also:] {\tt Payoff}.
\ed

\item
\protect \large \begin{verbatim}
SetPayoff[outcome->OUTCOME, payoff->LIST(FLOAT)] =: OUTCOME
SetPayoff[outcome->OUTCOME, payoff->LIST(RATIONAL)] =: OUTCOME
\end{verbatim}\normalsize

\bd
Sets the payoffs of the outcome \verb+outcome+ to the
values specified by \verb+payoff+.  It is a run-time error if the type
of the list \verb+payoff+ does not match the type of the game in which
\verb+outcome+ is defined.  Returns \verb+outcome+.
\item
[See also:] {\tt Payoff}.
\ed

\item
\protect \large \begin{verbatim}
SetPayoff[nfg<->NFG, list->LIST(INTEGER),
          payoff->LIST(FLOAT)] =: LIST(STRATEGY)
SetPayoff[nfg<->NFG, list->LIST(INTEGER), 
          payoff->LIST(RATIONAL)] =: LIST(STRATEGY)
\end{verbatim}\normalsize

\bd
Sets the payoffs in the normal form game \verb+nfg+ of the
contingency specified by \verb+list+ to the values specified by
\verb+payoff+.  It is a run-time error if the type of the list
\verb+payoff+ does not match the type of the game in which the
strategies in \verb+list+ are defined.  Returns \verb+list+.
\item
[See also:] {\tt Payoff}.  
\ed

\item
\protect \large \begin{verbatim}
SimpDivSolve[nfg<->NFG | support->NFSUPPORT, {stopAfter->INTEGER}, 
             {nRestarts->INTEGER}, {leashLength->INTEGER},
             {nEvals<->INTEGER}, {time<->FLOAT}] =: LIST(MIXED)
\end{verbatim}\normalsize

\bd
Computes a Nash equilibrium to a normal form game based
on a simplicial subdivision algorithm.  

\item
[Return value:] The list of equilibria found.
\item
[Required parameters:]\hfil\null

\bd
\item
[nfg:] The game in normal form on which the operation will be
performed.
\ed

\item
[Optional parameters:]\hfil\null
	
\bd
\item
[stopAfter:] Maximum number of equilibria to find. Default is 1.  
\item 
[nRestarts:] Number of restarts.  At each restart the mesh of the
triangulation is halved.  So this parameter determines the final mesh
by the formula ${1/2}^{ndivs}$.
\item
[leashLength:] Sets the leashlength. Default is 0, which results in no
constraint, or no leash.  Note that if this parameter is set to a value
different from 0, the algorithm is no longer guaranteed to converge.
\item
[time:] Returns the elapsed time for the operation.
\ed
\ed

\item
\protect \large \begin{verbatim}
StartWatch[] =: FLOAT
\end{verbatim}\normalsize

\bd
Starts the system stopwatch running.  If the stopwatch
is already running, {\tt StartWatch} has no effect.  Returns the amount
of time since the stopwatch was started.
\item
[See also:] {\tt ElapsedTime}, {\tt IsWatchRunning}, {\tt StopWatch}.
\ed

\item
\protect \large \begin{verbatim}
Strategies[player->NFPLAYER, {support->NFSUPPORT}] =: LIST(STRATEGY)
\end{verbatim}\normalsize

\bd
Returns the list of strategies from which player \verb+player+ may choose
in a normal form game.  If \verb+support+ is unspecified, returns the
player's full complement of strategies; else returns the list of strategies
in the support for the player.
\ed

\item
\protect \large \begin{verbatim}
StopWatch[] =: FLOAT
\end{verbatim}\normalsize

\bd
Stops the system stopwatch.  If the stopwatch was not
running, {\tt StopWatch} has no effect.  Returns the amount of time
on the stopwatch.
\item
[See also:] {\tt ElapsedTime}, {\tt IsWatchRunning}, {\tt StartWatch}.
\ed

%--T--

\item
\protect \large \begin{verbatim} 
TerminalNodes[efg<->EFG] =: LIST(NODE)
\end{verbatim}\normalsize

\bd
Returns the list of terminal nodes in the extensive form
game \verb+efg+ in prefix-traversal order.
\item
[See also:] {\tt Nodes}, {\tt NonterminalNodes}.
\ed

\item
\protect \large \begin{verbatim}
Text[x->INTEGER] =: TEXT
Text[x->FLOAT] =: TEXT
Text[x->RATIONAL] =: TEXT
Text[x->TEXT] =: TEXT
\end{verbatim} \normalsize

\bd
Converts the object \verb+x+ into the equivalent text object.
\item
[See also:] {\tt Float}, {\tt Rational}.
\ed

\item 
\protect \large \begin{verbatim}
Times[x->FLOAT, y->FLOAT] =: FLOAT
Times[x->INTEGER, y->INTEGER] =: INTEGER
Times[x->RATIONAL, y->RATIONAL] =: RATIONAL
Times[x->FLOAT, y->MIXED] =: MIXED
Times[x->MIXED, y->FLOAT] =: MIXED
Times[x->RATIONAL, y->MIXED] =: MIXED
Times[x->MIXED, y->RATIONAL] =: MIXED
Times[x->FLOAT, y->BEHAV] =: BEHAV
Times[x->BEHAV, y->FLOAT] =: BEHAV
Times[x->RATIONAL, y->BEHAV] =: BEHAV
Times[x->BEHAV, y->RATIONAL] =: BEHAV
\end{verbatim} \normalsize
  
\bd
Computes the product of \verb+x+ and \verb+y+.  In the cases where one
argument is a Mixed or Behavior profile, and the other is a scalar
type, it computes the scalar product of the scalar and the profile. 
\item
[Short form:] \verb+x * y+
\ed

%--U--

\item
\protect \large \begin{verbatim}
UnAssign[x<->T] =: T
\end{verbatim}\normalsize

\bd
Undefines the variable referenced by \verb+x+.  Returns the
last value of the variable.
\item
[See also:] {\tt Assign}.
\ed

%--V--

%--W--

\item 
\protect \large \begin{verbatim}
While[test, statements]
\end{verbatim} \normalsize
  
\bd
If test is True, evaluates the statement list consisting of
\verb+do+ followed by itself.  If test fails, evaluates the empty
statement list.
\item
[See also:] \verb+For+.
\ed

\item
\protect \large \begin{verbatim}
Write[output->OUTPUT, x->BEHAV] =: OUTPUT 
Write[output->OUTPUT, x->BOOL] =: OUTPUT 
Write[output->OUTPUT, x<->EFG] =: OUTPUT
Write[output->OUTPUT, x->FLOAT] =: OUTPUT
Write[output->OUTPUT, x->INTEGER] =: OUTPUT
Write[output->OUTPUT, x->MIXED] =: OUTPUT
Write[output->OUTPUT, x<->NFG] =: OUTPUT
Write[output->OUTPUT, x->RATIONAL] =: OUTPUT
Write[output->OUTPUT, x->TEXT] =: OUTPUT
\end{verbatim}\normalsize

\bd
Does a formatted write of the object \verb+x+ to the
output stream \verb+output+.  
\item
[See also:] {\tt Output}, {\tt SetFormat}
\ed

%--X--

%--Y--

%--Z--

\end{itemize}
\bibliographystyle{chicagob}
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{gambit}
\end{document}



\section{Language Description}

\subsection{Grammar and syntax}

The central paradigm of the GCL is that we can think of every legal
statement as a function call, which operates on some set of parameters and
returns a value.  Many commonly used functions have a more convenient
``short form'' format for additional terseness and readability.

Each function is identified by its \verb+FunctionName+, which is a
unique \verb+Name+.  A \verb+Name+ is any sequence of upper or lower
case letters or numbers beginning with a letter.  The set of all
built-in functions is listed in the Function Reference section of this
manual.

A statement in the GCL has the
following syntax
\begin{verbatim}
FunctionName[ArgumentList]
\end{verbatim}
where \verb+FunctionName+ is a unique name, and \verb+ArgumentList+ is
a sequence of arguments, separated by commas, each of which takes one
of the following two forms:
\begin{verbatim}
ArgumentName->argval
\end{verbatim}
or
\begin{verbatim}
ArgumentName<->argref
\end{verbatim}

Each function, when originally created, is given a list of formal
argument names, and each formal argument is assigned a data type,
which is one of the allowable data types listed in the section below
on data types.  For each of the built in functions, the formal
arguments and their data types are listed in the entry for that
function in the Function Reference section.  In the above syntax,
\verb+ArgumentName+, must be one of the list of possible formal
arguments for the given function, and \verb+argval+ or \verb+argref+
is any function that evaluates to correct data type for the
corresponding argument. 

The arguments to a function can be either optional or required.
Required arguments must be specified in \verb+ArgumentList+ when the
function is called.  Each optional argument has a default value, which
is also determined when the function is created.  Optional arguments
need only be specified when the default is to be changed.

The arguments to a function can be specified in any order, as long as
the above syntax for the \verb+ArgumentList+ is used.  However, the
argument list for a function can also be called without specifying the 
prefix \verb+ArgumentName->+ or \verb+ArgumentName<->+ as long as the 
arguments are specified in the correct order.  In fact a mixture is 
allowed in which the prefix is specified for some arguments and not
specified for others as long as all of the arguments which do not
include the prefix preceed those that do.  In this case, it is assumed
that those that do not include a prefix are in the correct order.  

Arguments can be passed in one of two ways, either by value or by
reference.  To pass an argument by value, the syntax is
\verb+ArgumentName->argval+.  If an argument is passed by value, then the
function whose name is specified in \verb+argval+ cannot be called
or changed by the function \verb+FunctionName+ unless it is in some
other way made visible to the function (specifically, if it is called
by reference in a different argument to the same function, or if it is a
funcion of global scope -- described below).  To pass by reference,
the syntax is \verb+ArgumentName<->argref+.  If an argument is passed
by reference, then the function whose name is specified in
\verb+argref+ can be called and changed by the function
\verb+FunctionName+.  

Finally, a function with no required arguments can be called by just
specifying the function name.  That function is then called with
default values for all optional arguments (if there are any.)

Summarizing, a rough description of the formal grammar of the GCL
follows:

\begin{verbatim}
Name: [A-Za-z]([A-Za-z0-9_])

Statement: FunctionName
        | FunctionName[ArgumentList]

FunctionName: Name

ArgumentList: Argument
        | Argument, Argumentlist

Argument: ArgumentName -> Statement
        | ArgumentName <-> Statement
        | Statement

ArgumentName: Name
\end{verbatim}

\subsection{Variables}




\begin{verbatim}
e := NewEfg[];
n := RootNode[e];
ent := NewPlayer[e,"Entrant"];
entiset := NewInfoset[ ent , {"Enter", "Out"} ];
AppendNode[n, entiset];
inc := NewPlayer[e,"Incumbent"];
inciset := NewInfoset[ inc , {"Fight", "Aquiesce"} ];
AppendNode[n#1, inciset]; 
\end{verbatim}

can be used to build up the game tree for one stage of a chain store
game.  One can then attach outcomes and set payoffs as follows:

\begin{verbatim}
o1:=AttachOutcome[node#1#1,NewOutcome[efg]];
o2:=AttachOutcome[node#1#2,NewOutcome[efg]];
o3:=AttachOutcome[node#2,NewOutcome[efg]];
SetPayoff[o1, {-0.5,-1.0}];
SetPayoff[o2, {0.5,0.0}];
SetPayoff[o3, {0.0,0.5}];
\end{verbatim}

