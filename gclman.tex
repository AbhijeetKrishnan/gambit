%
% FILE: gclman.tex -- source for GCL manual
%
% $Id$
%
\documentstyle[widetext,chicagob]{article}
\renewcommand{\baselinestretch}{.9}
\newcommand{\bd}{\begin{description}}
\newcommand{\ed}{\end{description}}
\begin{document}

\title{GAMBIT COMMAND LANGUAGE\thanks{This project was funded in part
by National Science Foundation grants SBR-9308637 to the California
Institute of Technology and SBR-9308862 to the University of
Minnesota.  We are grateful to Rob Weber for help in compiling this manual
and testing parts of the language.}}

\author{Richard D. McKelvey\\California Institute of
Technology
\and
Andrew McLennan\\University of
Minnesota
\and 
Ted Turocy\\California Institute of Technology
}

\date{\today\\ \jobname.tex}

\maketitle

\tableofcontents

\section{General Overview}

This document describes the GAMBIT Command Language (GCL).  GAMBIT is
a computer program that allows one to build, manipulate, and solve
finite extensive and normal form games. The GCL provides a method of
directing the operation of GAMBIT that is analagous to that of a high
level general purpose programming language.

The general purpose of the GCL is to provide a simple, but powerful
and flexible language by which one can perform complicated or
repetitive operations and procedures on games in extensive or normal
form.  The language has facilities for building and editing an
extensive or normal form game, converting back and forth between the
extensive and normal form representations, and then solving the
resulting game for various game theoretic equilibria of interest. Flow
control statements allow for repetitive operations (such as
investigating games as one changes various parameters) or conditional
operations.

\section{Installation}

\subsection{Unix}

\subsection{MS-DOS, Microsoft Windows}


\section{Getting Started}

There are small differences in the versions of the GCL between different
operating systems and platforms; however, the use and interface is
essentially the same in the main.  This manual is written for all platforms,
and any special notes pertaining to some particular platforms will be mentioned
at the appropriate time.

There are two ``modes'' in which you will use the GCL: interactive and batch.
First, we discuss batch mode.

Typing 'gcl [CR]' at your shell prompt (either in Unix or MS-DOS) will start
the GCL in batch mode.  After some preliminaries, you will get the GCL
prompt:
\begin{verbatim}
GCL1:
\end{verbatim}

which indicates that the program is ready to accept your input.  The prompt
number labels your input lines for later reference.

A GCL program consists of a series of statements, each ending in a
semi-colon or carriage return. A carriage return will not be
interpreted as the end of a statement, however, if there are unmatched
parentheses or brackets.  For example, the following two lines are
interpreted as one statement:

\begin{verbatim}
	Plus[x->1, 
	y->2]
\end{verbatim}

If both lines are followed by a carriage return, the statement will
generate the line of output:

\begin{verbatim}
	3
\end{verbatim}

The function \verb+Plus+ is defined to return the sum of two integers,
so the command language evaluates the function and returns the value of
$1 + 2$, which is 3.  A more complete description of functions follows in
a later section.

[NOTE: There will be better batch mode support soon.]

The user has the option of creating a text file containing a series of
commands which can then be run together, as a program, by the
language.  This is referred to as ``batch mode''.
The output of such a program can be directed either to the
screen or to a file specified by the user.  A text file can be read by
the language as a program by placing an input file command {\tt "<"}
followed by the name of the file, following the command which enters
the command language.  By using an output file command {\tt ">"}
followed by the name of a file, the user can direct the output of the
command language to an external text file.  For example, at the unix prompt:

\begin{verbatim}
	> gcl < input.gcl > output.out
\end{verbatim}

\section{Language Description}

\subsection{Grammar and syntax}

The central pardigm of the GCL is that we can think of every legal
statement as a function call, which operates on some set of parameters and
returns a value.  Many commonly used functions have a more convenient
``short form'' format for additional terseness and readability.

At any point in time, there is a set of ``visible functions.''
Functions can be either built-in functions, or user created functions.
Each function is identified by its \verb+FunctionName+, which is a
unique \verb+Name+.  A \verb+Name+ is any sequence of upper or lower
case letters or numbers beginning with a letter.  The set of all
built-in functions is listed in the Function Reference section of this
manual.  The built-in functions are always visible, unless they are
explicitly deleted.

A statement in the GCL has the
following syntax
\begin{verbatim}
FunctionName[ArgumentList]
\end{verbatim}
where \verb+FunctionName+ is a unique name, and \verb+ArgumentList+ is
a sequence of arguments, separated by commas, each of which takes one
of the following two forms:
\begin{verbatim}
ArgumentName->argval
\end{verbatim}
or
\begin{verbatim}
ArgumentName<->argref
\end{verbatim}

Each function, when originally created, is given a list of formal
argument names, and each formal argument is assigned a data type,
which is one of the allowable data types listed in the section below
on data types.  For each of the built in functions, the formal
arguments and their data types are listed in the entry for that
function in the Function Reference section.  In the above syntax,
\verb+ArgumentName+, must be one of the list of possible formal
arguments for the given function, and \verb+argval+ or \verb+argref+
is any function that evaluates to correct data type for the
corresponding argument. 

The arguments to a function can be either optional ar required.
Required arguments must be specified in \verb+ArgumentList+ when the
function is called.  Each optional argument has a default value, which
is also determined when the function is created.  Optional arguments
need only be specified when the default is to be changed.

The arguments to a function can be specified in any order, as long as
the above syntax for the \verb+ArgumentList+ is used.  However, the
argument list for a function ca also be called with without specifying
the prefix \verb+ArgumentName->+ or \verb+ArgumentName<->+ as long as
the arguments are specified in the correct order.  In fact a mixture
is allowed in which the prefix is specified for some arguments and not
sepecified for others as long as all of the arguments which do not
include the prefix preceed those that to.  In this case, it is assumed
that those that do not include a prefix are in the correct order.  

Arguments can be passed in one of two ways, either by value or by
reference.  To pass an argument by value, the syntax is
\verb+ArgumentName->argval+.  If an argument is passed by value, then the
function whose name is specified in \verb+argval+ cannot be be called
or changed by the function \verb+FunctionName+ unless it is in some
other way made visible to the function (specifically, if it is called
by reference in a different argument to the same function, or if is a
funcion of global scope -- described below).  To pass by reference,
the syntax is \verb+ArgumentName<->argref+.  If an argument is passed
by reference, then the function whose name is specified in
\verb+argref+ can be called and changed by the function
\verb+FunctionName+.  

Finally, a function with no required arguments can be called by just
specifying the function name.  That function is then called with
default values for all optional arguments (if there are any.)

Summarizing, a rough description of the formal grammar of the GCL
follows:

\begin{verbatim}
Name: [A-Za-z]([A-Za-z0-9])

Statement: FunctionName
        | FunctionName[ArgumentList]

FunctionName: Name

ArgumentList: Argument
        | Argument, Argumentlist

Argument: ArgumentName -> Statement
        | ArgumentName <-> Statement
        | Statement

ArgumentName: Name
\end{verbatim}

\subsection{Variables}

The simplest kind of function is a $variable$.  A variable is a
constant function with no arguments.  A variable stores one object of
the corresponding data type, and returns it when called.  To create a
user defined variable, or to give a new value to an existing variable,
one can use the built-in function,
\verb+Assign+, which has the syntax:
\begin{verbatim}
Assign[x<->T, y->T]
\end{verbatim}

If the \verb+x+ parameter is previously undefined variable name, a new
variable of the type is created and the value of the expression passed
to \verb+y+ is ``assigned'' to \verb+x+.  If \verb+Assign+ is called with
an argument \verb+varname+ which is a currently visible function, it results
in an error if the data type which \verb+y+ evaluates to is different that the
current data type of \verb+x+.  On the other hand, if the
data types match, then \verb+varname+ is ``modified:'' \verb+varname+
is first deleted from the list of visible functions and then
\verb+Assign+ is executed.  

The Assign function is used so frequently, it has the following short form
representation:
\begin{verbatim}
name := expression
\end{verbatim}

\subsection{User defined functions}

[This is very tentative.  I have problems with some aspects of this. -- TED]

\subsubsection{Creating functions}
A user defined function can be created using the function
\verb+NewFunction+, which has the following format.

\begin{verbatim}
NewFunction[name->TEXT,arglist->LIST[ TEXT, BOOLEAN, TEXT], 
            body->STATEMENTLIST,scope->BOOLEAN] =: BOOLEAN
\end{verbatim}

\subsubsection{Using functions}

When a user defined function is evaluated, the following things,
happen, in order:

\begin{enumerate}
\item
The current list of visible functions is 
replaced with a new set of visible functions, consisting of the
previous set of visible functions with global scope.  
 
\item
\begin{itemize}
\item
For each argument in the argument list which is called by
value, a new variable of local scope is created, whose name is the
corresponding \verb+ArgumentName+, and it is assigned the value
which results from evaluating the argument \verb+argval+.  
\item
For each
argument that is called by reference, the name \verb+ArgumentName+ is
added to the list of visible functions, and this name is treated as a
proxy (a reference) for the function name of \verb+argref+.  In other
words, this function remains visible, but is given a different name by
which it is referred to while in the function.  It is very important
to note that this means that any changes to the function with name
\verb+ArgumentName+ will result to the exact same change to
\verb+argref+, once that function is again visible, since
\verb+ArgumentName+ and \verb+argref+ are just different names for the
same function.
\end{itemize}

\item
The statements in the body of the function are evaluated, in
order, until a \verb+Return+ function is encountered.  

\item
When a return function is evaluated, the list of visible
functions is restored to what it was before the \verb+FunctionName+
was evaluated, and the argument of the Return function is evaluated
and returned as the evaluation of \verb+FunctionName+. 
\end{enumerate}

\subsection{Data types}

Like most high-level languages, GCL has a data typing system which
permits only one type of data to be returned by a given function.
However, GCL is a bit unusual in that it has implicit typing of
functions.  That is, a function's return type is determined by its
first use in the program.  For a user defined function, this is in the
NewFunction command that first creates the function.  For a user
defined variable, this will be in the \verb+Assign+ function that
first creates the variable.

The built-in data types for the GCL are the following:  

\medskip

\begin{tabular}{lp{4in}}
BOOLEAN & Evaluates to either True or False. \\ 

INTEGER & Evaluates to an integer of arbitrary size \\ 

RATIONAL & Evaluates to a rational number of arbitrary precision\\ 

FLOAT 	& Evaluates to a floating point number \\

TEXT	& String of arbitrary length enclosed in quotation marks\\ 

EFG	& Game in extensive form.  An extensive form is defined as any
element of the set of possible return values of built-in functions
that return data type EFG.\\

NFG	& Game in normal form.  A normal form is defined as any
element of the set of possible return values of built-in functions
that return data type NFG\\

NODE	& A node (may only be a subvariable of an extensive
form problem) \\ 

DATATYPE & Defines precision (constants: Float or
Rational) \\ 

STRATEGY & In a normal form game, one of the options a player may adopt.
This may only be a subvariable of a NFG \\

MIXED	& {Profile of mixed strategies.  Can only be a
subvariable of a normal form problem.  That is, if n is a problem in
normal form, a variable of type MIXED can only be assigned to a
subvariable of the form n.x.}\\ 

BEHAV	& Profile of behavioral
strategies.  Can only be a subvariable of an extensive form problem.
That is, if e is a problem in extensive form, a variable of type BEHAV
can only be assigned to a subvariable of the form e.x. \\
\end{tabular}



\medskip

\noindent
Additionally, variables of any type can be contained in lists of arbitrary
length.
Variables of type LIST are defined similarly to the above variables,
except that the expression to the right of the {\tt ":="} symbol
contains a vector of variables of the same type enclosed in curly braces
and separated by commas.  For example:

\begin{verbatim}
	LIST(BOOLEAN) := { BOOLEAN1, BOOLEAN2, . . . . , BOOLEANn }
\end{verbatim}

The elements of a list are indexed sequentially, with the first element
defined to have index 1.  Therefore, the ith
element of a list is defined as:

\begin{verbatim}
	LIST(BOOLEAN)[[i]]
\end{verbatim}

\noindent which evaluates to a single variable of type \verb+BOOLEAN+.
In the same manner, lists of any type may be created and manipulated.
Lists may be nested to any depth; however, the type of all the elements
of the list and any sublists must always be the same.  Hence

\begin{verbatim}
	{ 3, { 4, 6 }, 23 }
\end{verbatim}

is a legal list, since all the elements are of type \verb+INTEGER+, but

\begin{verbatim}
	{ 3, { 4.2, 5.7 }, 23 }
\end{verbatim}

is not, since the second element is a \verb+LIST(FLOAT)+.

\subsubsection{Boolean}

The BOOLEAN data type is used for logical operations

\begin{itemize}
\item
Variables:

There are two built-in BOOLEAN variables, \verb+True+  and \verb+False+, which
may not be modified: 

\bd
\item
\verb+True+ returns ``True.''

\item
\verb+False+ returns ``False.''
\ed

\item
Operators:

Let \verb+a+ and \verb+b+ be statements evaluating to BOOLEAN. Then  

\bd
\item
\verb+And[a,b]+ is logical ``and.''  It returns \verb+True+ if
both \verb+a+ and \verb+b+ evaluate to \verb+True+, and otherwise
returns \verb+False+.  It has the short form \verb+a && b+, or
\verb+a AND b+. 

\item
\verb+Or[a,b]+ is logical ``or.''  It returns \verb+True+ if
at least one of \verb+a+ and \verb+b+ evaluate to \verb+True+, and otherwise
returns \verb+False+. It has the short form \verb+a || b+, 
or \verb+a OR b+

\item
\verb+Not[a]+ is logical negation.  It returns \verb+True+ if \verb+a+
evaluates to \verb+False+, and \verb+False+ if \verb+a+ is evaluates
to \verb+True+.  It has the short form \verb+!a+ or \verb+NOT a+.
\ed 
\end{itemize}

\subsubsection{Integers}
\begin{itemize}
\item
The INTEGER type may contain arbitrarily large (positive or negative)
values.  It is not limited by the default integer size on any particular
computer.

\item
Operators:
Let \verb+a+ and \verb+b+ be statements evaluating to INTEGER. Then

\bd
\item
\verb+Plus[a,b]+ returns the sum of the values returned by
\verb+a+ and \verb+b+.  It has the short form \verb&a + b&.  Also,
any integer $n>1$ can be viewed as short form for \verb+Plus[n-1,1]+  
 
\item
\verb+Neg[a]+ returns the integer which when added to \verb+a+ yields
0.  It has the short form \verb&-a&.  
 
\item
\verb+Minus[a,b]+ returns the sum of the values returned by
\verb+a+ and \verb+Neg[b]+.  It has the short form \verb&a - b&.  

\item
\verb+Times[a,b]+ returns the product of the values returned by
\verb+a+ and \verb+b+.  It has the short form \verb+a * b+.

\item
\verb+Divide[a,b]+ returns the largest integer which, when
multiplied by \verb+b+ is less than or equal to \verb+a+.  It has the
short form \verb+a DIV b+.

\item
\verb+Modulus[a,b]+ returns the remainder of \verb+a+ divided by
\verb+b+.  This is the integer which, when added to
\verb+Times[b,Div[a,b]]+, yields \verb+a+.  It has the short form 
\verb+a MOD b+.
\item

\ed
\item
Relational operators take INTEGER arguments and
return a BOOLEAN
\bd
\item
\verb+GreaterThan[a,b]+ returns \verb+True+ if \verb+a+$>$\verb+b+, and
returns \verb+False+ otherwise.  It has the short form \verb+a > b+.

\item
\verb+LessThan[a,b]+ returns \verb+True+ if \verb+a+$<$\verb+b+, and
returns \verb+False+ otherwise.  It has the short form \verb+a < b+.

\item
\verb+GreaterEqual[a,b]+ returns \verb+True+ if \verb+a+$>=$\verb+b+, and
returns \verb+False+ otherwise.  It has the short form \verb+a >= b+.

\item
\verb+LessEqual[a,b]+ returns \verb+True+ if \verb+a+$<=$\verb+b+, and
returns \verb+False+ otherwise.  It has the short form \verb+a <= b+.

\item
\verb+Equal[a,b]+ returns \verb+True+ if \verb+a+$=$\verb+b+, and
returns \verb+False+ otherwise.  It has the short form \verb+a = b+.

\item
\verb+NotEqual[a,b]+ returns \verb+True+ if \verb+a+$!=$\verb+b+, and
returns \verb+False+ otherwise.  It has the short form \verb+a != b+.
\ed
\end{itemize}

\subsubsection{Rationals}

A RATIONAL returns a pair of integers, called the numerator and the
denominator, where the denominator is
non-zero.  A statement evaluating to rational is represented in the
form \verb+a/b+, where \verb+a+ is the numerator, and \verb+b+ is the
denominator.  

\begin{itemize}
\item
Operators for rationals can all be defined in terms of the operators
for integers.  Let \verb+a+ and \verb+b+ be statements evaluating to
RATIONAL. Say \verb+a+ evaluates to \verb+w/x+ and \verb+b+ evaluates
to \verb+y/z+

\bd
\item
\verb+Plus[a,b]+ returns \verb&w * z + y * x / x * z&. It has the
short form \verb&a + b&.  
 
\item
\verb+Neg[a]+ returns \verb+-w / x+.  It has the short form \verb&-a&.  
 
\item
\verb+Minus[a,b]+ returns \verb+w * z - y * x / x * z+.  
It has the short form \verb&a - b&.  

\item
\verb+Times[a,b]+ returns \verb+w * y / x * z+.  It has the short form 
\verb+a * b+.

\item
\verb+Divide[a,b]+ returns \verb+w * z / x * y+. It is only defined
when \verb+b+ does not evaluate to \verb+0+.  It has the
short form \verb+a / b+.
\item 
\verb+Power[a,b]+ is defined only when \verb+b+ is an INTEGER.  It 
returns \verb+w ^ b / x ^ b+.  It has the short form \verb+a ^ b+.

\ed
\item
Relational operators for RATIONAL can also be defined in terms of
relational operators for INTEGER.  
\bd
\item
\verb+GreaterThan[a,b]+ returns \verb+w * z +$>$\verb+ x * y+.
It has the short form \verb+a > b+.

\item
\verb+LessThan[a,b]+ returns \verb+w * z +$<$\verb+ x * y+.
It has the short form \verb+a < b+.

\item
\verb+GreaterEqual[a,b]+ returns \verb+w * z +$>=$\verb+ x * y+.
It has the short form \verb+a >= b+.

\item
\verb+LessEqual[a,b]+ returns \verb+w * z +$<=$\verb+ x * y+.
It has the short form \verb+a <= b+.

\item
\verb+Equal[a,b]+ returns \verb+w * z +$=$\verb+ x * y+.
It has the short form \verb+a = b+.

\item
\verb+NotEqual[a,b]+ returns \verb+w * z +$!=$\verb+ x * y+.
It has the short form \verb+a = b+.
\ed
\end{itemize}

\subsubsection{Floats}

A FLOAT returns a pair of integers, in the form \verb+a E b+, where
\verb+a+ is called the mantissa, and \verb+b+ is called the exponent.
The mantissa and exponent have restricted range, as follows:  
\verb+| a | < FloatPrecis+, and \verb+| b - Mag[a] | < FloatMag+, where
\verb+Mag[a]+ is the magnitude of \verb+a+ -- the largest power of ten 
that is less than or equal to \verb+a+.  

It is perhaps more natural to think of a FLOAT as consisting of the
RATIONAL mantissa, \verb+a / 10^Mag[a]+, together with an integer
exponent, \verb+e = | b - Mag[a] |+.  This is the engineering format
in which floating point numbers are frequently expressed.  In this
case, the rational mantissa is written in decimal notation, with one
digit, followed by a decimal point, and followed by the other
significant digits.

From the point of view of speed, floating point numbers have nice
characteristics.  Floating point numbers are tailored to fit in a
fixed amount of storage space.  Hence floating point operations can be
encoded in hardware, and be done in a few clock cycles, in contrast to
the software implementation of arithmetic operations for arbitrary
precision integers or rationals.  

However, from the point of view of accuracy, the FLOAT data type has a
number of undesirable properties which mean that it should be avoided
whenever exact answers are required.  Unlike the INTEGER and RATIONAL
data types, the FLOAT data type does not satisfy the basic axioms of
an ordered field: The set of floating point numbers is not closed
under addition or multiplication.  Neither addition or multiplication
is associative (it is not always the case that
\verb&(a+b)+c = a+(b+c)& or 
\verb+(a*b)*c = a*(b*c)+).  Nor does multiplication
distribute over addition (it is not always true that 
\verb&a*(b+c) = a*b+a*c&.  Further, not all floating point numbers have
multiplicative inverses.  This means that we can have such wonderful
properties as \verb+b*(a/b) != a+ (if \verb+a = 1+ and
\verb+b = 3+, for example), or \verb&a+b = a& and yet not \verb+ b = 0+.  In
addition to these problems, the result of a floating poing operation
can be machine dependent, since \verb+FloatPrecis+ and 
\verb+FloatMag+ can differ from machine to machine.

\begin{itemize}
\item
Operators for floats can all be defined in terms of the operators for
integers.  Let \verb+a+ and \verb+b+ be statements
evaluating to FLOAT. Say \verb+a+ evaluates to \verb+wEx+ and
\verb+b+ evaluates to \verb+yEz+.  For any integer \verb+i+, let 
\verb+Insig[i]+ be the number of insignificant digits of \verb+x+.  In
other words, \verb+Insig[i]+ is the smallest integer such that 
\verb+| x DIV 10 ^ m | +$<=$\verb+ FloatPrecis+.  In all of the following
definitions, we write \verb+n = FloatMag+.

\bd
\item
\verb+Plus[a,b]+ returns \verb&(x DIV 10^m)E(m-n)&, where 
\verb&x = a*10^(b+n) + c*10^(d+n)&, 
and \verb+m = Insig[x]+.  
It has the short form \verb&a + b&.
 
\item
\verb+Neg[a]+ returns \verb+-w E x+.  It has the short form \verb&-a&.  
 
\item
\verb+Minus[a,b]+ returns \verb+Plus[a, -b]+
It has the short form \verb&a - b&.  

\item
\verb+Times[a,b]+ returns \verb&(x DIV 10^m)E(m-n)&, where 
\verb&x = a*10^(b+n) * c*10^(d+n)&, 
and \verb+m = Insig[x]+.  
It has the short form \verb&a * b&.
 
\item
\verb+Divide[a,b]+ returns \verb&(x DIV 10^m)E(m-2*n)&, where 
\verb&x = a*10^(b+2*n) DIV c*10^(d+n)&, 
and \verb+m = Insig[x]+.  
It has the short form \verb&a * b&.
 
\ed
\item
Relational operators for FLOAT can also be defined in terms of
relational operators for INTEGER.  
\bd
\item
\verb+GreaterThan[a,b]+ returns \verb&w*10^(x+n) > y*10^(z+n)&.
It has the short form \verb+a > b+.

\item 
\verb+LessThan[a,b]+ returns \verb&w*10^(x+n) < y*10^(z+n)&.
It has the short form \verb+a < b+.

\item
\verb+GreaterEqual[a,b]+ returns \verb&w*10^(x+n) >= y*10^(z+n)&.
It has the short form \verb+a >= b+.

\item 
\verb+LessEqual[a,b]+ returns \verb&w*10^(x+n) <= y*10^(z+n)&.
It has the short form \verb+a <= b+.

\item 
\verb+Equal[a,b]+ returns \verb&w*10^(x+n) = y*10^(z+n)&.
It has the short form \verb+a = b+.

\item 
\verb+NotEqual[a,b]+ returns \verb&w*10^(x+n) != y*10^(z+n)&.
It has the short form \verb+a != b+.

\ed
\end{itemize}


\subsection{Order of precedence}

When functions are written in their canonical forms, no ambiguity
arises in the order of evaluation: In order to evaluate a function,
all arguments must be evaluated first.  Arguments are evaluated in the
natural order.  For built in functions, this is the default order
given in the Function Reference section.  For user defined functions,
it is the order specified when the function is created.  If another
function is encountered as an argument to a function, it is evaluated
at that time.  This leads to a recursive structure of evaluation,
which stops only when an argument being evaluated is a constant
function (i. e., a function with no arguments).

When short form forms are used, then ambiguity can arise in the
intended order of evaluation.  For example, the statement \verb&a + b * c&,
could be meant as \verb+Plus[a,Times[b,c]]+ or as
\verb+Times[Plus[a,b],c]+.  In order to resolve such ambiguities, all
functions that have a short form representation are given an order of
precedence.  When a statement is parsed by the GCL, it is first
scanned from left to right, replacing each short form expression at the
top level of precedence with its canonical form.  Then it is scanned
again replacing each short form expression at the second level of
precedence with its canonical form, and so on, until all short form
expressions have been eliminated.  

The order of precedence for built-in functions is as follows:
\bd
\item
\verb+()+
\item
\verb+:=+
\item
\verb+||+
\item
\verb+&&+
\item
\verb+NOT+
\item
\verb+= != < <= > >=+
\item
\verb&+ -&
\item
\verb+* / DIV MOD+
\item
\verb&(unary) + -&
\item
\verb+[[ ]]+
\ed

Thus, the statement \verb&a + b * c& would become 
\begin{verbatim}
Plus[a,b*c]
Plus[a,Times[b,c]]
\end{verbatim}

\noindent
On the other hand, the statement \verb&( a + b ) * c& would become 
\begin{verbatim}
Paren[a+b]*c
Paren[Plus[a,b]]*c
Times[Paren[Plus[a,b]],c]
\end{verbatim}

\noindent
which, since \verb+Paren+ is just the identity mapping, is equivalent to
\begin{verbatim}
Times[Plus[a,b],c]
\end{verbatim}

\subsection{Flow Control}

The GCL contains three functions which allow flow control within a
program.  Flow control functions differ from other functions in that
when they are evaluated, the list of visible functions does not
change.

\medskip

\begin{tabular}{lp{4in}}
If[BOOLEAN, & \\
\{series of commands\}] & Evaluates the BOOLEAN expression
once. If it evaluates to TRUE, the series of commands are performed.
Each command must be followed by a semi-colon or carriage return.  If
the BOOLEAN evaluates to FALSE, none of the commands are performed.\\
If[BOOLEAN, & \\
\{series of commands\}, & \\
\{series of commands\}] & Evaluates the BOOLEAN expression
once. If it evaluates to TRUE, the first series of commands are
performed.  Each command must be followed by a semi- colon or carriage
return.  If the BOOLEAN evaluates to FALSE, the second series of
commands are performed. \\
While[BOOLEAN, &\\
\{series of commands\}] & Evaluates the BOOLEAN
expression or variable.  As long as it evaluates to TRUE, the series
of commands are performed.  Each command must be followed by a
semi-colon or carriage return.  If the BOOLEAN evaluates to FALSE, the
loop ends without performing the commands.\\
NOTE: & The While command functions as a
loop.  That is, it continues to perform the series of commands as long
as the expression evaluates to TRUE.  The If statement, however, only
performs the series of commands once if the expression evaluates to
TRUE.\\
For[\{expressions\}, & \\
\{expression\}, & \\
\{expressions\}, & \\
\{statements\}] & Evaluates the first set of expressions as initialization;
afterwards, so long as the second parameter (which must evaluate to a 
BOOLEAN value) remains true, executes the statement body followed by the
third parameter expressions in a fashion similar to the While command.
\end{tabular}

\section{Function Reference}

The following is a list of procedures with the operations that they
perform in the Gambit Command Language:

Variable types in all capital letters indicate the type of the
required parameter or return value of the procedure.

The symbol {\tt "=:"} to the right of a procedure specifies the type
of the return value (if any exists) produced by the procedure.

Paremeters enclosed in brackets {\tt "\{ \}"} represent optional
parameters which are not necessary for the procedure to function.

\begin{itemize}

%--A--

\item 
\protect \large \begin{verbatim}
And[x->BOOLEAN, y->BOOLEAN] =: BOOLEAN
\end{verbatim} \normalsize
  
\bd
\item
[Short forms:] \verb+x && y+, \verb+x AND y+.
\item
[Description:] Logical And.
\item
[Return value:] Returns the minimum of $x$ and $y$.  
\item
[Required parameters:]\hfil\null
\bd
\item
[x:] First argument.  
\item
[y:] Second argument
\ed
\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
AppendNode[n->NODE, pl->INTEGER, br->INTEGER] =: NODE
\end{verbatim} \normalsize

\bd
\item
[Description:] Appends the number of branches specified to the
indicated terminal node and places the node in a new information set
for the given player.
\item
[Return value:] Returns the node to which new branches have been
appended.
\item
[Required parameters:]\hfil\null
\par
\bd
\item
[n:] The terminal node to which branches are to be added.
\item
[pl:] The player whose information set the node will now belong to.
If the player specified is not already defined in the game, the player
is created automatically.
\item
[br:] The number of branches to be appended to the node.
\ed

\item
[Optional parameters:] None.
\ed

\item 
\protect \large \begin{verbatim}
Assign[x<->T, y->T] =: T
\end{verbatim} \normalsize
for all types {\tt T}.
\bd
\item
[Short form:] \verb+name := expression+
\item
[Description:] Creates a variable (a function with no arguments) with name
given by \verb+name+ and return data type the same as that of
\verb+expression+
\item
[Return value:] Returns the value assigned.
\item
[Required parameters:]\hfil\null
\bd
\item
[name:] The name of the variable to be created.  This must be a different
name from any previously existing function.  
\item
[expression:] Returns the value to be stored by the variable
\ed
\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
AttachOutcome[n->NODE, outc->INTEGER] =: NODE
\end{verbatim}\normalsize

\bd
\item
[Description:] Attaches the indicated outcome to the specified node.
\item
[Return value:] Returns the node to which the outcome is attached.
\item
[Required parameters:]\hfil\null

\bd
\item
[n:] The node to which the outcome is to be attached.  Note that the
node need not be terminal in order to have an outcome attached.
\item
[outc:] The number of the outcome to be attached.  If no outcome with
the indicated number exists, no action is taken.
\ed

\item
[Optional parameters:] None.
\ed

%--B--

%--C--

\item
\protect \large \begin{verbatim}
Car[l->LIST(T)] =: T
\end{verbatim}\normalsize

For all types T.

\bd
\item
[Description:] Finds the first element of the specified list of type
T.
\item
[Return value:] Returns a value of type T which is the first element
of the list.
\item 
[Required parameters:]\hfil\null
	
\bd
\item
[l:] The list of type T on which the procedure is to be performed.
\ed

\item
[Optional parameters:] None.
\ed

\item

\protect \large \begin{verbatim}
Cdr[l->LIST(T)] =: LIST(T)
\end{verbatim}\normalsize

For all types T.

\bd
\item
[Description:] Deletes the first element of the specified list of type
T.
\item 
[Return value:] A list of type T which is the specified list minus its
first element.
\item   
[Required parameters:]\hfil\null

\bd
\item
[l:] The list of type T on which the procedure is to be performed.
\ed
\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
Contains[e->T, l->LIST(T)] =: BOOLEAN
\end{verbatim}\normalsize

For all types T.

\bd
\item
[Description:] Finds whether the specified value of type T is
contained in the indicated list of type T.
\item 
[Return value:] True when the specified value is contained in the
list.
\item
[Required parameters:]\hfil\null
	
\bd
\item	
[e:] The value of type T to be searched for.
\item
[l:] The list of type T which is to be searched in.
\ed

\item
[Optional parameters:] None.
\ed

\item

\protect \large \begin{verbatim}
CopyTree[n->NODE, to->NODE] =: NODE
\end{verbatim}\normalsize

\bd
\item
[Description:] Copies the subtree rooted at the specified node to the
indicated node.
\item
[Return value:] Returns the destination node $to$.
\item
[Required parameters:]\hfil\null

\bd
\item	
[n:] The node at which the subtree to be copied is rooted.
\item
[to:] The node to which the subtree is to be copied.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
CrunchNfg[N->NFG] =: NFG
\end{verbatim}\normalsize

\bd
\item
[Description:] Creates a new problem in normal form for which the
strategies are those of the smallest strategy set of the specified
normal form problem and which contains only those payoff elements
corresponding to those strategies.
\item
[Return value:] Returns the new normal form problem.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[N:] The problem in normal form from which the new normal form problem
is to be created.
\ed

\item  
[Optional parameters:] None.
\ed

%--D--

\item
\protect \large \begin{verbatim}
DeleteAction[n->NODE, br->INTEGER] =: NODE
\end{verbatim}\normalsize

\bd
\item
[Description:] Deletes the indicated action number from the
information set containing the specified node.
\item
[Return value:] The given node.  [Required parameters:]\hfil\null
	
\bd
\item
[n:] The node belonging to the information set from which the action
is to be deleted.
\item [br:] The number of the branch to be deleted.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
DeleteNode[n->NODE, keep->INTEGER] =: NODE
\end{verbatim}\normalsize

\bd
\item   
[Description:] Deletes the indicated node from the tree.  The
specified child of the deleted node is kept and replaces the node in
its spot in the tree.  The subtrees associated with all other children
of the deleted node are deleted.
\item
[Return value:] The node which replaces the deleted node.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[n:] The node to be deleted.
\item
[keep:] The child of the deleted node which is to be kept.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
DeleteTree[n->NODE] =: NODE
\end{verbatim}\normalsize

\bd
\item
[Description:] Deletes the subtree rooted at the specified node.  This
node then becomes a terminal node.
\item
[Return value:] The indicated node which is now a terminal node.
\item
[Required parameters:]\hfil\null

\bd
\item  
[n:] The node where the subtree to be deleted is rooted.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
DetachOutcome[n->NODE] =: NODE
\end{verbatim}\normalsize

\bd
\item
[Description:] Sets the outcome attached to the specified node to the
null outcome.
\item   
[Return value:] The indicated node.
\item
[Required parameters:]\hfil\null

\bd
\item	
[n:] The node whose outcome is to be detached.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
DisplayEfg[E->EFG]
\end{verbatim}\normalsize

\bd
\item
[Description:] Prints the game tree of the specified extensive form
problem in outline form.
\item
[Return value:] None.
\item
[Required parameters:]\hfil\null

\bd
\item
[E:] The game in extensive form which is to be displayed.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
DisplayNfg[N->NFG, {sset->INTEGER}]
\end{verbatim}\normalsize

\bd
\item
[Description:] Prints the specified normal form problem as a list of
contingencies and corresponding payoff vectors.  Uses the last
strategy set unless otherwise specified.
\item
[Return value:] None.
\item
[Required parameters:]\hfil\null

\bd	
\item
[N:] The game in normal form which is to be displayed.
\ed

\item
[Optional parameters:]\hfil\null

\bd
\item
[sset:] The number of the strategy set of the specified normal form
problem which is to be used in displaying the problem.  If not
specified, the last (smallest) strategy set is used.
\ed
\ed

\item 
\protect \large \begin{verbatim}
Divide[x->T, y->T] =: T
\end{verbatim} \normalsize

For T = FLOAT, RATIONAL  
\bd
\item
[Short form:] \verb%x / y%
\item
[Description:] Divides $y$ into $x$.
\item
[Return value:] Returns the value of $x / y$  
\item
[Required parameters:]\hfil\null
\bd
\item
[x:] First argument.  
\item
[y:] Second argument
\ed
\item
[Optional parameters:] None.
\ed

\item 
\protect \large \begin{verbatim}
Divide[x->INTEGER, y->INTEGER] =: INTEGER
\end{verbatim} \normalsize

\bd
\item
[Short form:] \verb%x DIV y%
\item
[Description:] Divides $y$ into $x$, truncating the result.
\item
[Return value:] Returns the value of $x DIV y$  
\item
[Required parameters:]\hfil\null
\bd
\item
[x:] First argument.  
\item
[y:] Second argument
\ed
\item
[Optional parameters:] None.
\item
[See also:] \verb+Modulus+.
\ed

%--E--

\item
\protect \large \begin{verbatim}
EfgToAfg[E->EFG, {time<->RATIONAL}] =: NFG
\end{verbatim}\normalsize

\bd
\item
[Description:] Converts a problem in extensive form to the same
problem in the corresponding agent normal form.
\item
[Return value:] The new agent normal form game.
\item 
[Required parameters:]\hfil\null

\bd
\item
[E:] The problem in extensive form to be converted to agent normal
form.
\ed

\item
[Optional parameters:]\hfil\null
	
\bd
\item
[time:] Returns the elapsed time for the operation.
\ed
\ed

\item
\protect \large \begin{verbatim}
EfgToNfg[E->EFG, {time<->RATIONAL}] =: NFG
\end{verbatim}\normalsize

\bd
\item
[Description:] Converts a problem in extensive form to the same
problem as a reduced normal form game.
\item
[Return value:] The new normal form game.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[E:] The problem in extensive form to be converted to normal form.
\ed

\item
[Optional parameters:]\hfil\null
	
\bd
\item
[time:] Returns the elapsed time for the operation.
\ed
\ed

\item

\protect \large \begin{verbatim}
ElapsedTime[] =: RATIONAL
\end{verbatim}\normalsize

\bd
\item
[Description:] Calculates the time transpired since the last time
StartWatch[] was used if the system stopwatch is currently running.
Otherwise, calculates the time elapsed between the last StartWatch[] -
StopWatch[] match.
\item
[Return value:] Returns the time value given by the system stopwatch
\item
[Required parameters:] None.
\item   
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
ElimDom[N->NFG, {pl->LIST(INTEGER)}, {strong->BOOLEAN},
{time<->RATIONAL}, 	{output->TEXT}, {NIT->INTEGER}] =: INTEGER
\end{verbatim} \normalsize

\bd
\item
[Description:] Performs iterated (unless otherwise specified) deletion
of dominated strategies for the list of players specified.
\item  
[Return value:] The number of the new strategy set.  The original full
strategy set is numbered 1.  Each iteration creates a new strategy set
with an integer value one greater than that of the previous strategy
set.  Therefore, if no dominated strategies are found, the return
value is equal to 1.
\item
[Required paremeters:]\hfil\null
	
\bd
\item
[N:] The problem in normal form for which dominated strategies are to
be eliminated.
\ed

\item
[Optional parameters:]\hfil\null

\bd
\item
[pl:] Specifies the list of players for which the procedure is to be
performed.  If unspecified, it defaults to all players.
\item
[strong:] Determines the type of dominance used.  The default value is
False, which signifies that weak dominance is used.  If `strong` is
specified to be True, strong dominance is used.
\item
[time:] Returns the elapsed time for the operation.
\item
[output:] Redirects the output of the procedure to a specified file.
Directing output to ``/dev/null'' under Unix turns output off.  By
default, it directs output to the screen.
\item
[NIT:] The number of iterations to be performed by the procedure.  If
not specified, it has a default value of zero which means that all
dominated strategies are iteratively deleted.
\ed
\ed

\item
\protect \large \begin{verbatim}
Equal[x->T, y->T] =: BOOLEAN
\end{verbatim}\normalsize

For all types T.

\bd
\item
[Short form:] \verb+x = y+.
\item
[Description:] Equality check for two objects.
\item
[Return value:] Returns the value of $x = y$.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[x:] First argument.
\item
[y:] Second argument.
\ed

\item
[Optional parameters:] None.

\ed

%--F--

\item
\protect \large \begin{verbatim}
For[start, test, incr, body]
\end{verbatim}\normalsize

\bd
\item
[Description:] Executes $start$, then repeatedly evaluates $body$ and $incr$
until $test$ fails to give $true$.
\item
[See also:] \verb+While+.
\ed

%--G--

\item
\protect \large \begin{verbatim}
GetActionName[n->NODE, br->INTEGER] =: TEXT
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds the name assigned to the action corresponding to
the indicated branch of the specified node.
\item   
[Return value:] The name of the action.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[n:] The node at which the action to be found exists.
\item
[br:] The branch which corresponds to the action to be found.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
GetActionProbs[n->NODE] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds the vector of probabilities for the actions at
the specified node.  This is only meaninful for nodes in information
sets belonging to the player representing chance (player 0).
\item
[Return value:] Returns the vector of action probabilities for the
node.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[n:] The node for which the action probabilities are to be found.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
GetDominator[N->NFG, pl->INTEGER, st->INTEGER] =: INTEGER
\end{verbatim}\normalsize

\bd
\item
[Description:] Determines the number of strategies which dominate the
specified strategy for the indicated player in the given problem in
normal form.
\item
[Return value:] Returns the number of strategies which dominate the
specified strategy.  If the strategy is undominated, returns a value
of zero.
\item
[Required parameters:]\hfil\null

\bd
\item
[N:] The problem in normal form in which the specified strategy of the
indicated player is to be tested for domination.
\item
[pl:] The number corresponding to the player for whom the specified
strategy is to be tested for domination.
\item
[st:] The number corresponding to the strategy belonging to the
indicated player which is to be tested for domination.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
GetInfosetName[n->NODE] =: TEXT
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds the name of the information set to which the
specified node belongs.
\item
[Return value:] The name of the information set.
\item
[Required parameters:]\hfil\null

\bd
\item
[n:] The node which belongs to the information set to be found.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
GetNextSibling[n->NODE] =: NODE
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds the next sibling of the specified node.
\item
[Return value:] The node which is the next sibling of the specified
node.
\item
[Required parameters:]\hfil\null

\bd
\item
[n:] The node for which the next sibling is to be found.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
GetOutcome[E->EFG, outc->INTEGER] =: LIST(RATIONAL)
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds the vector of payoffs to the players for the
outcome with the indicated number in the specified problem in
extensive form.
\item
[Return value:] The vector of payoffs corresponding to the specified
outcome.  If the outcome is not defined, the procedure returns the
empty list.
\item
[Required parameters:]\hfil\null

\bd
\item
[E:] The problem in extensive form for which the outcome is to be
found.
\item
[outc:] The number assigned to the outcome for which the payoff vector
will be returned.
\ed

\item
[Optional paramteters:] None.
\ed

\item
\protect \large \begin{verbatim}
GetOutcomeName[E->EFG, outc->INTEGER] =: TEXT
\end{verbatim}\normalsize

\bd

\item
[Description:] Finds the name of the specified outcome in the
indicated problem in extensive form.  If the outcome is not defined,
an error is given.
\item
[Return value:] The name assigned to the indicated outcome.  By
default, the name of an outcome is the empty string.
\item
[Required parameters:]\hfil\null

\bd
\item	  
[E:] The problem in extensive form for which the outcome name is to be
found.
\item
[outc:] The number corresponding to the outcome for which the name
will be returned.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
GetPlayerName[E->EFG, pl->INTEGER] =: TEXT
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds the name of the indicated player in the given
problem in extensive form.
\item
[Return value:] The name assigned to the indicated player.  If the
indicated player has not been assigned a name or does not exist, the
procedure returns the empty string.
\item
[Required parameters:]\hfil\null

\bd
\item  
[E:] The problem in extensive form for which the player name is to be
found.
\item
[pl:] The number assigned to the player whose name will be returned.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
GetPriorSibling[n->NODE] =: NODE
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds the prior sibling of the specified node.
\item
[Return value:] The node which is the prior sibling of the specified
node.
\item
[Required parameters:]\hfil\null

\bd
\item
[n:] The node for which the prior sibling is to be found.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
GetStratName[N->NFG, pl->INTEGER, st->INTEGER] =: TEXT
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds the name assigned to the specified strategy of
the indicated player of the given problem in normal form.
\item
[Return value:] Returns the name found.  If a name has not been
assigned to the strategy, the empty string is returned.
\item
[Required parameters:]\hfil\null

\bd
\item
[N:] The problem in normal form in which the name assigned to the
specified strategy of the indicated player is to be found.
\item
[pl:] The number corresponding to the player for which the name of the
indicated strategy is to be found.
\item
[st:] The number corresponding to the strategy of the indicated player
for which the name is to be found.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
GetTitle[E->EFG] =: TEXT
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds the title of the indicated problem in extensive
form.
\item
[Return value:] The title of the indicated extensive form problem.  If
the title has not been assigned, the empty string is returned.
\item
[Required parameters:]\hfil\null

\bd
\item
[E:] The problem in extensive form whose title is to be found.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
Gobit[N->NFG, E->EFG, {trace->INTEGER}, {nequilib->INTEGER},
{minLam->RATIONAL}, {maxLam->RATIONAL}, {delLam->RATIONAL},
{type->INTEGER}, {start-> MIXED or BEHAV} ,
{maxitsOpt->INTEGER}, {maxitsBrent->INTEGER},
{tolOpt->RATIONAL}, {tolBrent}->RATIONAL}, {time<->RATIONAL},
{output->TEXT}, {pxifile->TEXT}] =: INTEGER
\end{verbatim}\normalsize

\bd
\item
[Description:] Computes a branch of the logistic quantal response
correspondence (as described in \cite[1995]{MckPal:1994} for 
the specified extensive or normal form game.  The branch is computed
for values of $\lambda$ between $\underline{\lambda}$ and
$\bar{\lambda}.$ The algorithm starts at $\lambda_0 =
\underline{\lambda}$ if $\delta>0,$ or $\lambda_0 = \bar{\lambda}$ 
if $\delta<0$. It then increments according to the formula 
$$
\lambda_{t+1} = \lambda_t +\delta \lambda_t^a,
$$ 
where $\underline\lambda,$ $\bar\lambda,$ $\delta,$ and $a$ are
parameters described below. In the computation for the first value of
$\lambda_0$, the algorithm begins its search for a solution at the
starting point determined by the parameter ''start.''  At each
successive value of $\lambda_t,$ the algorithm begins it's search at
the point found in step $t - 1$
\item
[Return value:] XXXX.
\item 
[Required parameters:]\hfil\null Exactly one of the following

\bd
\item
[N:] The problem in normal form for which the Gobit solution is to be
found.
\item	
[E:] The problem in extensive form for which the Gobit solution is to
be found.
\ed

\item
[Optional parameters:]\hfil\null

\bd
\item
[trace:] Sets the print level.  Higher values generate more output.
The default value is 0.
\item
[nequilib:] Sets the number of equilibria to find for each value of
$\lambda$.  Has a default value of 1.
\item
[minLam:] Sets $\underline\lambda,$ the minimum value of $\lambda.$
Default is $\underline\lambda = 0.01$.
\item
[maxLam:] Sets $\bar\lambda,$ the maximum value of $\lambda.$  Default is
$\bar\lambda = 30.0.$
\item
[delLam:]  Constant, $\delta,$ used in incrementing.   Default is
$\delta = .01.$
\item
[type:] Exponent, $a,$ used in incrementing $\lambda.$  Setting $a = 0$
corresponds to linear incrementing, and $a = 1$ results in geometric
incrementing.  Default is $a = 1$.
\item
[start:] Sets the tarting point of the search for the initial value of
$\lambda.$  Default is the centroid, where all strategies are chosen
with equal probability.  
\item
[maxitsOpt:] Sets the maximum number of iterations to the
n-dimensional optimization routine.  Default is 200.
\item
[maxitsBrent:] Sets the maximum number of iterations in the
1-dimensional line search.  Default is 100.
\item
[tolOpt:] Sets the tolerance for the n-dimensional optimization
routine.  Default is 1.0e-10.
\item
[tolBrent:] Sets the tolerance for the 1-dimensional line search.
Default is 2.0e-10.
\item
[time:] Returns the elapsed time for the operation.
\item
[output:] Can be used to redirect the output of this procedure to a
file.  Directing output to ``/dev/null'' under Unix turns output off.
By default, output is directed to the screen.
\item
[pxifile:] Can be used to generate an output file compatible for input
to pxi, a program for graphical viewing and display of the output.  
\ed
\ed

\item
\protect \large \begin{verbatim}
GreaterEqual[x->T, y->T] =: BOOLEAN
\end{verbatim}\normalsize

For T = INTEGER, FLOAT, RATIONAL, or TEXT.

\bd
\item
[Short form:] \verb+x >= y+
\item
[Description:] Yields $true$ if $x$ is greater than or equal to $y$
\item
[Return value:] Returns the value of $x \geq y$.
\item
[Required parameters:]\hfil\null

\bd
\item
[x:] First argument
\item
[y:] Second argument
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
GreaterThan[x->T, y->T] =: BOOLEAN
\end{verbatim}\normalsize

For T = INTEGER, FLOAT, RATIONAL, or TEXT.

\bd
\item
[Short form:] \verb+x > y+
\item
[Description:] Yields $true$ if $x$ is greater than $y$
\item
[Return value:] Returns the value of $x > y$.
\item
[Required parameters:]\hfil\null

\bd
\item
[x:] First argument
\item
[y:] Second argument
\ed
\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
GridSolve[N->NFG, {trace->INTEGER}, {output->TEXT},
{minLam->RATIONAL}, {maxLam->RATIONAL}, {delLam->RATIONAL},
{type->INTEGER}, {delp->RATIONAL}, {tol->RATIONAL},
{time<->RATIONAL}] =: INTEGER
\end{verbatim}\normalsize

\bd
\item
[Description:] Performs a grid search to compute the complete logistic
quantal response correspondence (as described in McKelvey and Palfrey
[1994, 1995]) for a (small) two-person normal form game.  The
correspondence is computed for values of $\lambda$ between
$\underline{\lambda}$ and $\bar{\lambda}.$ Points are evaluated in
terms of the value of an objective function, that measures the
distance between the original point, and the best response to the best
response (under the logistic best response function.)  Points that are
close (within 'tol') to being fixed points are kept, others are
discarded.  The first value of $\lambda$ is $\lambda_0 =
\underline\lambda.$ $\lambda$ is incremented according to the formula

$$  
\lambda_{t+1} = \lambda_t +\delta \lambda_t^a,
$$ 
Here, $a$ is given by $1.0 - $ 'type', and $\underline\lambda,$
$\bar\lambda,$ and $\delta,$ are parameters described below.  Values
of the probabilities are evaluated on a grid of mesh 'delp.'

\item
[Return value:] XXXX .
\item
[Required parameters:]\hfil\null
	
\bd
\item  
[N:] The problem in normal form which is to be operated on.
\ed

\item
[Optional parameters:]\hfil\null

\bd
\item	
 [trace:] Sets the print level.  Higher values generate more output.
The default value is 0.
\item
[output:] Can be used to redirect the output of this procedure to a
file.  Directing output to ``/dev/null'' under Unix turns output off.
By default, output is directed to the screen.
\item
[minLam:] Sets $\underline\lambda,$ the minimum value of $\lambda.$
Default is $\underline\lambda = $ XXXX.
\item
[maxLam:]  Sets $\bar\lambda,$ the maximum value of $\lambda.$
Default is $\bar\lambda = $ XXXX.
\item
[delLam:] Specifies the rate at which the value of Lambda changes.
Has a default value of XXXX .
\item
[type:] Specifies whether to have geometric or linear incrementing.
Default is 0, resulting in $a = 1,$ or !geometric incrementing.
\item
[delp:] Grid size for search over probability space.  Default is XXXX .
\item
[tol:] XXXX .
\item
[time:] Returns the elapsed time for the operation.
\ed
\ed

%--H--

%--I--

\item 
\protect \large \begin{verbatim}
If[condition, t, f]
\end{verbatim} \normalsize
  
\bd
\item
[Description:] If antecedent is true, evaluates $t$.  If
antecedent is false, evaluates $f$. 
\item
[Return value:] If antecedent is true, returns value of $t$.  If
antecedent is false, returns value of $f$.  
\item
[Required parameters:]\hfil\null
\bd
\item
[condition:] The boolean guard of the expression.
\item
[t:] Statements to be evaluated if antecedent is true. 
\item
[f:] Statements to be evaluated if antecedent is false. 
\ed
\ed


\item
\protect \large \begin{verbatim}
InsertAction[n->NODE, as->1, br->3] =: NODE
\end{verbatim}\normalsize

\bd
\item
[Description:] Inserts the indicated number of actions into the
information set containing the specified node.
\item
[Return value:] Returns the specified node.
\item
[Required parameters:]\hfil\null

\bd
\item
[n:] The node which belongs to the information set which is to have
actions inserted into it.
\item
[as:] The number which will correspond to the first inserted action.
\item
[br:] The number of actions to be inserted at the specified node.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
InsertNode[n->NODE, pl->INTEGER, br->INTEGER] =: NODE
\end{verbatim}\normalsize

\bd
\item
[Description:] Inserts a new node belonging to the indicated player at
the location of the specified node and moves that node to the end of
the first branch of the new node.
\item
[Return value:] Returns the specified node.
\item
[Required parameters:]\hfil\null

\bd
\item
[n:] The location where the new node is to be inserted.  The node
currently at this location is then moved to the end of the first
branch of the new node.
\item
[pl:] The number corresponding to the player to which the new node
will belong.  If the player specified is not already defined in	the
game, the player is created automatically.
\item
[br:] The number of branches which the new node will have.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
IsDominated[N->NFG, pl->INTEGER, st->INTEGER] =: BOOLEAN
\end{verbatim}\normalsize

\bd
\item
[Description:] Determines if the strategy corresponding to the
specified number for the indicated player is dominated by another
strategy in the given problem in normal form.  Uses only strategies in
the first strategy set.
\item
[Return value:] Returns True only if the specified strategy for the
given player is dominated.  Returns false otherwise.
\item
[Required parameters:]\hfil\null

\bd
\item
[N:] The problem in normal form in which the specified strategy of the
indicated player is to be tested for domination.
\item
[pl:] The number corresponding to the player for whom the specified
strategy is to be tested for domination.
\item
[st:] The number corresponding to the strategy belonging to the
indicated player which is to be tested for domination.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
IsPredecessor[n->NODE, of->NODE] =: BOOLEAN
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds whether or not the first node indicated is a
predecessor of the second node given.
\item
[Return value:] Returns True only if the first node indicated is a
predecessor of the second node given.
\item
[Required parameters:]\hfil\null

\bd
\item
[n:] The node which, when it is the predecessor of the other node,
will result in the return value being True.
\item
[of:] The node which, when it is preceeded by the other node, will
result in the return value being True.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
IsSuccessor[n->NODE, from->NODE] =: NODE
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds whether or not the first node indicated is a
successor of the second node given.
\item
[Return value:] Returns True only if the first node indicated is a
successor of the second node given.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[n:] The node which, when it is a successor of the other node, will
result in the return value being True.
\item
[of:] The node which, when it is succeeded by the other node, will
result in the return value being True.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
IsWatchRunning[] =: BOOLEAN
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds whether or not the system stopwatch is currently
running.
\item
[Return value:] True only if the system stopwatch is currently
running.  Returns False otherwise.
\item
[Required parameters:] None.
\item
[Optional parameters:] None.
\ed

%--J--

\item
\protect \large \begin{verbatim}
JoinInfoset[n->NODE, to->NODE] =: NODE
\end{verbatim}\normalsize

\bd
\item
[Description:] Removes the first node specified from the information
set to which it currently belongs and places it in the information set
to which the second node given belongs.
\item
[Return value:] Returns the node $n$.
\item
[Required parameters:]\hfil\null
	  
\bd
\item
[n:] The node which is to be removed from its current information set
and placed in the information set belonging to the second node given.
\item
[to:] The node belonging to the information set to which the first
node specified will be transfered.
\ed

\item
[Optional parameters:] None.
\ed

%--K--

%--L--

\item
\protect \large \begin{verbatim}
LeaveInfoset[n->NODE] =: NODE
\end{verbatim}\normalsize

\bd
\item
[Description:] Removes the specified node from the information set to
which it currently belongs and creates and places it in a new
singleton information set belonging to the same player.
\item
[Return value:] The specified node.
\item
[Required parameters:]\hfil\null
	  
\bd
\item
[n:] The node which is to be removed from the information which it
currently belongs to.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
Lemke[N->NFG, {nequilib->INTEGER},
{time<->RATIONAL}] =: LIST(MIXED)
\end{verbatim}\normalsize

\bd
\item
[Description:] Searches for one solution of the specified normal form
game specified using the Lemke-Howson algorithm.
\item
[Return value:] The list of solutions found.
\item
[Required parameters:]\hfil\null

\bd
\item
[N:] The problem in normal form for which the solution is to be
searched.
\ed

\item
[Optional parameters:]\hfil\null

\bd
\item
[nequilib:] Specifies the number of equilibria to find.  If not given
the default value is zero, which means that all equilibria are to be
found.
\item
[time:] Returns the elapsed time for the operation.
\ed
\ed

\item
\protect \large \begin{verbatim}
Length[l->LIST(T)] =: INTEGER
\end{verbatim}\normalsize
For all types T.

\bd
\item
[Description:] Finds the number of elements in the specified list of
type T.
\item
[Return value:] The number of elements found in the list.
\item
[Required parameters:]\hfil\null

\bd
\item
[l:] The list of type T for which the number of elements is to be
found.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
LessEqual[x->T, y->T] =: BOOLEAN
\end{verbatim}\normalsize

For T = INTEGER, FLOAT, RATIONAL, or TEXT.

\bd
\item
[Short form:] \verb+x <= y+
\item
[Description:] Yields $true$ if $x$ is less than or equal to $y$
\item
[Return value:] Returns the value of $x \leq y$.
\item
[Required parameters:]\hfil\null

\bd
\item
[x:] First argument
\item
[y:] Second argument
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
LessThan[x->T, y->T] =: BOOLEAN
\end{verbatim}\normalsize

For T = INTEGER, FLOAT, RATIONAL, or TEXT.

\bd
\item
[Short form:] \verb+x < y+
\item
[Description:] Yields $true$ if $x$ is less than $y$
\item
[Return value:] Returns the value of $x < y$.
\item
[Required parameters:]\hfil\null

\bd
\item
[x:] First argument
\item
[y:] Second argument
\ed
\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
Liap[{N->NFG|E->EFG}, {trace->INTEGER},
{output->TEXT},
{ntries->INTEGER}, {nequilib->INTEGER},
{start->MIXED|BEHAV},
{maxitsOpt->RATIONAL}, {maxitsBrent->RATIONAL}, 
{tolOpt->RATIONAL}, {tolBrent->RATIONAL},
{time<->RATIONAL}] =: LIST(MIXED)
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds Nash equilibria via the Lyapunov function method
described in McKelvey [1992].  Works on either the extensive or normal
form.  This algorithm casts the problem as a function minimization
problem by use of a Lyapunov function for Nash equilibria.  This is a
continuously differentiable non negative function whose zeros coincide
with the set of Nash equilibria of the game.  A standard descent
algorithm is used to find a constrained local minimum of the function
from any given starting location.  Since a local minimum need not be a
global minimum (with value 0,) the algorithm is not guaranteed to find
a Nash equilibrium from any fixed starting point.  The algorithm thus
incorporates the capability of restarting.  The algorithm starts from
the initial starting point determined by the parameter 'start'.  If a
Nash equilibrium is not found, it will keep searching from new
randomly chosen starting points until a Nash equilibrium has been
found or the maximum number of tries (parameter 'ntries') is exceeded,
whichever comes first.
\item
[Return value:] Returns the list of solutions found.
\item
[Required parameters:] Exactly one of the following \hfil\null

\bd
\item
[N:] The problem in normal form for which the Liapunov solution is to
be found.
\item
[E:] The problem in extensive form for which the Liapunov solution is
to be found.
\ed

\item
[Optional parameters:]\hfil\null

\bd
\item
[start:] Sets the starting profile for the descent algorithm.  The
default is the centroid.
\item
[trace:] Sets the print level.  Higher values generate more output.
The default value is 0.
\item
[output:] Can be used to redirect the output of this procedure to a
file.  Directing output to ``/dev/null'' under Unix turns output off.
By default, output is directed to the screen.
\item
[ntries:] Sets the maximum number of attempts at finding each
equilibrium. Default is 10
\item
[nequilib:] Sets the number of equilibria to find.  Has a default
value of 1.  [maxitsOpt:] Sets the maximum number of iterations to the
n-dimensional optimization routine.  Default is 200.
\item
[maxitsBrent:] Sets the maximum number of iterations in the
1-dimensional line search.  Default is 100.
\item
[tolOpt:] Sets the tolerance for the n-dimensional optimization
routine.  Default is 1.0e-10.
\item
[tolBrent:] Sets the tolerance for the 1-dimensional line search.
Default is 2.0e-10.
\item
[time:] Returns the elapsed time for the operation.
\ed
\ed

%--M--

\item
\protect \large \begin{verbatim}
MergeInfosets[n->NODE, to->NODE] =: NODE
\end{verbatim}\normalsize

\bd
\item
[Description:] Moves all the nodes contained in the information set
which contains the node first specified to the information to which
the second node indicated belongs.
\item
[Return value:] Returns the node $n$.
\item
[Required parameters:]\hfil\null

\bd
\item
[n:] The node which belongs to the information set whose nodes are to
be moved to the second information set.
\item
[to:] The node which belongs to the information set to which all the
nodes from the first information set are to be moved.
\ed

\item
[Optional parameters:] None.
\ed

\item 
\protect \large \begin{verbatim}
Minus[x->T, y->T] =: T
\end{verbatim} \normalsize

For T = INTEGER, FLOAT, RATIONAL  
\bd
\item
[Short form:] \verb%x - y%
\item
[Description:] Subtracts $y$ from $x$.
\item
[Return value:] Returns the value of $x - y$  
\item
[Required parameters:]\hfil\null
\bd
\item
[x:] First argument.  
\item
[y:] Second argument
\ed
\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
MixedToBehav[E->EFG, mp->MIXED] =: BEHAV
\end{verbatim}\normalsize

\bd
\item
[Description:] Projects a specified mixed profile to a behavioral
profile on the given extensive form problem.
\item
[Return value:] Returns the behavioral profile.
\item
[Required parameters:]\hfil\null

\bd
\item
[E:] The problem in extensive form of which the behavioral profile is
to be a subvariable.
\item
[mp:] The mixed profile which is to be projected to a behavioral
profile.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
MixedToBehav[E->EFG, mp->LIST(MIXED)] =: LIST(BEHAV)
\end{verbatim}\normalsize

\bd
\item
[Description:] Projects a specified vector of mixed profiles to a
vector of behavioral profiles on the given extensive form problem.
\item
[Return value:] Returns the vector of behavioral profiles.
\item
[Required parameters:]\hfil\null

\bd
\item
[E:] The problem in extensive form of which the vector of behavioral
profiles is to be a subvariable.
\item
[mp:] The vector of mixed profiles which is to be projected to a
vector of behavioral profiles.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
Modulus[x->INTEGER, y->INTEGER] =: INTEGER
\end{verbatim}\normalsize

\bd
\item
[Short form:] \verb+x MOD y+
\item
[Description:] Computes the remainder from dividing \verb+y+ into \verb+x+.
\item
[Return value:] Returns the remainder of $x / y$.
\item
[Required parameters:]\hfil\null

\bd
\item
[x:] The dividend
\item
[y:] The divisor
\ed

\item
[Optional parameters:] None.
\item
[See also:] \verb+Divide+.
\ed


\item
\protect \large \begin{verbatim}
MoveTree[n->NODE, to->NODE] =: NODE
\end{verbatim}\normalsize

\bd
\item
[Description:] Moves the subtree rooted at the first node specified to
the second given node.
\item
[Return value:] Returns the destination node $to$.
\item
[Required parameters:]\hfil\null
	  
\bd
\item
[n:] The node at which the subtree to be moved is currently rooted.
\item
[to:] The node to which the subtree is to be moved.
\ed

\item
[Optional parameters:] None.
\ed

%--N--

\item
\protect \large \begin{verbatim}
NameOf[n->NODE] =: TEXT
\end{verbatim}\normalsize

\bd
\item
[Description:] Returns the name of the specified node.
\item
[Return value:] The name of the specified node.
\item
[Required parameters:]\hfil\null

\bd
\item
[n:] The node for which the name will be returned.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
NewEfg[{type->DATATYPE}] =: EFG
\end{verbatim}\normalsize

\bd
\item
[Description:] Allocates and returns a new extensive form game.
\item
[Return value:] The newly allocated problem in extensive form.
\item
[Required parameters:] None.
\item
[Optional parameters:]\hfil\null

\bd
\item
[type:] Specifies the type (Float or Rational) of the new extensive
form problem.
\ed
\ed

\item
\protect \large \begin{verbatim}
NewFunction[name->TEXT,arglist->LIST[ TEXT, BOOLEAN, TEXT], 
            body->STATEMENTLIST] =: BOOLEAN
\end{verbatim}\normalsize

\bd
\item [Notes:] Not implemented yet.  
\item
[Description:] Creates a new function.  The return data type of the
function is the return type of \verb+body+ on first evaluation.  It is
a run time error to ever return a different data type.  A function is
visible only after it is created.  Functions created within the body
of a function are only visible to the body, and to functions created
within the body.
\item
[Return value:] 1 if success, 0 if failure.  
\item
[Required parameters:]
\bd
\item[name:] The name of the newly created name.  Must be different
than all function names in current scope.  
\ed
\item
[Optional parameters:]\hfil\null

\bd
\item
[type:] Specifies the type (Float or Rational) of the new extensive
form problem.
\ed
\ed

\item

\protect \large \begin{verbatim}
NewNfg[dim->LIST(INTEGER), {seed->INTEGER},
{type->DATATYPE}] =: NFG
\end{verbatim}\normalsize

\bd
\item
[Description:] Constructs a new game in normal form with the
specified dimensionality.  The \verb+seed+ parameter allows the creation
of a random normal form game with entries between 0 and 1.

\item
[Return value:] Returns the new game in normal form.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[dim:] The desired dimensionality of the new game.
\ed

\item
[Optional parameters:]\hfil\null
	
\bd
\item
[seed:] Reseeds the random number generator with the given integer.  If the
\verb+seed+ is unspecified, or is specified as 0, the created normal form
has all zero entries.  Specifying the \verb+seed+ seeds the random number
generator and generates a game with random payoffs.
\item

[type:] Specifies the type (Float or Rational) of the new normal form
game.  This parameter defaults to \verb+Float+.
\ed
\ed

\item
\protect \large \begin{verbatim}
NewOutcome[E->EFG, {outc->INTEGER}] =: INTEGER
\end{verbatim}\normalsize

\bd
\item
[Description:] Creates and assigns a number to a new outcome within
the specified problem in extensive form.  Note that outcomes are
sequentially numbered, so that if an outcome with the number n exists,
then outcomes with the numbers 1 . . n-1 necessarily also exist.
Therefore, this procedure creates not only the outcome with the
specified number, but all other outcomes necessary to satisfy this
condition.
\item
[Return value:] The number of the newly created outcome.  The optional
parameter 'outc' allows the user to specify the number given to the
new outcome created.  If 'outc' is not specified, the new outcome is
assigned the lowest positive number for which no outcome is defined.
If the number specified by 'outc' already exists as an outcome, no
action is taken and the procedure returns a value of zero.
\item
[Required parameters:]\hfil\null

\bd
\item
[E:] The problem in extensive form for which a new outcome is to be
created.
\ed

\item
[Optional parameters:]\hfil\null

\bd
\item
[outc:] Allows the user to specify the number given to the new outcome
created.  If not specified, the new outcome is assigned the lowest
positive number for which no otcome is defined.  If the number
specified already exists as an outcome, no action is taken and the
procedure returns a value of zero.
\ed
\ed

\item
\protect \large \begin{verbatim}
Not[x->BOOLEAN] =: BOOLEAN
\end{verbatim}\normalsize

\bd
\item
[Short form:] \verb+NOT x+
\item
[Description:] Logical negation.
\item
[Return value:] Returns the boolean opposite of $x$.  
\item
[Required parameters:]\hfil\null
\bd
\item
[x:] The value to be negated.
\ed
\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
NotEqual[x->T, y->T] =: BOOLEAN
\end{verbatim}\normalsize

For all types T.

\bd
\item
[Short form:] \verb+x != y+.
\item
[Description:] Inequality check for two objects.
\item
[Return value:] Returns the value of $x != y$.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[x:] First argument.
\item
[y:] Second argument.
\ed

\item
[Optional parameters:] None.

\ed

\item
\protect \large \begin{verbatim}
NthChild[n->NODE, child->INTEGER] =: NODE
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds the node which is the indicated child of the
specified node.  The expression: NthChild[n->node, child->i] is
equivalent to: node\#i.
\item
[Return value:] Returns the node which is the indicated child of the
specified node.
\item
[Required parameters:]\hfil\null
	  
\bd
\item
[n:] The node for which the indicated child is to be found.
\item
[child:] The number corresponding to the child of the specified node
which is to be found.
\ed

\item 
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
NumChildren[n->NODE] := INTEGER
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds the number of children of the specified node.
\item
[Return value:] Returns the number of children of the specified node.
\item
[Required parameters:]\hfil\null

\bd
\item
[n:] The node whose children are to be counted.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
NumInfosets[E->EFG, pl->INTEGER] =: INTEGER
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds the number of information sets belonging to the
specified player in the given problem in extensive form.
\item
[Return value:] Returns the number of information sets belonging to
the specified player.  If the indicated player is not defined in the
game, the return value is equal to zero.
\item
[Required parameters:]\hfil\null

\bd
\item
[E:] The problem in extensive form in which the information sets for
the specified player are to be counted.
\item
[pl:] The number corresponding to the player for which the number of
information sets are to be counted.
\ed
\item
 [Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
NumNodes[E->EFG] =: INTEGER
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds the number of nodes (including terminal nodes) in
the specified problem in extensive form.
\item
[Return value:] Returns the number of nodes found.
\item
[Required parameters:]\hfil\null

\bd
\item
[E:] The problem in extensive form in which the number of nodes are to
be counted.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
NumOutcomes[E->EFG] =: INTEGER
\end{verbatim} \normalsize

\bd
\item
[Description:] Finds the number of outcomes in the specified problem
in extensive form.
\item
[Return value:] Returns the number of outcomes found.
\item
[Required parameters:] \hfil\null

\bd
\item
[E:] The problem in extensive form in which the number of outcomes is
to be found.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
NumOutcomes[N->NFG] =: INTEGER
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds the number of outcomes in the specified problem
in normal form.
\item
[Return value:] Returns the number of outcomes found.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[N:] The problem in normal form in which the number of outcomes is to
be found.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
NumPlayers[E->EFG] =: INTEGER
\end{verbatim} \normalsize

\bd
\item
[Description:] Finds the number of players in the specified problem in
extensive form.
\item
[Return value:] Returns the number of players found.
\item
[Required parameters:]\hfil\null

\bd
\item
[E:] The problem in extensive form in which the number of players is
to be found.
\ed

\item   
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
NumStrats[N->NFG, pl->INTEGER, {sset->INTEGER}] =: INTEGER
\end{verbatim}\normalsize

\bd

\item
[Description:] Finds the number of strategies for the specified player
in the given problem in normal form.
\item
[Return value:] Returns the number of strategies found.
\item
[Required parameters:]\hfil\null

\bd
\item
[N:] The normal form problem in which the number of strategies for the
specified player is to be found.
\item
[pl:] The number corresponding to the player in the given problem in
normal form for whom the number of strategies is to be found.
\ed

\item
[Optional parameters:]\hfil\null
	
\bd
\item  
[sset:] The number of the strategy set in which strategies for the
specified player will be counted.  If not given the last (smallest)
strategy set is used.

\ed
\ed

%--O--

\item 
\protect \large \begin{verbatim}
Or[x->BOOLEAN, y->BOOLEAN] =: BOOLEAN
\end{verbatim} \normalsize
  
\bd
\item
[Short form:] \verb+x || y+, \verb+x OR y+.
\item
[Description:] Logical Or.
\item
[Return value:] Returns the maximum of $x$ and $y$.  
\item
[Required parameters:]\hfil\null
\bd
\item
[x:] First argument.  
\item
[y:] Second argument
\ed
\item
[Optional parameters:] None.
\ed



\item

\protect \large \begin{verbatim}
OutcomeOf[n->NODE] =: INTEGER
\end{verbatim}\normalsize

\bd

\item
[Description:] Finds the number of the outcome associated with the
specified node.
\item
[Return value:] Returns the number corresponding to the outcome
attached to the specified node.  If the node does not have an outcome
attached, a value of zero is returned.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[n:] The node for which the attached outcome is to be found.
\ed

\item
[Optional parameters:] None.
\ed

%--P--

\item
\protect \large \begin{verbatim}
Paren[x->T] =: T
\end{verbatim}\normalsize

for all types T.

\bd
\item
[Short form:] \verb+(x)+
\item
[Description:] The identity mapping.  Used to control the order of evaluation
of expressions.
\item
[Return value:] The value of the expression \verb+x+.
\item
[Required parameters:]\hfil\null
\bd
\item
[x:] The expression to be evaluated.
\ed
\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
ParentOf[n->NODE] =: NODE
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds the node which is the parent of the specified
node.
\item
[Return value:] Returns the node which is the parent of the specified
node.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[n:] The node for which the parent is to be found.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
PlayerOf[n->NODE] =: INTEGER
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds the player who makes the decision at the
specified node.
\item
[Return value:] Returns the number corresponding to the player found.
\item
[Required parameters:]\hfil\null

\bd
\item
[n:] The node for which the player making the decision is to be found.
\ed

\item
[Optional parameters:] None.
\ed

\item 
\protect \large \begin{verbatim}
Plus[x->T, y->T] =: T
\end{verbatim} \normalsize

For T = INTEGER, FLOAT, RATIONAL  
\bd
\item
[Short form:] \verb%x + y%
\item
[Description:] Adds $x$ and $y$.
\item
[Return value:] Returns the value of $x + y$  
\item
[Required parameters:]\hfil\null
\bd
\item
[x:] First argument.  
\item
[y:] Second argument
\ed
\item
[Optional parameters:] None.
\ed

\item 
\protect \large \begin{verbatim}
Plus[x->TEXT, y->TEXT] =: TEXT
\end{verbatim} \normalsize

\bd
\item
[Short form:] \verb%x + y%
\item
[Description:] Concatenates $x$ and $y$.
\item
[Return value:] Returns a TEXT object consisting of $x$ followed by $y$  
\item
[Required parameters:]\hfil\null
\bd
\item
[x:] First argument.  
\item
[y:] Second argument
\ed
\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
PureNash[N->NFG, {num->INTEGER}, {time<->RATIONAL},
{output->TEXT}] =: INTEGER
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds the weak pure strategy Nash equilibria in the
specified normal form game.  [Return value:] The number of equilibria
found.  The optional parameter 'num' allows the user to set the
maximum number of Nash equilibria to find and has a default value of
1.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[N:] The problem in normal form for which the weak pure strategy Nash
equilibria are to be found.
\ed

\item
[Optional parameters:]\hfil\null
	
\bd
\item
[num:] Allows the user to set the maximum number of Nash equilibria to
find.  Has a default value of 1.
\item
[time:] Returns the elapsed time for the operation.
\item
[output:] Can be used to redirect the output of this procedure to a
file.  Directing output to ``/dev/null'' under Unix turns output off.
By default, output is directed to the screen.

\ed
\ed

\item

%--Q--

\protect \large \begin{verbatim}
Quit
\end{verbatim}\normalsize

\bd

\item
[Description:] Exits the command language.
\item
[Return value:] None.
\item
[Required parameters:] None.
\item
[Optional parameters:] None.
\ed

%--R--

\item
\protect \large \begin{verbatim}
ReadEfgFile[file->TEXT] =: EFG
\end{verbatim}\normalsize

\bd
\item
[Description:] Creates a new problem whose contents are the extensive
form game stored in the specified file.
\item
[Return value:] The problem in extensive form read from the file.
\item

[Required parameters:

\bd
\item
[file:] Specifies the file from which the extensive form game is to be
read.  If the file specified does not exist, an error message is
returned.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
ReadNfgFile[file->TEXT, {type->DATATYPE}] =: NFG
\end{verbatim}\normalsize

\bd
\item
[Description:] Creates a new problem whose contents are the normal
form game stored in the specified file.  The file is read as a
floating- point normal form unless otherwise specified by the user.
\item
[Return value:] The problem in normal form read from the file.
\item
[Required parameters:]\hfil\null

\bd
\item
[file:] Specifies the file from which the normal form game is to be
read.  If the file specified does not exist, an error message is
returned.
\ed

\item
[Optional parameters:]\hfil\null
	

\bd
\item
[type:] Indicates whether the file is to be read as a floating- point
normal form or as a rational normal form.  If not given, the default
value is floating-point.
\ed
\ed

\item

\protect \large \begin{verbatim}
RemoveOutcome[E->EFG, outc->INTEGER] =: EFG
\end{verbatim}\normalsize

\bd
\item
[Description:] Removes the specified outcome from the given problem in
extensive form.  All nodes with the specified outcome attached are
reset to having no outcome attached.  If the outcome does not exist in
the given problem, no action is taken.  The outcomes remaining in the
game are re-numbered, so that the number of the outcome removed is
given to the outcome which previously had the next highest number, the
number previously corresponding to this outcome is assigned to the
outcome which previously had the next highest number, and so on.
\item  
[Return value:] Returns the modified extensive form problem.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[E:] The problem in extensive form from which the specified outcome is
to be removed.
\item
[outc:] The number corresponding to the outcome which is to be removed
from the given problem.  If no outcome with that number exists in the
problem, no action is taken.
\ed
\ed

\item
\protect \large \begin{verbatim}
RootNode[E->EFG, {game->INTEGER}] =: NODE
\end{verbatim}\normalsize

\bd
\item
[Description:] Finds the root node of specified game in the given
problem in extensive form.  If a game is not specified, the first game
is used by default.
\item
[Return value:] Returns the root node of the game.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[E:] The problem in extensive form in which the root node is to be
found.
\ed

\item
[Optional parameters:]\hfil\null

\bd
\item
[game:] Specifies the game of which the root node is to be found.  If
not given, the first game is used by default.
\ed
\ed

\item

\protect \large \begin{verbatim}
Run[TEXT]
\end{verbatim}\normalsize

\bd
\item
[Description:] Includes the commands in the specified file as commands
in the running GCL program.  The program treats the command as if it
were replaced by the contents of the file.
\item
[Return value:] None.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[TEXT:] Any expression which evaluates to a text string which is a
valid filename.
\ed

\item
[Optional parameters:] None.
\ed

%--S--

\item

\protect \large \begin{verbatim}
SetActionName[n->NODE, br->INTEGER, name->TEXT] =: NODE
\end{verbatim}\normalsize

\bd
\item
[Description:] Sets the name of the specified branch number of the
indicated node to the name given.
\item
[Return value:] Returns the node specified.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[n:] The node at which the desired action occurs.
\item
[br:] The number of the branch or action ocurring at the given node
which is to be assigned a name.
\item
[name:] The name which is to be assigned to the given action.
\ed

\item
[Optional parameters:] None.

\ed

\item

\protect \large \begin{verbatim}
SetActionProbs[n->NODE, probs->LIST(RATIONAL)] =: NODE
\end{verbatim}\normalsize

\bd
\item
[Description:] Sets the action probabilities to the specified values
for the given node.  This is only meaninful for nodes in information
sets belonging to the player representing chance (player 0).
\item
[Return value:] Returns the node specified.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[n:] The node at which the actions will be assigned the specified
probabilities.
\item
[probs:] The vector of values which represent the probabilites which
will be assigned to the actions at the indicated node.
\ed

\item
[Optional parameters:] None.
\ed

\item

\protect \large \begin{verbatim}
SetInfosetName[n->NODE, name->TEXT] =: NODE
\end{verbatim}\normalsize

\bd
\item
[Description:] Assigns the given name given to the information set to
which the indicated node belongs.
\item
[Return value:] Returns the node specified.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[n:] A node belonging to the information set which is to be assigned a
name.
\item
[name:] The name which is to be assigned to the given information set.
\ed

\item
[Optional parameters:] None.
\ed

\item

\protect \large \begin{verbatim}
SetNodeName[n->NODE, name->TEXT] =: NODE
\end{verbatim}\normalsize

\bd
\item
[Description:] Assigns the given name to the specified node.
\item
[Return value:] Returns the specified node.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[n:] The node which is to have a name assigned.
\item
[name:] The name which is to be assigned to the specified node.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
SetOutcome[E->EFG, outc->INTEGER, value->LIST(RATIONAL)] =: EFG
\end{verbatim}\normalsize
   
\bd
\item
[Description:] Sets the value of the indicated outcome in the given
problem in extensive form, to the values in the specified vector.
\item
[Return value:] Returns the modified problem in extensive form.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[E:] The extensive form problem in which the given outcome is to be
assigned values.
\item

[outc:] The number corresponding to the outcome which is to be
assigned values.  If no outcome with the given number exists, then it
is created.
\item
[value:] The vector of payoffs (as a list of rationals) which are to
be assigned to the outcome.  The length of `value` must match the
number of players defined in the problem.
\ed

\item
[Optional parameters:] None.
\ed

\item

\protect \large \begin{verbatim} 
SetOutcome[E->EFG, outc->INTEGER,
pl->INTEGER, value->RATIONAL] =: EFG
\end{verbatim}\normalsize

\bd
\item
[Description:] Sets the payoff to the player specified for the
indicated outcome in the given problem in extensive form to the given
value.
\item
[Return value:] Returns the modified problem in extensive form.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[E:] The extensive form problem in which the given outcome is to be
assigned a value for the specified player.
\item
[outc:] The number corresponding to the outcome which is to be
assigned a value for the specified player.  If no outcome with the
given number exists, no action is performed.
\item
[pl:] The player for which the payoff of the given outcome is to be
set.
\item
[value:] The value (as a rational) which is to be assigned to the
given outcome for the specified player.
\ed
\ed

\item

\protect \large \begin{verbatim}
SetOutcomeName[E->EFG, outc->INTEGER, name->TEXT] =: EFG
\end{verbatim}\normalsize

\bd
\item
[Description:] Assigns to the outcome with the specified number the
given title.
\item
[Return value:] Returns the modified problem in extensive form.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[E:] The problem in extensive form in which the indicated outcome is
to be assigned the given title.
\item
[outc:] The number corresponding to the outcome which is to be
assigned a title.
\item
[name:] The name which is to be assigned to the indicated outcome.
\ed

\item
[Optional parameters:] None.
\ed

\item

\protect \large \begin{verbatim}
SetPlayerName[E->EFG, pl->INTEGER, name->TEXT] =: EFG
\end{verbatim}\normalsize

\bd
\item
[Description:] Assigns to the player with the specified number the
given name.
\item
[Return value:] Returns the modified problem in extensive form.
\item
[Required parameters:]\hfil\null

\bd
\item
[E:] The problem in extensive form in which the indicated player is to
be assigned a name.
\item
[pl:] The number corresponding to the player which is to be assigned a
name.
\item
[name:] The name which is to be assigned to the specified player.
\ed
\item
[Optional parameters:] None.
\ed

\item

\protect \large \begin{verbatim}
SetStratName[N->NFG, pl->INTEGER, st->INTEGER,
name->TEXT] =: NFG
\end{verbatim}\normalsize

\bd
\item
[Description:] Assigns the given name to the specified strategy of the
indicated player in the given problem in normal form.
\item
[Return value:] Returns the modified normal form problem.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[N:] The problem in normal form in which the given name is to be
assigned to the specified strategy of the indicated player.
\item
[pl:] The number corresponding to the player for which the indicated
strategy is to be assigned the given name.
\item
[st:] The number corresponding to the strategy of the indicated player
to which the given name is to be assigned.
\ed

\item
[Optional parameters:] None.

\ed

\item

\protect \large \begin{verbatim}
SetTitle[E->EFG, title->TEXT] =: EFG
\end{verbatim}\normalsize

\bd
\item
[Description:] Assigns the specified title to the given problem in
extensive form.
\item
[Return value:] Returns the modified problem in extensive form.
\item
[Required parameters:]\hfil\null
	
\bd
\item
[E:] The problem in extensive form which is to be assigned a title.
\item
[title:] The title which is to be assigned to the given problem in
extensive form.
\ed

\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
SimpDiv[N->NFG, {trace->INTEGER},
{output->TEXT},
{number->INTEGER}, {ndivs->INTEGER}, {leash->INTEGER},
{nevals->INTEGER}, {time<->RATIONAL}] =: LIST(MIXED)
\end{verbatim}\normalsize

\bd
\item
[Description:] Computes a Nash equilibrium to a normal form game based
on a simplicial subdivision algorithm.  The algorithm implemented is
that of \cite{VTH:1987}.  The 
algorithm is a simplicial subdivision algorithm which can start at any
point in the simplex.  The algorithm starts with a given grid size,
follows a path of almost completely labeled subsimplexes, and
converges to a completely labeled sub-simplex that approximates the
solution.  Additional accuracy is obtained by refining the grid size
and restarting from the previously found point.  The idea is that by
restarting at a close approximation to the solution, each successive
increase in accuracy will yield a short path, and hence be quick.

In its pure form, the algorithm is guaranteed to find at least one
mixed strategy equilibrium to any n-person game.  Experience shows
that the algorithm works well, and is acceptably fast for many
moderate size problems.  But in some examples it can be quite slow.
The reason for this is that sometimes after restarting with a refined
grid size, even though the starting point is a good approximation to
the solution, the algorithm will go to the boundary of the simplex
before converging back to a point that is close to the original
starting point.  When this occurs, each halving of the grid size will
take twice as long to converge as the previous grid size.  If a high
degree of accuracy is required, or if the normal form is large, this
can result in the algorithm taking a long time to converge.

In order to combat the above difficulty, a parameter 'leash' has been
added to the algorithm which places a limit on the distance which the
algorithm can wander from the restart point. (Setting this parameter
to 0 results in no limit, and gives the pure form of the algorithm.)
With this parameter set to a non trivial value, the algorithm is no
longer guaranteed to converge, and setting small values of the
parameter will sometimes yield lack of convergence.  However,
experience shows that values of the parameter on the order of 10
generally do not destroy convergence, and yield much faster
convergence.

\item
[Return value:] The list of equilibria found.
\item
[Required parameters:]\hfil\null

\bd
\item
[N:] The problem in normal form on which the operation will be
performed.
\ed

\item
[Optional parameters:]\hfil\null
	
\bd
\item
[trace:] Sets the print level.  Higher values generate more output.
The default value is 0.
\item
[output:] Can be used to redirect the output of this procedure to a
file.  Directing output to ``/dev/null'' under Unix turns output off.
By default, output is directed to the screen.
\item
[number:] Maximum number of equilibria to find. Default is 1.  
\item 
[ndivs:] Number of restarts.  At each restart the mesh of the
triangulation is halved.  So this parameter determines the final mesh
by the formula ${1/2}^{ndivs}$.
\item
[leash:] Sets the leashlength. Default is 0, which results in no
constraint, or no leash.  
\item
[time:] Returns the elapsed time for the operation.
\ed
\ed

\item

\protect \large \begin{verbatim}
StartWatch[] =: INTEGER
\end{verbatim}\normalsize

\bd
\item
[Description:] Starts the system stopwatch.
\item
[Return value:] The return value is uninteresting.
\item
[Required parameters:] None.
\item
[Optional parameters:] None.
\ed

\item
\protect \large \begin{verbatim}
StopWatch[] =: INTEGER
\end{verbatim}\normalsize

\bd
\item
[Description:] Stops the system stopwatch.
\item
[Return value:] The return value is uninteresting.
\item
[Required parameters:] None.
\item
[Optional parameters:] None.
\ed

%--T--

\item 
\protect \large \begin{verbatim}
Times[x->T, y->T] =: T
\end{verbatim} \normalsize
  
\bd
\item
[Short form:] \verb+x * y+
\item
[Description:] Multiplies $x$ and $y$.
\item
[Return value:] Returns the value of $x * y$  
\item
[Required parameters:]\hfil\null
\bd
\item
[x:] First argument.  
\item
[y:] Second argument
\ed
\item
[Optional parameters:] None.
\ed

%--U--

%--V--

%--W--

\item 
\protect \large \begin{verbatim}
While[test, statements]
\end{verbatim} \normalsize
  
\bd
\item
[Description:] If test is true, evaluates the statement list consisting of
\verb+do+ followed by itself.  If test fails, evaluates the empty
statement list.
\item
[Return value:] If test fails, returns the last value evaluated from the
statement body, or NULL if the loop never executes.

\item
[Required parameters:]\hfil\null
\bd
\item
[antecedent:] Antecedent.  
\item
[then:] Statement list to be evaluated if antecedent is true. 
\item
[else:] Statement list to be evaluated if antecedent is false. 
\ed
\item
[See also:] \verb+For+.
\ed

\item

\protect \large \begin{verbatim}
WriteEfgFile[E->EFG, file->TEXT] =: EFG
\end{verbatim}\normalsize

\bd
\item
[Description:] Writes the given extensive form problem to the
specified file.  Indicates in the file the type of the file(Float or
Rational) immediately following the title string.  If the type is
Float, the file contains floating point numbers and if the type is
Rational, the file contains rational numbers.
\item
[Return value:] Returns the same extensive form problem.
\item
[Required parameters:]\hfil\null

\bd
\item
[E:] The problem in extensive form which is to be written to the
indicated file.
\item
[file:] The name of the file to which the extensive form problem is to
be written.
\ed
\ed

\item

\protect \large \begin{verbatim}
WriteNfgFile[N->NFG, file->TEXT] =: NFG
\end{verbatim}\normalsize

\bd
\item
[Description:] Writes the given normal form problem to the specified
file.
\item
[Return value:] Returns the same normal form problem.
\item
[Required parameters:]\hfil\null

\bd
\item
[N:] The problem in normal form which is to be written to the
indicated file.

\item
[file:] The name of the file to which the normal form problem is
to be written.
\ed
\ed

%--X--

%--Y--

%--Z--

\end{itemize}
\bibliographystyle{chicagob}
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{gambit}
\end{document}







 




















