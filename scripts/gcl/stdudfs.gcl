// Standard User defined functions

NewFunction[SetNumericFormat[{width->0},{decimals->6},{expmode->False}]=:BOOLEAN,
  !IsNull[Format[1.0,width,decimals,expmode]]
]

NewFunction[GetNumericFormat[{width<->0}, {decimals<->6},
  {expmode<->False}]=:BOOLEAN,
  GetFormat[1.0,width,decimals,expmode];
  True
]

NewFunction[SetIntegerFormat[{width->0}]=:BOOLEAN,
  !IsNull[Format[1,width]]
]

NewFunction[GetIntegerFormat[{width<->0}]=:BOOLEAN,
  GetFormat[1,width];
  True
]

NewFunction[SetTextFormat[{quote->True}]=:BOOLEAN,
  !IsNull[Format["",quote]]
]

NewFunction[GetTextFormat[{quote<->True}]=:BOOLEAN,
  GetFormat["",quote];
  True
]

NewFunction[SetSolutionFormat[{info->False}, {names->False}]=:BOOLEAN,
  !IsNull[Format[Centroid[NewEfg[]],info,names]]
]

NewFunction[GetSolutionFormat[{info<->False}, {names<->False}]=:BOOLEAN,
  GetFormat[Centroid[NewEfg[]],info,names];
  True
]

NewFunction[SetListFormat[{braces->True},{commas->True},{lf->1},{indent->2}]=:BOOLEAN,
  ListFormat[braces,commas,lf,indent]
]

NewFunction[Max[x->LIST(NUMBER)]=:NUMBER,
  i:=1;r:=x_1;
  While[i<NumElements[x],i:=i+1;If[x_i>r,r:=x_i]];
  r
]

NewFunction[Min[x->LIST(NUMBER)]=:NUMBER,-Max[-x]]

NewFunction[Dimensions[x->NLIST(ANYTYPE)]=:LIST(INTEGER),
//*  Note:  x is assumed rectangular
  l:=Length[x];
  If[IsList[l],{NumElements[x]}&Dimensions[x_1],{l}]
]

NewFunction[Prepend[x->ANYTYPE,l->LIST(ANYTYPE)]=:LIST(ANYTYPE),
  {x}&l
]

NewFunction[CartesianProd[l->LIST(LIST(ANYTYPE))]=:LIST(LIST(ANYTYPE)),
  If[NumElements[l]=1,
    Prepend[l_1,{}],
    r:={};i:=1;
    l1:=l_1;
    l2:=CartesianProd[Remove[l,1]];
    While[i<=Length[l1], r:=r&{Prepend[l1_i,l2]};i:=i+1];
    r
  ]
]	

NewFunction[Nfg[x->NLIST(NUMBER)]=:NFG,
  d:=Dimensions[x];
  n:=NewNfg[Remove[d,Length[d]]];
  s:=CartesianProd[Strategies[n]];
  NewOutcome[s,x];
  n
]

NewFunction[Payoffs[profile->LIST(STRATEGY)],
  Payoff[Outcome[profile],Players[Game[profile_1]]]
]

NewFunction[Payoffs[n->NFG]=:NLIST(NUMBER),
  Payoffs[CartesianProd[Strategies[n]]]
]

NewFunction[Strategies[s->NFSUPPORT]=:LIST(LIST(STRATEGY)),
  Strategies[Players[Game[s]],s]
]    

NewFunction[Actions[s->EFSUPPORT]=:LIST(LIST(LIST(ACTION))),
  Actions[Infosets[Game[s]],s]
]    

NewFunction[Profiles[s->NFSUPPORT]=:NLIST(STRATEGY),
  CartesianProd[Strategies[s]]
]

NewFunction[Profiles[nfg->NFG]=:NLIST(STRATEGY),
  Profiles[Support[nfg]]
]


NewFunction[AddMove[i->INFOSET,a->ACTION]=:LIST(NODE),
  AddMove[i,Filter[n:=Nodes[Game[i]],PriorAction[n]=a]]
]

NewFunction[MaxInt[] =: INTEGER, 
// MAXINT = 2^31-1
  2147483647
]

NewFunction[Ancestors[n->NODE]=:LIST(NODE),
  If[IsRoot[n],{n},Flatten[{Ancestors[Parent[n]]}&{n}]]
]

NewFunction[History[n->NODE]=:LIST(ACTION),
  If[IsRoot[n],{},Flatten[{History[Parent[n]]}&{PriorAction[n]}]]
]

NewFunction[Sum[list->LIST(NUMBER)] =: NUMBER, 
  Dot[list,List[1/1,Length[list] ]]
]

NewFunction[IsRoot[n->NODE]=:BOOLEAN,
  IsNull[Parent[n]]
]

NewFunction[Behav[efg->EFG, list->LIST(LIST(LIST(NUMBER)))] =: BEHAV,
  SetProbs[Behav[Support[efg]],list]
]

NewFunction[Mixed[nfg->NFG, list->LIST(LIST(NUMBER))] =: MIXED,
  SetProbs[Mixed[Support[nfg]],list]
]

NewFunction[ActionProbs[profile->BEHAV]=:LIST(LIST(LIST(NUMBER))),
  ActionProb[profile,Actions[Game[profile]]]
]

NewFunction[ActionValues[profile->BEHAV]=:LIST(LIST(LIST(NUMBER))),
  ActionValue[profile,Actions[Game[profile]]]
]

NewFunction[Beliefs[profile->BEHAV]=:LIST(LIST(LIST(NUMBER))),
  Belief[profile,Members[Game[profile]]]
]

NewFunction[InfosetProbs[profile->BEHAV]=:LIST(LIST(NUMBER)),
  InfosetProb[profile,Infosets[Game[profile]]]
]

NewFunction[InfosetValues[profile->BEHAV]=:LIST(LIST(NUMBER)),
  InfosetValue[profile,Infosets[Game[profile]]]
]

NewFunction[NodeValues[profile->BEHAV,player->EFPLAYER]=:LIST(NUMBER),
  NodeValue[profile,player,Nodes[Game[profile]]]
]

NewFunction[NodeValues[profile->BEHAV,node->NODE]=:LIST(NUMBER),
  NodeValue[profile,Players[Game[profile]],node]
]

NewFunction[NodeValues[profile->BEHAV]=:LIST(NUMBER),
  NodeValues[profile,Nodes[Game[profile]]]
]

NewFunction[RealizProbs[profile->BEHAV]=:LIST(NUMBER),
  RealizProb[profile,Nodes[Game[profile]]]
]

NewFunction[Regrets[profile->BEHAV]=:LIST(LIST(LIST(NUMBER))),
  Regret[profile,Actions[Game[profile]]]
]

// Note: The following functions are intended to be UDFs, but because of
// poor speed performance, are currently implemented as BIFs
//
//NewFunction[StrategyProbs[mixed->MIXED]=:LIST(LIST(NUMBER)),
//  StrategyProb[mixed,Strategies[Game[mixed]]]
//]
//
//NewFunction[StrategyValues[profile->MIXED]=:LIST(LIST(NUMBER)),
//  StrategyValue[profile,Strategies[Game[profile]]]
//]
//
//NewFunction[Regrets[mixed->MIXED]=:LIST(LIST(NUMBER)),
//  Regret[mixed,Strategies[Game[mixed]]]
//]

// the ListForm[] functions will be replaced by ActionProbs[] 
// and StrategyProbs[]. The old versions are provided for backwards 
// compatibility only and should not be counted on to exist in the future. 

NewFunction[ListForm[profile->BEHAV]=:LIST(LIST(LIST(NUMBER))),
  ActionProb[profile,Actions[Game[profile]]]
]

NewFunction[ListForm[mixed->MIXED]=:LIST(LIST(NUMBER)),
  StrategyProb[mixed,Strategies[Game[mixed]]]
]

NewFunction[Centroid[s->EFSUPPORT]=:BEHAV,
  Behav[s]
]

NewFunction[Centroid[s->NFSUPPORT]=:MIXED,
  Mixed[s]
]

NewFunction[Centroid[efg->EFG]=:BEHAV,
  Behav[Support[efg]]
]

NewFunction[Centroid[nfg->NFG]=:MIXED,
  Mixed[Support[nfg]]
]

NewFunction[Infosets[efg->EFG]=:LIST(LIST(INFOSET)),
  Infosets[Players[efg]]
]

NewFunction[AllInfosets[efg->EFG]=:LIST(LIST(INFOSET)),
  Infosets[{Chance[efg]}&Players[efg]]
]

NewFunction[Members[efg->EFG]=:LIST(LIST(LIST(NODE))),
  Members[Infosets[Players[efg]]]
]

NewFunction[AllMembers[efg->EFG]=:LIST(LIST(LIST(NODE))),
  Members[AllInfosets[efg]]
]

NewFunction[Actions[infoset->INFOSET] =: LIST(ACTION),
  Actions[infoset,Support[Game[infoset]]]
]

NewFunction[Actions[efg->EFG]=:LIST(LIST(LIST(ACTION))),
  Actions[Infosets[Players[efg]]]
]

NewFunction[Strategies[player->NFPLAYER] =: LIST(STRATEGY),
  Strategies[player,Support[Game[player]]]
]

NewFunction[Strategies[nfg->NFG]=:LIST(LIST(STRATEGY)),
  Strategies[Players[nfg]]
]

NewFunction[AllActions[efg->EFG]=:LIST(LIST(LIST(ACTION))),
  Actions[AllInfosets[efg]]
]

NewFunction[DeleteEmptyInfosets[efg->EFG] =: LIST(BOOLEAN),
  DeleteEmptyInfoset[Filter[i:=Infosets[efg],NumMembers[i]=0]]
]

NewFunction[NumChildren[n->NODE]=:INTEGER,
  Length[Children[n]]
]

NewFunction[NumPlayers[efg->EFG]=:INTEGER,
  Length[Players[efg]]
]

NewFunction[PlayerNumber[p->EFPLAYER]=:INTEGER,
  Index[Players[Game[p]],p]_1
]

NewFunction[PlayerNumber[p->NFPLAYER]=:INTEGER,
  Index[Players[Game[p]],p]_1
]

NewFunction[NumMembers[i->INFOSET]=:INTEGER,
  Length[Members[i]]
]

NewFunction[NumPlayers[nfg->NFG]=:INTEGER,
  Length[Players[nfg]]
]

NewFunction[NumActions[infoset->INFOSET, support->EFSUPPORT]=:INTEGER,
  Length[Actions[infoset,support]] 
]

NewFunction[NumActions[infoset->INFOSET] =: INTEGER,
  Length[Actions[infoset,Support[Game[infoset]]]] 
]

NewFunction[NumStrats[player->NFPLAYER, support->NFSUPPORT] =: INTEGER,
  Length[Strategies[player,support]] 
]

NewFunction[Descendants[n->NODE]=:NLIST(NODE),
  {n}&Descendants[Children[n]]
// the above version is _very_ slow on large games.
// You may want to repalce with following:
//  {n}&Flatten[Descendants[Children[n]]];
]

NewFunction[NodeTree[efg->EFG]=:NLIST(NODE),
  Descendants[RootNode[efg]]
]

NewFunction[TerminalNodes[efg->EFG]=:LIST(NODE),
  Filter[d:=Nodes[efg],NumChildren[d]=0]
]

NewFunction[NonterminalNodes[efg->EFG]=:LIST(NODE),
  Filter[d:=Nodes[efg],NumChildren[d]>0]
]

NewFunction[UnDominated[nfg->NFG, {strong->False}, {mixed->False},
  {precision->Rational},{time<->0.00}, 
  {traceFile<->NullOut}, {traceLevel->00}] =: NFSUPPORT,
  UnDominated[Support[nfg],strong,mixed,precision,time,traceFile,traceLevel]
]

NewFunction[UnDominated[efg->EFG, {strong->False}, {conditional->False}, 
  {time<->0.00}, {traceFile<->NullOut}, {traceLevel->00}] =: EFSUPPORT,
  UnDominated[Support[efg],strong,conditional,time,traceFile,traceLevel]
]

NewFunction[IterativeUnDominated[s->NFSUPPORT, {strong->False}, {mixed->False},
  {precision->Rational},
  {time<->0.00},{traceFile<->NullOut}, {traceLevel->00}] =: NFSUPPORT,
  While[s!=(ss:=UnDominated[s,strong,mixed,precision,time,traceFile,traceLevel]),
    s:=ss
  ];
  s;
]

NewFunction[IterativeUnDominated[s->EFSUPPORT, {strong->False}, 
  {conditional->False}, {time<->0.00}, {traceFile<->NullOut}, 
  {traceLevel->00}] =: EFSUPPORT,
  While[s!=(ss:=UnDominated[s,strong,conditional,time,traceFile,traceLevel]),
    s:=ss
  ];
  s;
]

NewFunction[IterativeUnDominated[nfg->NFG, {strong->False}, {mixed->False},
  {precision->Rational},
  {time<->0.00},{traceFile<->NullOut}, {traceLevel->00}] =: NFSUPPORT,
  IterativeUnDominated[Support[nfg],strong,mixed,precision,time,traceFile,traceLevel];
]

NewFunction[IterativeUnDominated[efg->EFG, {strong->False}, 
  {conditional->False}, {time<->0.00}, {traceFile<->NullOut}, 
  {traceLevel->00}] =: EFSUPPORT,
  IterativeUnDominated[Support[efg],strong,conditional, time,traceFile,traceLevel];
]

NewFunction[NewPlayer[efg->EFG,  name->TEXT] =: EFPLAYER,
  SetName[NewPlayer[efg],name]
]

NewFunction[NewPlayer[nfg->NFG,  name->TEXT] =: NFPLAYER,
  SetName[NewPlayer[nfg],name]
]

NewFunction[NewOutcome[efg->EFG,  name->TEXT] =: EFOUTCOME,
 SetName[NewOutcome[efg],name]
]

NewFunction[NewInfoset[player->EFPLAYER, actions->LIST(TEXT), 
  {name->""}] =: INFOSET,
  i:=SetName[NewInfoset[player,Length[actions]],name];
  SetName[Actions[i,Support[Game[player]]],actions];
  i
]

NewFunction[SetPayoffs[outcome->EFOUTCOME, 
  payoff->LIST(NUMBER)]=:EFOUTCOME,
  SetPayoff[outcome,Players[Game[outcome]],payoff];
  outcome
]

NewFunction[SetPayoffs[outcome->NFOUTCOME, 
  payoff->LIST(NUMBER)]=:NFOUTCOME,
  SetPayoff[outcome,Players[Game[outcome]],payoff];
  outcome
]

NewFunction[Payoffs[outcome->EFOUTCOME*]=:LIST(NUMBER),
  Payoff[outcome,Players[Game[outcome]]]
]

NewFunction[Payoffs[outcome->NFOUTCOME*]=:LIST(NUMBER),
  Payoff[outcome,Players[Game[outcome]]]
]

NewFunction[EnumMixedSolve[nfg->NFG, {stopAfter->00}, {precision->Float},
  {nPivots<->00}, {time<->0.00}, {traceFile<->NullOut}, 
  {traceLevel->00},{cliques->False}] =: LIST(MIXED),
  EnumMixedSolve[Support[nfg], stopAfter, precision, nPivots, time, 
  traceFile, traceLevel, cliques]
]

NewFunction[EnumMixedSolve[efg->EFG, {asNfg->False},{stopAfter->00}, 
  {precision->Float}, {nPivots<->00}, {time<->0.00}, {traceFile<->NullOut}, 
  {traceLevel->00},{cliques->False}] =: LIST(BEHAV),
  EnumMixedSolve[Support[efg], asNfg,stopAfter, precision, nPivots, time,
  traceFile, traceLevel, cliques]
]

NewFunction[EnumPureSolve[nfg->NFG, {stopAfter->00}, {time<->0.00},
  {traceFile<->NullOut}, {traceLevel->00}] =: LIST(MIXED),
  EnumPureSolve[Support[nfg], stopAfter, time, traceFile, traceLevel]
]

NewFunction[EnumPureSolve[efg->EFG, {stopAfter->00},  {precision->Float},
  {time<->0.00}, {traceFile<->NullOut}, 
  {traceLevel->00}] =: LIST(BEHAV),
  EnumPureSolve[Support[efg], False, stopAfter, precision, time, 
  traceFile, traceLevel]
]

NewFunction[QreSolve[efg->EFG, {pxifile->""}, {minLam->.001}, 
  {maxLam->500.}, {delLam->.02}, {powLam->01}, {fullGraph->False}, 
  {accuracy->.00000001}, {time<->0.00}, {nEvals<->00}, {nIters<->00}, 
  {traceFile<->NullOut}, {traceLevel->00}] =: LIST(BEHAV),
  QreSolve[Centroid[Support[efg]],pxifile,minLam,maxLam,delLam,powLam, 
  fullGraph,accuracy,time,nEvals,nIters,traceFile, traceLevel]
]

NewFunction[QreSolve[nfg->NFG, {pxifile->""}, {minLam->.001}, 
  {maxLam->500.}, {delLam->.02}, {powLam->01}, {fullGraph->False}, 
  {accuracy->.00000001}, {time<->0.00}, {nEvals<->00}, {nIters<->00}, 
  {traceFile<->NullOut}, {traceLevel->00}, {method->0}] =: LIST(MIXED),
  QreSolve[Centroid[Support[nfg]],pxifile,minLam,maxLam,delLam,powLam,
  fullGraph,accuracy,time,nEvals,nIters,traceFile,traceLevel,method]
]

NewFunction[LcpSolve[nfg->NFG,{stopAfter->1}, {precision->Float},
  {nPivots<->00}, {time<->0.00}, {traceFile<->NullOut},
  {traceLevel->00}] =: LIST(MIXED),
  LcpSolve[Support[nfg], stopAfter, precision, nPivots,
    time, traceFile, traceLevel]
]

NewFunction[LcpSolve[efg->EFG, {asNfg->False}, {stopAfter->1}, 
   {precision->Float}, {nPivots<->00}, {time<->0.00}, {traceFile<->NullOut}, 
  {traceLevel->00}] =: LIST(BEHAV),
  LcpSolve[Support[efg], asNfg, stopAfter, precision, nPivots,
    time, traceFile, traceLevel]
]

NewFunction[LpSolve[nfg->NFG, {precision->Float},
  {nPivots<->00}, {time<->0.00}, {traceFile<->NullOut}, 
  {traceLevel->00}] =: LIST(MIXED),
  LpSolve[Support[nfg], precision, nPivots, time, traceFile, 
  traceLevel]
]

NewFunction[LpSolve[efg->EFG, {asNfg->False}, 
  {precision->Float}, {nPivots<->00}, {time<->0.00},
  {traceFile<->NullOut}, {traceLevel->00}] =: LIST(BEHAV),
  LpSolve[Support[efg], asNfg, precision, nPivots, time, 
  traceFile, traceLevel]
]

NewFunction[LiapSolve[nfg->NFG, {stopAfter->01}, {nTries->10}, 
  {accuracy->.00000001}, {time<->0.00}, {nEvals<->00}, 
  {traceFile<->NullOut}, {traceLevel->00}] =: LIST(MIXED),
  LiapSolve[Centroid[Support[nfg]], stopAfter, nTries,
  accuracy, time, nEvals, traceFile, traceLevel]
]

NewFunction[LiapSolve[efg->EFG, {asNfg->False}, {stopAfter->01}, 
  {nTries->10}, {accuracy->.00000001}, {time<->0.00}, {nEvals<->00}, 
  {traceFile<->NullOut}, {traceLevel->00}] =: LIST(BEHAV),
  LiapSolve[Centroid[Support[efg]], asNfg, stopAfter, nTries,
  accuracy, time, nEvals, traceFile, traceLevel]
]

NewFunction[SimpDivSolve[nfg->NFG, {stopAfter->01}, {nRestarts->36}, 
  {leashLength->00}, {precision->Float}, {nEvals<->00},
  {time<->0.00}, {traceFile<->NullOut},
  {traceLevel->00}] =: LIST(MIXED),
  SimpDivSolve[Support[nfg], stopAfter, nRestarts, leashLength,
    precision, nEvals, time, traceFile, traceLevel]
]

NewFunction[SimpDivSolve[efg->EFG, {asNfg->False}, {stopAfter->01}, 
  {nRestarts->36}, {leashLength->00}, {precision->Float},
  {nEvals<->00}, {time<->0.00},
  {traceFile<->NullOut}, {traceLevel->00}] =: LIST(BEHAV),
  SimpDivSolve[Support[efg], asNfg, stopAfter, nRestarts, leashLength,
    precision, nEvals, time, traceFile, traceLevel]
]

NewFunction[PolEnumSolve[nfg->NFG, {stopAfter->0},
  {nEvals<->0}, {time<->0.00},{traceFile<->NullOut}, {traceLevel->00},
  {singularSupps<->{  }},{recurse->True}] =: LIST(MIXED),
  PolEnumSolve[Support[nfg],stopAfter,nEvals,time,traceFile,
    traceLevel,singularSupps,recurse];
]

NewFunction[PolEnumSolve[efg->EFG, {asNfg->False}, {stopAfter->0},
  {nEvals<->0}, {time<->0.00},{traceFile<->NullOut}, {traceLevel->00},
  {singularSupps<->{  }},{recurse->True}] =: LIST(BEHAV),
  PolEnumSolve[Support[efg],asNfg,stopAfter,nEvals,time,traceFile,
    traceLevel,singularSupps,recurse];
]

NewFunction[MarkSubgames[efg->EFG(T)]=:LIST(NODE),
  MarkSubgame[s:=Subgames[efg]];
  MarkedSubgames[efg]
//  replace above line with following when we know this works:
//  s;
]

NewFunction[MarkSubgames[n->LIST(NODE)]=:LIST(BOOLEAN),  
  UnMarkSubgames[Game[n_1]];MarkSubgame[n]
]

NewFunction[UnMarkSubgames[efg->EFG(T)]=:LIST(NODE),
  UnMarkSubgame[Nodes[efg]];
  MarkedSubgames[efg]
//  replace above line with following when we know this works:
//  {RootNode[efg]}
]

NewFunction[MarkedSubgames[efg->EFG(T)]=:LIST(NODE),
  Filter[n:=Nodes[efg],MarkedSubgame[n]]
]

NewFunction[GambitExe[]=:TEXT,
  p:=Platform[];
  f:="gambit";
  If[(h:=GetEnv["GAMBIT_HOME"])="",p:=ExePath[file->False]+f,p:=h+f];
  p
]

NewFunction[Display[e->EFG]=:NUMBER,
  SaveEfg[e,"junk.efg"];
  Shell[GambitExe[]+" junk.efg"]
]

NewFunction[Display[n->NFG]=:NUMBER,
  SaveNfg[n,"junk.nfg"];
  Shell[GambitExe[]+" junk.nfg"]
]


NewFunction[Payoffs[profile->BEHAV]=:LIST(NUMBER),
  Payoff[profile,Players[Game[profile]]]
]

NewFunction[Payoffs[profile->MIXED]=:LIST(NUMBER),
  Payoff[profile,Players[Game[profile]]]
]

//
// A set of user defined gcl functions for computing standard 
// equilibrium sets
// 

NewFunction[InfiniteLoopWarning[stopAfter->NUMBER,nTries->NUMBER]=:TEXT,
  If[nTries=0,
    If[stopAfter=0,
    " Warning: Entering infinite loop.  Use Ctl-C to exit.",  
    " Warning: Entering possible infinite loop.  Use Ctl-C to exit."],
  " Warning: May not find all"]
]

NewFunction[OneNash[n->NFG,{precision->Float}]=:LIST(MIXED),
  s:=IterativeUnDominated[n];
  If[NumPlayers[n] = 2,
    If[IsConstSum[n],LpSolve[s,precision],LcpSolve[s,1,precision]],
    SimpDivSolve[s,stopAfter->1,nRestarts->36,precision->precision]
  ]
]  

NewFunction[ManyNash[n->NFG,{stopAfter->0},{nTries->0},{precision->Float}]=:LIST(MIXED),
  s:=IterativeUnDominated[n,strong->True];
  If[NumPlayers[n] = 2, 
    EnumMixedSolve[s,0,precision],
    << InfiniteLoopWarning[stopAfter,nTries];
    LiapSolve[Centroid[s],stopAfter,nTries]
  ]
]  

NewFunction[AllNash[n->NFG,{stopAfter->0},{nTries->0},{precision->Float}]=:LIST(MIXED),
  s:=IterativeUnDominated[n,strong->True];
  If[NumPlayers[n] = 2, 
    EnumMixedSolve[s,0,precision],
    PolEnumSolve[s,stopAfter]
  ]
]  

NewFunction[OnePerfect[n->NFG,{precision->Float}]=:LIST(MIXED),
  If[NumPlayers[n] = 2, 
    s:=IterativeUnDominated[n];
    LcpSolve[s,1,precision],
    << " Not implemented for n-person games";
    List[Centroid[Support[n]],0] // return empty set of mixed
  ]
]  

NewFunction[AllPerfect[n->NFG,{stopAfter->0},{nTries->0},{precision->Float}]=:LIST(MIXED),
  If[NumPlayers[n] = 2, 
    s:=IterativeUnDominated[n,mixed->True];
    m:=EnumMixedSolve[s,0,precision];
    Filter[m,IsPerfect[m]],
    << " Not implemented for n-person games";
    List[Centroid[Support[n]],0]
  ]
]  

NewFunction[OneNash[e->EFG,{precision->Float}]=:LIST(BEHAV),
  ms:=MarkedSubgames[e];MarkSubgames[e];
  If[NumPlayers[e] = 2 && IsPerfectRecall[e],
    If[IsConstSum[e],
      b:=LpSolve[e,False,precision],
      b:=LcpSolve[e,False,1,precision]
    ],
    b:=SimpDivSolve[e,asNfg->True,stopAfter->1,nRestarts->36,
      precision->precision]
  ];
  MarkSubgames[ms];b
]  

NewFunction[ManyNash[e->EFG,{stopAfter->0},{nTries->0},{precision->Float}]=:LIST(BEHAV),
  ms:=MarkedSubgames[e];UnMarkSubgames[e];
  s:=IterativeUnDominated[Nfg[e],strong->True];
  If[NumPlayers[e] = 2, 
    m:=EnumMixedSolve[s,0,precision],
    << InfiniteLoopWarning[stopAfter,nTries];
    m:=LiapSolve[Centroid[s],stopAfter,nTries]
  ];
  MarkSubgames[ms];Behav[m]
]  

NewFunction[AllNash[e->EFG,{stopAfter->0},{nTries->0},{precision->Float}]=:LIST(BEHAV),
  ms:=MarkedSubgames[e];UnMarkSubgames[e];
  If[NumPlayers[e] = 2, 
    s:=IterativeUnDominated[Nfg[e],strong->True];
    b:=Behav[EnumMixedSolve[s,0,precision]],
    b:=PolEnumSolve[e,False,stopAfter]
  ];
  MarkSubgames[ms];b
]  

NewFunction[OneSubgamePerfect[e->EFG,{precision->Float}]=:LIST(BEHAV),
  ms:=MarkedSubgames[e];MarkSubgames[e];
  If[NumPlayers[e] = 2 && IsPerfectRecall[e],
    If[IsConstSum[e],
      b:=LpSolve[e,False,precision],
      b:=LcpSolve[e,False,1,precision]
    ],
    b:=SimpDivSolve[e,asNfg->True,stopAfter->1,nRestarts->36,
      precision->precision]
  ];
  MarkSubgames[ms];b
]  

NewFunction[AllSubgamePerfect[e->EFG,{stopAfter->0},{nTries->0},{precision->Float}]=:LIST(BEHAV),
  ms:=MarkedSubgames[e];MarkSubgames[e];
  If[NumPlayers[e] = 2, 
    b:=EnumMixedSolve[e,True,0,precision],
    b:=PolEnumSolve[e,False,stopAfter]
  ];
  MarkSubgames[ms];b
]  

NewFunction[OneSequential[e->EFG,{accuracy->0.00000001}]=:LIST(BEHAV),
  ms:=MarkedSubgames[e];UnMarkSubgames[e];
  del:=.02;
  b:=QreSolve[e,fullGraph->False];
  If[!IsSequential[b_1],
    bb:=LiapSolve[b_1,nTries->1,accuracy->accuracy];
    If[Length[bb]=0,
      << " Warning: Algorithm did not converge, returning last value";,
    b:=bb;
    ];
  ];
  MarkSubgames[ms];b
]  

NewFunction[AllSequential[e->EFG,{stopAfter->0},{nTries->0}]=:LIST(BEHAV),
  ms:=MarkedSubgames[e];UnMarkSubgames[e];
  << InfiniteLoopWarning[stopAfter,nTries];
  b:=LiapSolve[e,stopAfter->stopAfter,nTries->nTries];
  MarkSubgames[ms];b
]


// the following added after .94 distribution
 
NewFunction[ActionNumber[a->ACTION]=:INTEGER,
  Index[Actions[Infoset[a]],a]_1
]

NewFunction[Float[x->MIXED]=:MIXED,
  1.0*x;
]

NewFunction[Float[x->BEHAV]=:BEHAV,
  1.0*x
]

NewFunction[SetProbs[profile<->MIXED,value->LIST(LIST(NUMBER))]=:MIXED,
  SetStrategyProbs[profile,Players[Game[profile]],value];
  profile
]

NewFunction[SetProbs[profile<->BEHAV,value->LIST(LIST(LIST(NUMBER)))]=:BEHAV,
  SetActionProbs[profile,Infosets[Game[profile]],value];
  profile
]

NewFunction[Read[input<->INPUT,x<->MIXED]=:INPUT,
  v:=ListForm[x];
  input >> v;
  SetProbs[x,v];
  input
]

NewFunction[Read[input<->INPUT,x<->BEHAV]=:INPUT,
  v:=ListForm[x];
  input >> v;
  SetProbs[x,v];
  input
]

NewFunction[StrategyValues[profile->MIXED]=:LIST(LIST(NUMBER)),
  StrategyValue[profile,Strategies[Game[profile]]];
];

NewFunction[Mixed[list->LIST(STRATEGY)]=:MIXED,
  n:=Game[list_1];
  s:=Strategies[n];
  m:=Centroid[n];
  v:=ListForm[m];
  For[i:=1,i<=NumElements[v],i:=i+1,
    For[j:=1,j<=NumElements[v_i],j:=j+1,
      v_i_j:=0/1;
    ];
    v_i_(Index[s_i,list_i]_1) := 1/1
  ];
  SetProbs[m,v];   
];

NewFunction[Randomize[x->EFG, {seed->0}]=:EFG,
  o:=Outcomes[x];
  pay:=Payoffs[o];
  Randomize[pay_1_1,seed];
  pay:=Randomize[pay];
  SetPayoffs[o,pay];
  x;
];
  
NewFunction[Randomize[x->NFG, {seed->0}]=:NFG,
  o:=Outcomes[x];
  pay:=Payoffs[o];
  Randomize[pay_1_1,seed];
  pay:=Randomize[pay];
  SetPayoffs[o,pay];
  x;
];
  
NewFunction[OutcomeForm[n->NFG(NUMBER)]=:NLIST(NFOUTCOME),
  Outcome[CartesianProd[Strategies[n]]]
]

NewFunction[NewOutcome[nfg->NFG,  name->TEXT] =: NFOUTCOME,
  SetName[NewOutcome[nfg],name]
]

NewFunction[Concat[list->LIST(TEXT)]=:TEXT,
  If[Length[list]=1,list_1,list_1+Concat[Remove[list,1]]];
]

NewFunction[NewOutcome[profile->LIST(STRATEGY)]=:NFOUTCOME,
  name:=Concat[Name[profile]];
  SetName[SetOutcome[profile,NewOutcome[Game[profile_1]]],name];
];

NewFunction[NewOutcome[profile->LIST(STRATEGY), 
  payoff->LIST(NUMBER)]=:NFOUTCOME,
  SetPayoffs[NewOutcome[profile], payoff];
]

NewFunction[NewNfg[dim->LIST(INTEGER),outcomes->BOOLEAN] =: NFG,
  n:=NewNfg[dim];
  If[outcomes=True,
    NewOutcome[CartesianProd[Strategies[n]]]
  ];
  n;
];

NewFunction[NthElement[s<->NFSUPPORT,n->NUMBER]=:LIST(STRATEGY),
Strategies[s]_n;
];

NewFunction[NthElement[s<->EFSUPPORT,n->NUMBER]=:LIST(ACTION),
Actions[s]_n;
];

NewFunction[Rational[g->NFG]=:NFG,
  gg:=CompressNfg[Support[g]];    // to make a copy
  SetPayoffs[Outcomes[gg],Rational[Payoffs[Outcomes[gg]]]];
  gg;
];  

NewFunction[Float[g->NFG]=:NFG,
  gg:=CompressNfg[Support[g]];    // to make a copy
  SetPayoffs[Outcomes[gg],Float[Payoffs[Outcomes[gg]]]];
  gg;
];  

NewFunction[Rational[g->EFG]=:EFG,
  gg:=CompressEfg[Support[g]];    // to make a copy
  i:=Infosets[Chance[gg]];
  If[Length[i]>0,SetChanceProbs[i,Rational[ChanceProb[Actions[i]]]]];
  SetPayoffs[Outcomes[gg],Rational[Payoffs[Outcomes[gg]]]];
  gg;
];  

NewFunction[Float[g->EFG]=:EFG,
  gg:=CompressEfg[Support[g]];    // to make a copy
  i:=Infosets[Chance[gg]];
  If[Length[i]>0,SetChanceProbs[i,Float[ChanceProb[Actions[i]]]]];
  SetPayoffs[Outcomes[gg],Float[Payoffs[Outcomes[gg]]]];
  gg;
];  

