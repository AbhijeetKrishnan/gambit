//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of partitioned vector members
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include "gpvector.h"

//-------------------------------------------------------------------------
//          gbtPVector<T>: Private and protected member functions
//-------------------------------------------------------------------------

template <class T> int gbtPVector<T>::sum(const gbtArray<int> &V) const
{
  int total = 0;
  for (int i = V.First(); i <= V.Last(); total += V[i++]);
  return total;
}

template <class T> void gbtPVector<T>::setindex(void)
{
  int index = First();
  for(int i = 1; i <= svlen.Length(); i++)  {
    svptr[i] = data + index - 1;
    index += svlen[i];
  }
  assert(index == Last() + 1);
}


template <class T> int gbtPVector<T>::Check(const gbtPVector<T> &v) const
{
  if (v.mindex == mindex && v.maxdex == maxdex)  {
    for (int i = 1; i <= svlen.Length(); i++)
      if (svlen[i] != v.svlen[i])   return 0;
    return 1;
  }
  return 0;
}

//-------------------------------------------------------------------------
//     gbtPVector<T>: Constructors, destructor, and constructive operators
//-------------------------------------------------------------------------

template <class T> gbtPVector<T>::gbtPVector(void) : svptr(0)
{ }

template <class T> gbtPVector<T>::gbtPVector(const gbtArray<int> &sig)
  : gbtVector<T>(sum(sig)), svlen(sig)
{
  svptr = new T *[sig.Last() - sig.First() + 1];
  svptr -= 1;    // align things correctly
  setindex();
}

template <class T> gbtPVector<T>::gbtPVector(const gbtVector<T> &val,
					 const gbtArray<int> &sig)
  : gbtVector<T>(val), svlen(sig)
{
  assert(sum(svlen) == val.Length());
  svptr = new T *[sig.Last() - sig.First() + 1];
  svptr -= 1;
  setindex();
}

template <class T> gbtPVector<T>::gbtPVector(const gbtPVector<T> &v)
  : gbtVector<T>(v), svlen(v.svlen)
{
  svptr = new T *[v.svlen.Last() - v.svlen.First() + 1];
  svptr -= 1;
  setindex();
}

template <class T> gbtPVector<T>::~gbtPVector()
{
  if (svptr)   delete [] (svptr + 1);
}

template <class T> gbtPVector<T>& gbtPVector<T>::operator=(const gbtPVector<T> &v)
{
  if (!Check(v))   throw BadDim();
  gbtVector<T>::operator=(v);
  return (*this);
}

template <class T> gbtPVector<T>& gbtPVector<T>::operator=(const gbtVector<T> &v)
{
  gbtVector<T>::operator=(v);
  return (*this);
}

template <class T> gbtPVector<T>& gbtPVector<T>::operator=(T c)
{
  gbtVector<T>::operator=(c);
  return (*this);
}

//-------------------------------------------------------------------------
//                 gbtPVector<T>: Operator definitions
//-------------------------------------------------------------------------

template <class T> T& gbtPVector<T>::operator()(int a, int b)
{
  if (svlen.First() > a || a > svlen.Last())   throw BadIndex();
  if (1 > b || b > svlen[a])    throw BadIndex();

  return svptr[a][b];
}

template <class T> const T& gbtPVector<T>::operator()(int a, int b) const
{
  if (svlen.First() > a || a > svlen.Last())   throw BadIndex();
  if (1 > b || b > svlen[a])    throw BadIndex();
  return svptr[a][b];
}

template <class T>
gbtPVector<T> gbtPVector<T>::operator+(const gbtPVector<T> &v) const
{
  if (!Check(v))   throw BadDim();

  gbtPVector<T> tmp(*this);
  tmp.gbtVector<T>::operator+=(v);
  return tmp;
}

template <class T> gbtPVector<T>& gbtPVector<T>::operator+=(const gbtPVector<T> &v)
{
  if (!Check(v))   throw BadDim();

  gbtVector<T>::operator+=(v);
  return (*this);
}

template <class T> gbtPVector<T> gbtPVector<T>::operator-(void) const
{
  gbtPVector<T> tmp(*this);
  for(int i=First(); i<=Last(); i++)
    tmp[i]= -tmp[i];
  return tmp;
}

template <class T>
gbtPVector<T> gbtPVector<T>::operator-(const gbtPVector<T> &v) const
{
  if (!Check(v))   throw BadDim();

  gbtPVector<T> tmp(*this);
  tmp.gbtVector<T>::operator-=(v);
  return tmp;
}

template <class T> gbtPVector<T>& gbtPVector<T>::operator-=(const gbtPVector<T> &v)
{
  if (!Check(v))   throw BadDim();

  gbtVector<T>::operator-=(v);
  return (*this);
}

template <class T> T gbtPVector<T>::operator*(const gbtPVector<T> &v) const
{
  if (!Check(v))   throw BadDim();

  return (*this).gbtVector<T>::operator*(v);
}

template <class T> gbtPVector<T> gbtPVector<T>::operator*(const T &c) const
{
  gbtPVector<T> ret(*this);
  ret *= c;
  return ret;
}

template <class T> gbtPVector<T>& gbtPVector<T>::operator*=(const T c)
{
  gbtVector<T>::operator*=(c);
  return (*this);
}

template <class T> gbtPVector<T> gbtPVector<T>::operator/(T c)
{
  gbtPVector<T> tmp(*this);
  tmp= tmp.gbtVector<T>::operator/(c);
  return tmp;
}

template <class T> bool gbtPVector<T>::operator==(const gbtPVector<T> &v) const
{
  if (!Check(v))   throw BadDim();

  return (*this).gbtVector<T>::operator==(v);
}

template <class T> bool gbtPVector<T>::operator!=(const gbtPVector<T> &v) const
{ return !((*this)==v); }

//-------------------------------------------------------------------------
//                 gbtPVector<T>: General data access
//-------------------------------------------------------------------------

template <class T> gbtVector<T> gbtPVector<T>::GetRow(int row) const
{
  if (svlen.First() > row || row > svlen.Last())   throw BadIndex();

  gbtVector<T> v(1, svlen[row]);

  for(int i=v.First(); i<=v.Last(); i++)
    v[i]= (*this)(row,i);
  return v;
}

template <class T> void gbtPVector<T>::GetRow(int row, gbtVector<T> &v) const
{
  if (svlen.First() > row || row > svlen.Last())  throw BadIndex();
  if (v.First() != 1 || v.Last() != svlen[row])   throw BadDim();

  for(int i=v.First(); i<=v.Last(); i++)
    v[i]= (*this)(row,i);
}

template <class T> void gbtPVector<T>::SetRow(int row, const gbtVector<T> &v)
{
  if (svlen.First() > row || row > svlen.Last())   throw BadIndex();
  if (v.First() != 1 || v.Last() != svlen[row])    throw BadDim();

  for(int i=v.First(); i<=v.Last(); i++)
    (*this)(row,i)= v[i];
}

template <class T> void gbtPVector<T>::CopyRow(int row, const gbtPVector<T> &v)
{
  if (!Check(v))   throw BadDim();
  if (svlen.First() > row || row > svlen.Last())   throw BadIndex(); 

  for (int i = 1; i <= svlen[row]; i++)
    svptr[row][i] = v.svptr[row][i];
}

template <class T> const gbtArray<int> &gbtPVector<T>::Lengths(void) const
{
  return svlen;
}

//-------------------------------------------------------------------------
//                    gbtPVector<T>: Output functions
//-------------------------------------------------------------------------

template <class T> gbtOutput &operator<<(gbtOutput &to, const gbtPVector<T> &v)
{
  v.Dump(to); return to;
}

template <class T> void gbtPVector<T>::Dump(gbtOutput &f) const
{
  for (int i = svlen.First(); i <= svlen.Last(); i++)    {
    f << "{ ";
    for (int j = 1; j <= svlen[i]; j++)
      f << (*this)(i,j) << " ";
    f << "}";
  }
}
