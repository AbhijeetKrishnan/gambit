//
// FILE: nfgalleq.imp -- Polynomial Nash Enum module
//
// $Id$
//

#include "nfgalleq.h"

template <class T> class AllNashSolveModule  {
private:
  const Nfg &NF;
  const NFSupport fullsupport;
  gList<const NFSupport> possiblenashsupports;
  PolEnumParams params;
  long count,nevals;
  double time;
  gList<MixedSolution> solutions;
  gList<const NFSupport> singular_supports;

public:
  AllNashSolveModule(const Nfg &, const PolEnumParams &p);

  void NashEnum(void);
  
  long NumEvals(void) const;
  double Time(void) const;
  PolEnumParams &Parameters(void);

  const gList<MixedSolution> &GetSolutions(void) const;

  const gList<const NFSupport> &GetSingularSupports(void) const;
};

//-------------------------------------------------------------------------
//                    AllNashSolveModule<T>: Member functions
//-------------------------------------------------------------------------

template <class T>
AllNashSolveModule<T>::AllNashSolveModule(const Nfg &N, const PolEnumParams &p)
  : NF(N), 
    fullsupport(N), 
    possiblenashsupports(), 
    params(p), 
    count(0), nevals(0),
    solutions(),
    singular_supports()
{ 
  possiblenashsupports += PossibleNashSubsupports(fullsupport,params.status);
}


template <class T> void AllNashSolveModule<T>::NashEnum(void)
{
  for (int i = 1; i <= possiblenashsupports.Length(); i++) {
    long newevals = 0;
    double newtime = 0.0;
    gList<MixedSolution> newsolns;
    bool is_singular = false;
    PolEnum(possiblenashsupports[i], params, newsolns, newevals, newtime,
	    is_singular);
    for (int j = 1; j <= newsolns.Length(); j++)
      if (newsolns[j].IsNash()) 
	solutions += newsolns[j];
    if (is_singular) 
      singular_supports += possiblenashsupports[i];
    nevals += newevals;
    time += newtime;
  }
}

template <class T> long AllNashSolveModule<T>::NumEvals(void) const
{
  return nevals;
}

template <class T> double AllNashSolveModule<T>::Time(void) const
{
  return time;
}

template <class T> PolEnumParams &AllNashSolveModule<T>::Parameters(void)
{
  return params;
}

template <class T>
const gList<MixedSolution> &AllNashSolveModule<T>::GetSolutions(void) const
{
  return solutions;
}

template <class T> const gList<const NFSupport> &
AllNashSolveModule<T>::GetSingularSupports(void) const
{
  return singular_supports;
}







