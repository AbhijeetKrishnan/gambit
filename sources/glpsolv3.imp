//
// FILE: glpsolv3.imp -- Implementation of LP solver
//
// $Id$
//

#include "glpsolv3.h"



#ifdef __GNUG__
#define INLINE inline
#elif defined __BORLANDC__
#define INLINE
#else
#error Unsupported compiler type
#endif   // __GNUG__, __BORLANDC__

template <class T> INLINE gLPTableau3<T>::gLPTableau3(const gMatrix<T> &A, 
						      const gVector<T> &B,
						      const gVector<T> &C) 
	  : gTableau<T>(1, B.Length() + 1, 0, 0, B.Length() + 1, B.Length()),
             // We probably want to just dispose of this last construction
	    feasible(1), bounded(1), well_formed(1), optimum(1, C.Length())
{
// Check to make sure the sizes of the matrix and vectors match up properly
  if (A.NumRows() != B.Length() ||
      A.NumColumns() != C.Length())   {
    well_formed = 0;
    return;
  }

// Construct the matrices to be fed to glpsolve.h.
  gMatrix<T> A0(2 * A.NumRows(), A.NumColumns());
  gVector<T> B0(2 * B.Length()), C0(C.Length());

  int i;
  for (i = 1; i <= A.NumRows(); i++)         // Set A0
    for (int j = 1; j <= A.NumColumns(); j++)
      { A0(i,j) = A(i,j); A0(i + A.NumRows(), j) = -A(i,j); }

  for (i = 1; i <= B.Length(); i++)          // Set B0
    { B0[i] = B[i]; B0[i + B.Length()] = -B[i]; }

  C0 = C;                                    // Set C0

// Get the constructor in glpsolve.h to do the actual work
  gLPTableau<T> Tableau0(A0, B0, C0);

// Report findings
  well_formed = Tableau0.IsWellFormed();
  feasible = Tableau0.IsFeasible();
  bounded = Tableau0.IsBounded();
  for (int j = 1; j <= C.Length(); j++)
    optimum = Tableau0.OptimumVector()[j] 
            - Tableau0.OptimumVector()[j + C.Length()];
  cost = Tableau0.OptimumCost();
}   


template <class T> T gLPTableau3<T>::OptimumCost(void) const
{
  return cost;
}

template <class T> const gVector<T> &gLPTableau3<T>::OptimumVector(void) const
{
  return optimum;
}

template <class T> int gLPTableau3<T>::IsFeasible(void) const
{
  return feasible;
}

template <class T> int gLPTableau3<T>::IsBounded(void) const
{
  return bounded;
}

template <class T> int gLPTableau3<T>::IsWellFormed(void) const
{
  return well_formed;
}

template <class T> gLPTableau3<T>::~gLPTableau3()
{ }
