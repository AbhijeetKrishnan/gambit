//
// FILE: seqform.imp -- Sequence Form module
//
// @(#)seqform.imp	2.9.1.1 7/15/97
//


#include "seqform.h"
#include "gwatch.h"


//---------------------------------------------------------------------------
//                        SeqFormModule: member functions
//---------------------------------------------------------------------------

template <class T>
SeqFormModule<T>::SeqFormModule(const Efg &E, const SeqFormParams &p, 
			      const EFSupport &S)
  : EF(E), support(S), params(p), A(0), b(0), maxpay((T) 0), npivots(0)
{ 
  int ntot;
  ns1=S.NumSequences(1);
  ns2=S.NumSequences(2);
  ni1=E.Players()[1]->NumInfosets()+1;
  ni2=E.Players()[2]->NumInfosets()+1;
  gout << "\nns1: " << ns1 << " ns2: " << ns2 << " ni1: " << ni1 << " ni2: " << ni2;

  ntot = ns1+ns2+ni1+ni2;

  A = new gMatrix<T>(1,ntot,0,ntot);
  b = new gVector<T>(1,ntot);
  int i,j;

  maxpay = (T)EF.MaxPayoff()+(T)1;

  T prob = (T)1;
  for(i=A->MinRow();i<=A->MaxRow();i++) {
    (*b)[i] = (T)0;
    for(j=A->MinCol();j<=A->MaxCol();j++)
      (*A)(i,j) = (T)0; 
  }

  FillTableau(EF.RootNode(),prob,1,1,0,0);
  for(i=A->MinRow();i<=A->MaxRow();i++) 
    (*A)(i,0) = -(T)1;
  (*A)(1,ns1+ns2+1) = (T)1;
  (*A)(ns1+ns2+1,1) = -(T)1;
  (*A)(ns1+1,ns1+ns2+ni1+1) = (T)1;
  (*A)(ns1+ns2+ni1+1,ns1+1) = -(T)1;
  (*b)[ns1+ns2+1] = -(T)1;
  (*b)[ns1+ns2+ni1+1] = -(T)1;
  gout.SetWidth(4).SetPrec(1);
  gout << "\nA:\n";
  A->Dump(gout);
  gout << "\nb:\n";
  b->Dump(gout);

  tab = new LTableau<T>(*A,*b);
  eps = tab->Epsilon();
//  tab->Refactor();  // not necessary?
  gout << "\ntab:\n";
  tab->Dump(gout);
}

template <class T> SeqFormModule<T>::~SeqFormModule()
{ if(A) delete A; if(b) delete b; if(tab) delete tab;}

//
// Lemke implements the Lemke's algorithm (as refined by Eaves 
// for degenerate problems) for  Linear Complementarity
// problems, starting from the primary ray.  
//

template <class T> int SeqFormModule<T>::Lemke(void)
{
  BFS<T> cbfs((T) 0);
  int i;
  
  if (EF.NumPlayers() != 2 || !params.tracefile)   return 0;
  
  gWatch watch;
  
  BehavProfile<T> profile(EF);
  gVector<T> sol(tab->MinRow(),tab->MaxRow());
    
  solutions.Flush();
  List.Flush();

  if(params.stopAfter!=1) 
    All_Lemke(ns1+ns2+1,*tab,npivots,0);
  else {

    tab->Pivot(ns1+ns2+1,0);
    tab->SF_LCPPath(ns1+ns2+1,params.status);

    Add_BFS(*tab);
    tab->BasisVector(sol);
    //  gout << "\nsol = " << sol;
    GetProfile(*tab, profile,sol,EF.RootNode(),1,1);
    //  gout << "\nprofile = " << profile << "\n";
    solutions.Flush();
    solutions.Append(BehavSolution<T>(profile, EfgAlg_SEQFORM));
  }

  gout << "\n";  
  if (params.trace >= 2)  {
    for (i = 1; i <= List.Length(); i++)   {
      List[i].Dump(*params.tracefile);
      (*params.tracefile) << "\n";
    }
  }
  
  // if(params.trace >= 1)
  //   (*params.tracefile) << "\nN Pivots = " << npivots << "\n";

  npivots=tab->NumPivots();
  time = watch.Elapsed();
  return List.Length();
}

template <class T> int SeqFormModule<T>::Add_BFS(const LTableau<T> &tableau)
{
  BFS<T> cbfs((T) 0);
  gVector<T> v(tableau.MinRow(), tableau.MaxRow());
  tableau.BasisVector(v);

  for (int i = tableau.MinCol(); i <= tableau.MaxCol(); i++)
    if (tableau.Member(i)) {
      cbfs.Define(i, v[tableau.Find(i)]);
    }

  if (List.Contains(cbfs))  return 0;
  //  if(params.trace >=2) (*params.tracefile) << "\nFound CBFS";
  //  (*params.tracefile)  << "\nB = ";
  //  tableau.Dump(*params.tracefile);
  //  (*params.tracefile)  << "\ncbfs = ";
  //  cbfs.Dump(*params.tracefile );
  List.Append(cbfs);
  return 1;
}

//
// All_Lemke finds all accessible Nash equilibria by recursively 
// calling itself.  List maintains the list of basic variables 
// for the equilibria that have already been found.  
// From each new accessible equilibrium, it follows
// all possible paths, adding any new equilibria to the List.  
//
template <class T> int 
SeqFormModule<T>::All_Lemke(int j, LTableau<T> &B,long &np, int depth)
{
  int i,len,newsol,missing;
  T p1,p2,aa;
  T small_num = (T)1/(T)1000;

  np+=B.NumPivots();
  gVector<T> sol(tab->MinRow(),tab->MaxRow());
  BehavProfile<T> profile(EF);

  gout << "\nIn All_Lemke() depth: " << depth;
  
  newsol =0;
  for (i = B.MinRow(); 
       i <= B.MaxRow()  && !params.status.Get() && newsol ==0 &&
       (params.stopAfter==0 || solutions.Length() < params.stopAfter);
       i++)
    if (i != j)  {
      len=List.Length()-1;
      p1=(double)len/(double)(len+1);
      p2=(double)(len+1)/(double)(len+2);
      int num_strats = B.MaxCol()-B.MinCol()-1;
      aa=(double)(i)/(double)num_strats;
      params.status.SetProgress(p1+aa*(p2-p1));
      
      LTableau<T> BCopy(B);
      (*A)(i,0)=-small_num;

      if(depth==0) {
	BCopy.Pivot(j,0);
	missing = -j;
      }
      else
	missing = BCopy.SF_PivotIn(0);

      assert(missing);
      // gout << "\nafter Pivot, missing: " << missing << "\n";
      // BCopy.Dump(gout);

      gout << "\nDepth: " << depth << " Path: " << i;
      newsol=0;

      if(BCopy.SF_LCPPath(-missing,params.status)==1) {
	// gout << "\nafter LCPPath\n";
	// BCopy.Dump(gout);
	
	newsol = Add_BFS(BCopy);
	BCopy.BasisVector(sol);
	// gout << "\nsol = " << sol;
	GetProfile(BCopy, profile,sol,EF.RootNode(),1,1);
	if(newsol)
	  solutions.Append(BehavSolution<T>(profile, EfgAlg_SEQFORM)); 
	// gout << "\nprofile = " << profile;
      }
      else 
	gout << ": Dead End";
      
      (*A)(i,0)=-(T)1;
      if(newsol)
	All_Lemke(i,BCopy,npivots,depth+1);
    }
  
  return 1;
}

//-------------------------------------------------------------------------
//                   SeqFormModule<T>: Returning solutions
//-------------------------------------------------------------------------

template <class T> 
const gList<BehavSolution<T> > &SeqFormModule<T>::GetSolutions(void) const
{
  return solutions;
}


/*
template <class T> void LemkeModule<T>::AddSolutions(void)
{
  int i,j;
  int n1=support.NumStrats(1);
  int n2=support.NumStrats(2);
  solutions.Flush();

  for (i = 1; i <= List.Length(); i++)    {
    MixedProfile<T> profile(NF,support);
    T sum = (T) 0;

    for (j = 1; j <= n1; j++)
      if (List[i].IsDefined(j))   sum += List[i](j);

    if (sum == (T) 0)  continue;

    for (j = 1; j <= n1; j++) 
      if (List[i].IsDefined(j))   profile(1, j) = List[i](j) / sum;
      else  profile(1, j) = (T) 0;

    sum = (T) 0;

    for (j = 1; j <= n2; j++)
      if (List[i].IsDefined(n1 + j))  
	sum += List[i](n1 + j);

    if (sum == (T) 0)  continue;

    for (j = 1; j <= n2; j++)
      if (List[i].IsDefined(n1 + j))
	profile(2, j) = List[i](n1 + j) / sum;
      else
	profile(2, j) = (T) 0;

    int index;
    bool add = false;
    if((params.status.Get() !=1) 
//       || (params.status.Get() ==1 && profile.IsNash())
     )
      add = true;
    if(add) {
      index = solutions.Append(MixedSolution<T>(profile, NfgAlg_LEMKE));
      if(params.status.Get() != 1) {
	solutions[index].SetIsNash(T_YES);
	solutions[index].SetIsPerfect(T_YES);
	solutions[index].SetEpsilon(epsilon);
      }
    }
  }
}
*/

template <class T> long SeqFormModule<T>::NumPivots(void) const
{
  return npivots;
}

template <class T> double SeqFormModule<T>::Time(void) const
{
  return time;
}


template <class T> void SeqFormModule<T>
::FillTableau(const Node *n, T prob,int s1,int s2, int i1,int i2)
{
//  gout << "\ns1,s2,i1,i2: " << s1 << " " << s2  << " " << i1  << " " << i2;
//  gout << " prob = " << prob;
  int i,snew;
  if(n->GetOutcome()) {
    (*A)(s1,ns1+s2) = (*A)(s1,ns1+s2) +
       prob*(T) ((Efg &) EF).Payoff(n->GetOutcome(), 1) - maxpay;
    (*A)(ns1+s2,s1) = (*A)(ns1+s2,s1) +
       prob*(T) ((Efg &) EF).Payoff(n->GetOutcome(), 2) - maxpay;
  }
  if(n->GetInfoset()) {
    if(n->GetPlayer()->IsChance()) {
      for(i=1;i<=n->NumChildren();i++)
	FillTableau(n->GetChild(i),
		    prob * (T) EF.GetChanceProb(n->GetInfoset(), i),
		    s1,s2,i1,i2);
    }
    int pl = n->GetPlayer()->GetNumber();
    if(pl==1) {
      i1=n->GetInfoset()->GetNumber();
      snew=1;
      for(i=1;i<i1;i++)
	snew+=n->GetPlayer()->Infosets()[i]->NumActions();

      (*A)(s1,ns1+ns2+i1+1) = -(T)1;
      (*A)(ns1+ns2+i1+1,s1) = (T)1;
      for(i=1;i<=n->NumChildren();i++) {
	(*A)(snew+i,ns1+ns2+i1+1) = (T)1;
	(*A)(ns1+ns2+i1+1,snew+i) = -(T)1;
	FillTableau(n->GetChild(i),prob,snew+i,s2,i1,i2);
      }
    }
    if(pl==2) {
      i2=n->GetInfoset()->GetNumber();
      snew=1;
      for(i=1;i<i2;i++)
	snew+=n->GetPlayer()->Infosets()[i]->NumActions();
      (*A)(ns1+s2,ns1+ns2+ni1+i2+1) = -(T)1;
      (*A)(ns1+ns2+ni1+i2+1,ns1+s2) = (T)1;
      for(i=1;i<=n->NumChildren();i++) {
	(*A)(ns1+snew+i,ns1+ns2+ni1+i2+1) = (T)1;
	(*A)(ns1+ns2+ni1+i2+1,ns1+snew+i) = -(T)1;
	FillTableau(n->GetChild(i),prob,s1,snew+i,i1,i2);
      }
    }
    
  }
}


template <class T> void SeqFormModule<T>
::GetProfile(const LTableau<T> &tab, gDPVector<T> &v, const gVector<T> &sol,
	       const Node *n, int s1,int s2)
{
  int i,pl,inf,snew,ind,ind2;
//  T eps;
//  eps = tab->Epsilon();
//  gout << "\nv = " << v;
  if(n->GetInfoset()) {
    if(n->GetPlayer()->IsChance()) {
      for(i=1;i<=n->NumChildren();i++)
	GetProfile(tab, v,sol,n->GetChild(i),s1,s2);
    }
    pl = n->GetPlayer()->GetNumber();
    inf= n->GetInfoset()->GetNumber();
//    gout << "\niset: (" << pl << "," << inf << ")"; 
    if(pl==1) {
      snew=1;
      for(i=1;i<inf;i++)
	snew+=n->GetPlayer()->Infosets()[i]->NumActions(); 
      for(i=1;i<=n->NumChildren();i++) {
	v(pl,inf,i) = (T)0;
//	gout << "\npl1 ";
//	gout << "\n  v = " << v;
	if(tab.Member(s1)) {
	  ind = tab.Find(s1);
//	  if(sol[ind]!=(T)0) {
//*	  if(sol[ind]<-eps) {
	  if(sol[ind]>eps) {
	    if(tab.Member(snew+i)) {
	      ind2 = tab.Find(snew+i);
	      if(sol[ind2]>eps)
//*	      if(sol[ind2]<-eps)
		v(pl,inf,i) = sol[ind2]/sol[ind];
//	      gout << "\nind: " << ind << " " << sol[ind] << " ";
//	      gout << "\nind2: " << ind2 << " " << sol[ind2] << " ";
//	      gout << "\n  v = " << v;
	    }
	  } 
	} 
	GetProfile(tab, v,sol,n->GetChild(i),snew+i,s2);
      }
    }
    if(pl==2) {
      snew=1;
      for(i=1;i<inf;i++)
	snew+=n->GetPlayer()->Infosets()[i]->NumActions(); 
      for(i=1;i<=n->NumChildren();i++) {
	v(pl,inf,i) = (T)0;
//	gout << "\npl2 ";
//	gout << "\n  v = " << v;
	if(tab.Member(ns1+s2)) {
	  ind = tab.Find(ns1+s2);
//	  if(sol[ind]!=(T)0) {
//*	  if(sol[ind]<-eps) {
	  if(sol[ind]>eps) {
	    if(tab.Member(ns1+snew+i)) {
	      ind2 = tab.Find(ns1+snew+i);
//*	      if(sol[ind2]<-eps)
	      if(sol[ind2]>eps)
		v(pl,inf,i) = sol[ind2]/sol[ind];
//	      gout << "\nind: " << ind << " " << sol[ind] << " ";
//	      gout << "\nind2: " << ind2 << " " << sol[ind2] << " ";
//	      gout << "\n  v = " << v;
	    }
	  } 
	} 
	GetProfile(tab, v,sol,n->GetChild(i),s1,snew+i);
      }
    }
  }
}


//-----------------------------------
// Interfacing to solve-by-subgame
//-----------------------------------

template <class T>
int SeqFormBySubgame<T>::SolveSubgame(const Efg &E, const EFSupport &sup,
				      gList<BehavSolution<T> > &solns)
{
  BehavProfile<T> bp(E, sup);

  SeqFormModule<T> M(E, params, sup);
  
  M.Lemke();

  npivots += M.NumPivots();

  solns = M.GetSolutions();
  return params.status.Get();
}

template <class T>
SeqFormBySubgame<T>::SeqFormBySubgame(const Efg &E, const EFSupport &S,
				      const SeqFormParams &p, int max)
  : SubgameSolver<T>(E, S, max), npivots(0), params(p)
{ }

template <class T>  SeqFormBySubgame<T>::~SeqFormBySubgame()   { }
  
