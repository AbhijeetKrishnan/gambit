//
// File: equisolv.imp  
//        -- Implementation of class EquiSolv
// 
// @(#)EquiSolv.imp	1.6 01/24/98
//

#include "equisolv.h"


//---------------------------------------------------------------
//                      class: EquiSolv
//---------------------------------------------------------------

//---------------------------
// Constructors / Destructors
//---------------------------

template <class T> EquiSolv<T>::EquiSolv(const gList<gPolyList<T> >& given) 
: UtilityLists(CopyGivenLists(given)),
  gDoubleULists(ListsTogDouble(given)),
  UDiffPartialTrees(UtilityDiffPartialTrees()),
  ListsOfTreesOfPartials(GenerateTreesOfPartials()),
  System(DerivedEquationSystem()), 
  gDoubleSystem(ListTogDouble(System)),
  TreesOfPartials(gDoubleSystem),
  HasBeenSolved(false), 
  Roots()
{
}

template<class T> EquiSolv<T>::EquiSolv(const EquiSolv& qs)
: UtilityLists(qs.UtilityLists),
  gDoubleULists(qs.gDoubleULists),
  UDiffPartialTrees(qs.UDiffPartialTrees),
  ListsOfTreesOfPartials(qs.ListsOfTreesOfPartials),
  System(qs.System), 
  gDoubleSystem(qs.gDoubleSystem),
  TreesOfPartials(qs.TreesOfPartials), 
  HasBeenSolved(qs.HasBeenSolved), 
  Roots(qs.Roots)
{
}

template<class T> EquiSolv<T>::~EquiSolv()
{
}

//-----------------------------------------------------------
//      Functions Used in Initialization in Constructors
//-----------------------------------------------------------

template <class T> const gList<gPolyList<T> >
EquiSolv<T>::CopyGivenLists(const gList<gPolyList<T> >& given) const
{
  gList<gPolyList<T> > answer;
  for (int i = 1; i <= given.Length(); i++)
    answer += given[i];
  return answer;
}

template <class T> 
const gPolyList<T> EquiSolv<T>::DerivedEquationSystem() const
{
  gList<gPoly<T> > polylist;
  for (int i = 1; i <= UtilityLists.Length(); i++)
    for (int j = 2; j <= UtilityLists[i].Length(); j++)
      polylist += UtilityLists[i][j] - UtilityLists[i][1];
  return gPolyList<T>(UtilityLists[1].AmbientSpace(),
		UtilityLists[1].TermOrder(),polylist);
}

template <class T> const gPolyList<gDouble>
EquiSolv<T>::ListTogDouble(const gPolyList<T>& given) const
{
  return gPolyList<gDouble>(given.AmbientSpace(),
			    given.TermOrder(),
			    given.ListTogDouble());
}

template <class T> const gList<gPolyList<gDouble> >
EquiSolv<T>::ListsTogDouble(const gList<gPolyList<T> >& given) const
{
  gList<gPolyList<gDouble> > answer;
  for (int i = 1; i <= given.Length(); i++)
    answer += gPolyList<gDouble>(given[i].AmbientSpace(),
				 given[i].TermOrder(),
				 given[i].ListTogDouble());
  return answer;
}

template <class T> const gList<ListOfPartialTrees<gDouble> >
EquiSolv<T>::GenerateTreesOfPartials() const
{
  gList<ListOfPartialTrees<gDouble> > answer;
  for (int i = 1; i <= gDoubleULists.Length(); i++)
    answer += ListOfPartialTrees<gDouble>(gDoubleULists[i]);
  return answer;
}

template <class T> const gList<gList<gList<TreeOfPartials<gDouble> > > >
EquiSolv<T>::UtilityDiffPartialTrees() const
{
  gList<gList<gList<TreeOfPartials<gDouble> > > > answer;
  for (int i = 1; i <= UtilityLists.Length(); i++) {
    gList<gList<TreeOfPartials<gDouble> > > listoflists;
    for (int j = 1; j <= UtilityLists[i].Length(); j++) {
      gList<TreeOfPartials<gDouble> > list;
      for (int k = 1; k <= UtilityLists[i].Length(); k++)
	list += TreeOfPartials<gDouble>(gDoubleULists[i][j] - 
					gDoubleULists[i][k]);
      listoflists += list;
    }
    answer += listoflists;
  }
  return answer;
}

//----------------------------------
//      Supporting Calculations
//----------------------------------

//---------------------------
// Is a root impossible?
//---------------------------

template<class T> bool
EquiSolv<T>::PolyHasNoRootsIn(const gRectangle<gDouble>& r, 
			      const int &index) const
{
  gVector<gDouble> center = r.Center();

  //DEBUG
  gout << "The index is now " << index << ".\n";

  gDouble constant = 
    TreesOfPartials[index].RootNode()->GetData().Evaluate(center);
  if (constant < (gDouble)0) constant = - constant;

  gVector<gDouble> HalvesOfSideLengths(Dmnsn());
  for (int k = 1; k <= Dmnsn(); k++) 
    HalvesOfSideLengths[k] = r.HeightInCoord(k) / (gDouble)2.0;

  gDouble max = TreesOfPartials[index].MaximalNonconstantContribution(
							center,
							HalvesOfSideLengths);

  if (max > constant) return false;
  else                return true;
}

template<class T> bool
EquiSolv<T>::PolyEverywhereNegativeIn(const gRectangle<gDouble>& r, 
				      const int &index) const
{
  gVector<gDouble> center = r.Center();

  gDouble constant = 
    TreesOfPartials[index].RootNode()->GetData().Evaluate(center);
  if (constant >= (gDouble)0) return false;

  gVector<gDouble> HalvesOfSideLengths(Dmnsn());
  for (int k = 1; k <= Dmnsn(); k++) 
    HalvesOfSideLengths[k] = r.HeightInCoord(k) / (gDouble)2.0;

  gDouble max = TreesOfPartials[index].MaximalNonconstantContribution(
							center,
							HalvesOfSideLengths);

  if (max + constant >= 0) return false;
  else                     return true;
}

template<class T> 
bool EquiSolv<T>::SystemHasNoRootsIn(const gRectangle<gDouble>& r,
				     gArray<int>& precedence)        const
{
  for (int i = 1; i <= System.Length(); i++)
    if ( (precedence[i] <= Dmnsn() && 
	                      PolyHasNoRootsIn(r, precedence[i])) ||
         (precedence[i] >  Dmnsn() && 
	                      PolyEverywhereNegativeIn(r, precedence[i])) ) { 
      if (i != 1) { // We have found a new "most likely to never vanish"
	int tmp = precedence[i];
	for (int j = 1; j <= i-1; j++) 
	  precedence[i - j + 1] = precedence[i - j];
	precedence[1] = tmp;
      }
      return true; 
    }
  return false;
}

template<class T> 
bool EquiSolv<T>::SystemHasNoEquilibriaIn(const gRectangle<gDouble>& r)  const
{
  gVector<gDouble> center = r.Center();
  for (int i = 1; i <= gDoubleULists.Length(); i++) {

    gDouble min = gDoubleULists[i][1].Evaluate(center); int mindex = 1;
    gDouble max = gDoubleULists[i][1].Evaluate(center); int maxdex = 1;

    for (int j = 2; j <= gDoubleULists[i].Length(); j++) {
      if (gDoubleULists[i][j].Evaluate(center) < min) {
	min = gDoubleULists[i][j].Evaluate(center);
	mindex = j;
      }
      if (gDoubleULists[i][j].Evaluate(center) > max) {
	max = gDoubleULists[i][j].Evaluate(center);
	maxdex = j;
      }
    }

    if (mindex == maxdex) return false;

    gVector<gDouble> HalvesOfSideLengths(r.Dmnsn());
    for (int k = 1; k <= r.Dmnsn(); k++)
      HalvesOfSideLengths[k] = r.HeightInCoord(k) / (gDouble)2.0;
    gDouble ncdiff = ListsOfTreesOfPartials[i].
      MaximalNonconstantDifference(maxdex,mindex,center,HalvesOfSideLengths);

    if (max - min > ncdiff) 
      return true;
  }

  return false;
}

//--------------------------------------
// Does Newton's method lead to a root?
//--------------------------------------

template <class T> gSquareMatrix<gDouble> 
EquiSolv<T>::DerivativeMatrix(const gVector<gDouble>& point) const
{
  gSquareMatrix<gDouble> Df(Dmnsn());

  int rownumber = 1;

  for (int i = 1; i <= UtilityLists.Length(); i++) {
    for (int j = 2; j <= UtilityLists[i].Length(); j++) {
      gVector<gDouble> v = UDiffPartialTrees[i][j][1].VectorOfPartials(point);
      for (int k = 1; k <= Dmnsn(); k++) 
	Df(rownumber,k) = v[k];

      rownumber++;
    }
  }
  return Df;
}

template <class T> gVector<gDouble> 
EquiSolv<T>::UtilityDiffs(const gVector<gDouble>& point) const
{
  gVector<gDouble> Diffs(Dmnsn());

  int index = 1;

  for (int i = 1; i <= UtilityLists.Length(); i++) {
    for (int j = 2; j <= UtilityLists[i].Length(); j++) {

      Diffs[index] = gDoubleULists[i][j].Evaluate(point) - 
	             gDoubleULists[i][1].Evaluate(point);
      index++;
    }
  }
  return Diffs;
}

template <class T>
bool EquiSolv<T>::NewtonEquiInRectangle(const gRectangle<gDouble>& r,
					      gVector<gDouble>& point) const
{
  gVector<gDouble> zero(Dmnsn());
  for (int i = 1; i <= Dmnsn(); i++) zero[i] = (gDouble)0;

  gVector<gDouble> oldevals = UtilityDiffs(point);

  if ( oldevals == zero ) 
    if (r.Contains(point)) return true;
    else                   return false;

  gRectangle<gDouble> bigr = r.SameCenterDoubleSideLengths();

  while (true) {
    gSquareMatrix<gDouble> Df = DerivativeMatrix(point);
    if (Df.Determinant() == (gDouble)0) return false;
    gVector<gDouble> Del = - (Df.Inverse() * oldevals);

    if ( !bigr.Contains(point + Del) ) return false;
    point += Del;

    gVector<gDouble> newevals = UtilityDiffs(point);

    if (newevals * newevals > oldevals * oldevals) return false;
    if ( newevals == zero )
      if (r.Contains(point)) return true;
      else                   return false;                

    oldevals = newevals;
  }
}

template <class T>
bool EquiSolv<T>::NewtonRootInRectangle(const gRectangle<gDouble>& r,
					      gVector<gDouble>& point) const
{
  assert(TreesOfPartials.Length() == System.Length());

  gVector<gDouble> zero(Dmnsn());
  for (int i = 1; i <= Dmnsn(); i++) zero[i] = (gDouble)0;

  gVector<gDouble> oldevals = TreesOfPartials.ValuesOfRootPolys(point,
							     System.Length());

  if ( oldevals == zero ) 
    if (r.Contains(point)) return true;
    else                   return false;

  gRectangle<gDouble> bigr = r.SameCenterDoubleSideLengths();

  while (true) {
    gSquareMatrix<gDouble> Df = TreesOfPartials.SquareDerivativeMatrix(point);
    if (Df.Determinant() == (gDouble)0) return false;
    gVector<gDouble> Del = - (Df.Inverse() * oldevals);

    if ( !bigr.Contains(point + Del) ) return false;
    point += Del;

    gVector<gDouble> newevals = TreesOfPartials.ValuesOfRootPolys(point,
							     System.Length());

    if (newevals * newevals > oldevals * oldevals) return false;
    if ( newevals == zero )
      if (r.Contains(point)) return true;
      else                   return false;                

    oldevals = newevals;
  }
}

//------------------------------------
// Is the Newton root the only root?
//------------------------------------

template<class T> 
gPoly<gDouble> EquiSolv<T>::TranslateOfMono(const gMono<gDouble>& m, 
				      const gVector<gDouble>& new_origin) const
{
  gPoly<gDouble> answer(AmbientSpace(), (gDouble)1, TermOrder());

  for (int i = 1; i <= Dmnsn(); i++) {
    if (m.ExpV()[i] > 0) {
      gPoly<gDouble> lt(AmbientSpace(), i, 1, TermOrder());
      lt += gPoly<gDouble>(AmbientSpace(), new_origin[i], TermOrder());
      for (int j = 1; j <= m.ExpV()[i]; j++)
	answer *= lt;
    }
  }

  answer *= m.Coef();

  return answer;
}

template<class T> 
gPoly<gDouble>  EquiSolv<T>::TranslateOfPoly(const gPoly<gDouble>& p, 
				       const gVector<gDouble>& new_origin) const
{
  gPoly<gDouble> answer(AmbientSpace(), TermOrder());
  for (int i = 1; i <= p.MonomialList().Length(); i++) 
    answer += TranslateOfMono(p.MonomialList()[i],new_origin);
  return answer;
}


template<class T> 
gPolyList<gDouble>  EquiSolv<T>::TranslateOfSystem(const gPolyList<gDouble>& old,
					     const gVector<gDouble>& new_origin) 
const
{
  gList<gPoly<gDouble> > new_polys;
  for (int i = 1; i <= UnderlyingEquations().Length(); i++)
    new_polys += gPoly<gDouble>( TranslateOfPoly(old[i],new_origin) );
  return gPolyList<gDouble>(AmbientSpace(),TermOrder(),new_polys);
}


template<class T> 
gPoly<gDouble>  EquiSolv<T>::MonoInNewCoordinates(const gMono<gDouble>& m, 
					    const gSquareMatrix<gDouble>& M) const
{
  assert(M.NumRows() == Dmnsn());

  gPoly<gDouble> answer(AmbientSpace(), (gDouble)1, TermOrder());

  for (int i = 1; i <= Dmnsn(); i++) {
    if (m.ExpV()[i] > 0) {
      gPoly<gDouble> linearform(AmbientSpace(), (gDouble)0, TermOrder());
      for (int j = 1; j <= Dmnsn(); j++) {
	exp_vect exps(AmbientSpace(), j, 1);
	linearform += gPoly<gDouble>(AmbientSpace(), exps, M(i,j), TermOrder());
      }
      for (int k = 1; k <= m.ExpV()[i]; k++) answer *= linearform;
    }
  }

  answer *= m.Coef();

  return answer;
}

template<class T> 
gPoly<gDouble> EquiSolv<T>::PolyInNewCoordinates(const gPoly<gDouble>& p, 
					   const gSquareMatrix<gDouble>& M) const
{
  gPoly<gDouble> answer(AmbientSpace(), TermOrder());
  for (int i = 1; i <= p.MonomialList().Length(); i++) 
    answer += MonoInNewCoordinates(p.MonomialList()[i],M);
  return answer;
}


template<class T> gPolyList<gDouble> 
EquiSolv<T>::SystemInNewCoordinates(const gPolyList<gDouble>& old,
				    const gSquareMatrix<gDouble>& M) const
{
  gList<gPoly<gDouble> > new_polys;
  for (int i = 1; i <= UnderlyingEquations().Length(); i++)
    new_polys += gPoly<gDouble>( PolyInNewCoordinates(old[i],M) );
  return gPolyList<gDouble>(AmbientSpace(),TermOrder(),new_polys);
}


template<class T>
   gDouble EquiSolv<T>::MaxDistanceFromPointToVertexAfterTransformation(
				      const gRectangle<gDouble>& r,
				      const gVector<gDouble>& p,
				      const gSquareMatrix<gDouble>& M)    const
{
  assert( r.Contains(p) );

  gDouble max = (gDouble)0;

  gArray<int> ListOfTwos(Dmnsn());
  for (int i = 1; i <= Dmnsn(); i++) ListOfTwos[i] = 2;
  gIndexOdometer ListOfTopBottoms(ListOfTwos);

  while (ListOfTopBottoms.Turn()) {
    gVector<gDouble> diffs(Dmnsn());
    for (int i = 1; i <= Dmnsn(); i++)
      if (ListOfTopBottoms[i] == 2)
	diffs[i] = r.UpperBoundOfCoord(i) - p[i];
      else 
	diffs[i] = p[i] - r.LowerBoundOfCoord(i);
    gVector<gDouble> new_diffs = M * diffs;
    gDouble squared_length = new_diffs * new_diffs;
    if (max < squared_length)
       max = squared_length;
  }

  return sqrt((gDouble)max);
}

template<class T>
gDouble EquiSolv<T>::MaximalContributionOfHigherOrderTerms(
						 const gPoly<gDouble>& p,
						 const gDouble& radius)  const
{
  gDouble maxcon = (gDouble)0;
  for (int i = 1; i <= p.MonomialList().Length(); i++) 
    if (p.MonomialList()[i].TotalDegree() > 1) 
      maxcon += p.MonomialList()[i].Coef() * 
	            pow(radius,p.MonomialList()[i].TotalDegree());

  return maxcon;
}


template<class T>
bool EquiSolv<T>::HasNoOtherRootsIn(const gRectangle<gDouble>& r,
			  const gVector<gDouble>& p,
			  const gSquareMatrix<gDouble>& M)  const
{
  gPolyList<gDouble> system1 = TranslateOfSystem(gDoubleSystem, p);
  gPolyList<gDouble> system2 = SystemInNewCoordinates(system1,M);

  gDouble radius = MaxDistanceFromPointToVertexAfterTransformation(r,p,M);

  gDouble max = (gDouble)0;
  for (int i = 1; i <= Dmnsn(); i++)
    max += MaximalContributionOfHigherOrderTerms(system2[i],radius);

  if (max >= radius) return false;
  else               return true;
}


//--------------------------------------------
// Does Newton's method yield a unique root?
//--------------------------------------------

template <class T>
bool EquiSolv<T>::NewtonRootIsOnlyInRct(const gRectangle<gDouble>& r,
					gVector<gDouble>& point) const
{

  if ( NewtonRootInRectangle(r,point) ) {
    gSquareMatrix<gDouble> Df = TreesOfPartials.SquareDerivativeMatrix(point);
    if ( HasNoOtherRootsIn(r,point,Df.Inverse()) ) return true;
    else                                           return false;
  }
  else                                             return false;
}

template <class T>
bool EquiSolv<T>::NewtonEquiIsOnlyInRct(const gRectangle<gDouble>& r,
					      gVector<gDouble>& point) const
{

  if ( NewtonRootInRectangle(r,point) ) {
    gSquareMatrix<gDouble> Df = DerivativeMatrix(point);
    if ( HasNoOtherRootsIn(r,point,Df.Inverse()) ) return true;
    else                                           return false;
  }
  else                                             return false;
}


//----------------------------------
//        Operators
//----------------------------------

template<class T> 
EquiSolv<T>& EquiSolv<T>::operator=(const EquiSolv<T> & rhs)
{
  assert (System == rhs.System);

  if (*this != rhs) {
    HasBeenSolved = rhs.HasBeenSolved;
    Roots         = rhs.Roots;
  }
  return *this;
}

template<class T>  
bool EquiSolv<T>::operator==(const EquiSolv<T> & rhs) const
{
    if (System        != rhs.System        ||
	HasBeenSolved != rhs.HasBeenSolved ||
	Roots         != rhs.Roots)
         return false;
    else return true;
}

template<class T>  
bool EquiSolv<T>::operator!=(const EquiSolv<T> & rhs) const
{
  return !(*this == rhs);
}

//-------------------------------------------
//          Check for Singularity
//-------------------------------------------

template<class T> bool
EquiSolv<T>::MightHaveSingularRoots() const
{
  gPoly<gDouble> newpoly = 
    gDoubleSystem.ReductionOf(  gDoubleSystem.DetOfDerivativeMatrix(),
			      *(gDoubleSystem.TermOrder()));

  if (newpoly.IsZero()) return true;

  gList<gPoly<gDouble> > newlist(gDoubleSystem.UnderlyingList());

  newlist += newpoly;
  gPolyList<gDouble> larger_system(gDoubleSystem.AmbientSpace(),
			     gDoubleSystem.TermOrder(),
			     newlist);
  gIdeal<gDouble> test_ideal(gDoubleSystem.TermOrder(),larger_system);

  return !(test_ideal.IsEntireRing());
}

//-------------------------------------------
//           The Central Calculation
//-------------------------------------------

template<class T> bool
EquiSolv<T>::FindRoots(const gRectangle<gDouble>& r, 
		       const int& max_iterations) 
{
  int zero = 0;
  return FindCertainNumberOfRoots(r,max_iterations,zero);
}

template<class T> bool
EquiSolv<T>::FindRoots(const int& max_iterations) 
{
  int zero = 0;
  return FindCertainNumberOfRoots(max_iterations,zero);
}

template<class T> bool
EquiSolv<T>::FindCertainNumberOfRoots(const gRectangle<gDouble>& r, 
				      const int& max_iterations,
				      const int& max_no_roots) 
{
  gList<gVector<gDouble> >* rootlistptr = new gList<gVector<gDouble> >();

  gArray<int> precedence(System.Length());  
            // Orders search for nonvanishing poly
  for (int i = 1; i <= System.Length(); i++) precedence[i] = i;

  int iterations = 0;

  int* no_found = new int(0);
  FindRootsRecursion(rootlistptr,
		     r,
		     max_iterations, 
		     precedence, 
		     iterations,
		     max_no_roots,
		     no_found);

  if (iterations < max_iterations) { 
    Roots = *rootlistptr; 
    HasBeenSolved = true; 
    return true; 
  }

  return false;

//DEBUG
//else { gout << "We are quitting.\n"; exit(0); }

// If not yet returned, it bogged down, so do it the other way
  gSolver<T> bigsolver(System.TermOrder(), System);

  if ( !bigsolver.IsZeroDimensional() ) return false;
  else {
    gList<gVector<gDouble> > rootlist;
    rootlist = bigsolver.Roots();
    gList<gVector<gDouble> > roots;
    for (int j = 1; j <= rootlist.Length(); j++)
      if (r.Contains(rootlist[j])) roots += rootlist[j];
    Roots = roots;
  }

  return true;
}

template<class T> bool
EquiSolv<T>::FindCertainNumberOfRoots(const int& max_iterations,
				      const int& max_no_roots) 
{
  gList<gVector<gDouble> >* rootlistptr = new gList<gVector<gDouble> >();

  int iterations = 0;

  gList<gSimplex<gDouble> > simpletope;

  int* no_found = new int(0);
  FindRootsRecursion(rootlistptr,
		     simpletope,
		     max_iterations, 
		     iterations,
		     max_no_roots,
		     no_found);

  if (iterations < max_iterations) { 
    Roots = *rootlistptr; 
    HasBeenSolved = true; 
    return true; 
  }

  return false;
}


template <class T> void //ORIG
EquiSolv<T>::FindRootsRecursion(      gList<gVector<gDouble> >* rootlistptr,
				const gRectangle<gDouble>& r, 
				const int& max_iterations,
				      gArray<int>& precedence,
				      int& iterations,
				const int& max_no_roots,
				      int* roots_found)    const
{
  if ( SystemHasNoRootsIn(r, precedence) ) 
    return; // newlist; 

  gVector<gDouble> point = r.Center();
  if ( NewtonRootIsOnlyInRct(r, point) ) {
    for (int i = Dmnsn() + 1; i <= System.Length(); i++)
      if (TreesOfPartials[i].ValueOfRootPoly(point) < (gDouble)0)
	return;
    bool already_found = false;
    for (int i = 1; i <= rootlistptr->Length(); i++)
      if (point == (*rootlistptr)[i])
	already_found = true;
    if (!already_found) {
      *rootlistptr += point;
      (*roots_found)++; 
    }
    return; 
  }

  int i = 1;
  while (i <= r.NumberOfCellsInSubdivision() && 
                 (max_no_roots == 0 || *roots_found < max_no_roots)) {
    if (iterations >= max_iterations) return;
    else {
      iterations++;
      FindRootsRecursion(rootlistptr,
			 r.SubdivisionCell(i),
			 max_iterations, 
			 precedence, 
			 iterations,
			 max_no_roots,
			 roots_found);
      i++;
    }
  }

  return; 
}


template <class T> void 
EquiSolv<T>::FindRootsRecursion(      gList<gVector<gDouble> >* rootlistptr,
				const gSimpletope<gDouble>& s, 
				const int& max_iterations,
				      int& iterations,
				const int& max_no_roots,
				      int* roots_found)    const
{
  if ( SystemHasNoEquilibriaIn(s.BoundingRectangle()) ) 
    return; 
/*
  gVector<gDouble> point = r.Center();
  if ( NewtonRootIsOnlyInRct(r, point) ) {
    for (int i = Dmnsn() + 1; i <= System.Length(); i++)
      if (TreesOfPartials[i].ValueOfRootPoly(point) < (gDouble)0)
	return;
    bool already_found = false;
    for (int i = 1; i <= rootlistptr->Length(); i++)
      if (point == (*rootlistptr)[i])
	already_found = true;
    if (!already_found) {
      *rootlistptr += point;
      (*roots_found)++; 
    }
    return; 
  }

  int i = 1;
  while (i <= r.NumberOfCellsInSubdivision() && 
                 (max_no_roots == 0 || *roots_found < max_no_roots)) {
    if (iterations >= max_iterations) return;
    else {
      iterations++;
      FindRootsRecursion(rootlistptr,
			 r.SubdivisionCell(i),
			 max_iterations, 
			 precedence, 
			 iterations,
			 max_no_roots,
			 roots_found);
      i++;
    }
  }
*/
  return; 
}

//----------------------------------
//           Printing
//----------------------------------

template <class T> gOutput& operator << (gOutput& output, 
					 const EquiSolv<T>& x)
{
  output << "The system is\n" << x.System;
  if (x.HasBeenSolved) 
    output << "It has been solved with roots:\n" << x.Roots;
  else output << "It has not been solved.";
  return  output;
}
