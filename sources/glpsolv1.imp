//#
//# FILE: glpsolv1.imp -- Implementation of LP solver
//#
//# @(#)glpsolv1.imp	1.3 7/18/95
//#

#include "glpsolv1.h"



#ifdef __GNUG__
#define INLINE inline
#elif defined __BORLANDC__
#define INLINE
#else
#error Unsupported compiler type
#endif   // __GNUG__, __BORLANDC__

template <class T> INLINE gLPTableau1<T>::gLPTableau1(const gMatrix<T> &A, 
						      const gVector<T> &B,
						      const gVector<T> &C,
						      const gMatrix<T> &D, 
						      const gVector<T> &E) 
	  : gTableau<T>(1, B.Length() + 1, 0, 0, B.Length() + 1, B.Length()),
             // We probably want to just dispose of this last construction
	    feasible(1), bounded(1), well_formed(1), optimum(1, C.Length())
{
// Check to make sure the sizes of the matrix and vectors match up properly
  if (A.NumRows() != B.Length() ||
      A.NumColumns() != C.Length() ||
      D.NumRows() != E.Length() ||
      D.NumColumns() != C.Length())   {
    well_formed = 0;
    return;
  }

// Construct the matrices to be fed to glpsolve.h.
  gMatrix<T> A0(A.NumRows() + 2 * D.NumRows(), A.NumColumns());
  gVector<T> B0(B.Length() + 2 * E.Length()), C0(C.Length());

  int i;
  for (i = 1; i <= A.NumRows(); i++)         // Set A0
    for (int j = 1; j <= A.NumColumns(); j++)
      A0(i,j) = A(i,j);
  for (i = 1; i <= D.NumRows(); i++)  
    for (int j = 1; j <= A.NumColumns(); j++)
      A0(A.NumRows() + i,j) = D(i,j);
  for (i = 1; i <= D.NumRows(); i++)  
    for (int j = 1; j <= A.NumColumns(); j++)
      A0(A.NumRows() + D.NumRows() + i,j) = -D(i,j);
  
  for (i = 1; i <= B.Length(); i++)          // Set B0
    B0[i] = B[i];
  for (i = 1; i <= E.Length(); i++) 
    B0[B.Length() + i] = E[i];
  for (i = 1; i <= E.Length(); i++) 
    B0[B.Length() + E.Length() + i] = - E[i];

  for (i = 1; i <= C.Length(); i++)          // Copy C to C0
    C0[i] = C[i];
              // Remark - this is wasteful (we could just pass C)
              //    but consistent and prettier

// Get the constructor in glpsolve.h to do the actual work
  gLPTableau<T> Tableau0(A0, B0, C0);

// Report findings
  feasible = Tableau0.IsFeasible();
  bounded = Tableau0.IsBounded();
  well_formed = Tableau0.IsWellFormed();
  optimum = Tableau0.OptimumVector();
  cost = Tableau0.OptimumCost();
}   
