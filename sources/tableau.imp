//
// FILE: tableau.imp: implementation of Tableau classes
//
// $Id$
//

#include "tableau.h"
#include "tableau2.imp"

// ---------------------------------------------------------------------------
//                BaseTableau method definitions
// ---------------------------------------------------------------------------


template <class T>
bool BaseTableau<T>::ColIndex(int x) const
{ return MinCol()<=x && x<=MaxCol(); }

template <class T>
bool BaseTableau<T>::RowIndex(int x) const
{ return MinRow()<=x && x<=MaxRow(); }

template <class T>
bool BaseTableau<T>::ValidIndex(int x) const
{ return (ColIndex(x) || RowIndex(-x)); }

template <class T>
void BaseTableau<T>::CompPivot(int outlabel, int col)
{
  Pivot(Find(outlabel),col);
  Pivot(Find(-col),-outlabel);
}


// ---------------------------------------------------------------------------
//            TableauInterface method definitions
// ---------------------------------------------------------------------------

// Constructors and Destructor
 
template <class T> 
TableauInterface<T>::TableauInterface(const gMatrix<T> &A, const gVector<T> &b)
  : A(&A), b(&b), basis(A), solution(A.MinRow(),A.MaxRow()), npivots(0)
{ 
  // These are the values recommended by Murtagh (1981) for 15 digit 
  // accuracy in LP problems 
  // Note: for gRational, eps1 and eps2 resolve to 0
  gEpsilon(eps1,5);
  gEpsilon(eps2);
}

template <class T>
TableauInterface<T>::TableauInterface(const TableauInterface<T> &orig) 
  : A(orig.A), b(orig.b), basis(orig.basis), solution(orig.solution),
    npivots(orig.npivots), eps1(orig.eps1), eps2(orig.eps2)
{ }

template <class T>
TableauInterface<T>::~TableauInterface()
{ }

template <class T>
TableauInterface<T>& TableauInterface<T>::operator=(const TableauInterface<T> &orig)
{
  if(this!= &orig) {
    A = orig.A;
    b = orig.b;
    basis= orig.basis;
    solution= orig.solution;
    npivots = orig.npivots;
  }
  return *this;
}

// getting information

template <class T>
int TableauInterface<T>::MinRow() const { return A->MinRow(); }

template <class T>
int TableauInterface<T>::MaxRow() const { return A->MaxRow(); }

template <class T>
int TableauInterface<T>::MinCol() const { return A->MinCol(); }

template <class T>
int TableauInterface<T>::MaxCol() const { return A->MaxCol(); }

template <class T>
const gMatrix<T> & TableauInterface<T>::Get_A(void) const {return *A; }

template <class T>
const gVector<T> & TableauInterface<T>::Get_b(void) const {return *b;}

template <class T>
bool TableauInterface<T>::Member(int i) const
{ return basis.Member(i);}

template <class T>
int TableauInterface<T>::Label(int i) const
{ return basis.Label(i);}

template <class T>
int TableauInterface<T>::Find(int i) const
{ return basis.Find(i);}

template <class T>
long TableauInterface<T>::NumPivots() const
{ return npivots; }

template <class T>
long &TableauInterface<T>::NumPivots()
{ return npivots; }

template <class T>
void TableauInterface<T>::Mark(int label)
{basis.Mark(label);}

template <class T>
void TableauInterface<T>::UnMark(int label)
{basis.UnMark(label);}

template <class T>
bool TableauInterface<T>::IsBlocked(int label) const
{
  return basis.IsBlocked(label);
}

template <class T>
void TableauInterface<T>::BasisVector(gVector<T> &out) const
{
  out= solution;
}

template <class T>
void TableauInterface<T>::GetColumn(int col, gVector<T> &out) const
{
  basis.GetColumn(col,out);
}

template <class T>
void TableauInterface<T>::GetBasis(Basis<T> &out) const
{
  out= basis;
}

template <class T>
BFS<T> TableauInterface<T>::GetBFS() const
{
  BFS<T> cbfs((T) 0);
  for(int i=MinCol();i<=MaxCol();i++) {
    if(Member(i)) 
      cbfs.Define(i,solution[basis.Find(i)]);
  }
  gout << "\ncbfs: " << cbfs;
  return cbfs;
}

template <class T>
BFS<T> TableauInterface<T>::GetBFS1() const
{
  BFS<T> cbfs((T) 0);
int i;
  for(i=-MaxRow();i<=-MinRow();i++) {
    if(Member(i)) 
      cbfs.Define(i,solution[basis.Find(i)]);
  }
  for(i=MinCol();i<=MaxCol();i++) {
    if(Member(i)) 
      cbfs.Define(i,solution[basis.Find(i)]);
  }
  return cbfs;
}

template <class T>
void TableauInterface<T>::Dump(gOutput &to) const
{ basis.Dump(to);to << "\n";solution.Dump(to);}

template <class T>
void TableauInterface<T>::BigDump(gOutput &to)
{ 
  to << "\nBasis:\n";
  basis.Dump(to);
  gMatrix<T> AA(MinRow(),MaxRow(),MinCol(),MaxCol()+(*A).NumRows());
  gVector<T> bb(MinRow(), MaxRow());

  BasisVector(bb);
  to << "\nBasisVector:\n" << bb;

  for(int j=MinCol();j<=MaxCol();j++) {
    SolveColumn(j, bb);
    for(int i=AA.MinRow();i<=AA.MaxRow();i++) 
      AA(i,j) = bb[i];
  }
  for(int j=MinRow();j<=MaxRow();j++) {
    SolveColumn(-j, bb);
    for(int i=AA.MinRow();i<=AA.MaxRow();i++) 
      AA(i,MaxCol()+j) = bb[i];
  }
  to << "\nTableau:\n" << AA;
}

// miscellaneous functions

template <class T>
bool TableauInterface<T>::EqZero(T x) const
{ 
  return (LeZero(x) && GeZero(x));
}

template <class T>
bool TableauInterface<T>::LtZero(T x) const
{ 
  return !GeZero(x);
}

template <class T>
bool TableauInterface<T>::GtZero(T x) const
{ 
  return !LeZero(x);
}

template <class T>
bool TableauInterface<T>::LeZero(T x) const
{ 
  if(x <=eps2) return 1;
  return 0;
}

template <class T>
bool TableauInterface<T>::GeZero(T x) const
{ 
  if(x >= -eps2) return 1;
  return 0;
}

template <class T>
T TableauInterface<T>::Epsilon(int i) const
{
  assert(i==1 || i==2);
  if(i==1) return eps1;
  return eps2;
}

// ---------------------------------------------------------------------------
//                   Tableau<double> method definitions
// ---------------------------------------------------------------------------

// Constructors and Destructor
 
Tableau<double>::Tableau(const gMatrix<double> &A, const gVector<double> &b)
  : TableauInterface<double>(A,b), B(basis), tmpcol(b.First(),b.Last())
{
  Solve(b, solution);
};


Tableau<double>::Tableau(const Tableau<double> &orig)
  : TableauInterface<double>(orig), B(orig.B,basis), tmpcol(orig.tmpcol)
{ }

Tableau<double>::~Tableau()
{ }

Tableau<double>& Tableau<double>::operator=(const Tableau<double> &orig)
{
  TableauInterface<double>::operator=(orig);
  if(this!= &orig) {
    B.Copy(orig.B,basis);
    tmpcol = orig.tmpcol;
  }
  return *this;
}

//
// pivoting operations
//

int Tableau<double>::CanPivot(int outlabel, int col)
{
  SolveColumn(col,tmpcol);
  double val = tmpcol[basis.Find(outlabel)];
  if(val <=eps2 && val >= -eps2) return 0;
  return 1;  
}

void Tableau<double>::Pivot(int outrow,int col)
{
  assert( RowIndex(outrow) );
  assert( ValidIndex(col) );

  // int outlabel = Label(outrow);
  // gout << "\noutrow:" << outrow;
  // gout << " outlabel: " << outlabel;
  // gout << " inlabel: " << col;
  // BigDump(gout);
  basis.Pivot(outrow,col);
  
  B.update(outrow, col);
  Solve(*b, solution);
  npivots++;
  // BigDump(gout);
}

void Tableau<double>::SolveColumn(int col, gVector<double> &out)
{
  //** can we use tmpcol here, instead of allocating new vector?
  gVector<double> tmpcol2(MinRow(),MaxRow());
  basis.GetColumn(col,tmpcol2);
  Solve(tmpcol2,out);
}

//
// raw Tableau functions
//

void Tableau<double>::Refactor()
{
  B.refactor();
  //** is re-solve necessary here?
  Solve(*b, solution);
}

void Tableau<double>::SetRefactor(int n)
{
  B.SetRefactor(n);
}

void Tableau<double>::SetConst(const gVector<double> &bnew)
{
  assert(bnew.First()==b->First() && bnew.Last()==b->Last());
  b=&bnew;
  Solve(*b, solution);
}

//** this function is not currently used.  Drop it?
void Tableau<double>::SetBasis(const Basis<double> &in)
{
  basis= in;
  B.refactor();
  Solve(*b, solution);
}

void Tableau<double>::Solve(const gVector<double> &b, gVector<double> &x)
{
  B.solve(b,x);
}

void Tableau<double>::SolveT(const gVector<double> &c, gVector<double> &y)
{
  B.solveT(c,y);
  //** gout << "\nTableau<double>::SolveT(), y: " << y;
  //   gout << "\nc: " << c;
}

bool Tableau<double>::IsFeasible()
{
  //** is it really necessary to solve first here?
  Solve(*b, solution);
  for(int i=solution.First();i<=solution.Last();i++)
    if(solution[i]>=eps2) return false;
  return true;
}

bool Tableau<double>::IsLexMin()
{
  int i,j;
  for(i=MinRow();i<=MaxRow();i++)
    if(EqZero(solution[i]))
      for(j=-MaxRow();j<Label(i);j++) if(j!=0){
	SolveColumn(j,tmpcol);
	if(LtZero(tmpcol[i]))
	  return 0;
      }
  return 1;
}

gOutput &operator<<(gOutput &to, const Tableau<double> &v)
{
  v.Dump(to); return to;
}

