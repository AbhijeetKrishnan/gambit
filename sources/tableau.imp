//#
//# FILE: tableau.imp: implementation of tableau and basis classes
//#
//# $Id$
//#

#include "tableau.h"


// Basis method definitions

template <class T>
Basis<T>::Basis(Tableau<T> &tab, const BasisCode<T> &code)
: tableau(&tab),
  columns(code),
  B(tab.A.MinRow(), tab.A.MaxRow()),
  basis(tab.A.MinRow(),tab.A.MaxRow()),
  dual(tab.A.MinRow(),tab.A.MaxRow()),
  unitcost(tab.A.MinRow(),tab.A.MaxRow()),
  cost(tab.A.MinCol(),tab.A.MaxCol()),
  costdefined(0)
// , tmpcol(tab.A.MinRow(),tab.A.MaxRow())
{
  B.refactor(tab.A, code.unitflag, code.column);
  B.solve(tab.b, basis);
};

template <class T>
Basis<T>::Basis(Tableau<T> &tab, const gVector<T> &c, const BasisCode<T> &code)
: tableau(&tab),
  columns(code),
  B(tab.A.MinRow(), tab.A.MaxRow()),
  basis(tab.A.MinRow(),tab.A.MaxRow()),
  unitcost(tab.A.MinRow(),tab.A.MaxRow()),
  cost(c),
  dual(tab.A.MinRow(),tab.A.MaxRow()),
  costdefined(1)
// , tmpcol(tab.A.MinRow(),tab.A.MaxRow())
{
  assert( c.First()==tab.A.MinCol() && c.Last()==tab.A.MaxCol() );

  B.refactor(tab.A, code.unitflag, code.column);
  B.solve(tab.b, basis);

  unitcost= (T)0;
  SolveDual();
}

template <class T>
Basis<T>::Basis(Tableau<T> &tab,
		const gVector<T> &uc,
		const gVector<T> &c,
		const BasisCode<T> &code)
: tableau(&tab),
  columns(code),
  B(tab.A.MinRow(), tab.A.MaxRow()),
  basis(tab.A.MinRow(),tab.A.MaxRow()),
  unitcost(uc),
  cost(c),
  dual(tab.A.MinRow(),tab.A.MaxRow()),
  costdefined(1)
// , tmpcol(tab.A.MinRow(),tab.A.MaxRow())
{
  assert( uc.First()==MinRow() && uc.Last()==MaxRow() );
  assert( c.First()==MinCol() && c.Last()==MaxCol() );

  B.refactor(tab.A, code.unitflag, code.column);
  B.solve(tab.b, basis);

  SolveDual();
}


template <class T>
Basis<T>::Basis(Basis<T> &orig)
: tableau(orig.tableau),
  columns(orig.columns),
  B(orig.B),
  basis(orig.basis),
  unitcost(orig.unitcost),
  cost(orig.cost),
  dual(orig.dual),
  costdefined(orig.costdefined)
// , tmpcol(orig.tmpcol)
{
}

template <class T>
Basis<T>& Basis<T>::operator=(Basis<T> &orig)
{
  assert( tableau==orig.tableau );
  columns= orig.columns;
  B= orig.B;
  basis= orig.basis;
  unitcost= orig.unitcost;
  cost= orig.cost;
  dual= orig.dual;
  costdefined= orig.costdefined;
}

template <class T>
Basis<T>::~Basis()
{
}


// checking functions

template <class T>
bool Basis<T>::NegOK() const
{ return tableau->A.MinCol()>0 && tableau->A.MinRow()>0; }

template <class T>
int Basis<T>::MinRow() const
{ return tableau->A.MinRow(); }

template <class T>
int Basis<T>::MaxRow() const
{ return tableau->A.MaxRow(); }

template <class T>
bool Basis<T>::ColIndex(int x) const
{ return MinRow()<=x && x<=MaxRow(); }

template <class T>
int Basis<T>::MinCol() const 
{ return tableau->A.MinCol(); }

template <class T>
int Basis<T>::MaxCol() const
{ return tableau->A.MaxCol(); }

template <class T>
bool Basis<T>::RowIndex(int x) const
{ return MinCol()<=x && x<=MaxCol(); }


// cost-based functions

template <class T>
void Basis<T>::SetCost(const gVector<T>& c)
{
  unitcost= (T)0;
  cost= c;
  costdefined= 1;
  
  SolveDual();
}

template <class T>
void Basis<T>::SetCost(const gVector<T> &uc, const gVector<T> &c)
{
  unitcost= uc;
  cost= c;
  costdefined= 1;
  
  SolveDual();
}


template <class T>
void Basis<T>::GetCost(gVector<T> &uc, gVector<T> &c)
{
  assert(costdefined);
  uc= unitcost;
  c=cost;
}

template <class T>
void Basis<T>::ClearCost()
{
  costdefined= 0;
}

template <class T>
T Basis<T>::TotalCost() const
{
  assert(costdefined);
  gVector<T> tmpcol(MinRow(),MaxRow());
  columns.BasisSelect(unitcost,cost,tmpcol);
  return tmpcol*basis;
}

template <class T>
void Basis<T>::DualVector(gVector<T> &L)
{
  assert(costdefined);
  L= dual;
}

template <class T>
T Basis<T>::RelativeCost(int col) const
{
  assert(costdefined);
  assert(NegOK());

  if( col<0 )
    {
      return cost[-col] - dual[-col];
    }
  else
    {
      gVector<T> tmpcol(MinRow(),MaxRow());
      tableau->A.GetColumn(col, tmpcol);
      return cost[col] - dual*tmpcol;
    }
}

template <class T>
T Basis<T>::RelativeCost(bool uflag, int col) const
{
  assert(costdefined);

  if( uflag )
    {
      return cost[col] - dual[col];
    }
  else
    {
      gVector<T> tmpcol(MinRow(),MaxRow());
      tableau->A.GetColumn(col, tmpcol);
      return cost[col] - dual*tmpcol;
    }
}

template <class T>
void Basis<T>::RelativeCostVector(gVector<T> &relunitcost,
				  gVector<T> &relcost) const
{
  assert(costdefined);
  assert(tableau->A.CheckColumn(relunitcost));
  assert(tableau->A.CheckRow(relcost));

  relunitcost= unitcost - dual;
  relcost= cost - dual*tableau->A;
}

template <class T>
void Basis<T>::SolveDual()
{
  assert(costdefined);
  gVector<T> tmpcol(MinRow(),MaxRow());
  columns.BasisSelect(unitcost,cost,tmpcol);
  B.solveT(tmpcol,dual);
}

// non-cost-based functions

template <class T>
void Basis<T>::BasisVector(gVector<T> &out) const
{
  out= basis;
}

template <class T>
void Basis<T>::SolveColumn(int col, gVector<T> &out) const
{
  assert( NegOK() );

  gVector<T> tmpcol(MinRow(),MaxRow());
  if( col<0 )
    {
      tmpcol= (T)0;
      tmpcol[-col]=1;
    }
  else
    tableau->A.GetColumn(col,tmpcol);
  B.solve(tmpcol,out);
}

template <class T>
void Basis<T>::SolveColumn(bool flag, int col, gVector<T> &out) const
{
  gVector<T> tmpcol(MinRow(),MaxRow());

  if( flag )
    {
      tmpcol= (T)0;
      tmpcol[col]=1;
    }
  else
    tableau->A.GetColumn(col,tmpcol);
  B.solve(tmpcol,out);
}

template <class T>
void SetBasis(const BasisCode<T> &in)
{
  columns= in;
  B.refactor(template->A, code.columns);
  B.solve(template->b, basis);
  if( costdefined )
    SolveDual();
}

template <class T>
void Basis<T>::GetBasis(BasisCode<T> &out) const
{
  out= columns;
}

template <class T>
void Basis<T>::Pivot(int outgoing, int incoming)
{
  assert( NegOK() );

  if( incoming<0 )
    Pivot(outgoing, 1, -incoming);
  else
    Pivot(outgoing, 0, incoming);
}

template <class T>
void Basis<T>::Pivot(int outgoing, bool inflag,int incoming)
{
  assert( RowIndex(outgoing) );
  assert( inflag ? RowIndex(incoming) : ColIndex(incoming) );

  gVector<T> tmpcol(MinRow(),MaxRow());

  for(int i=outgoing; i<MaxRow(); i++)
    columns.swap(i,i+1);
  columns.change(MaxRow(), inflag,incoming);

  if( inflag )
    { tmpcol=(T)0; tmpcol[incoming]=(T)1; }
  else
    tableau->A.GetColumn(incoming, tmpcol);
  B.update(outgoing, tmpcol);

  B.solve(tableau->b, basis);
  if( costdefined )
    SolveDual();
}


// raw basis functions

template <class T>
void Basis<T>::Solve(const gVector<T> &in, gVector<T> &out) const
{
  B.solve(in,out);
}

template <class T>
void Basis<T>::SolveT(const gVector<T> &in, gVector<T> &out) const
{
  B.solveT(in,out);
}

template <class T>
void Basis<T>::Multiply(const gVector<T> &in, gVector<T>&out) const
{
  gVector<T> tmprow(MinCol(),MaxCol());
  gVector<T> tmpcol(MinRow(),MaxRow());

  for(int i=MinRow(); i<=MaxRow(); i++)
    {
      tableau->A.GetRow(i,tmprow);
      columns.BasisSelect(tmprow,tmpcol);
      out[i]=  tmpcol*in;
      for(int j=MinRow(); j<=MaxRow(); j++)
	if( columns.unitflag[j] && columns.column[j]==i )
	  out[i]+= in[j];
    }
}

template <class T>
void Basis<T>::MultiplyT(const gVector<T> &in, gVector<T> &out) const
{
  gVector<T> tmpcol(MinRow(),MaxRow());
  for(int i=out.First(); i<=out.Last(); i++)
    {
      if( columns.unitflag[i] )
	{ tmpcol= (T)0; tmpcol[columns.column[i]]=0; }
      else
	{ tableau->A.GetColumn(columns.column[i],tmpcol); }
      out[i]= in*tmpcol;
    }
}




// BasisCode method definitions

template <class T>
BasisCode<T>::BasisCode(const Tableau<T> &tab)
: unitflag(tab.A.MinRow(),tab.A.MaxRow()),
  column(tab.A.MinRow(),tab.A.MaxRow())
{
  tableau= &tab;

  unitflag=1;
  for(int i=column.First(); i<=column.Last(); i++)
    column[i]= i;
}

template <class T>
BasisCode<T>::BasisCode(const Tableau<T> &tab, const gTuple<int> &v)
: unitflag(tab.A.MinRow(),tab.A.MaxRow()),
  column(tab.A.MinRow(),tab.A.MaxRow()),
  tableau(&tab)
{
  assert( NegOK() );
  assert( v.First()==column.First() && v.Last()==column.Last() );

  for(int i=v.First(); i<=v.Last(); i++)
    {
      if( v[i]<0 )
	{
	  assert( tab.A.CheckRow(-v[i]) );
	  unitflag[i]=1;
	  column[i]= -v[i];
	}
      else
	{
	  assert( tab.A.CheckColumn(v[i]) );
	  unitflag[i]=0;
	  column[i]= v[i];
	}
    }
}

template <class T>
BasisCode<T>::BasisCode(const Tableau<T> &tab,
		     const gTuple<bool> &flag,
		     const gTuple<int> &v)
: unitflag(tab.A.MinRow(),tab.A.MaxRow()),
  column(tab.A.MinRow(),tab.A.MaxRow())
{
  unitflag= flag;
  column= v;

  tableau= &tab;

  for(int i=v.First(); i<=v.Last(); i++)
    {
      if( flag[i] )
	assert( tab.A.CheckRow(v[i]) );
      else
	assert( tab.A.CheckColumn(v[i]) );
    }
}

template <class T>
BasisCode<T>::BasisCode(const BasisCode<T> &code)
: unitflag(code.unitflag),
  column(code.column),
  tableau(code.tableau)
{
}


template <class T>
void BasisCode<T>::NewBasis()
{
  unitflag=1;
  for(int i=column.First(); i<=column.Last(); i++)
    column[i]= i;
}

template <class T>
void BasisCode<T>::NewBasis(const gTuple<int> &v)
{
  assert( NegOK() );
  assert( v.First()==column.First() && v.First()==column.First() );

  for(int i=v.First(); i<=v.Last(); i++)
    {
      if( v[i]<0 )
	{
	  assert( tableau->A.CheckRow(-v[i]) );
	  unitflag[i]=1;
	  column[i]= -v[i];
	}
      else
	{
	  assert( tableau->A.CheckColumn(v[i]) );
	  unitflag[i]=0;
	  column[i]= v[i];
	}
    }
}

template <class T>
void BasisCode<T>::NewBasis(const gTuple<bool> &flag, const gTuple<int> &v)
{

  unitflag= flag;
  column= v;

  for(int i=v.First(); i<=v.Last(); i++)
    {
      if( flag[i] )
	assert( tableau->A.CheckRow(v[i]) );
      else
	assert( tableau->A.CheckColumn(v[i]) );
    }
}

template <class T>
BasisCode<T>& BasisCode<T>::operator=(const BasisCode<T> &code)
{
  assert( tableau==code.tableau );

  unitflag= code.unitflag;
  column= code.column;
}

template <class T>
BasisCode<T>::~BasisCode()
{
}


// ordinary BasisCode methods:

template <class T>
void BasisCode<T>::change(int basisnum, int col)
{
  assert( NegOK() );

  if( col<0 )
    {
      assert( tableau->A.CheckRow(col) );
      unitflag[basisnum]= 1;
      column[basisnum]= -col;
    }
  else
    {
      assert( tableau->A.CheckColumn(col) );
      unitflag[basisnum]= 0;
      column[basisnum]= col;
    }
}

template <class T>
void BasisCode<T>::change(int basisnum, bool flag, int col)
{
  if( flag )
    assert( tableau->A.CheckRow(col) );
  else
    assert( tableau->A.CheckColumn(col) );
  unitflag[basisnum]= flag;
  column[basisnum]= col;
}

template <class T>
void BasisCode<T>::swap(int a, int b)
{
  bool tb= unitflag[a];
  unitflag[a]=unitflag[b];
  unitflag[b]= tb;

  int tc= column[a];
  column[a]=column[b];
  column[b]= tc;
}

template <class T>
bool BasisCode<T>::member(int col) const
{
  assert( NegOK() );

  if(col<0)
    {
      for(int i=column.First(); i<=column.Last(); i++)
	if( unitflag[i]==1 && column[i]==-col )
	  return 1;
    }
  else
    {
      for(int i=column.First(); i<=column.Last(); i++)
	if( unitflag[i]==0 && column[i]==col )
	  return 1;
    }
  return 0;
}

template <class T>
bool BasisCode<T>::member(bool flag, int col) const
{
  if(flag)
    {
      for(int i=column.First(); i<=column.Last(); i++)
	if( unitflag[i]==1 && column[i]==col )
	  return 1;
    }
  else
    {
      for(int i=column.First(); i<=column.Last(); i++)
	if( unitflag[i]==0 && column[i]==col )
	  return 1;
    }
  return 0;
}

template <class T>
int BasisCode<T>::find(int col) const
{
  assert( NegOK() );

  if(col<0)
    {
      for(int i=column.First(); i<=column.Last(); i++)
	if( unitflag[i]==1 && column[i]==-col )
	  return i; // returns basis index
    }
  else
    {
      for(int i=column.First(); i<=column.Last(); i++)
	if( unitflag[i]==0 && column[i]==col )
	  return i; // returns basis index
    }
  assert(0); // couldn't find column (also, assumes there are no duplicates)
}

template <class T>
int BasisCode<T>::find(bool flag, int col)
{
  if(flag)
    {
      for(int i=column.First(); i<=column.Last(); i++)
	if( unitflag[i]==1 && column[i]==col )
	  return i;
    }
  else
    {
      for(int i=column.First(); i<=column.Last(); i++)
	if( unitflag[i]==0 && column[i]==col )
	  return i;
    }
  assert(0);
}

template <class T>
void BasisCode<T>::FindColumn(int basisnum, int &index) const
{
  assert(NegOK());

  if( unitflag[basisnum] )
    index= -column[basisnum];
  else
    index= column[basisnum];
}

template <class T>
void BasisCode<T>::FindColumn(int basisnum, bool &flag, int &col) const
{
  flag= unitflag[basisnum];
  col= column[basisnum];
}

template <class T>
void BasisCode<T>::BasisSelect(const gVector<T> &rowv, gVector<T> &colv) const
{
  assert(tableau->A.CheckColumn(colv) && tableau->A.CheckRow(rowv));

  for(int i=column.First(); i<=column.Last(); i++)
    {
      if(unitflag[i])
	colv[i]= 0;
      else
	colv[i]= rowv[column[i]];
    }
}

template <class T>
void BasisCode<T>::BasisSelect(const gVector<T> &unitv,
			    const gVector<T> &rowv,
			    gVector<T> &colv ) const
{
  assert(tableau->A.CheckColumn(colv)
      && tableau->A.CheckColumn(unitv)
      && tableau->A.CheckRow(rowv) );

  for(int i=column.First(); i<=column.Last(); i++)
    {
      if(unitflag[i])
	colv[i]= unitv[column[i]];
      else
	colv[i]= rowv[column[i]];
    }
}


  
