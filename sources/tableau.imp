//#
//# FILE: tableau.imp: implementation of tableau and basis classes
//#
//# $Id$
//#

#include "tableau.h"

// Tableau definitions

template <class T>Tableau<T>::Tableau(void)
  : A() , b()
{ }

template <class T>Tableau<T>::Tableau(int n1, int n2)
  : A(1,n1,1,n2), b(1,n1)
{ }

template <class T>Tableau<T>
::Tableau(const gMatrix<T>& A, const gVector<T>& b) 
  : A(A) , b(b)
{ }

template <class T>Tableau<T>::~Tableau(void)
{ }

// Basis method definitions

template <class T>
Basis<T>::Basis(const Tableau<T> &tab)
: tableau(&tab),
  columns(tab),
  B(tab.A.MinRow(), tab.A.MaxRow()),
  basis(tab.A.MinRow(),tab.A.MaxRow()),
  dual(tab.A.MinRow(),tab.A.MaxRow()),
  unitcost(tab.A.MinRow(),tab.A.MaxRow()),
  cost(tab.A.MinCol(),tab.A.MaxCol()),
  costdefined(0)
{
  B.refactor(tab.A, columns.unitflag, columns.column);
  B.solve(tab.b, basis);
};

template <class T>
Basis<T>::Basis(const Tableau<T> &tab, const BasisCode<T> &code)
: tableau(&tab),
  columns(code),
  B(tab.A.MinRow(), tab.A.MaxRow()),
  basis(tab.A.MinRow(),tab.A.MaxRow()),
  dual(tab.A.MinRow(),tab.A.MaxRow()),
  unitcost(tab.A.MinRow(),tab.A.MaxRow()),
  cost(tab.A.MinCol(),tab.A.MaxCol()),
  costdefined(0)
// , tmpcol(tab.A.MinRow(),tab.A.MaxRow())
{
  B.refactor(tab.A, code.unitflag, code.column);
  B.solve(tab.b, basis);
};

template <class T>
Basis<T>::Basis(const Tableau<T> &tab, const gVector<T> &c, const BasisCode<T> &code)
: tableau(&tab),
  columns(code),
  B(tab.A.MinRow(), tab.A.MaxRow()),
  basis(tab.A.MinRow(),tab.A.MaxRow()),
  unitcost(tab.A.MinRow(),tab.A.MaxRow()),
  cost(c),
  dual(tab.A.MinRow(),tab.A.MaxRow()),
  costdefined(1)
// , tmpcol(tab.A.MinRow(),tab.A.MaxRow())
{
  assert( c.First()==tab.A.MinCol() && c.Last()==tab.A.MaxCol() );

  B.refactor(tab.A, code.unitflag, code.column);
  B.solve(tab.b, basis);

  unitcost= (T)0;
  SolveDual();
}

template <class T>
Basis<T>::Basis(const Tableau<T> &tab,
		const gVector<T> &uc,
		const gVector<T> &c,
		const BasisCode<T> &code)
: tableau(&tab),
  columns(code),
  B(tab.A.MinRow(), tab.A.MaxRow()),
  basis(tab.A.MinRow(),tab.A.MaxRow()),
  unitcost(uc),
  cost(c),
  dual(tab.A.MinRow(),tab.A.MaxRow()),
  costdefined(1)
// , tmpcol(tab.A.MinRow(),tab.A.MaxRow())
{
  assert( uc.First()==MinRow() && uc.Last()==MaxRow() );
  assert( c.First()==MinCol() && c.Last()==MaxCol() );

  B.refactor(tab.A, code.unitflag, code.column);
  B.solve(tab.b, basis);

  SolveDual();
}


template <class T>
Basis<T>::Basis(const Basis<T> &orig)
: tableau(orig.tableau),
  columns(orig.columns),
  B(orig.B),
  basis(orig.basis),
  unitcost(orig.unitcost),
  cost(orig.cost),
  dual(orig.dual),
  costdefined(orig.costdefined)
// , tmpcol(orig.tmpcol)
{
}

template <class T>
Basis<T>& Basis<T>::operator=(const Basis<T> &orig)
{
  assert( tableau==orig.tableau );
  columns= orig.columns;
  B= orig.B;
  basis= orig.basis;
  unitcost= orig.unitcost;
  cost= orig.cost;
  dual= orig.dual;
  costdefined= orig.costdefined;
}

template <class T>
virtual Basis<T>::~Basis()
{
}


// checking functions

template <class T>
bool Basis<T>::NegOK() const
{ return tableau->A.MinCol()>0 && tableau->A.MinRow()>0; }

template <class T>
int Basis<T>::MinRow() const
{ return tableau->A.MinRow(); }

template <class T>
int Basis<T>::MaxRow() const
{ return tableau->A.MaxRow(); }

template <class T>
bool Basis<T>::ColIndex(int x) const
{ return MinRow()<=x && x<=MaxRow(); }

template <class T>
int Basis<T>::MinCol() const 
{ return tableau->A.MinCol(); }

template <class T>
int Basis<T>::MaxCol() const
{ return tableau->A.MaxCol(); }

template <class T>
bool Basis<T>::RowIndex(int x) const
{ return MinCol()<=x && x<=MaxCol(); }


// cost-based functions

template <class T>
void Basis<T>::SetCost(const gVector<T>& c)
{
  unitcost= (T)0;
  cost= c;
  costdefined= 1;
  
  SolveDual();
}

template <class T>
void Basis<T>::SetCost(const gVector<T> &uc, const gVector<T> &c)
{
  unitcost= uc;
  cost= c;
  costdefined= 1;
  
  SolveDual();
}


template <class T>
void Basis<T>::GetCost(gVector<T> &uc, gVector<T> &c)
{
  assert(costdefined);
  uc= unitcost;
  c=cost;
}

template <class T>
void Basis<T>::ClearCost()
{
  costdefined= 0;
}

template <class T>
T Basis<T>::TotalCost() const
{
  assert(costdefined);
  gVector<T> tmpcol(MinRow(),MaxRow());
  columns.BasisSelect(unitcost,cost,tmpcol);
  return tmpcol*basis;
}

template <class T>
void Basis<T>::DualVector(gVector<T> &L)
{
  assert(costdefined);
  L= dual;
}

template <class T>
T Basis<T>::RelativeCost(int col) const
{
  assert(costdefined);
  assert(NegOK());

  if( col<0 )
    {
      return cost[-col] - dual[-col];
    }
  else
    {
      gVector<T> tmpcol(MinRow(),MaxRow());
      tableau->A.GetColumn(col, tmpcol);
      return cost[col] - dual*tmpcol;
    }
}

template <class T>
T Basis<T>::RelativeCost(bool uflag, int col) const
{
  assert(costdefined);

  if( uflag )
    {
      return cost[col] - dual[col];
    }
  else
    {
      gVector<T> tmpcol(MinRow(),MaxRow());
      tableau->A.GetColumn(col, tmpcol);
      return cost[col] - dual*tmpcol;
    }
}

template <class T>
void Basis<T>::RelativeCostVector(gVector<T> &relunitcost,
				  gVector<T> &relcost) const
{
  assert(costdefined);
  assert(tableau->A.CheckColumn(relunitcost));
  assert(tableau->A.CheckRow(relcost));

  relunitcost= unitcost - dual;
  relcost= cost - dual*tableau->A;
}

template <class T>
void Basis<T>::SolveDual()
{
  assert(costdefined);
  gVector<T> tmpcol(MinRow(),MaxRow());
  columns.BasisSelect(unitcost,cost,tmpcol);
  B.solveT(tmpcol,dual);
}

// non-cost-based functions

template <class T>
void Basis<T>::BasisVector(gVector<T> &out) const
{
  out= basis;
}

template <class T>
void Basis<T>::SolveColumn(int col, gVector<T> &out) const
{
  assert( NegOK() );

  gVector<T> tmpcol(MinRow(),MaxRow());
  if( col<0 )
    {
      tmpcol= (T)0;
      tmpcol[-col]=1;
    }
  else
    tableau->A.GetColumn(col,tmpcol);
  B.solve(tmpcol,out);
}

template <class T>
void Basis<T>::SolveColumn(bool flag, int col, gVector<T> &out) const
{
  gVector<T> tmpcol(MinRow(),MaxRow());

  if( flag )
    {
      tmpcol= (T)0;
      tmpcol[col]=1;
    }
  else
    tableau->A.GetColumn(col,tmpcol);
  B.solve(tmpcol,out);
}
/*
template <class T>
void Basis<T>::SetBasis(const BasisCode<T> &in)
{
  columns= in;
  B.refactor(template->A, code.columns);
  B.solve(template->b, basis);
  if( costdefined )
    SolveDual();
}
*/
template <class T>
void Basis<T>::GetBasis(BasisCode<T> &out) const
{
  out= columns;
}

template <class T>
int Basis<T>::CanPivot(int outlabel, int inlabel)
{
  gVector<T> tmpcol(MinRow(),MaxRow());
  SolveColumn(inlabel,tmpcol);
  if(tmpcol[columns.find(outlabel)] == (T)0) return 0;
  return 1;  
}

template <class T>
void Basis<T>::CompPivot(int outlabel, int inlabel)
{
    Pivot(columns.find(outlabel),inlabel);
    Pivot(columns.find(-inlabel),-outlabel);
}

template <class T>
void Basis<T>::Pivot(int outrow, int inlabel)
{
  assert( NegOK() );

  if( inlabel<0 )
    Pivot(outrow, 1, -inlabel);
  else
    Pivot(outrow, 0, inlabel);
}

template <class T>
void Basis<T>::Pivot(int outrow, bool inflag,int inlabel)
{
  assert( RowIndex(outrow) );
  assert( inflag ? RowIndex(inlabel) : ColIndex(inlabel) );

  gVector<T> tmpcol(MinRow(),MaxRow());

  for(int i=outrow; i<MaxRow(); i++)
    columns.swap(i,i+1);
  columns.change(MaxRow(), inflag,inlabel);

  if( inflag )
    { tmpcol=(T)0; tmpcol[inlabel]=(T)1; }
  else
    tableau->A.GetColumn(inlabel, tmpcol);
  B.update(outrow, tmpcol);

  B.solve(tableau->b, basis);
  if( costdefined )
    SolveDual();
}


// raw basis functions

template <class T>
void Basis<T>::Solve(const gVector<T> &in, gVector<T> &out) const
{
  B.solve(in,out);
}

template <class T>
void Basis<T>::SolveT(const gVector<T> &in, gVector<T> &out) const
{
  B.solveT(in,out);
}

template <class T>
void Basis<T>::Multiply(const gVector<T> &in, gVector<T>&out) const
{
  gVector<T> tmprow(MinCol(),MaxCol());
  gVector<T> tmpcol(MinRow(),MaxRow());

  for(int i=MinRow(); i<=MaxRow(); i++)
    {
      tableau->A.GetRow(i,tmprow);
      columns.BasisSelect(tmprow,tmpcol);
      out[i]=  tmpcol*in;
      for(int j=MinRow(); j<=MaxRow(); j++)
	if( columns.unitflag[j] && columns.column[j]==i )
	  out[i]+= in[j];
    }
}

template <class T>
void Basis<T>::MultiplyT(const gVector<T> &in, gVector<T> &out) const
{
  gVector<T> tmpcol(MinRow(),MaxRow());
  for(int i=out.First(); i<=out.Last(); i++)
    {
      if( columns.unitflag[i] )
	{ tmpcol= (T)0; tmpcol[columns.column[i]]=0; }
      else
	{ tableau->A.GetColumn(columns.column[i],tmpcol); }
      out[i]= in*tmpcol;
    }
}

template <class T>
bool Basis<T>::IsNash() const
{ for(int i=basis.First();i<=basis.Last();i++)
    if(basis[i]>(T) 0) return 0;
  return 1;
}

template <class T>
BFS<T> Basis<T>::GetBFS() const
{ 
  BFS<T> cbfs((T) 0);
  for(int i=columns.column.First();i<=columns.column.Last();i++) {
    if(Member(i)) 
      cbfs.Define(i,basis[columns.find(i)]);
  }
  return cbfs;
}

template <class T> gOutput &operator<<(gOutput &to, const Basis<T> &v)
{
  v.Dump(to); return to;
}

template <class T>
void Basis<T>::Dump(gOutput &to) const
{ columns.Dump(to);basis.Dump(to); }

template <class T>
bool Basis<T>::Member(int i) const
{ return columns.member(i);}

template <class T>
bool Basis<T>::Member(int i,bool flag) const
{ return columns.member(i,flag);}

template <class T>
int Basis<T>::Label(int i) const
{ return columns.Label(i);}




// BasisCode method definitions

template <class T>
BasisCode<T>::BasisCode(const Tableau<T> &tab)
: unitflag(tab.A.MinRow(),tab.A.MaxRow()),
  column(tab.A.MinRow(),tab.A.MaxRow())
{
  tableau= &tab;

//  unitflag=1;
  for(int i=column.First(); i<=column.Last(); i++)
    column[i]= i;
  for(i=unitflag.First(); i<=unitflag.Last(); i++)
    unitflag[i]= 1;
}

template <class T>
BasisCode<T>::BasisCode(const Tableau<T> &tab, const gBlock<int> &v)
: unitflag(tab.A.MinRow(),tab.A.MaxRow()),
  column(tab.A.MinRow(),tab.A.MaxRow()),
  tableau(&tab)
{
  assert( NegOK() );
  assert( v.First()==column.First() && v.Last()==column.Last() );

  for(int i=v.First(); i<=v.Last(); i++)
    {
      if( v[i]<0 )
	{
	  assert( tab.A.CheckRow(-v[i]) );
	  unitflag[i]=1;
	  column[i]= -v[i];
	}
      else
	{
	  assert( tab.A.CheckColumn(v[i]) );
	  unitflag[i]=0;
	  column[i]= v[i];
	}
    }
}

template <class T>
BasisCode<T>::BasisCode(const Tableau<T> &tab,
		     const gBlock<bool> &flag,
		     const gBlock<int> &v)
: unitflag(tab.A.MinRow(),tab.A.MaxRow()),
  column(tab.A.MinRow(),tab.A.MaxRow())
{
  unitflag= flag;
  column= v;

  tableau= &tab;

  for(int i=v.First(); i<=v.Last(); i++)
    {
      if( flag[i] )
	assert( tab.A.CheckRow(v[i]) );
      else
	assert( tab.A.CheckColumn(v[i]) );
    }
}

template <class T>
BasisCode<T>::BasisCode(const BasisCode<T> &code)
: unitflag(code.unitflag),
  column(code.column),
  tableau(code.tableau)
{
}


template <class T>
void BasisCode<T>::NewBasis()
{
//  unitflag=1;
  for(int i=column.First(); i<=column.Last(); i++)
    column[i]= i;
  for(i=unitflag.First(); i<=unitflag.Last(); i++)
    unitflag[i]= 1;

}

template <class T>
void BasisCode<T>::NewBasis(const gBlock<int> &v)
{
  assert( NegOK() );
  assert( v.First()==column.First() && v.First()==column.First() );

  for(int i=v.First(); i<=v.Last(); i++)
    {
      if( v[i]<0 )
	{
	  assert( tableau->A.CheckRow(-v[i]) );
	  unitflag[i]=1;
	  column[i]= -v[i];
	}
      else
	{
	  assert( tableau->A.CheckColumn(v[i]) );
	  unitflag[i]=0;
	  column[i]= v[i];
	}
    }
}

template <class T>
void BasisCode<T>::NewBasis(const gBlock<bool> &flag, const gBlock<int> &v)
{

  unitflag= flag;
  column= v;

  for(int i=v.First(); i<=v.Last(); i++)
    {
      if( flag[i] )
	assert( tableau->A.CheckRow(v[i]) );
      else
	assert( tableau->A.CheckColumn(v[i]) );
    }
}

template <class T>
BasisCode<T>& BasisCode<T>::operator=(const BasisCode<T> &code)
{
  assert( tableau==code.tableau );

  unitflag= code.unitflag;
  column= code.column;
}

template <class T>
BasisCode<T>::~BasisCode()
{
}


// ordinary BasisCode methods:

template <class T>
void BasisCode<T>::change(int basisnum, int col)
{
  assert( NegOK() );

  if( col<0 )
    {
      assert( tableau->A.CheckRow(col) );
      unitflag[basisnum]= 1;
      column[basisnum]= -col;
    }
  else
    {
      assert( tableau->A.CheckColumn(col) );
      unitflag[basisnum]= 0;
      column[basisnum]= col;
    }
}

template <class T>
void BasisCode<T>::change(int basisnum, bool flag, int col)
{
  if( flag )
    assert( tableau->A.CheckRow(col) );
  else
    assert( tableau->A.CheckColumn(col) );
  unitflag[basisnum]= flag;
  column[basisnum]= col;
}

template <class T>
void BasisCode<T>::swap(int a, int b)
{
  bool tb= unitflag[a];
  unitflag[a]=unitflag[b];
  unitflag[b]= tb;

  int tc= column[a];
  column[a]=column[b];
  column[b]= tc;
}

template <class T>
bool BasisCode<T>::member(int col) const
{
  assert( NegOK() );

  if(col<0)
    {
      for(int i=column.First(); i<=column.Last(); i++)
	if( unitflag[i]==1 && column[i]==-col )
	  return 1;
    }
  else
    {
      for(int i=column.First(); i<=column.Last(); i++)
	if( unitflag[i]==0 && column[i]==col )
	  return 1;
    }
  return 0;
}

template <class T>
bool BasisCode<T>::member(bool flag, int col) const
{
  if(flag)
    {
      for(int i=column.First(); i<=column.Last(); i++)
	if( unitflag[i]==1 && column[i]==col )
	  return 1;
    }
  else
    {
      for(int i=column.First(); i<=column.Last(); i++)
	if( unitflag[i]==0 && column[i]==col )
	  return 1;
    }
  return 0;
}

template <class T>
int BasisCode<T>::find(int col) const
{
  assert( NegOK() );

  if(col<0)
    {
      for(int i=column.First(); i<=column.Last(); i++)
	if( unitflag[i]==1 && column[i]==-col )
	  return i; // returns basis index
    }
  else
    {
      for(int i=column.First(); i<=column.Last(); i++)
	if( unitflag[i]==0 && column[i]==col )
	  return i; // returns basis index
    }
  assert(0); // couldn't find column (also, assumes there are no duplicates)
}

template <class T>
int BasisCode<T>::find(bool flag, int col)
{
  if(flag)
    {
      for(int i=column.First(); i<=column.Last(); i++)
	if( unitflag[i]==1 && column[i]==col )
	  return i;
    }
  else
    {
      for(int i=column.First(); i<=column.Last(); i++)
	if( unitflag[i]==0 && column[i]==col )
	  return i;
    }
  assert(0);
}

template <class T>
int BasisCode<T>::Label(int basisnum) const
{
  assert(NegOK());
  int index;

  if( unitflag[basisnum] )
    index= -column[basisnum];
  else
    index= column[basisnum];
  return index;
}

template <class T>
int BasisCode<T>::Label(int basisnum, bool &flag) const
{
  flag= unitflag[basisnum];
  int col= column[basisnum];
  return col;
}

template <class T>
void BasisCode<T>::BasisSelect(const gVector<T> &rowv, gVector<T> &colv) const
{
  assert(tableau->A.CheckColumn(colv) && tableau->A.CheckRow(rowv));

  for(int i=column.First(); i<=column.Last(); i++)
    {
      if(unitflag[i])
	colv[i]= 0;
      else
	colv[i]= rowv[column[i]];
    }
}

template <class T>
void BasisCode<T>::BasisSelect(const gVector<T> &unitv,
			    const gVector<T> &rowv,
			    gVector<T> &colv ) const
{
  assert(tableau->A.CheckColumn(colv)
      && tableau->A.CheckColumn(unitv)
      && tableau->A.CheckRow(rowv) );

  for(int i=column.First(); i<=column.Last(); i++)
    {
      if(unitflag[i])
	colv[i]= unitv[column[i]];
      else
	colv[i]= rowv[column[i]];
    }
}

template <class T>
bool BasisCode<T>::NegOK() const
{ return tableau->A.MinCol()>0 && tableau->A.MinRow()>0; }

template <class T> gOutput &operator<<(gOutput &to, const BasisCode<T> &v)
{
  v.Dump(to); return to;
}

template <class T>
void BasisCode<T>::Dump(gOutput &to) const
{ 
  to << "{";
  for(int i=column.First();i<=column.Last();i++) {
    if(unitflag[i]) 
      to << " " << -column[i];
    else 
      to << "  " << column[i];  
  }
  to << " }";
}





  
