//#
//# FILE: tableau.imp: implementation of tableau and Tableau classes
//#
//# $Id$
//#

#include "tableau.h"
#include "normal.h"
#include "normiter.h"

    // These are the values recommended by Murtagh (1981) for 15 digit 
    // accuracy in LP problems 
void Epsilon_T(double &v, int i)
{
  if(i==1)v=(double)1.0e-5;
  if(i==2)v=(double)1.0e-8;
  if(i==3)v=(double)1.0e-6;
}

void Epsilon_T(gRational &v, int) { v = (gRational)0;}

template <class T> 
Basis<T>::Basis(const gMatrix<T> &A)
  :  A(&A), label(A.MinRow(), A.MaxRow())
{
  for(int i=label.First(); i<=label.Last(); i++)
    label[i]= -i;
}


template <class T>
Basis<T>::Basis(const Basis<T> &bas)
  : A(bas.A), label(bas.label)
{ }

template <class T>
Basis<T>::~Basis()
{ }

template <class T>
Basis<T>& Basis<T>::operator=(const Basis<T> &code)
{
  if(this != &code) {
    A = code.A;
    label= code.label; }
  return *this;
}


/*
template <class T>
void Basis<T>::NewBasis(const gBlock<int> &v)
{
  assert( v.First()==label.First() && v.First()==label.First() );
  
  for(int i=v.First(); i<=v.Last(); i++) {
    if( v[i]<0 ) {
      assert( A->CheckRow(-v[i]) );
      label[i]= v[i];
    }
    else {
      assert( A->CheckColumn(v[i]) );
      label[i]= v[i];
    }
  }
}
*/

//
// ordinary Basis methods:
//

template <class T>
void Basis<T>::Change(int index, int col)
{
  if( col<0 ) {
    assert( A->CheckRow(-col) );
    label[index]= col;
  }
  else {
    assert( A->CheckColumn(col) );
    label[index]= col;
  }
}

template <class T>
void Basis<T>::Swap(int a, int b)
{
  int tc= label[a];
  label[a]=label[b];
  label[b]= tc;
}

template <class T>
bool Basis<T>::Member(int col) const
{
  for(int i=label.First(); i<=label.Last(); i++)
    if(label[i]==col )
      return 1;
  return 0;
}

template <class T>
int Basis<T>::Find(int col) const
{
  for(int i=label.First(); i<=label.Last(); i++)
    if( label[i]==col )
      return i; // returns Tableau index
  assert(0); // couldn't find column (also, assumes there are no duplicates)
  return 0;
}

template <class T>
int Basis<T>::Label(int index) const
{
  return  label[index];
}

template <class T>
void Basis<T>::BasisSelect(const gVector<T> &rowv, gVector<T> &colv) const
{
  assert(A->CheckColumn(colv) && A->CheckRow(rowv));

  for(int i=label.First(); i<=label.Last(); i++) {
    if(label[i]<0)
      colv[i]= 0;
    else
      colv[i]= rowv[label[i]];
  }
}

template <class T>
void Basis<T>::BasisSelect(const gVector<T> &unitv,
			   const gVector<T> &rowv,
			   gVector<T> &colv ) const
{
  assert(A->CheckColumn(colv)
	 && A->CheckColumn(unitv)
	 && A->CheckRow(rowv) );
  
  for(int i=label.First(); i<=label.Last(); i++) {
    if(label[i]<0)
      colv[i]= unitv[-label[i]];
    else
      colv[i]= rowv[label[i]];
  }
}

template <class T> gOutput &operator<<(gOutput &to, const Basis<T> &v)
{
  v.Dump(to); return to;
}

template <class T>
void Basis<T>::Dump(gOutput &to) const
{ 
  to << "{";
  for(int i=label.First();i<=label.Last();i++) {
    to << "  " << label[i];  
  }
  to << " }";
}

//
// Tableau method definitions
//

// Constructors and Destructor

template <class T>
Tableau<T>::Tableau(const gMatrix<T> &A, const gVector<T> &b)
  : npivots(0), tmpcol(A.MinRow(),A.MaxRow()), A(&A), b(&b), 
    basis(A),  B(A.MinRow(), A.MaxRow()),
    solution(A.MinRow(),A.MaxRow()) 
{
  Epsilon_T(eps1,1);
  Epsilon_T(eps2,2);
  B.refactor(A, basis.label);
  B.solve(b, solution);
};


template <class T> 
Tableau<T>::Tableau(const Tableau<T> &orig) 
  : npivots(0), eps1(orig.eps1), eps2(orig.eps2), tmpcol(orig.tmpcol),
    A(orig.A),b(orig.b), basis(orig.basis), B(orig.B),
    solution(orig.solution) 
{ }

template <class T> Tableau<T>::~Tableau()
{ }

template <class T>
Tableau<T>& Tableau<T>::operator=(const Tableau<T> &orig)
{
//  assert( A==orig.A );
  if(this!= &orig) {
    tmpcol = orig.tmpcol;
    A = orig.A;
    b = orig.b;
    basis= orig.basis;
    B= orig.B;
    solution= orig.solution;
    npivots = orig.npivots;
  }
  return *this;
}

//
// checking functions
//

template <class T>
bool Tableau<T>::ColIndex(int x) const
{ return MinCol()<=x && x<=MaxCol(); }

template <class T>
bool Tableau<T>::RowIndex(int x) const
{ return MinCol()<=x && x<=MaxCol(); }

template <class T>
int Tableau<T>::MinRow() const { return A->MinRow(); }

template <class T>
int Tableau<T>::MaxRow() const { return A->MaxRow(); }

template <class T>
int Tableau<T>::MinCol() const { return A->MinCol(); }

template <class T>
int Tableau<T>::MaxCol() const { return A->MaxCol(); }


template <class T>
bool Tableau<T>::Member(int i) const
{ return basis.Member(i);}

template <class T>
int Tableau<T>::Label(int i) const
{ return basis.Label(i);}

template <class T>
int Tableau<T>::Find(int i) const
{ return basis.Find(i);}


//
// pivoting operations
//

template <class T>
int Tableau<T>::CanPivot(int outlabel, int inlabel)
{
//  gVector<T> tmpcol(MinRow(),MaxRow());
  SolveColumn(inlabel,tmpcol);
  T val = tmpcol[basis.Find(outlabel)];
  if(val <=eps2 && val >= -eps2) return 0;
  return 1;  
}

template <class T>
void Tableau<T>::Pivot(int outrow,int inlabel)
{
  assert( RowIndex(outrow) );
  assert( (inlabel<0) ? RowIndex(-inlabel) : ColIndex(inlabel) );
  
//  gVector<T> tmpcol(MinRow(),MaxRow());
  
  for(int i=outrow; i<MaxRow(); i++)
    basis.Swap(i,i+1);
  basis.Change(MaxRow(), inlabel);
  
  if( inlabel<0 )
    { tmpcol=(T)0; tmpcol[-inlabel]=(T)1; }
  else
    A->GetColumn(inlabel, tmpcol);
  B.update(outrow, tmpcol);
  
  B.solve(*b, solution);
  npivots++;
}

template <class T>
void Tableau<T>::CompPivot(int outlabel, int inlabel)
{
  Pivot(basis.Find(outlabel),inlabel);
  Pivot(basis.Find(-inlabel),-outlabel);
}

template <class T> long Tableau<T>::NumPivots() const
{ return npivots; }

template <class T> long &Tableau<T>::NumPivots()
{ return npivots; }

//
// raw Tableau functions
//

template <class T> void Tableau<T>::Refactor()
{
  B.refactor(*A, basis.label);
  B.solve(*b, solution);
}

    // solve A x = b 
template <class T>
void Tableau<T>::Solve(const gVector<T> &b, gVector<T> &x) const
{
  B.solve(b,x);
}

    // solve y A = c 
template <class T>
void Tableau<T>::SolveT(const gVector<T> &c, gVector<T> &y) const
{
  B.solveT(c,y);
}

template <class T>
void Tableau<T>::Multiply(const gVector<T> &in, gVector<T>&out)
{
  gVector<T> tmprow(MinCol(),MaxCol());
//  gVector<T> tmpcol(MinRow(),MaxRow());
  
  for(int i=MinRow(); i<=MaxRow(); i++)
    {
      A->GetRow(i,tmprow);
      basis.BasisSelect(tmprow,tmpcol);
      out[i]=  tmpcol*in;
      for(int j=MinRow(); j<=MaxRow(); j++)
	if( basis.label[j]<0 && basis.label[j]==i )
	  out[i]+= in[j];
    }
}

template <class T>
void Tableau<T>::MultiplyT(const gVector<T> &in, gVector<T> &out)
{
//  gVector<T> tmpcol(MinRow(),MaxRow());
  for(int i=out.First(); i<=out.Last(); i++) {
      if( basis.label[i]<0 ) {
	tmpcol= (T)0; 
	tmpcol[-basis.label[i]]=(T)0; // ? is this right ?
      }
      else {
	A->GetColumn(basis.label[i],tmpcol); }
      out[i]= in*tmpcol;
    }
 }

template <class T>
void Tableau<T>::BasisVector(gVector<T> &out) const
{
  out= solution;
}

template <class T>
void Tableau<T>::SolveColumn(int col, gVector<T> &out)
{
  gVector<T> tmpcol2(MinRow(),MaxRow());
  if( col<0 ) {
    tmpcol2= (T)0;
    tmpcol2[-col]=1;
  }
  else
    A->GetColumn(col,tmpcol2);
  B.solve(tmpcol2,out);
}

/*
template <class T>
void Tableau<T>::SetBasis(const Basis<T> &in)
{
  basis= in;
  B.refactor(template->A, code.basis);
  B.solve(template->b, solution);
  if( costdefined )
    SolveDual();
}
*/

template <class T>
void Tableau<T>::GetBasis(Basis<T> &out) const
{
  out= basis;
}

// miscellaneous functions

template <class T>
bool Tableau<T>::IsNash() const
{ for(int i=solution.First();i<=solution.Last();i++)
    if(solution[i]>(T) 0) return 0;
  return 1;
}

template <class T>
BFS<T> Tableau<T>::GetBFS() const
{
  BFS<T> cbfs((T) 0);
  for(int i=MinCol();i<=MaxCol();i++) {
    if(Member(i)) 
      cbfs.Define(i,solution[basis.Find(i)]);
  }
  return cbfs;
}

template <class T> gOutput &operator<<(gOutput &to, const Tableau<T> &v)
{
  v.Dump(to); return to;
}

template <class T>
void Tableau<T>::Dump(gOutput &to) const
{ basis.Dump(to);to << "\n";solution.Dump(to); }


//
// LP Tableau member definitions 
// 


// template <class T> LPTableau<T>::LPTableau(void)
// : Tableau() , 
// { }


template <class T>
LPTableau<T>::LPTableau(const gMatrix<T> &A, const gVector<T> &b)
  : Tableau<T>(A,b), dual(A.MinRow(),A.MaxRow()),
    unitcost(A.MinRow(),A.MaxRow()),
    cost(A.MinCol(),A.MaxCol())
{
  B.refactor(A, basis.label);
  B.solve(b, solution);
};


template <class T>
LPTableau<T>::LPTableau(const LPTableau<T> &orig)
  : Tableau<T>(orig), dual(orig.dual),  unitcost(orig.unitcost),
    cost(orig.cost)
{ }

template <class T> LPTableau<T>::~LPTableau()
{ }

/*
template <class T>
LPTableau<T>& LPTableau<T>::operator=(const LPTableau<T> &orig)
{
//  assert( A==orig.A );
  if(this!= &orig) {
    A = orig.A;
    b = orig.b;
    basis= orig.basis;
    B= orig.B;
    solution= orig.solution;
    npivots = orig.npivots;
    unitcost= orig.unitcost;
    cost= orig.cost;
  }
  return *this;
}
*/

// cost-based functions

template <class T>
void LPTableau<T>::SetCost(const gVector<T>& c)
{
  int i;
  if(cost.Check(c)) {
    unitcost= (T)0;
    cost= c;
    return;
  }
  assert(c.First()==cost.First());
  assert(c.Last()==(cost.Last()+unitcost.Length()));
  for(i=c.First();i<=cost.Last();i++)
    cost[i]=c[i];
  for(i=unitcost.First();i<=unitcost.Last();i++)
    unitcost[i]=c[cost.Length()+i-unitcost.First()+1];

  SolveDual();
}

template <class T>
void LPTableau<T>::SetCost(const gVector<T> &uc, const gVector<T> &c)
{
  assert(unitcost.Check(uc) && cost.Check(c));
  unitcost= uc;
  cost= c;
  SolveDual();
}


template <class T>
void LPTableau<T>::GetCost(gVector<T> &uc, gVector<T> &c) const
{
  uc= unitcost;
  c=cost;
}

template <class T>
T LPTableau<T>::TotalCost()
{
//  gVector<T> tmpcol(MinRow(),MaxRow());
  basis.BasisSelect(unitcost,cost,tmpcol);
  return tmpcol*solution;
}

template <class T>
void LPTableau<T>::DualVector(gVector<T> &L) const
{
  L= dual;
}

template <class T>
T LPTableau<T>::RelativeCost(int col) const
{
  if( col<0 ) {
    return cost[-col] - dual[-col];
  }
  else {
//      gVector<T> tmpcol(MinRow(),MaxRow());
    A->GetColumn(col, (gArray<T> &)tmpcol);
    return cost[col] - dual*tmpcol;
  }
}
/*
template <class T>
void LPTableau<T>::RelativeCostVector(gVector<T> &relunitcost,
				      gVector<T> &relcost) const
{
  assert(A->CheckColumn(relunitcost));
  assert(A->CheckRow(relcost));
  
  relunitcost= unitcost - dual;
  relcost= cost - dual*A;  // pre multiplication not defined?  
}
*/

template <class T>
void LPTableau<T>::SolveDual()
{
  gVector<T> tmpcol1(MinRow(),MaxRow());
  basis.BasisSelect(unitcost,cost,tmpcol1);
  B.solveT(tmpcol1,dual);
}

    // Redefined functions
template <class T> void LPTableau<T>::Refactor()
{
  Tableau<T>::Refactor();
  SolveDual();
}

template <class T>
void LPTableau<T>::Pivot(int outrow,int inlabel)
{
  Tableau<T>::Pivot(outrow,inlabel);
  SolveDual();
}


template <class T>
BFS<T> LPTableau<T>::DualBFS() const
{
  BFS<T> cbfs((T) 0);
  for(int i=MinRow();i<=MaxRow();i++) {
    if(!Member(-i)) 
      cbfs.Define(-i,dual[i]);
  }
  return cbfs;
}


  

