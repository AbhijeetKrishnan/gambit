//#
//# FILE: tableau.imp: implementation of tableau and basis classes
//#
//# $Id$
//#

#include "tableau.h"


// Basis method definitions

template <class T>
Basis<T>::Basis(Tableau<T> &tab, const BasisCode &code)
: tableau(*tab),
  columns(code),
  B(tab.A.MinRow(), tab.A.MaxRow()),
  basis(tab.A.MinRow(),tab.A.MaxRow()),
  dual(tab.A.MinRow(),tab.A.MaxRow()),
  unitcost(tab.A.MinRow(),tab.A.MaxRow()),
  cost(tab.A.MinCol(),tab.A.MaxCol()),
  costdefined(0),
  tmpcol(tab.A.MinRow,tab.A.MaxRow())
{
  tab.AddBasis(this);
  B.refactor(tab.A, code.unitflag, code.column);
  B.solve(tab.b, basis);
};

template <class T>
Basis<T>::Basis(Tableau<T> &tab, const gVector<T> &c, const BasisCode &code)
: tableau(*tab),
  columns(code),
  B(tab.A.MinRow(), tab.A.MaxRow()),
  basis(tab.A.MinRow(),tab.A.MaxRow()),
  unitcost(tab.a.MinRow(),tab.A.MaxRow()),
  cost(c),
  dual(tab.A.MinRow(),tab.A.MaxRow()),
  costdefined(1),
  tmpcol(tab.A.MinRow,tab.A.MaxRow())
{
  assert( c.Min()==tab.A.MinCol() && c.Max()==tab.A.MaxCol() );

  tab.AddBasis(this);
  B.refactor(tab.A, code.unitflag, code.column);
  B.solve(tab.b, basis);

  unitcost= 0;
  SolveDual();
}

template <class T>
Basis<T>::Basis(Tableau<T> &tab,
		const gVector<T> &uc
		const gVector<T> &c,
		const BasisCode &code)
: tableau(*tab),
  columns(code),
  B(tab.A.MinRow(), tab.A.MaxRow()),
  basis(tab.A.MinRow(),tab.A.MaxRow()),
  unitcost(uc),
  cost(c),
  dual(tab.A.MinRow(),tab.A.MaxRow()),
  costdefined(1),
  tmpcol(tab.A.MinRow,tab.A.MaxRow())
{
  assert( uc.Min()==MinRow() && uc.Max()==MaxRow() );
  assert( c.Min()==MinCol() && c.Max()==MaxCol() );

  tab.AddBasis(this);
  B.refactor(tab.A, code.unitflag, code.column);
  B.solve(tab.b, basis);

  SolveDual();
}


template <class T>
Basis<T>::Basis(Basis<T> &orig)
: tableau(orig.tableau),
  columns(orig.columns),
  B(orig.B),
  basis(orig.basis),
  unitcost(orig.unitcost),
  cost(orig.cost),
  dual(orig.dual),
  costdefined(orig.costdefined),
  tmpcol(orig.tmpcol)
{
  tab.AddBasis(this);
}

template <class T>
Basis<T>& Basis<T>::operator=(Basis<T> &orig)
{
  assert( tableau==orig.tableau );
  columns= orig.columns;
  B= orig.B;
  basis= orig.basis;
  unitcost= orig.unitcost;
  cost= orig.cost;
  dual= orig.dual;
  costdefined= orig.costdefined;
}

template <class T>
Basis<T>::~Basis()
{
  tableau->RemoveBasis(this);
}


// checking functions

template <class T>
bool Basis<T>::NegOK()
{ return tableau->A.MinCol()>0 && tableau->A.MinRow()>0; }

template <class T>
int Basis<T>::MinRow()
{ return tableau->A.MinRow() };

template <class T>
int Basis<T>::MaxRow()
{ return tableau->A.MaxRow() };

template <class T>
bool Basis<T>::ColIndex(int x)
{ return MinRow()<=x && x<=MaxRow(); }

template <class T>
int Basis<T>::MinCol()
{ return tableau->A.MinColumn() };

template <class T>
int Basis<T>::MaxCol()
{ return tableau->A.MaxColumn() };

template <class T>
bool Basis<T>::RowIndex(int x)
{ return MinCol()<=x && x<=MaxCol(); }


// cost-based functions

template <class T>
void Basis<T>::SetCost(const gVector<T>& c)
{
  unitcost= 0;
  cost= c;
  costdefined= 1;
  
  SolveDual();
}

template <class T>
void Basis<T>::SetCost(const gVector<T> &uc, const gVector<T> &c)
{
  unitcost= uc;
  cost= c;
  costdefined= 1;
  
  SolveDual();
}


template <class T>
void Basis<T>::GetCost(gVector<T> &uc, gVector<T> &c)
{
  assert(costdefined);
  uc= unitcost;
  c=cost;
}

template <class T>
void Basis<T>::ClearCost()
{
  costdefined= 0;
}

template <class T>
T Basis<T>::TotalCost() const
{
  assert(costdefined);
  columns.BasisSelect(unitcost,cost,tmpcol);
  return tmpcol*basis;
}

template <class T>
void Basis<T>::DualVector(gVector<T> &L)
{
  assert(costdefined);
  L= dual;
}

template <class T>
T Basis<T>::RelativeCost(int col) const
{
  assert(costdefined);
  assert(NegOK());

  if( col<0 )
    {
      return cost[-col] - dual[-col];
    }
  else
    {
      tableau->A.GetColumn(col, tmpcol);
      return cost[col] - dual*tmpcol;
    }
}

template <class T>
T Basis<T>::RelativeCost(bool uflag, int col) const
{
  assert(costdefined);

  if( uflag )
    {
      return cost[col] - dual[col];
    }
  else
    {
      tableau->A.GetColumn(col, tmpcol);
      return cost[col] - dual*tmpcol;
    }
}

template <class T>
void Basis<T>::RelativeCostVector(gVector<T> &relunitcost,
				  gVector<T> &relcost) const
{
  assert(costdefined);
  assert(tableau->A.CheckColumn(relunitcost));
  assert(tableau->A.CheckRow(relcost));

  relunitcost= unitcost - dual;
  relcost= cost - dual*tableau->A;
}

template <class T>
void Basis<T>::SolveDual()
{
  assert(costdefined);
  columns.BasisSelect(unitcost,cost,tmpcol);
  B.SolveT(tmpcol,dual);
}

// non-cost-based functions

template <class T>
void Basis<T>::BasisVector(gVector<T> &out) const
{
  out= basis;
}

template <class T>
void Basis<T>::SolveColumn(int col, gVector<T> &out) const
{
  assert( NegOK() );

  if( col<0 )
    {
      tmpcol=0;
      tmpcol[-col]=1;
    }
  else
    tableau->A.GetColumn(col,tmpcol);
  B.Solve(tmpcol,out);
}

template <class T>
void Basis<T>::SolveColumn(bool flag, int col, gVector<T> &out) const
{

  if( flag )
    {
      tmpcol=0;
      tmpcol[col]=1;
    }
  else
    tableau->A.GetColumn(col,tmpcol);
  B.Solve(tmpcol,out);
}

template <class T>
void SetBasis(const BasisCode &in)
{
  columns= in;
  B.refactor(template->A, code.columns);
  B.solve(template->b, basis);
  if( costdefined )
    SolveDual();
}

template <class T>
void Basis<T>::GetBasis(BasisCode &out) const
{
  out= columns;
}

template <class T>
void Basis<T>::Pivot(int outgoing, int incoming)
{
  assert( NegOK() );

  if( incoming<0 )
    Pivot(outgoing, 1, -incoming);
  else
    Pivot(outgoing, 0, incoming);
}

template <class T>
void Basis<T>::Pivot(int outgoing, bool inflag,int incoming)
{
  assert( RowIndex(outgoing) );
  assert( inflag ? RowIndex(incoming) : ColIndex(incoming) );

  for(int i=outgoing; i<MaxRow(); i++)
    columns.swap(i,i+1);
  columns.change(MaxRow(), inflag,incoming);

  if( inflag )
    { tmpcol=(T)0; tmpcol[incoming]=(T)1; }
  else
    tableau->A.GetColumn(incoming, tmpcol);
  B.update(outgoing, tmpcol);

  B.solve(tableau->b, basis);
  if( costdefined )
    SolveDual();
}


// raw basis functions

template <class T>
void Basis<T>::Solve(const gVector<T> &in, gVector<T> &out) const
{
  B.solve(in,out);
}

template <class T>
void Basis<T>::SolveT(const gVector<T> &in, gVector<T> &out) const
{
  B.solveT(in,out);
}

template <class T>
void Basis<T>::Multiply(const gVector<T> &in, gVector<T>&out) const
{
  gVector<T> tmprow(MinCol(),MaxCol());

  for(int i=MinRow(); i<=MaxRow(); i++)
    {
      tableau->A.GetRow(i,tmprow);
      columns.BasisSelect(tmprow,tmpcol);
      out[i]=  tmpcol*in;
      for(int j=MinRow(); j<=MaxRow(); j++)
	if( columns.unitflag[j] && columns.column[j]==i )
	  out[i]+= in[j];
    }
}

template <class T>
void Basis<T>::MultiplyT(const gVector<T> &in, gVector<T> &out) const
{
  for(int i=out.Min(); i<=out.Max(); i++)
    {
      if( columns.unitflag[i] )
	{ tmpcol=0; tmpcol[columns.column[i]]=0; }
      else
	{ tableau->A.GetColumn(columns.column[i],tmpcol); }
      out[i]= in*tmpcol;
    }
}




// BasisCode method definitions

template <class T>
BasisCode::BasisCode(const Tableau<T> &tab)
: unitflag(tab.A.MinRow(),tab.A.MaxRow()),
  column(tab.A.MinRow(),tab.A.MaxRow())
{
  tableau= &tab;
  tab.AddCode(this);

  unitflag=1;
  for(int i=column.Min(); i<=column.Max(); i++)
    column[i]= i;
}

template <class T>
BasisCode::BasisCode(const Tableau<T> &tab, const gTuple<int> &v)
: unitflag(tab.A.MinRow(),tab.A.MaxRow()),
  column(tab.A.MinRow(),tab.A.MaxRow())
{
  assert( tab.NegOK() );
  assert( v.Min()==column.Min() && v.Max()==column.Max() );

  tableau= &tab;
  tab.AddCode(this);

  for(int i=v.Min(); i<=v.Max(); i++)
    {
      if( v[i]<0 )
	{
	  assert( tab.A.CheckRow(-v[i]) );
	  unitflag[i]=1;
	  column[i]= -v[i];
	}
      else
	{
	  assert( tab.A.CheckCol(v[i]) );
	  unitflag[i]=0;
	  column[i]= v[i];
	}
}

template <class T>
BasisCode::BasisCode(const Tableau<T> &tab,
		     const gTuple<bool> &flag,
		     const gTuple<int> &v)
: unitflag(tab.A.MinRow(),tab.A.MaxRow()),
  column(tab.A.MinRow(),tab.A.MaxRow())
{
  unitflag= flag;
  column= v;

  tableau= &tab;
  tab.AddCode(this);

  for(int i=v.Min(); i<=v.Max(); i++)
    {
      if( flag[i] )
	assert( tab.A.CheckRow(v[i]) );
      else
	assert( tab.A.CheckCol(v[i]) );
    }
}

template <class T>
BasisCode::BasisCode(const BasisCode<T> &code)
: unitflag(code.unitflag),
  column(code.column)
{
  tableau= &tab;
  tab.AddCode(this);
}


template <class T>
void BasisCode::NewBasis()
{
  unitflag=1;
  for(int i=column.Min(); i<=column.Max(); i++)
    column[i]= i;
}

template <class T>
void BasisCode::NewBasis(const gTuple<int> &v)
{
  assert( NegOK() );
  assert( v.Min()==column.Min() && v.Max()==column.Max() );

  for(int i=v.Min(); i<=v.Max(); i++)
    {
      if( v[i]<0 )
	{
	  assert( tableau->A.CheckRow(-v[i]) );
	  unitflag[i]=1;
	  column[i]= -v[i];
	}
      else
	{
	  assert( tableau->A.CheckCol(v[i]) );
	  unitflag[i]=0;
	  column[i]= v[i];
	}
}

template <class T>
void BasisCode::NewBasis(const gTuple<bool> &flag, const gTuple<int> &v)
{

  unitflag= flag;
  column= v;

  for(int i=v.Min(); i<=v.Max(); i++)
    {
      if( flag[i] )
	assert( tableau->A.CheckRow(v[i]) );
      else
	assert( tableau->A.CheckCol(v[i]) );
    }
}

template <class T>
BasisCode<T>& BasisCode::operator=(const BasisCode<T> &code)
{
  assert( tableau==code.tableau );

  unitflag= code.unitflag;
  column= code.column;
}

template <class T>
BasisCode::~BasisCode()
{
  tableau->A.RemoveCode();
}


// ordinary BasisCode methods:

template <class T>
void BasisCode::change(int basisnum, int col)
{
  assert( negOK() );

  if( column<0 )
    {
      assert( tableau->CheckRow(col) );
      unitflag[basisnum]= 1;
      column[basisnum]= -col;
    }
  else
    {
      assert( tableau->CheckCol(col) );
      unitflag[basisnum]= 0;
      column[basisnum]= col;
    }
}

template <class T>
void BasisCode::change(int basisnum, bool flag, int col)
{
  if( flag )
    assert( tableau->CheckRow(col) );
  else
    assert( tableau->CheckCol(col) );
  unitflag[basisnum]= flag;
  column[basisnum]= column;
}

template <class T>
void BasisCode::swap(int a, int b)
{
  bool tb= unitflag[a];
  unitflag[a]=unitflag[b];
  unitflag[b]= tb;

  int tc= column[a];
  column[a]=column[b];
  column[b]= tc;
}

template <class T>
bool BasisCode::member(int col) const;
{
  assert( NegOK() );

  if(col<0)
    {
      for(int i=column.Min(); i<=column.Max(); i++)
	if( unitflag[i]==1 && column[i]==-col )
	  return 1;
    }
  else
    {
      for(int i=column.Min(); i<=column.Max(); i++)
	if( unitflag[i]==0 && column[i]==col )
	  return 1;
    }
  return 0;
}

template <class T>
bool BasisCode::member(bool flag, int col) const;
{
  if(flag)
    {
      for(int i=column.Min(); i<=column.Max(); i++)
	if( unitflag[i]==1 && column[i]==col )
	  return 1;
    }
  else
    {
      for(int i=column.Min(); i<=column.Max(); i++)
	if( unitflag[i]==0 && column[i]==col )
	  return 1;
    }
  return 0;
}

template <class T>
int BasisCode::find(int col) const
{
  assert( NegOK() );

  if(col<0)
    {
      for(int i=column.Min(); i<=column.Max(); i++)
	if( unitflag[i]==1 && column[i]==-col )
	  return i; // returns basis index
    }
  else
    {
      for(int i=column.Min(); i<=column.Max(); i++)
	if( unitflag[i]==0 && column[i]==col )
	  return i; // returns basis index
    }
  assert(0); // couldn't find column (also, assumes there are no duplicates)
}

template <class T>
int BasisCode::find(bool flag, int col)
{
  if(flag)
    {
      for(int i=column.Min(); i<=column.Max(); i++)
	if( unitflag[i]==1 && column[i]==col )
	  return i;
    }
  else
    {
      for(int i=column.Min(); i<=column.Max(); i++)
	if( unitflag[i]==0 && column[i]==col )
	  return i;
    }
  assert(0);
}

template <class T>
void BasisCode::column(int basisnum, int &index) const;
{
  assert(NegOK());

  if( unitflag[basisnum] )
    index= -column[basisnum];
  else
    index= column[basisnum];
}

template <class T>
void BasisCode::column(int basisnum, int &flag, int &col) const
{
  flag= unitflag[basisnum];
  col= column[basisnum];
}

template <class T>
void BasisCode::BasisSelect(const gVector<T>&rowv, int gVector<T> &colv) const
{
  assert(column.Check(colv) && tableau->b.Check(rowv));

  for(int i=column.First(); i<=column.Last(); i++)
    {
      if(unitflag[i])
	colv[i]= 0;
      else
	colv[i]= rowv[column[i]];
    }
}

template <class T>
void BasisCode::BasisSelect(const gVector<T> &unitv,
			    const gVector<T> &rowv,
			    gVector<T> &colv ) const
{
  assert(column.Check(colv) && column.Check(unitv) && tableau->b.Check(rowv));

  for(int i=column.First(); i<=column.Last(); i++)
    {
      if(unitflag[i])
	colv[i]= unitv[column[i]];
      else
	colv[i]= rowv[column[i]];
    }
}


  
