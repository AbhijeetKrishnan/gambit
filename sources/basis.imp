//
// FILE: basis.imp -- implementation of the Basis class
//
// 

#include"basis.h"

// ---------------------------------------------------------------------------
// Class Basis
// ---------------------------------------------------------------------------

// -----------------------
// C-tor, D-tor, Operators
// -----------------------

template <class T> 
Basis<T>::Basis(const gMatrix<T> &mat)
: A(&mat), label( mat.MinRow(), mat.MaxRow() ), 
  cols( mat.MinCol(), mat.MaxCol() ), slacks( mat.MinRow(), mat.MaxRow() ), 
  arts(), artUnitEntry(),colBlocked(mat.MinCol(), mat.MaxCol() ),
  rowBlocked( mat.MinRow(), mat.MaxRow() )
{

  int i;
  for(i = cols.First(); i <= cols.Last(); i++) {
    cols[i] = 0;
    colBlocked[i] = false;
  }

  for(i = label.First(); i <= label.Last(); i++) {
    label[i]= - i;
    slacks[i] = i;
    rowBlocked[i] = false;
  }
  IsBasisIdent = true;
}

template <class T>
Basis<T>::Basis(const Basis<T> &bas)
: A(bas.A), label(bas.label), cols( bas.cols ), slacks( bas.slacks ),
  arts(bas.arts), artUnitEntry(bas.artUnitEntry),
  colBlocked(bas.colBlocked),rowBlocked(bas.rowBlocked),
  IsBasisIdent(bas.IsBasisIdent)
{ }

template <class T>
Basis<T>::~Basis()
{ }

template <class T>
Basis<T>& Basis<T>::operator=(const Basis<T> &orig)
{
  if(this != &orig) {
    A = orig.A;
    label = orig.label; 
    cols = orig.cols;
    slacks = orig.slacks;
    arts = orig.arts;
    artUnitEntry = orig.artUnitEntry;
    rowBlocked = orig.rowBlocked;
    colBlocked = orig.colBlocked;
    IsBasisIdent = orig.IsBasisIdent;

  }
  return *this;
}


// -------------------------
// Public Members
// -------------------------

template <class T>
int Basis<T>::Pivot(int outindex, int col)
{
  int outlabel = label[outindex];
 
  if ( -col >= label.First() && -col <= label.Last() ) slacks[-col] = outindex;
  else if ( col >= cols.First() && col <= cols.Last() ) cols[col] = outindex;
  else if ( col > cols.Last() && col <= cols.Last() + arts.Length() ) 
    arts[col - cols.Last()] = outindex;
  else assert(0); // not a valid column to pivot in.
  
  if ( -outlabel >= label.First() && -outlabel <= label.Last() ) 
    slacks[-outlabel] = 0;
  else if ( outlabel >= cols.First() && outlabel <= cols.Last() ) 
    cols[outlabel] = 0;
  else if ( outlabel > cols.Last() && 
	   outlabel <= cols.Last() + arts.Length() ) 
    arts[outlabel - cols.Last()] = 0;
  else assert(0); // not a valid column to pivot in.
  
  label[outindex] = col;
  CheckBasis();
  
  return outlabel;
}

template <class T>
bool Basis<T>::Member( int col ) const
{
  int ret;

  if ( -col >= label.First() && -col <= label.Last() ) ret = slacks[-col];
  else if ( col >= cols.First() && col <= cols.Last() ) ret = cols[col];
  else if ( col > cols.Last() && col <= cols.Last() + arts.Length() ) 
    ret = arts[col - cols.Last()];
  else ret = 0;

  return (ret != 0);
}


template <class T>
int Basis<T>::Find( int col ) const
{
  int ret;

  if ( -col >= label.First() && -col <= label.Last() ) ret = slacks[-col];
  else if ( col >= cols.First() && col <= cols.Last() ) ret = cols[col];
  else if ( col > cols.Last() && col <= cols.Last() + arts.Length() ) 
    ret = arts[col - cols.Last()];
  else ret = 0;
  
  assert (ret != 0);
  return ret;
}

template <class T>
int Basis<T>::Label(int index) const
{
  return  label[index];
}

template <class T>
void Basis<T>::Mark(int col )
{
  if ( -col >= label.First() && -col <= label.Last() ) 
    rowBlocked[-col] = true;
  else if ( col >= cols.First() && col <= cols.Last() ) 
    colBlocked[col] = true;
}

template <class T>
void Basis<T>::UnMark(int col )
{
  if ( -col >= label.First() && -col <= label.Last() ) 
    rowBlocked[-col] = false;
  else if ( col >= cols.First() && col <= cols.Last() ) 
    colBlocked[col] = false;
}

template <class T>
bool Basis<T>::IsBlocked(int col) const
{
  if ( -col >= label.First() && -col <= label.Last() ) 
    return rowBlocked[-col];
  else if ( col >= cols.First() && col <= cols.Last() ) 
    return colBlocked[col];
  return false;
}

template <class T>
void Basis<T>::BasisSelect(const gVector<T> &rowv, gVector<T> &colv) const
{
  assert(A->CheckColumn(colv) && A->CheckRow(rowv));

  for(int i=label.First(); i<=label.Last(); i++) {
    if(label[i]<0)
      colv[i]= 0;
    else
      colv[i]= rowv[label[i]];
  }
}

template <class T>
void Basis<T>::BasisSelect(const gVector<T> &unitv,
			   const gVector<T> &rowv,
			   gVector<T> &colv ) const
{
  assert(A->CheckColumn(colv)
	 && A->CheckColumn(unitv)
	 && A->CheckRow(rowv) );
  
  for(int i=label.First(); i<=label.Last(); i++) {
    if(label[i]<0)
      colv[i]= unitv[-label[i]];
    else
      colv[i]= rowv[label[i]];
  }
}

template <class T> 
bool Basis<T>::IsSpecialColumn( int col ) const
{
  return ( (-col >= label.First() && -col <= label.Last()) ||
	  ( col > cols.Last() && col <= cols.Last() + arts.Length()) ); 
}
 
template <class T>
void Basis<T>::GetColumn( int col, gVector<T> &ret ) const
{
  
  if ( IsSpecialColumn( col ) ) {
    if ( col < 0 ) {
      ret = (T) 0;
      ret[-col] = (T) 1;
    }
    else { // its an artificial variable
      ret = (T) 0;
      ret[artUnitEntry[col - cols.Last()]] = (T) 1;
    }
  }
  else 
    A->GetColumn(col, ret);
  
}


template <class T>
void Basis<T>::InsertArtificial( int art, int col )
{
  arts.Insert( 0, col - cols.Last() );
  artUnitEntry.Insert( art, col - cols.Last() );
}

template <class T>
int Basis<T>::AppendArtificial( int art )
{
  arts.Append(0);
  return artUnitEntry.Append(art) + cols.Last();
}

template <class T>
void Basis<T>::RemoveArtificial( int col )
{
  arts.Remove(col-cols.Last());
  artUnitEntry.Remove( col - cols.Last() );
}

template <class T>
void Basis<T>::FlushArtificial()
{
  arts.Flush();
  artUnitEntry.Flush();
}

template <class T>
int Basis<T>::LastArtificial()
{
  return ( artUnitEntry.Last() + cols.Last() );
}

template <class T> 
gOutput &operator<<(gOutput &to, const Basis<T> &v)
{
  v.Dump(to); return to;
}

template <class T>
void Basis<T>::Dump(gOutput &to) const
{ 
  to << "{";
  for(int i=label.First();i<=label.Last();i++) {
    to << "  " << label[i];  
  }
  to << " }";
}

template<class T>
void Basis<T>::CheckBasis() 
{
  int i;
  bool check = true;

  for ( i =label.First(); i <= label.Last() && check != false; 
       i++){
    check = check && ( label[i] == -i  || ( label[i] == i + cols.Last() ));
  }

//  if ( !check ) {
//    check = true;
//    for ( i = label.First(); i <= label.Last() && check != false; i++ ) {
//      if (basis[i] > 0) {
//	for ( j = (*A).MinRow(); j <= (*A).MaxRow() && check != false; j++ ) {
//	  if ( i == j ) {
//	    check = check && ( (*A)(j,label[i])  == (T) 1 );
//	  }
//	  else {
//	    check = check && ( (*A)(j,label[i])  == (T) 0 );
//	  }
//	}
//      }
//      else if (label[i] != -i ) check = false;
//    }
//  }

  IsBasisIdent = check;
}

template<class T>
bool Basis<T>::IsIdent()
{
  return IsBasisIdent;
}


