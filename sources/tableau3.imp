//
// FILE: tableau3.imp: implementation of Tableau classes for gRational
//
// $Id$
//
gMatrix<gInteger> IntCast(const gMatrix<gRational> &mat)
{
  int i,j;
  gMatrix<gInteger> ret(mat.MinRow(),mat.MaxRow(),mat.MinCol(),mat.MaxCol());
  for (i=mat.MinRow();i<=mat.MaxRow();++i){
    for(j=mat.MinCol();j<=mat.MaxCol();++j){
      ret(i,j)=mat(i,j).numerator();
    }
  }
  return(ret);
}

gVector<gInteger> IntCast(const gVector<gRational> &vec)
{
  int i;
  gVector<gInteger> ret(vec.First(),vec.Last());
  for (i=vec.First();i<=vec.Last();++i){
    assert(vec[i].denominator()==1);
      ret[i]=vec[i].numerator();
  }
  return(ret);
}

gMatrix<gRational> RatCast(const gMatrix<gInteger> &mat)
{
  int i,j;
  gMatrix<gRational> ret(mat.MinRow(),mat.MaxRow(),mat.MinCol(),mat.MaxCol());
  for (i=mat.MinRow();i<=mat.MaxRow();++i){
    for(j=mat.MinCol();j<=mat.MaxCol();++j){
      ret(i,j)=gRational(mat(i,j));
    }
  }
  return(ret);
}      


gInteger find_lcd(const gMatrix<gRational> &mat)
{
  gInteger lcd(1);
  for(int i=mat.MinRow();i<=mat.MaxRow();i++)
    for(int j=mat.MinCol();j<=mat.MaxCol();j++) 
      lcd = lcm(mat(i,j).denominator(),lcd);
  return lcd;
}

gInteger find_lcd(const gVector<gRational> &vec)
{
  gInteger lcd(1);
  for(int i=vec.First();i<=vec.Last();i++)
    lcd = lcm(vec[i].denominator(),lcd);
  return lcd;
}

//
// Tableau method definitions 
//

// Constructor

Tableau<gRational>::Tableau(const gMatrix<gRational> &A, const gVector<gRational> &b)
  : TableauInterface<gRational>(A,b), Det(1),totdenom(1),
    InvDat(A.MinRow(),A.MaxRow(),A.MinRow(),A.MaxRow()), tmpcol(b.First(),b.Last())
{
  //   gout << "\nMY CODE\n";
  totdenom = lcm(find_lcd(A),find_lcd(b));
  assert(totdenom>0);
  InvDat.MakeIdent();
  InvDat = InvDat * totdenom;
  solution = b;
}

// Copy Constructor

Tableau<gRational>::Tableau(const Tableau<gRational> &orig) 
  : TableauInterface<gRational>(orig), Det(orig.Det), totdenom(orig.totdenom),
    InvDat(orig.InvDat), tmpcol(orig.tmpcol)
{ }

// Destructor

Tableau<gRational>::~Tableau()
{ }


// = operator

Tableau<gRational>& Tableau<gRational>::operator=(const Tableau<gRational> &orig)
{
  TableauInterface<gRational>::operator=(orig);
  if(this!= &orig) {
    InvDat = orig.InvDat;
    Det = orig.Det;
    totdenom = orig.totdenom;
    tmpcol = orig.tmpcol;
  }
  return *this;
}

//
// pivoting operations
//

int Tableau<gRational>::CanPivot(int outlabel, int col)
{
  SolveColumn(col,tmpcol);
  gRational val = tmpcol[basis.Find(outlabel)];
  if(val == (gRational)0) return 0;
  //   if(val <=eps2 && val >= -eps2) return 0;
  return 1;  
}

#ifdef TEMPO
void Tableau<gRational>::Reduce()
{
  int i,j;
  gInteger temp_gcd(Det.numerator());
  for(i=InvDat.MinRow();i<=InvDat.MaxRow();++i){
    for(j=InvDat.MinCol();j<=InvDat.MaxCol();++j){
      temp_gcd=gcd(temp_gcd,InvDat(i,j).numerator());
    }
  }
  InvDat/=temp_gcd;
  Det/=temp_gcd;
  if (temp_gcd!=1) gout << "\nREDUCE: " << temp_gcd << '\n';
  gout << "InvDat /n" << InvDat << '\n';
}
#endif //TEMPO


void Tableau<gRational>::Pivot(int outrow, int in_col)
{
  int i,j;
  //if (npivots%4 == 0){Reduce();}
  //int outlabel = Label(outrow);
  //gout << "\noutrow:" << outrow;
  //gout << " outlabel: " << outlabel;
  //gout << " inlabel: " << in_col;
  // This is the Pivot Column, calculated here
  gVector<gRational> Lambda((*A).MinRow(),(*A).MaxRow());
  gVector<gInteger> LambdaPrime((*A).MinRow(),(*A).MaxRow());

  // pivot in the new basis
  basis.Pivot(outrow,in_col);
  
  // The paper states that the pivot column = Inverse*Aj
  if(in_col<0){
    for(i=Lambda.First();i<=Lambda.Last();++i)
      if(i==abs(in_col)){
	Lambda[i]=1;
      }
      else{
	Lambda[i]=0;
      }
  }
  else{
    (*A).GetColumn(in_col,Lambda);
  }
  LambdaPrime=IntCast(RatCast(InvDat)*Lambda);

  // gout << "\nLAMBDA: \n" << Lambda << '\n';

  // Multiplication without TempMatrix
  for(i=InvDat.MinRow();i<=InvDat.MaxRow();++i){
    for(j=InvDat.MinCol();j<=InvDat.MaxCol();++j){
      if(i!=outrow){
	InvDat(i,j)=LambdaPrime[outrow]*InvDat(i,j)-LambdaPrime[i]*InvDat(outrow,j);
	InvDat(i,j)/=Det;
      }
    }
  }

  // for(j=InvDat.MinCol();j<=InvDat.MaxCol();++j){
  //   InvDat(outrow,j)*=Det;
  // }
  // InvDat/=Det;

  Det = LambdaPrime[outrow];

  //gout << "\nDet: \n" << Det << '\n';
  //gout << "\nLambda: \n" << Lambda << '\n';
  //gout << "\nInvDat: \n" << InvDat << '\n'; 

  // Update solution
  solution=(RatCast(InvDat)*(*b))/gRational(Det);


  //gout << solution << '\n';
  //gout << "\nDET: \n" << Det << '\n';
  //gout << "PIVOT:" << '\n';
  //gout << InvDat << '\n';
  ++npivots;
  //BigDump(gout);
}


void Tableau<gRational>::SolveColumn(int in_col, gVector<gRational> &out)
{
  int i;
  
  if(in_col<0){
    for(i=out.First();i<=out.Last();++i){
      if(i==abs(in_col)){out[i]=1;}
      else{out[i]=0;}
    }
  }
  else{
    (*A).GetColumn(in_col,out);
  }
  // gout << "SOLVECOLUMN:" << '\n';
  // gout << InvDat << '\n';

  out = (RatCast(InvDat)*out)/gRational(Det);

}

void Tableau<gRational>::Refactor()
{ 
  gInteger old_denom(totdenom);
  totdenom = lcm(find_lcd(*A),find_lcd(*b));
  InvDat = (InvDat * totdenom)/old_denom;

}

void Tableau<gRational>::SetRefactor(int)
{ }

void Tableau<gRational>::SetConst(const gVector<gRational> &bnew)
{
  b=&bnew;
  Refactor();
  //** this will have to be changed -- Need to start over and re-solve
  //** current basis with bnew.  Here is where vertenum probably screws up (RDM)
  // B.solve(*b, solution);
}


//** this function is not currently used.  Drop it?
void Tableau<gRational>::SetBasis(const Basis<gRational> &in)
{
  basis= in;
  //** this has to be changed -- Need to start over and pivot to new basis.  
  // B.refactor();
  // B.solve(*b, solution);
}

 // solve M x = b
void Tableau<gRational>::Solve(const gVector<gRational> &b, gVector<gRational> &x)
{
  //** Note --- commenting this out breaks LP<gRational> for now
  //** need to add private GetInverse() function to get V = M^(-1) (M inverse)
  //** then do x = V * b
  // B.solve(b,x);
  x=(RatCast(InvDat)*b)/gRational(Det);
}

 // solve y M = c
void Tableau<gRational>::SolveT(const gVector<gRational> &c, gVector<gRational> &y)
{
  //** Note --- commenting this out breaks LP<gRational> for now
  //** need to add private GetInverse() function to get V = M^(-1) (M inverse)
  //** then do y = b * V
  // B.solveT(c,y);
  y=(c*RatCast(InvDat))/gRational(Det);
}

bool Tableau<gRational>::IsFeasible()
{
  // B.solve(*b, solution);
  for(int i=solution.First();i<=solution.Last();i++)
    if(solution[i]>=eps2) return false;
  return true;
}

bool Tableau<gRational>::IsLexMin()
{
  int i,j;
  for(i=MinRow();i<=MaxRow();i++)
    if(EqZero(solution[i]))
      for(j=-MaxRow();j<Label(i);j++) if(j!=0){
	SolveColumn(j,tmpcol);
	if(LtZero(tmpcol[i]))
	  return 0;
      }
  return 1;
}

gOutput &operator<<(gOutput &to, const Tableau<gRational> &v)
{
  v.Dump(to); return to;
}












