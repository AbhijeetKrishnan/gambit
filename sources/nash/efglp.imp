//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of algorithm to solve efgs via linear programming
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include "base/gnullstatus.h"
#include "efglp.h"
#include "numerical/tableau.h"
#include "numerical/lpsolve.h"

template <class T> class gbtEfgNashLp {
private:
  T maxpay, minpay;
  int ns1,ns2,ni1,ni2;
  gbtList<gbtBasicFeasibleSolution<T> > List;
  gbtList<gbtGameInfoset> isets1, isets2;

  void FillTableau(const gbtGame &,
		   gbtMatrix<T> &, const gbtGameNode &, T ,int ,int , int ,int );
  void GetSolutions(const gbtGame &, gbtList<gbtBehavProfile<T> > &) const;
  int Add_BFS(/*const*/ gbtLPSolver<T> &B);
  
  void GetProfile(const gbtGame &, gbtBehavProfile<T> &v, 
		  const gbtBasicFeasibleSolution<T> &sol,
		  const gbtGameNode &n, int s1,int s2) const;

public:
  gbtEfgNashLp(void);
  virtual ~gbtEfgNashLp() { }

  std::string GetAlgorithm(void) const { return "Lp[EFG]"; }
  gbtList<gbtBehavProfile<T> > Solve(const gbtGame &, gbtStatus &);
};


//-------------------------------------------------------------------------
//                     gbtEfgNashLp<T>: Member functions
//-------------------------------------------------------------------------

template <class T>
gbtEfgNashLp<T>::gbtEfgNashLp(void)
{ }

template <class T> gbtList<gbtBehavProfile<T> > 
gbtEfgNashLp<T>::Solve(const gbtGame &p_efg, gbtStatus &p_status)
{
  gbtBasicFeasibleSolution<T> cbfs((T) 0);
  
  ns1 = p_efg->GetPlayer(1)->NumSequences();
  ns2 = p_efg->GetPlayer(2)->NumSequences();
  ni1 = p_efg->GetPlayer(1)->NumInfosets()+1;  
  ni2 = p_efg->GetPlayer(2)->NumInfosets()+1; 

  for (int i = 1; i <= p_efg->GetPlayer(1)->NumInfosets(); i++) {
    isets1.Append(p_efg->GetPlayer(1)->GetInfoset(i));
  }
  for (int i = 1; i <= p_efg->GetPlayer(2)->NumInfosets(); i++) {
    isets2.Append(p_efg->GetPlayer(2)->GetInfoset(i));
  }

  if (p_efg->NumPlayers() != 2 || !p_efg->IsConstSum() || !p_efg->IsPerfectRecall()) {
    return gbtList<gbtBehavProfile<T> >();
  }
  
  List.Flush();
  
  gbtMatrix<T> A(1,ns1+ni2,1,ns2+ni1);
  gbtVector<T> b(1,ns1+ni2);
  gbtVector<T> c(1,ns2+ni1);

  maxpay = p_efg->GetMaxPayoff() + gbtRational(1);
  minpay = p_efg->GetMinPayoff() - gbtRational(1);

  A = (T)0;
  T prob = (T)1;
  FillTableau(p_efg, A, p_efg->GetRoot(), prob, 1, 1, 0, 0);
  A(1,ns2+1) = -(T)1;
  A(ns1+1,1) = (T)1;

  b = (T)0;
  b[ns1+1] = (T)1;

  c = (T)0;
  c[ns2+1] = -(T)1;

  gbtLPSolver<T> LP(A,b,c,ni2,p_status);
  if (!LP.IsAborted()) {
    Add_BFS(LP); 
  }

  gbtList<gbtBehavProfile<T> > solutions;
  GetSolutions(p_efg, solutions);
  return solutions;
}


template <class T> int gbtEfgNashLp<T>::Add_BFS(/*const*/ gbtLPSolver<T> &lp)
{
  gbtBasicFeasibleSolution<T> cbfs((T) 0);

  // gbtLPSolver<T>::GetAll() does not currently work correctly; for now,
  // LpSolve is restricted to returning only one equilibrium 
  lp.OptBFS(cbfs);
  if (List.Contains(cbfs))  return 0;
  List.Append(cbfs);
  return 1;
}



template <class T> 
void gbtEfgNashLp<T>::GetProfile(const gbtGame &p_efg,
				 gbtBehavProfile<T> &v,
				 const gbtBasicFeasibleSolution<T> &sol,
				 const gbtGameNode &n,
				 int s1,int s2) const
{
  
  int i,pl,inf,snew;
  T eps = (T)0;
//  eps = tab->Epsilon();
  if (!n->GetInfoset().IsNull()) {
    if(n->GetPlayer()->IsChance()) {
      for(i=1;i<=n->NumChildren();i++)
	GetProfile(p_efg,v,sol,n->GetChild(i),s1,s2);
    }
    pl = n->GetPlayer()->GetId();
    if(pl==2) {
    inf= isets2.Find(n->GetInfoset());
      snew=1;
      for(i=1;i<inf;i++)
	snew+=isets2[i]->NumActions();
      for(i=1;i<=n->GetInfoset()->NumActions();i++) {
	v(pl,inf,i) = (T)0;
	if(sol.IsDefined(s1)) {
	  if(sol(s1)>eps) {
	    if(sol.IsDefined(snew+i)) {
	      if(sol(snew+i)>eps)
		v(pl,inf,i) = sol(snew+i)/sol(s1);
	    }
	  } 
	} 
	GetProfile(p_efg,v,sol,n->GetChild(n->GetInfoset()->GetAction(i)->GetId()),snew+i,s2);
      }
    }
    if(pl==1) {
    inf= isets1.Find(n->GetInfoset());
      snew=1;
      for(i=1;i<inf;i++)
	snew+=isets1[i]->NumActions(); 
      for(i=1;i<=n->GetInfoset()->NumActions();i++) {
	v(pl,inf,i) = (T)0;
	if(sol.IsDefined(-s2)) {
	  if(sol(-s2)>eps) {
	    if(sol.IsDefined(-(snew+i))) {
	      if(sol(-(snew+i))>eps)
		v(pl,inf,i) = sol(-(snew+i))/sol(-s2);
	    }
	  } 
	} 
	GetProfile(p_efg,v,sol,n->GetChild(n->GetInfoset()->GetAction(i)->GetId()),s1,snew+i);
      }
    }
  }
}


template <class T>
void gbtEfgNashLp<T>::FillTableau(const gbtGame &p_efg,
				  gbtMatrix<T> &A, const gbtGameNode &n, T prob,
				  int s1, int s2, int i1, int i2)
{
  int i,snew;
  if (!n->GetOutcome().IsNull()) {
    A(s1,s2) = gbtRational(A(s1,s2)) +
      gbtRational(prob) * n->GetOutcome()->GetPayoff(p_efg->GetPlayer(1)) - gbtRational(minpay);
  }
  if (!n->GetInfoset().IsNull()) {
    if (n->GetPlayer()->IsChance()) {
      for(i=1;i<=n->NumChildren();i++)
	FillTableau(p_efg, A, n->GetChild(i),
		    gbtRational(prob) * n->GetInfoset()->GetAction(i)->GetChanceProb(),
		    s1,s2,i1,i2);
    }
    int pl = n->GetPlayer()->GetId();
    if(pl==1) {
      i1=isets1.Find(n->GetInfoset());
      snew=1;
      for(i=1;i<i1;i++)
	snew+=isets1[i]->NumActions();
      A(s1,ns2+i1+1) = (T) +1;
      for(i=1;i<=n->GetInfoset()->NumActions();i++) {
	A(snew+i,ns2+i1+1) = (T) -1;
	FillTableau(p_efg, A, n->GetChild(n->GetInfoset()->GetAction(i)->GetId()),prob,snew+i,s2,i1,i2);
      }
    }
    if(pl==2) {
      i2=isets2.Find(n->GetInfoset());
      snew=1;
      for(i=1;i<i2;i++)
	snew+=isets2[i]->NumActions();
      A(ns1+i2+1,s2) = (T) -1;
      for(i=1;i<=n->GetInfoset()->NumActions();i++) {
	A(ns1+i2+1,snew+i) = (T) +1;
	FillTableau(p_efg, A, n->GetChild(n->GetInfoset()->GetAction(i)->GetId()),prob,s1,snew+i,i1,i2);
      }
    }
  }
}

template <class T>
void gbtEfgNashLp<T>::GetSolutions(const gbtGame &p_efg,
				   gbtList<gbtBehavProfile<T> > &solutions) const
{
  for (int i = 1; i <= List.Length(); i++)    {
    gbtBehavProfile<T> profile = p_efg->NewBehavProfile((T) 0);
    GetProfile(p_efg, profile, List[i], p_efg->GetRoot(), 1, 1);
    solutions.Append(profile);
  }

}

template <class T> gbtList<gbtBehavProfile<T> >
gbtNashLpEfg(const gbtGame &p_game, const T &)
{
  gbtEfgNashLp<T> algorithm;
  gbtNullStatus status;
  return algorithm.Solve(p_game, status);
}
