//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of algorithm to compute mixed strategy equilibria
// of constant sum normal form games via linear programming
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include "nfglp.h"
#include "game/nfgiter.h"

//-------------------------------------------------------------------------
//                   gbtNfgNashLp<T>: Member functions
//-------------------------------------------------------------------------

template <class T> gbtNfgNashLp<T>::gbtNfgNashLp(void)
{ }

template <class T> 
gbtMixedNashSet gbtNfgNashLp<T>::Solve(const gbtNfgGame &p_game,
				       gbtStatus &p_status)
{
  gbtBasicFeasibleSolution<T> cbfs((T) 0);
  
  if (p_game->NumPlayers() != 2 ||
      !p_game->IsConstSum()) {
    return gbtMixedNashSet();
  }
  
  gbtList<gbtBasicFeasibleSolution<T> > bfsList;
  
  int i,j,m,k;
  
  m = p_game->GetPlayer(1)->NumStrategies();
  k = p_game->GetPlayer(2)->NumStrategies();
  gbtMatrix<T> A(1,k+1,1,m+1);
  gbtVector<T> b(1,k+1);
  gbtVector<T> c(1,m+1);
  gbtNfgIterator iter(p_game);

  T minpay = p_game->GetMinPayoff() - gbtNumber(1);

  for (i = 1; i <= k; i++)  {
    for (j = 1; j <= m; j++)  {
      A(i, j) = gbtNumber(minpay) - iter.GetPayoff(p_game->GetPlayer(1));
      iter.Next(1);
    }
    A(i,m+1) = (T)1;
    iter.Next(2);
  }
  for (j = 1;j<=m;j++)  {
    A(k+1,j)= (T)1;
  }
  A(k+1,m+1) = (T)0;

  b = (T)0;
  b[k+1] = (T)1;
  c = (T)0;
  c[m+1] = (T)1;

  gbtLPSolver<T> LP(A,b,c,1,p_status);

  if (!LP.IsAborted()) {
    Add_BFS(p_game, LP, bfsList); 
  }

  gbtMixedNashSet solutions;
  GetSolutions(p_game, bfsList, solutions, LP.Epsilon());
  return solutions;
}

template <class T> int gbtNfgNashLp<T>::Add_BFS(const gbtNfgGame &p_game,
						/*const*/ gbtLPSolver<T> &lp,
						gbtList<gbtBasicFeasibleSolution<T> > &p_list)
{
  gbtBasicFeasibleSolution<T> cbfs((T) 0);

  // gbtLPSolver<T>::GetAll() does not currently work correctly; for now,
  // LpSolve is restricted to returning only one equilibrium
  lp.OptBFS(cbfs);
  cbfs.Remove(p_game->GetPlayer(1)->NumStrategies()+1);
  cbfs.Remove(-p_game->GetPlayer(2)->NumStrategies()-1);
  if (p_list.Contains(cbfs))  return 0;
  p_list.Append(cbfs);
  return 1;
}

template <class T>
void gbtNfgNashLp<T>::GetSolutions(const gbtNfgGame &p_game,
				   const gbtList<gbtBasicFeasibleSolution<T> > &p_list,
				   gbtMixedNashSet &solutions,
				   const T &p_epsilon) const
{
  int n1 = p_game->GetPlayer(1)->NumStrategies();
  int n2 = p_game->GetPlayer(2)->NumStrategies();
  solutions.Flush();

  for (int i = 1; i <= p_list.Length(); i++)    {
    gbtMixedProfile<T> profile = p_game->NewMixedProfile((T) 0.0);
    int j;
    for (j = 1; j <= n1; j++) 
      if (p_list[i].IsDefined(j))   
	profile(1, j) = p_list[i](j);
      else  profile(1, j) = (T) 0;

    for (j = 1; j <= n2; j++)
      if (p_list[i].IsDefined(-j))
	profile(2, j) = p_list[i](-j);
      else
	profile(2, j) = (T) 0;

    solutions.Append(profile->NewMixedProfile(gbtNumber(0)));
  }
}
