//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of algorithm to compute mixed strategy equilibria
// of constant sum normal form games via linear programming
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include "base/gstatus.h"
#include "nfglp.h"
#include "numerical/lpsolve.h"

template <class T> class gbtNfgNashLp {
private:
  int Add_BFS(const gbtGame &, /*const*/ gbtLPSolver<T> &B,
	      gbtList<gbtBasicFeasibleSolution<T> > &);
  void GetSolutions(const gbtGame &, 
		    const gbtList<gbtBasicFeasibleSolution<T> > &,
		    gbtList<gbtMixedProfile<T> > &,
		    const T &) const;

public:
  gbtNfgNashLp(void);
  virtual ~gbtNfgNashLp() { }

  std::string GetAlgorithm(void) const { return "Lp[NFG]"; }
  gbtList<gbtMixedProfile<T> > Solve(const gbtGame &, gbtStatus &);
};


//-------------------------------------------------------------------------
//                   gbtNfgNashLp<T>: Member functions
//-------------------------------------------------------------------------

template <class T> gbtNfgNashLp<T>::gbtNfgNashLp(void)
{ }

template <class T> gbtList<gbtMixedProfile<T> > 
gbtNfgNashLp<T>::Solve(const gbtGame &p_game, gbtStatus &p_status)
{
  gbtBasicFeasibleSolution<T> cbfs((T) 0);
  
  if (p_game->NumPlayers() != 2 || !p_game->IsConstSum()) {
    return gbtList<gbtMixedProfile<T> >();
  }
  
  gbtList<gbtBasicFeasibleSolution<T> > bfsList;
  
  int m = p_game->GetPlayer(1)->NumStrategies();
  int k = p_game->GetPlayer(2)->NumStrategies();
  gbtMatrix<T> A(1,k+1,1,m+1);
  gbtVector<T> b(1,k+1);
  gbtVector<T> c(1,m+1);
  gbtGameContingencyIterator iter = p_game->NewContingencyIterator();

  T minpay = p_game->GetMinPayoff() - gbtRational(1);

  do {
    int i = iter->GetStrategy(p_game->GetPlayer(2))->GetId();
    int j = iter->GetStrategy(p_game->GetPlayer(1))->GetId();
    A(i, j) = gbtRational(minpay) - iter->GetPayoff(p_game->GetPlayer(1));
  } while (iter->NextContingency());

  for (int j = 1; j <= m; j++)  {
    A(k+1,j)= (T)1;
  }
  A(k+1,m+1) = (T)0;

  b = (T)0;
  b[k+1] = (T)1;
  c = (T)0;
  c[m+1] = (T)1;

  gbtLPSolver<T> LP(A,b,c,1,p_status);

  if (!LP.IsAborted()) {
    Add_BFS(p_game, LP, bfsList); 
  }

  gbtList<gbtMixedProfile<T> > solutions;
  GetSolutions(p_game, bfsList, solutions, LP.Epsilon());
  return solutions;
}

template <class T> 
int gbtNfgNashLp<T>::Add_BFS(const gbtGame &p_game,
			     /*const*/ gbtLPSolver<T> &lp,
			     gbtList<gbtBasicFeasibleSolution<T> > &p_list)
{
  gbtBasicFeasibleSolution<T> cbfs((T) 0);

  // gbtLPSolver<T>::GetAll() does not currently work correctly; for now,
  // LpSolve is restricted to returning only one equilibrium
  lp.OptBFS(cbfs);
  cbfs.Remove(p_game->GetPlayer(1)->NumStrategies() + 1);
  cbfs.Remove(-p_game->GetPlayer(2)->NumStrategies() - 1);
  if (p_list.Contains(cbfs))  return 0;
  p_list.Append(cbfs);
  return 1;
}

template <class T>
void gbtNfgNashLp<T>::GetSolutions(const gbtGame &p_game,
				   const gbtList<gbtBasicFeasibleSolution<T> > &p_list,
				   gbtList<gbtMixedProfile<T> > &solutions,
				   const T &p_epsilon) const
{
  int n1 = p_game->GetPlayer(1)->NumStrategies();
  int n2 = p_game->GetPlayer(2)->NumStrategies();
  solutions.Flush();

  for (int i = 1; i <= p_list.Length(); i++)    {
    gbtMixedProfile<T> profile = p_game->NewMixedProfile((T) 0);
    int j;
    for (j = 1; j <= n1; j++) 
      if (p_list[i].IsDefined(j))   
	profile(1, j) = p_list[i](j);
      else  profile(1, j) = (T) 0;

    for (j = 1; j <= n2; j++)
      if (p_list[i].IsDefined(-j))
	profile(2, j) = p_list[i](-j);
      else
	profile(2, j) = (T) 0;

    solutions.Append(profile);
  }
}

template <class T> gbtList<gbtMixedProfile<T> >
gbtNashLpNfg(const gbtGame &p_game, const T &)
{
  gbtNfgNashLp<T> algorithm;
  gbtNullStatus status;
  return algorithm.Solve(p_game, status);
}
