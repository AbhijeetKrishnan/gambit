//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of algorithm to compute mixed strategy equilibria
// of constant sum normal form games via linear programming
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include "nfglp.h"
#include "game/nfgiter.h"

//-------------------------------------------------------------------------
//                   gbtNfgNashLp<T>: Member functions
//-------------------------------------------------------------------------

template <class T> gbtNfgNashLp<T>::gbtNfgNashLp(void)
{ }

template <class T> 
gbtList<MixedSolution> gbtNfgNashLp<T>::Solve(const gbtNfgSupport &p_support,
					    gbtStatus &p_status)
{
  BFS<T> cbfs((T) 0);
  
  if (p_support.GetGame().NumPlayers() != 2 ||
      !p_support.GetGame().IsConstSum()) {
    return gbtList<MixedSolution>();
  }
  
  gbtList<BFS<T> > bfsList;
  
  int i,j,m,k;
  
  m = p_support.NumStrats(1);
  k = p_support.NumStrats(2);
  gbtMatrix<T> A(1,k+1,1,m+1);
  gbtVector<T> b(1,k+1);
  gbtVector<T> c(1,m+1);
  NfgIter iter(p_support);

  T minpay = MinPayoff(p_support.GetGame()) - gbtNumber(1);

  for (i = 1; i <= k; i++)  {
    for (j = 1; j <= m; j++)  {
      A(i, j) = gbtNumber(minpay) - iter.GetPayoff(p_support.GetGame().GetPlayer(1));
      iter.Next(1);
    }
    A(i,m+1) = (T)1;
    iter.Next(2);
  }
  for (j = 1;j<=m;j++)  {
    A(k+1,j)= (T)1;
  }
  A(k+1,m+1) = (T)0;

  b = (T)0;
  b[k+1] = (T)1;
  c = (T)0;
  c[m+1] = (T)1;

  LPSolve<T> LP(A,b,c,1,p_status);

  if (!LP.IsAborted()) {
    Add_BFS(p_support, LP, bfsList); 
  }

  gbtList<MixedSolution> solutions;
  GetSolutions(p_support, bfsList, solutions, LP.Epsilon());
  return solutions;
}

template <class T> int gbtNfgNashLp<T>::Add_BFS(const gbtNfgSupport &p_support,
						/*const*/ LPSolve<T> &lp,
						gbtList<BFS<T> > &p_list)
{
  BFS<T> cbfs((T) 0);

  // LPSolve<T>::GetAll() does not currently work correctly; for now,
  // LpSolve is restricted to returning only one equilibrium
  lp.OptBFS(cbfs);
  cbfs.Remove(p_support.GetGame().NumStrats(1)+1);
  cbfs.Remove(-p_support.GetGame().NumStrats(2)-1);
  if (p_list.Contains(cbfs))  return 0;
  p_list.Append(cbfs);
  return 1;
}

template <class T>
void gbtNfgNashLp<T>::GetSolutions(const gbtNfgSupport &p_support,
				   const gbtList<BFS<T> > &p_list,
				   gbtList<MixedSolution > &solutions,
				   const T &p_epsilon) const
{
  int index;
  int n1 = p_support.NumStrats(1);
  int n2=p_support.NumStrats(2);
  solutions.Flush();

  for (int i = 1; i <= p_list.Length(); i++)    {
    gbtMixedProfile<T> profile(p_support);
    int j;
    for (j = 1; j <= n1; j++) 
      if (p_list[i].IsDefined(j))   
	profile(1, j) = p_list[i](j);
      else  profile(1, j) = (T) 0;

    for (j = 1; j <= n2; j++)
      if (p_list[i].IsDefined(-j))
	profile(2, j) = p_list[i](-j);
      else
	profile(2, j) = (T) 0;

    index = solutions.Append(MixedSolution(profile, "Lp[NFG]"));
    solutions[index].SetEpsilon(p_epsilon);
  }
}
