//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Compute Nash equilibria via Mangasarian's algorithm
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include "base/base.h"
#include "base/gnullstatus.h"
#include "game/game.h"
#include "numerical/vertenum.h"

#include "nfgmixed.h"
#include "clique.h"

template <class T> class gbtNfgNashEnumMixed {
private:
  int m_stopAfter;
  bool m_cliques;

  // Private auxiliary functions
  bool EqZero(const T &) const;

public:
  gbtNfgNashEnumMixed(void);
  virtual ~gbtNfgNashEnumMixed() { }
  
  int StopAfter(void) const { return m_stopAfter; }
  void SetStopAfter(int p_stopAfter) { m_stopAfter = p_stopAfter; }

  bool Cliques(void) const { return m_cliques; }
  void SetCliques(bool p_cliques) { m_cliques = p_cliques; }

  std::string GetAlgorithm(void) const { return "EnumMixed[NFG]"; }
  gbtList<gbtMixedProfile<T> > Solve(const gbtGame &, gbtStatus &);
};


template <class T> gbtNfgNashEnumMixed<T>::gbtNfgNashEnumMixed(void)
  : m_stopAfter(0), m_cliques(false)
{ }

template <class T> gbtList<gbtMixedProfile<T> > 
gbtNfgNashEnumMixed<T>::Solve(const gbtGame &p_game, gbtStatus &p_status)
{
  gbtList<gbtVector<T> > key1, key2;  
  gbtList<int> node1, node2;   // IDs of each component of the extreme equilibria

  if (p_game->NumPlayers() != 2) {
    return gbtList<gbtMixedProfile<T> >();
  }
  
  gbtList<gbtMixedProfile<T> > solutions;

  T min = p_game->GetMinPayoff() - gbtRational(1);
  T max = p_game->GetMaxPayoff();
  T fac = ((T)1)/(max - min);

  // Construct matrices A1, A2
  gbtMatrix<T> A1(1, p_game->GetPlayer(1)->NumStrategies(), 
		  1, p_game->GetPlayer(2)->NumStrategies());
  gbtMatrix<T> A2(1, p_game->GetPlayer(2)->NumStrategies(), 
		  1, p_game->GetPlayer(1)->NumStrategies());

  gbtGameContingencyIterator iter = p_game->NewContingencyIterator(); 

  do {
    int i = iter->GetStrategy(p_game->GetPlayer(1))->GetId();
    int j = iter->GetStrategy(p_game->GetPlayer(2))->GetId();
    A1(i, j) = iter->GetPayoff(p_game->GetPlayer(1)) - gbtRational(min);
    A2(j, i) = iter->GetPayoff(p_game->GetPlayer(2)) - gbtRational(min);
    A1(i, j) *= fac;
    A2(j, i) *= fac;
  } while (iter->NextContingency());

  // Construct vectors b1, b2
  gbtVector<T> b1(1, p_game->GetPlayer(1)->NumStrategies());
  gbtVector<T> b2(1, p_game->GetPlayer(2)->NumStrategies());
  b1 = (T) -1;
  b2 = (T) -1;

  // enumerate vertices of A1 x + b1 <= 0 and A2 x + b2 <= 0
  p_status.SetProgress(0.0);
  p_status << "Step 1 of 3: Enumerating vertices for player 1";

  gbtVertEnum<T> poly1(A1, b1, p_status);

  p_status.SetProgress(0.0);
  p_status << "Step 2 of 3: Enumerating vertices for player 2";

  gbtVertEnum<T> poly2(A2, b2, p_status);

  p_status.SetProgress(0.0);
  p_status << "Step 3 of 3: Searching for equilibria";
  
  const gbtList<gbtBasicFeasibleSolution<T> > &verts1(poly1.VertexList());
  const gbtList<gbtBasicFeasibleSolution<T> > &verts2(poly2.VertexList());
  int v1 = verts1.Length();
  int v2 = verts2.Length();

  gbtArray<int> vert1id(v1);
  gbtArray<int> vert2id(v2);
  for (int i = 1; i <= vert1id.Length(); vert1id[i++] = 0);
  for (int i = 1; i <= vert2id.Length(); vert2id[i++] = 0);

  int i = 0;
  int id1 = 0, id2 = 0;

  try {
    for (int i2 = 2; 
	 i2 <= v2 &&
	   (m_stopAfter == 0 || solutions.Length() < m_stopAfter);
	 i2++) {
      p_status.Get();
      gbtBasicFeasibleSolution<T> bfs1 = verts2[i2];
      p_status.SetProgress((double) (i-2) / (double) v2);
      i++;
      for (int i1 = 2; 
	   i1 <= v1 &&
	     (m_stopAfter==0 || solutions.Length() < m_stopAfter);
	   i1++) {
	gbtBasicFeasibleSolution<T> bfs2 = verts1[i1];
	
	// check if solution is nash 
	// need only check complementarity, since it is feasible
	bool nash = true;
	for (int k = 1; nash && k <= p_game->GetPlayer(1)->NumStrategies();
	     k++) {
	  if (bfs1.IsDefined(k) && bfs2.IsDefined(-k)) {
	    nash = nash && EqZero(bfs1(k) * bfs2(-k));
	  }
	}
	
	for (int k = 1; nash && k <= p_game->GetPlayer(2)->NumStrategies(); 
	     k++) {
	  if (bfs2.IsDefined(k) && bfs1.IsDefined(-k)) {
	    nash = nash && EqZero(bfs2(k) * bfs1(-k));
	  }
	}
	
	if (nash) {
	  gbtMixedProfile<T> profile = p_game->NewMixedProfile((T) 0);
	  T sum = (T) 0;
	  for (int k = 1; k <= p_game->GetPlayer(1)->NumStrategies(); k++) {
	    profile(1, k) = (T) 0;
	    if (bfs1.IsDefined(k)) {
	      profile(1,k) = -bfs1(k);
	      sum += profile(1,k);
	    }
	  } 
	  
	  for (int k = 1; k <= p_game->GetPlayer(1)->NumStrategies(); k++) {
	    if (bfs1.IsDefined(k)) { 
	      profile(1,k) /= sum;
	    }
	  }

	  sum = (T) 0;
	  for (int k = 1; k <= p_game->GetPlayer(2)->NumStrategies(); k++) {
	    profile(2,k) = (T) 0;
	    if (bfs2.IsDefined(k)) {
	      profile(2,k) =-bfs2(k);
	      sum += profile(2,k);
	    }
	  } 
	
	  for (int k = 1; k <= p_game->GetPlayer(2)->NumStrategies(); k++) {
	    if (bfs2.IsDefined(k)) { 
	      profile(2,k) /= sum;
	    }
	  }

	  solutions.Append(profile);
    
	  // note: The keys give the mixed strategy associated with each node. 
	  //       The keys should also keep track of the basis
	  //       As things stand now, two different bases could lead to
	  //       the same key... BAD!
	  if (vert1id[i1] == 0) {
	    id1++;
	    vert1id[i1] = id1;
	    gbtVector<T> v(p_game->GetPlayer(2)->NumStrategies());
	    for (int i = 1; i <= v.Length(); i++) {
	      v[i] = profile(2, i);
	    }
	    key2.Append(v);
	  }
	  if (vert2id[i2] == 0) {
	    id2++;
	    vert2id[i2] = id2;
	    gbtVector<T> v(p_game->GetPlayer(1)->NumStrategies());
	    for (int i = 1; i <= v.Length(); i++) {
	      v[i] = profile(1, i);
	    }
	    key1.Append(v);
	  }
	  node1.Append(vert2id[i2]);
	  node2.Append(vert1id[i1]);
	}
      }
    }
  }
  catch (gbtInterruptException &) {
    // catch exception; return list of computed equilibria (if any)
  }

  return solutions;
}

template <class T> bool gbtNfgNashEnumMixed<T>::EqZero(const T &x) const
{
  T eps;
  gEpsilon(eps, 12);
  return (x <= eps && x >= -eps);
}     

template <class T> gbtList<gbtMixedProfile<T> >
gbtNashEnumMixedNfg(const gbtGame &p_game, const T &, int p_stopAfter)
{
  gbtNfgNashEnumMixed<T> algorithm;
  algorithm.SetStopAfter(p_stopAfter);
  gbtNullStatus status;
  return algorithm.Solve(p_game, status);
}
			

#ifdef UNUSED
template <class T> void EnumModule<T>::GetCliques(gbtOutput &p_stream) const
{
  int n = node1.Length();
  assert(node2.Length() == n);

  gbtArray<edge> edgelist(n);

  p_stream << "\nKey:\nPlayer 1:";
  for (int i = 1; i <= key1.Length(); i++) {
    p_stream << "\n" << i << ": " << key1[i];
  }
  p_stream << "\nPlayer 2:";
  for (int i = 1; i <= key2.Length(); i++) {
    p_stream << "\n" << i << ": " << key2[i];
  }
  p_stream << "\nExtreme equilibria:";
  for (int i = 1; i <= n; i++) {
    edgelist[i].node1 = node1[i];
    edgelist[i].node2 = node2[i];
    p_stream << "\n" << node1[i] << " " << node2[i];
  }
  EnumCliques clique(edgelist, v2+1, v1+1);
}

#endif  // UNUSED
