//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of algorithm to solve extensive forms using linear
// complementarity program from sequence form
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include "base/base.h"
#include "efglcp.h"
#include "lhtab.h"

#include "numerical/lemketab.h"

template <class T> class gbtEfgNashLcp {
private:
  int m_stopAfter, m_maxDepth;

  int ns1,ns2,ni1,ni2;
  T maxpay,eps;
  gbtList<gbtBasicFeasibleSolution<T> > List;
  gbtList<gbtGameInfoset> isets1, isets2;

  void FillTableau(const gbtGame &, gbtMatrix<T> &, const gbtGameNode &, T,
		   int, int, int, int);
  int Add_BFS(const gbtLemkeTableau<T> &tab);
  int All_Lemke(const gbtGame &, int dup, gbtLemkeTableau<T> &B,
		int depth, gbtMatrix<T> &, 
		gbtList<gbtBehavProfile<T> > &, gbtStatus &);
  
  void GetProfile(const gbtGame &, const gbtLemkeTableau<T> &tab, 
		  gbtBehavProfile<T> &, const gbtVector<T> &, 
		  const gbtGameNode &n, int,int);

public:
  gbtEfgNashLcp(void);
  virtual ~gbtEfgNashLcp();
  
  int StopAfter(void) const { return m_stopAfter; }
  void SetStopAfter(int p_stopAfter) { m_stopAfter = p_stopAfter; }

  int MaxDepth(void) const { return m_maxDepth; }
  void SetMaxDepth(int p_maxDepth) { m_maxDepth = p_maxDepth; }

  std::string GetAlgorithm(void) const { return "Lcp[EFG]"; }
  gbtList<gbtBehavProfile<T> > Solve(const gbtGame &, gbtStatus &);
};

//---------------------------------------------------------------------------
//                     gbtEfgNashLcp: member functions
//---------------------------------------------------------------------------

template <class T>
gbtEfgNashLcp<T>::gbtEfgNashLcp(void)
  : m_stopAfter(1), m_maxDepth(0)
{ } 

template <class T> gbtEfgNashLcp<T>::~gbtEfgNashLcp()
{ }

//
// Lemke implements the Lemke's algorithm (as refined by Eaves 
// for degenerate problems) for  Linear Complementarity
// problems, starting from the primary ray.  
//

template <class T> gbtList<gbtBehavProfile<T> > 
gbtEfgNashLcp<T>::Solve(const gbtGame &p_efg, gbtStatus &p_status)
{
  gbtBasicFeasibleSolution<T> cbfs((T) 0);
  int i, j;
  
  if (p_efg->NumPlayers() != 2) {
    return gbtList<gbtBehavProfile<T> >();
  }
  
  for (int i = 1; i <= p_efg->GetPlayer(1)->NumInfosets(); i++) {
    isets1.Append(p_efg->GetPlayer(1)->GetInfoset(i));
  }
  for (int i = 1; i <= p_efg->GetPlayer(2)->NumInfosets(); i++) {
    isets2.Append(p_efg->GetPlayer(2)->GetInfoset(i));
  }

  List.Flush();

  int ntot;
  ns1 = p_efg->GetPlayer(1)->NumSequences();
  ns2 = p_efg->GetPlayer(2)->NumSequences();
  ni1 = p_efg->GetPlayer(1)->NumInfosets()+1;
  ni2 = p_efg->GetPlayer(2)->NumInfosets()+1;

  ntot = ns1+ns2+ni1+ni2;

  gbtMatrix<T> A(1,ntot,0,ntot);
  gbtVector<T> b(1,ntot);

  maxpay = p_efg->GetMaxPayoff() + gbtRational(1);

  T prob = (T)1;
  for (i = A.MinRow(); i <= A.MaxRow(); i++) {
    b[i] = (T) 0;
    for (j = A.MinCol(); j <= A.MaxCol(); j++) {
      A(i,j) = (T) 0; 
    }
  }

  FillTableau(p_efg, A, p_efg->GetRoot(), prob, 1, 1, 0, 0);
  for (i = A.MinRow(); i <= A.MaxRow(); i++) { 
    A(i,0) = -(T) 1;
  }
  A(1,ns1+ns2+1) = (T)1;
  A(ns1+ns2+1,1) = -(T)1;
  A(ns1+1,ns1+ns2+ni1+1) = (T)1;
  A(ns1+ns2+ni1+1,ns1+1) = -(T)1;
  b[ns1+ns2+1] = -(T)1;
  b[ns1+ns2+ni1+1] = -(T)1;

  gbtLemkeTableau<T> tab(A,b);
  eps = tab.Epsilon();
  
  gbtBehavProfile<T> profile = p_efg->NewBehavProfile((T) 0);
  gbtVector<T> sol(tab.MinRow(),tab.MaxRow());
    
  gbtList<gbtBehavProfile<T> > solutions;

  try {
    if (m_stopAfter != 1) {
      All_Lemke(p_efg, ns1+ns2+1, tab, 0, A, solutions, p_status);
    }
    else {
      tab.Pivot(ns1+ns2+1,0);
      tab.SF_LCPPath(ns1+ns2+1, p_status);
      
      Add_BFS(tab);
      tab.BasisVector(sol);
      GetProfile(p_efg, tab, profile, sol, p_efg->GetRoot(), 1, 1);
      solutions.Append(profile);
    }
  }
  catch (gbtInterruptException &) {
    // catch exception; return list of computed equilibria (if any)
  }

  return solutions;
}

template <class T> int gbtEfgNashLcp<T>::Add_BFS(const gbtLemkeTableau<T> &tableau)
{
  gbtBasicFeasibleSolution<T> cbfs((T) 0);
  gbtVector<T> v(tableau.MinRow(), tableau.MaxRow());
  tableau.BasisVector(v);

  for (int i = tableau.MinCol(); i <= tableau.MaxCol(); i++)
    if (tableau.Member(i)) {
      cbfs.Define(i, v[tableau.Find(i)]);
    }

  if (List.Contains(cbfs))  return 0;
  List.Append(cbfs);
  return 1;
}

//
// All_Lemke finds all accessible Nash equilibria by recursively 
// calling itself.  List maintains the list of basic variables 
// for the equilibria that have already been found.  
// From each new accessible equilibrium, it follows
// all possible paths, adding any new equilibria to the List.  
//
template <class T> int 
gbtEfgNashLcp<T>::All_Lemke(const gbtGame &p_game,
			    int j, gbtLemkeTableau<T> &B, int depth,
			    gbtMatrix<T> &A, 
			    gbtList<gbtBehavProfile<T> > &p_solutions,
			    gbtStatus &p_status)
{
  if (m_maxDepth != 0 && depth > m_maxDepth) {
    return 1;
  }

  int i,len,newsol,missing;
  T p1,p2,aa;
  T small_num = (T)1/(T)1000;

  gbtVector<T> sol(B.MinRow(),B.MaxRow());
  gbtBehavProfile<T> profile = p_game->NewBehavProfile((T) 0);

  newsol =0;
  for (i = B.MinRow(); 
       i <= B.MaxRow()  && newsol == 0 &&
       (m_stopAfter == 0 || p_solutions.Length() < m_stopAfter);
       i++) {
    p_status.Get();
    
    if (i != j)  {
      len=List.Length();  
      p1=(double)len/(double)(len+1);
      p2=(double)(len+1)/(double)(len+2);
      int num_strats = B.MaxCol()-B.MinCol()-1;
      aa=(double)(i)/(double)num_strats;
      p_status.SetProgress(p1+aa*(p2-p1));
      
      gbtLemkeTableau<T> BCopy(B);
      A(i,0)=-small_num;
      BCopy.Refactor();

      if(depth==0) {
	BCopy.Pivot(j,0);
	missing = -j;
      }
      else
	missing = BCopy.SF_PivotIn(0);

      newsol=0;

      if(BCopy.SF_LCPPath(-missing,p_status)==1) {
	newsol = Add_BFS(BCopy);
	BCopy.BasisVector(sol);
	GetProfile(p_game, BCopy, profile,
		   sol, p_game->GetRoot(), 1, 1);
	if(newsol) {
	  p_solutions.Append(profile);
	}
      }
      else {
	// gout << ": Dead End";
      }
      
      A(i,0)=-(T)1;
      if(newsol) {
	BCopy.Refactor();
	All_Lemke(p_game,i,BCopy,depth+1, A, p_solutions, p_status);
      }
    }
  }
  
  return 1;
}

template <class T>
void gbtEfgNashLcp<T>::FillTableau(const gbtGame &p_game, gbtMatrix<T> &A,
				   const gbtGameNode &n, T prob,
				   int s1, int s2, int i1, int i2)
{
  int snew;
  if (!n->GetOutcome().IsNull()) {
    A(s1,ns1+s2) = gbtRational(A(s1,ns1+s2)) +
      gbtRational(prob) * (n->GetOutcome()->GetPayoff(p_game->GetPlayer(1)) - gbtRational(maxpay));
    A(ns1+s2,s1) = gbtRational(A(ns1+s2,s1)) +
      gbtRational(prob) * (n->GetOutcome()->GetPayoff(p_game->GetPlayer(2)) - gbtRational(maxpay));
  }
  if (!n->GetInfoset().IsNull()) {
    if (n->GetPlayer()->IsChance()) {
      for (int i = 1; i <= n->NumChildren(); i++) {
	FillTableau(p_game, A, n->GetChild(i),
		    gbtRational(prob) * n->GetInfoset()->GetAction(i)->GetChanceProb(),
		    s1,s2,i1,i2);
      }
    }
    int pl = n->GetPlayer()->GetId();
    if (pl==1) {
      i1=isets1.Find(n->GetInfoset());
      snew=1;
      for (int i = 1; i < i1; i++) {
	snew+=isets1[i]->NumActions();
      }
      A(s1,ns1+ns2+i1+1) = -(T)1;
      A(ns1+ns2+i1+1,s1) = (T)1;
      for (int i = 1; i <= n->GetInfoset()->NumActions(); i++) {
	A(snew+i,ns1+ns2+i1+1) = (T)1;
	A(ns1+ns2+i1+1,snew+i) = -(T)1;
	FillTableau(p_game, A, n->GetChild(n->GetInfoset()->GetAction(i)->GetId()),prob,snew+i,s2,i1,i2);
      }
    }
    if(pl==2) {
      i2=isets2.Find(n->GetInfoset());
      snew=1;
      for (int i = 1; i < i2; i++) {
	snew+=isets2[i]->NumActions();
      }
      A(ns1+s2,ns1+ns2+ni1+i2+1) = -(T)1;
      A(ns1+ns2+ni1+i2+1,ns1+s2) = (T)1;
      for (int i = 1; i <= n->GetInfoset()->NumActions(); i++) {
	A(ns1+snew+i,ns1+ns2+ni1+i2+1) = (T)1;
	A(ns1+ns2+ni1+i2+1,ns1+snew+i) = -(T)1;
	FillTableau(p_game, A, n->GetChild(n->GetInfoset()->GetAction(i)->GetId()),prob,s1,snew+i,i1,i2);
      }
    }
    
  }
}


template <class T>
void gbtEfgNashLcp<T>::GetProfile(const gbtGame &p_efg,
				  const gbtLemkeTableau<T> &tab, 
				  gbtBehavProfile<T> &v, const gbtVector<T> &sol,
				  const gbtGameNode &n, int s1,int s2)
{
  int i,pl,inf,snew,ind,ind2;
  if (!n->GetInfoset().IsNull()) {
    if (n->GetPlayer()->IsChance()) {
      for (i = 1; i <= n->NumChildren();i++)
	GetProfile(p_efg, tab, v, sol, n->GetChild(i), s1, s2);
    }
    pl = n->GetPlayer()->GetId();
    if(pl==1) {
      inf = isets1.Find(n->GetInfoset());
      snew=1;
      for(i=1;i<inf;i++)
	snew+=isets1[i]->NumActions();
      for(i=1;i<=n->GetInfoset()->NumActions();i++) {
	v(pl,inf,i) = (T)0;
	if(tab.Member(s1)) {
	  ind = tab.Find(s1);
	  if(sol[ind]>eps) {
	    if(tab.Member(snew+i)) {
	      ind2 = tab.Find(snew+i);
	      if(sol[ind2]>eps)
		v(pl,inf,i) = sol[ind2]/sol[ind];
	    }
	  } 
	} 
	GetProfile(p_efg, tab, v,sol,n->GetChild(n->GetInfoset()->GetAction(i)->GetId()),snew+i,s2);
      }
    }
    if(pl==2) {
      inf= isets2.Find(n->GetInfoset());
      snew=1;
      for(i=1;i<inf;i++)
	snew+=isets2[i]->NumActions();
      for(i=1;i<=n->GetInfoset()->NumActions();i++) {
	v(pl,inf,i) = (T)0;
	if(tab.Member(ns1+s2)) {
	  ind = tab.Find(ns1+s2);
	  if(sol[ind]>eps) {
	    if(tab.Member(ns1+snew+i)) {
	      ind2 = tab.Find(ns1+snew+i);
	      if(sol[ind2]>eps)
		v(pl,inf,i) = sol[ind2]/sol[ind];
	    }
	  } 
	} 
	GetProfile(p_efg, tab, v, sol, n->GetChild(n->GetInfoset()->GetAction(i)->GetId()),s1,snew+i);
      }
    }
  }
}

template <class T> gbtList<gbtBehavProfile<T> >
gbtNashLcpEfg(const gbtGame &p_game, const T &,
	      int p_stopAfter, int p_maxDepth)
{
  gbtEfgNashLcp<T> algorithm;
  algorithm.SetStopAfter(p_stopAfter);
  algorithm.SetMaxDepth(p_maxDepth);
  gbtNullStatus status;
  return algorithm.Solve(p_game, status);
}
