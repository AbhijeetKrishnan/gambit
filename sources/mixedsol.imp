//#
//# FILE: mixedsol.cc -- Mixed strategy profile classes
//#
//# $Id$
//#


#include "assert.h"
#include "mixedsol.h"

template <class T> 
MixedSolution<T>::MixedSolution(const Nfg<T>& n, bool truncated)
: MixedProfile<T>(n, truncated),
  _Creator(id_USER),
  _IsNash(T_DONTKNOW),
  _IsPerfect(T_DONTKNOW),
  _IsProper(T_DONTKNOW),
  _GobitLambda(-1),
  _GobitValue(-1),
  _LiapValue(-1),
  _Payoff(0)
{}

template <class T> 
MixedSolution<T>::MixedSolution(const Nfg<T>& n, const NFSupport& s)
: MixedProfile<T>(n, s),
  _Creator(id_USER),
  _IsNash(T_DONTKNOW),
  _IsPerfect(T_DONTKNOW),
  _IsProper(T_DONTKNOW),
  _GobitLambda(-1),
  _GobitValue(-1),
  _LiapValue(-1)
{}

template <class T> 
MixedSolution<T>::MixedSolution(const Nfg<T>& n, const gPVector<T>& v)
: MixedProfile<T>(n, v),
  _Creator(id_USER),
  _IsNash(T_DONTKNOW),
  _IsPerfect(T_DONTKNOW),
  _IsProper(T_DONTKNOW),
  _GobitLambda(-1),
  _GobitValue(-1),
  _LiapValue(-1)
{}

template <class T> 
MixedSolution<T>::MixedSolution(const MixedProfile<T>& m, int creator)
: MixedProfile<T>(m),
  _Creator(creator),
  _IsNash(T_DONTKNOW),
  _IsPerfect(T_DONTKNOW),
  _IsProper(T_DONTKNOW),
  _GobitLambda(-1),
  _GobitValue(-1),
  _LiapValue(-1)
{}


template <class T> MixedSolution<T>::MixedSolution(const MixedSolution<T>& m)
: MixedProfile<T>(m), 
  _Creator(m._Creator),
  _IsNash(m._IsNash),
  _IsPerfect(m._IsPerfect),
  _IsProper(m._IsProper),
  _GobitLambda(m._GobitLambda),
  _GobitValue(m._GobitValue),
  _LiapValue(m._LiapValue)
{}

template <class T> MixedSolution<T>::~MixedSolution() {}


template <class T> void MixedSolution<T>::EvalEquilibria()
{
  if(_IsNash == T_DONTKNOW)
    if(MixedProfile<T>::IsNash())
      _IsNash = T_YES;
    else
      _IsNash = T_NO;
  if( _IsNash == T_NO )
  {
    _IsPerfect = T_NO;
    _IsProper = T_NO;
  }
}


template <class T> void MixedSolution<T>::SetCreator(int c)
{ _Creator = c; }

template <class T> int MixedSolution<T>::Creator() const
{ return _Creator; }

template <class T> void MixedSolution<T>::SetIsNash(int i)
{ _IsNash = i; }

template <class T> int MixedSolution<T>::IsNash()
{ EvalEquilibria(); return _IsNash; }

template <class T> void MixedSolution<T>::SetIsPerfect(int i)
{ _IsPerfect = i; }

template <class T> int MixedSolution<T>::IsPerfect()
{ EvalEquilibria(); return _IsPerfect; }

template <class T> void MixedSolution<T>::SetIsProper(int i)
{ _IsProper = i; }

template <class T> int MixedSolution<T>::IsProper()
{ EvalEquilibria(); return _IsProper; }

template <class T> NFSupport MixedSolution<T>::Support() const
{ return stratset; }


template <class T> void MixedSolution<T>::SetGobit(T lambda, T value)
{
  _GobitLambda = lambda;
  _GobitValue = value;
}

template <class T> T MixedSolution<T>::GobitLambda() const
{ return _GobitLambda; }

template <class T> T MixedSolution<T>::GobitValue() const
{ return _GobitValue; }

template <class T> void MixedSolution<T>::SetLiap(T value)
{ _LiapValue = value; }

template <class T> T MixedSolution<T>::LiapValue() 
{ 
  if(_LiapValue < 0)
    _LiapValue = MixedProfile<T>::LiapValue();
  return _LiapValue; 
}

template <class T> 
bool MixedSolution<T>::operator==(const MixedSolution<T> & s) const
{ return MixedProfile<T>::operator==(s); }

template <class T> void MixedSolution<T>::Dump(gOutput& f) const
{
  MixedProfile<T>::Dump(f);
  f << " Creator:"; DisplayID(f, _Creator);
  f << " IsNash:"; DisplayTriState(f, _IsNash);
  f << " IsPerfect:"; DisplayTriState(f, _IsPerfect);
  f << " IsProper:"; DisplayTriState(f, _IsProper);
  f << " Support:" << Support();
  f << " GobitLambda:" << _GobitLambda;
  f << " GobitValue:" << _GobitValue;
  f << " LiapValue:" << _LiapValue;
}

template <class T> gOutput &operator<<(gOutput &f, const MixedSolution<T> &s)
{ s.Dump(f); return f; }


template <class T> void MixedSolution<T>::Invalidate()
{
  _Creator = id_USER;
  _IsNash = T_DONTKNOW;
  _IsProper = T_DONTKNOW;
  _GobitLambda = -1;
  _GobitValue = -1;
  _LiapValue = -1;
}

template <class T> T& MixedSolution<T>::operator[](int i)
{ Invalidate(); return MixedProfile<T>::operator[](i); }

template <class T> T& MixedSolution<T>::operator()(int a, int b)
{ Invalidate(); return MixedProfile<T>::operator()(a, b); }

template <class T> 
gPVector<T>& MixedSolution<T>::operator=(const gPVector<T>& v)
{ Invalidate(); return gPVector<T>::operator=(v); }

template <class T> 
gPVector<T>& MixedSolution<T>::operator=(const gVector<T>& v)
{ assert(0); Invalidate(); return gPVector<T>::operator=(v); }

template <class T> 
gPVector<T>& MixedSolution<T>::operator=(T i)
{ assert(0); Invalidate(); return gPVector<T>::operator=(i); }

template <class T> 
gPVector<T>& MixedSolution<T>::operator+=(const gPVector<T>& v)
{ Invalidate(); return gPVector<T>::operator+=(v); }

template <class T> 
gVector<T>& MixedSolution<T>::operator+=(const gVector<T>& v)
{ assert(0); Invalidate(); return gVector<T>::operator+=(v); }

template <class T> 
gPVector<T>& MixedSolution<T>::operator-=(const gPVector<T>& v)
{ Invalidate(); return gPVector<T>::operator-=(v); }

template <class T> 
gVector<T>& MixedSolution<T>::operator-=(const gVector<T>& v)
{ assert(0); Invalidate(); return gVector<T>::operator-=(v); }

template <class T> gPVector<T>& MixedSolution<T>::operator*=(T i)
{ Invalidate(); return gPVector<T>::operator*=(i); }

template <class T> 
MixedProfile<T>& MixedSolution<T>::operator=(const MixedProfile<T>& v)
{ Invalidate(); return MixedProfile<T>::operator=(v); }
