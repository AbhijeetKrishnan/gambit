//
// FILE: mixedsol.imp -- Mixed strategy profile classes
//
// $Id$
//

#include "assert.h"
#include "mixedsol.h"
#include "gmisc.h"

MixedSolution::MixedSolution(const MixedProfile<double> &m, NfgAlgType creator)
  : MixedProfile<gNumber>(m.Game(), m.Support()),
    _Creator(creator), _IsNash(T_DONTKNOW), _IsPerfect(T_DONTKNOW),
    _IsProper(T_DONTKNOW), _GobitLambda(-1), _GobitValue(-1),
    _LiapValue(-1), _Id(0)
{
  gEpsilon(_Epsilon);
  for (int i = 1; i <= m.Length(); i++)
    ((gVector<gNumber> &) *this)[i] = m[i]; 
}

MixedSolution::MixedSolution(const MixedProfile<gRational> &m, NfgAlgType creator)
  : MixedProfile<gNumber>(m.Game(), m.Support()),
    _Creator(creator), _IsNash(T_DONTKNOW), _IsPerfect(T_DONTKNOW),
    _IsProper(T_DONTKNOW), _GobitLambda(-1), _GobitValue(-1),
    _LiapValue(-1), _Id(0)
{
  gEpsilon(_Epsilon);
  for (int i = 1; i <= m.Length(); i++)
    ((gVector<gNumber> &) *this)[i] = m[i]; 
}

MixedSolution::MixedSolution(const MixedProfile<gNumber> &m, NfgAlgType creator)
  : MixedProfile<gNumber>(m.Game(), m.Support()),
    _Creator(creator), _IsNash(T_DONTKNOW), _IsPerfect(T_DONTKNOW),
    _IsProper(T_DONTKNOW), _GobitLambda(-1), _GobitValue(-1),
    _LiapValue(-1), _Id(0)
{
  gEpsilon(_Epsilon);
  for (int i = 1; i <= m.Length(); i++)
    ((gVector<gNumber> &) *this)[i] = m[i]; 
}

MixedSolution::MixedSolution(const MixedSolution &m)
  : MixedProfile<gNumber>(m),
    _Creator(m._Creator), _IsNash(m._IsNash), _IsPerfect(m._IsPerfect),
    _IsProper(m._IsProper), _Epsilon(m._Epsilon), _GobitLambda(m._GobitLambda),
    _GobitValue(m._GobitValue), _LiapValue(m._LiapValue), _Id(m._Id)
{ }

MixedSolution::~MixedSolution() {}

MixedSolution &MixedSolution::operator=(const MixedSolution &m)
{
  if (this != &m)  {
    MixedProfile<gNumber>::operator=(m);
    _Creator = m._Creator;
    _IsNash = m._IsNash;
    _IsPerfect = m._IsPerfect;
    _IsProper = m._IsProper;
    _Epsilon = m._Epsilon;
    _GobitLambda = m._GobitLambda;
    _GobitValue = m._GobitValue;
    _LiapValue = m._LiapValue;
    _Id = m._Id;
  }
  return *this;
}

void MixedSolution::EvalEquilibria(void) const
{
  if(IsComplete())
    if(_IsNash == T_DONTKNOW)
      if(MaxRegret() <= _Epsilon)
	_IsNash = T_YES;
      else
	_IsNash = T_NO;
  if( _IsNash == T_NO )
    {
      _IsPerfect = T_NO;
      _IsProper = T_NO;
    }
}

unsigned int MixedSolution::Id(void) const
{return _Id;}
void MixedSolution::SetId(unsigned int i)
{_Id=i;}

void MixedSolution::SetCreator(NfgAlgType c)
{ _Creator = c; }

NfgAlgType MixedSolution::Creator(void) const
{ return _Creator; }

bool MixedSolution::IsComplete(void) const
{ 
  gNumber sum;
  for(int pl= 1; pl <=svlen.Length(); pl++) {
    sum = -1;
    for(int str = 1;str <= svlen[pl]; str++) 
      sum+= svptr[pl][str];
    if(sum > _Epsilon || sum < -_Epsilon) 
      return false;
  }
  return true;
}

void MixedSolution::SetIsNash(TriState i)
{ _IsNash = i; }

TriState MixedSolution::IsNash(void) const
{ this->EvalEquilibria(); return _IsNash; }

void MixedSolution::SetIsPerfect(TriState i)
{ _IsPerfect = i; }

TriState MixedSolution::IsPerfect(void) const
{ this->EvalEquilibria(); return _IsPerfect; }

void MixedSolution::SetIsProper(TriState i)
{ _IsProper = i; }

TriState MixedSolution::IsProper(void) const
{ this->EvalEquilibria(); return _IsProper; }


void MixedSolution::SetEpsilon(gNumber value)
{
  _Epsilon = value;
}

gNumber MixedSolution::Epsilon(void) const
{ return _Epsilon; }

void MixedSolution::SetGobit(gNumber lambda, gNumber value)
{
  _GobitLambda = lambda;
  _GobitValue = value;
}

gNumber MixedSolution::GobitLambda(void) const
{ return _GobitLambda; }

gNumber MixedSolution::GobitValue(void) const
{ return _GobitValue; }

void MixedSolution::SetLiap(gNumber value)
{ _LiapValue = value; }

gNumber MixedSolution::LiapValue(void) const 
{ 
  if(_LiapValue < 0)
    this->_LiapValue = MixedProfile<gNumber>::LiapValue();
  return _LiapValue; 
}

bool MixedSolution::Equals(const MixedProfile<double> &s) const
{ 
  gNumber eps;
  gEpsilon(eps,4);   // this should be a function of _Epsilon
  bool flag=true;
  int i=s.First();
  while(flag==true && i<=s.Length()) {
    if(abs((*this)[i]-s[i]) > eps) 
      flag=false;
    i++;
  }
  return flag;
}

bool MixedSolution::operator==(const MixedSolution & s) const
{ return MixedProfile<gNumber>::operator==(s); }

void MixedSolution::Dump(gOutput& f) const
{
  MixedProfile<gNumber>::Dump(f);
  f << " Creator:"; DisplayNfgAlgType(f, _Creator);
  f << " IsNash:"; DisplayTriState(f, _IsNash);
  f << " IsPerfect:"; DisplayTriState(f, _IsPerfect);
  f << " IsProper:"; DisplayTriState(f, _IsProper);
  f << " Support:" << Support();
  f << " GobitLambda:" << _GobitLambda;
  f << " GobitValue:" << _GobitValue;
  f << " LiapValue:" << _LiapValue;
}

gOutput &operator<<(gOutput &f, const MixedSolution &s)
{ s.Dump(f); return f; }


void MixedSolution::Invalidate(void)
{
  _Creator = NfgAlg_USER;
  _IsNash = T_DONTKNOW;
  _IsProper = T_DONTKNOW;
  _GobitLambda = -1;
  _GobitValue = -1;
  _LiapValue = -1;
}

gNumber& MixedSolution::operator[](int i)
{ Invalidate(); return MixedProfile<gNumber>::operator[](i); }

const gNumber& MixedSolution::operator[](int i) const
{ return MixedProfile<gNumber>::operator[](i); }

gNumber& MixedSolution::operator()(int a, int b)
{ Invalidate(); return MixedProfile<gNumber>::operator()(a, b); }

const gNumber& MixedSolution::operator()(int a, int b) const
{ return MixedProfile<gNumber>::operator()(a, b); }


