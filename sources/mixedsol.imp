//
// FILE: mixedsol.imp -- Mixed strategy profile classes
//
// $Id$
//

#include "assert.h"
#include "mixedsol.h"
#include "gmisc.h"

template <class T> 
MixedSolution<T>::MixedSolution(const Nfg<T>& n)
  : MixedProfile<T>(n),
  _Creator(NfgAlg_USER),
  _IsNash(T_DONTKNOW),
  _IsPerfect(T_DONTKNOW),
  _IsProper(T_DONTKNOW),
  _GobitLambda(-1),
  _GobitValue(-1),
  _LiapValue(-1),
	_Payoff(0),
	_Id(0)
{
	gEpsilon(_Epsilon);
}

template <class T>
MixedSolution<T>::MixedSolution(const Nfg<T>& n, const NFSupport& s)
: MixedProfile<T>(n, s),
	_Creator(NfgAlg_USER),
	_IsNash(T_DONTKNOW),
	_IsPerfect(T_DONTKNOW),
	_IsProper(T_DONTKNOW),
	_GobitLambda(-1),
	_GobitValue(-1),
	_LiapValue(-1),
	_Id(0)
{
	gEpsilon(_Epsilon);
}

template <class T>
MixedSolution<T>::MixedSolution(const Nfg<T>& n, const gPVector<T>& v)
: MixedProfile<T>(n, v),
	_Creator(NfgAlg_USER),
	_IsNash(T_DONTKNOW),
	_IsPerfect(T_DONTKNOW),
	_IsProper(T_DONTKNOW),
	_GobitLambda(-1),
	_GobitValue(-1),
	_LiapValue(-1),
	_Id(0)
{
	gEpsilon(_Epsilon);
}

template <class T>
MixedSolution<T>::MixedSolution(const MixedProfile<T>& m, NfgAlgType creator)
: MixedProfile<T>(m),
	_Creator(creator),
	_IsNash(T_DONTKNOW),
	_IsPerfect(T_DONTKNOW),
	_IsProper(T_DONTKNOW),
	_GobitLambda(-1),
	_GobitValue(-1),
	_LiapValue(-1),
	_Id(0)
{
	gEpsilon(_Epsilon);
}


template <class T> MixedSolution<T>::MixedSolution(const MixedSolution<T>& m)
: MixedProfile<T>(m),
	_Creator(m._Creator),
	_IsNash(m._IsNash),
	_IsPerfect(m._IsPerfect),
	_IsProper(m._IsProper),
	_Epsilon(m._Epsilon),
	_GobitLambda(m._GobitLambda),
	_GobitValue(m._GobitValue),
	_LiapValue(m._LiapValue),
	_Id(m._Id)
{}

template <class T> MixedSolution<T>::~MixedSolution() {}


template <class T> void MixedSolution<T>::EvalEquilibria()
{
  if(IsComplete())
    if(_IsNash == T_DONTKNOW)
      if(MaxRegret() <= _Epsilon)
	_IsNash = T_YES;
      else
	_IsNash = T_NO;
  if( _IsNash == T_NO )
    {
      _IsPerfect = T_NO;
      _IsProper = T_NO;
    }
}

template <class T> unsigned int MixedSolution<T>::Id(void) const
{return _Id;}
template <class T> void MixedSolution<T>::SetId(unsigned int i)
{_Id=i;}

template <class T> void MixedSolution<T>::SetCreator(NfgAlgType c)
{ _Creator = c; }

template <class T> NfgAlgType MixedSolution<T>::Creator(void) const
{ return _Creator; }

template <class T> bool MixedSolution<T>::IsComplete(void) const
{ 
  T sum;
  for(int pl= 1; pl <=svlen.Length(); pl++) {
    sum = -(T)1;
    for(int str = 1;str <= svlen[pl]; str++) 
      sum+= svptr[pl][str];
    if(sum > _Epsilon || sum < -_Epsilon) 
      return false;
  }
  return true;
}

template <class T> void MixedSolution<T>::SetIsNash(TriState i)
{ _IsNash = i; }

template <class T> TriState MixedSolution<T>::IsNash(void) const
{ ((MixedSolution<T> &) *this).EvalEquilibria(); return _IsNash; }

template <class T> void MixedSolution<T>::SetIsPerfect(TriState i)
{ _IsPerfect = i; }

template <class T> TriState MixedSolution<T>::IsPerfect(void) const
{ ((MixedSolution<T> &) *this).EvalEquilibria(); return _IsPerfect; }

template <class T> void MixedSolution<T>::SetIsProper(TriState i)
{ _IsProper = i; }

template <class T> TriState MixedSolution<T>::IsProper(void) const
{ ((MixedSolution<T> &) *this).EvalEquilibria(); return _IsProper; }


template <class T> void MixedSolution<T>::SetEpsilon(T value)
{
  _Epsilon = value;
}

template <class T> T MixedSolution<T>::Epsilon(void) const
{ return _Epsilon; }

template <class T> void MixedSolution<T>::SetGobit(T lambda, T value)
{
  _GobitLambda = lambda;
  _GobitValue = value;
}

template <class T> T MixedSolution<T>::GobitLambda(void) const
{ return _GobitLambda; }

template <class T> T MixedSolution<T>::GobitValue(void) const
{ return _GobitValue; }

template <class T> void MixedSolution<T>::SetLiap(T value)
{ _LiapValue = value; }

template <class T> T MixedSolution<T>::LiapValue(void) const 
{ 
  if(_LiapValue < (T)0)
    ((MixedSolution<T> &) *this)._LiapValue = MixedProfile<T>::LiapValue();
  return _LiapValue; 
}

template <class T> 
bool MixedSolution<T>::Equals(const MixedProfile<T> & s) const
{ 
  T eps;
  gEpsilon(eps,4);   // this should be a function of _Epsilon
  bool flag=true;
  int i=s.First();
  while(flag==true && i<=s.Length()) {
    if(abs((*this)[i]-s[i]) > eps) 
      flag=false;
    i++;
  }
  return flag;
}

template <class T> 
bool MixedSolution<T>::operator==(const MixedSolution<T> & s) const
{ return MixedProfile<T>::operator==(s); }

template <class T> void MixedSolution<T>::Dump(gOutput& f) const
{
  MixedProfile<T>::Dump(f);
  f << " Creator:"; DisplayNfgAlgType(f, _Creator);
  f << " IsNash:"; DisplayTriState(f, _IsNash);
  f << " IsPerfect:"; DisplayTriState(f, _IsPerfect);
  f << " IsProper:"; DisplayTriState(f, _IsProper);
  f << " Support:" << Support();
  f << " GobitLambda:" << _GobitLambda;
  f << " GobitValue:" << _GobitValue;
  f << " LiapValue:" << _LiapValue;
}

template <class T> gOutput &operator<<(gOutput &f, const MixedSolution<T> &s)
{ s.Dump(f); return f; }


template <class T> void MixedSolution<T>::Invalidate(void)
{
  _Creator = NfgAlg_USER;
  _IsNash = T_DONTKNOW;
  _IsProper = T_DONTKNOW;
  _GobitLambda = -1;
  _GobitValue = -1;
  _LiapValue = -1;
}

template <class T> T& MixedSolution<T>::operator[](int i)
{ Invalidate(); return MixedProfile<T>::operator[](i); }

template <class T> const T& MixedSolution<T>::operator[](int i) const
{ return MixedProfile<T>::operator[](i); }

template <class T> T& MixedSolution<T>::operator()(int a, int b)
{ Invalidate(); return MixedProfile<T>::operator()(a, b); }

template <class T> const T& MixedSolution<T>::operator()(int a, int b) const
{ return MixedProfile<T>::operator()(a, b); }

template <class T> 
MixedSolution<T>& MixedSolution<T>::operator=(const MixedProfile<T>& v)
{
  Invalidate();
  MixedProfile<T>::operator=(v);
  return *this;
}

template <class T> 
MixedSolution<T> &MixedSolution<T>::operator=(const gPVector<T>& v)
{
  Invalidate();
  gPVector<T>::operator=(v);
  return *this;
}

template <class T> 
MixedSolution<T>& MixedSolution<T>::operator=(const gVector<T>& v)
{
  assert(0);
  Invalidate();
  gPVector<T>::operator=(v);
  return *this;
}

template <class T> 
MixedSolution<T>& MixedSolution<T>::operator=(T x)
{ 
  assert(0); 
  Invalidate(); 
  gPVector<T>::operator=(x);
  return *this;
}

template <class T> 
MixedSolution<T>& MixedSolution<T>::operator+=(const gPVector<T>& v)
{ 
  Invalidate(); 
  gPVector<T>::operator+=(v);
  return *this;
}

template <class T> 
MixedSolution<T>& MixedSolution<T>::operator+=(const gVector<T>& v)
{
  assert(0);
  Invalidate();
  gVector<T>::operator+=(v);
  return *this;
}

template <class T> 
MixedSolution<T>& MixedSolution<T>::operator-=(const gPVector<T>& v)
{
  Invalidate(); 
  gPVector<T>::operator-=(v);
  return *this;
}

template <class T> 
MixedSolution<T>& MixedSolution<T>::operator-=(const gVector<T>& v)
{ 
  assert(0);
  Invalidate(); 
  gVector<T>::operator-=(v);
  return *this;
}

template <class T> MixedSolution<T>& MixedSolution<T>::operator*=(T x)
{
  Invalidate();
  gPVector<T>::operator*=(x);
  return *this;
}



