

#include "mixedsol.h"

template <class T> 
MixedSolution<T>::MixedSolution(const Nfg<T>& n, bool truncated)
: MixedProfile<T>(n, truncated),
  _Creator(id_USER),
  _IsNash(T_DONTKNOW),
  _IsProper(T_DONTKNOW),
  _GobitLambda(-1),
  _GobitValue(-1),
  _LiapValue(-1),
  _Payoff(0)
{}

template <class T> 
MixedSolution<T>::MixedSolution(const Nfg<T>& n, const NFSupport& s)
: MixedProfile<T>(n, s),
  _Creator(id_USER),
  _IsNash(T_DONTKNOW),
  _IsProper(T_DONTKNOW),
  _GobitLambda(-1),
  _GobitValue(-1),
  _LiapValue(-1)
{}

template <class T> 
MixedSolution<T>::MixedSolution(const Nfg<T>& n, const gPVector<T>& v)
: MixedProfile<T>(n, v),
  _Creator(id_USER),
  _IsNash(T_DONTKNOW),
  _IsProper(T_DONTKNOW),
  _GobitLambda(-1),
  _GobitValue(-1),
  _LiapValue(-1)
{}

template <class T> 
MixedSolution<T>::MixedSolution(const MixedProfile<T>& m, int creator)
: MixedProfile<T>(m),
  _Creator(creator),
  _IsNash(T_DONTKNOW),
  _IsProper(T_DONTKNOW),
  _GobitLambda(-1),
  _GobitValue(-1),
  _LiapValue(-1)
{}


template <class T> MixedSolution<T>::MixedSolution(const MixedSolution<T>& m)
: MixedProfile<T>(m), 
  _Creator(m._Creator),
  _IsNash(m._IsNash),
  _IsProper(m._IsProper),
  _GobitLambda(m._GobitLambda),
  _GobitValue(m._GobitValue),
  _LiapValue(m._LiapValue)
{}

template <class T> MixedSolution<T>::~MixedSolution() {}


template <class T> int MixedSolution<T>::Creator() const
{ return _Creator; }

template <class T> int MixedSolution<T>::IsNash()
{ 
  if( _IsNash == T_DONTKNOW )
    _IsNash = MixedProfile<T>::IsNash();
  return _IsNash; 
}

template <class T> int MixedSolution<T>::IsPerfect() const
{ 
  if(_Creator == id_LEMKE)
    return T_YES;
  else
    return T_DONTKNOW; 
}

template <class T> int MixedSolution<T>::IsProper() const
{ return _IsProper; }

template <class T> NFSupport MixedSolution<T>::Support() const
{ return stratset; }


template <class T> void MixedSolution<T>::SetGobit(T lambda, T value)
{
  _GobitLambda = lambda;
  _GobitValue = value;
}

template <class T> T MixedSolution<T>::GobitLambda() const
{ return _GobitLambda; }

template <class T> T MixedSolution<T>::GobitValue() const
{ return _GobitValue; }

template <class T> void MixedSolution<T>::SetLiap(T value)
{
  _LiapValue = value;
}

template <class T> T MixedSolution<T>::LiapValue() 
{ 
  if(_LiapValue < 0)
    _LiapValue = MixedProfile<T>::LiapValue();
  return _LiapValue; 
}

template <class T> 
bool MixedSolution<T>::operator==(const MixedSolution<T> & s) const
{
  return MixedProfile<T>::operator==(s);
}

template <class T> void MixedSolution<T>::Dump(gOutput& f) const
{
  MixedProfile<T>::Dump(f);
  f << " Creator:"; DisplayID(f, _Creator);
  f << " IsNash:"; DisplayTriState(f, _IsNash);
  f << " IsPerfect:"; DisplayTriState(f, IsPerfect());
  f << " IsProper:"; DisplayTriState(f, _IsProper);
  f << " Support:" << Support();
  f << " GobitLambda:" << _GobitLambda;
  f << " GobitValue:" << _GobitValue;
  f << " LiapValue:" << _LiapValue;
}

template <class T> gOutput &operator<<(gOutput &f, const MixedSolution<T> &s)
{ 
  s.Dump(f);  
  return f;
}
