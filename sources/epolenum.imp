//
// FILE: epolenum.imp -- Polynomial Nash Enum module for Extensive form games
//
// $Id$ 
//

#include "gwatch.h"
#include "efg.h"
#include "sfg.h"

#include "epolenum.h"
#include "quiksolv.h"
#include "odometer.h"

template <class T> class EfgPolEnumModule  {
private:
  T eps;
  const Efg &EF;
  const EFSupport &support;
  EfgPolEnumParams params;
  gSpace *Space;
  term_order *Lex;
  int num_vars;
  long count,nevals;
  double time;
  gList<BehavSolution> solutions;
  const Sfg SF;

//  bool EqZero(T x) const;
  
  // p_i_j as a gPoly, eliminating the last variable for 
  // each information set, and satisfying the adding up 
  // constraints of the sequence form strategies
  gPoly<T> Prob(int pl,int seq) const;
  double Prob(int pl,int seq, const gVector<gDouble> &x) const;

  // Payoff to player pl, after eliminating last variable for 
  // each infoset.  
  gPoly<T> Payoff(int pl) const;

  // equation for when player i sets strat1 = strat2
  // with last probs for each player substituted out.  
//  gPoly<T> Equation(int i, int strat2, int strat2) const;

  int SaveSolutions(const gList<gVector<gDouble> > &list);
  bool ExtendsToNash(BehavSolution &);
public:
  EfgPolEnumModule(const EFSupport &, const EfgPolEnumParams &p);
  ~EfgPolEnumModule();

  int EfgPolEnum(void);
  
  long NumEvals(void) const;
  double Time(void) const;

//  void SequentialEquilibrium(const EFSupport &B, const EFBasis &b); 
  
  EfgPolEnumParams &Parameters(void);
//   void SequenceForm(const Node *, gNumber,gArray<int>, gArray<int>);

  const gList<BehavSolution> &GetSolutions(void) const;
};

//-------------------------------------------------------------------------
//                    EfgPolEnumModule<T>: Member functions
//-------------------------------------------------------------------------

template <class T>
EfgPolEnumModule<T>::EfgPolEnumModule(const EFSupport &S,
				      const EfgPolEnumParams &p)
  : EF(S.Game()), support(S), params(p), count(0), nevals(0), SF(S)
{ 
//  gEpsilon(eps,12);

  if(params.trace>1) {
    (*params.tracefile) << "\nNumSequences: " << support.TotalNumSequences();
    SF.Dump(*(params.tracefile));
  }
  num_vars = SF.TotalNumSequences()-SF.TotalNumInfosets()-SF.NumPlayers();

  // gout << "\nNumSequences(): " << SF.NumSequences();
  // gout << "\nNumInfosets(): " << SF.NumInfosets();
  // gout << "\nnum_vars, TotNumSequences, TotNumInfosets, NumPlayers: " << num_vars << " " << SF.TotalNumSequences() << " " << SF.TotalNumInfosets() << " " << SF.NumPlayers();

  Space = new gSpace(num_vars);
  Lex = new term_order(Space, lex);
}

template <class T>
EfgPolEnumModule<T>::~EfgPolEnumModule()
{ 
  delete Lex;
  delete Space;
}

template <class T> int EfgPolEnumModule<T>::EfgPolEnum(void)
{
  int i,j;


  gWatch watch;
  gPolyList<T> equations(Space,Lex);

  // equations for equality of strat j to strat j+1

  int kk=0;
  for( i=1;i<=SF.NumPlayers();i++) {
    int n_vars=SF.NumSequences(i)-SF.NumInfosets()[i]-1; 
    for(j=1;j<=n_vars;j++) 
      equations+=(Payoff(i)).PartialDerivative(kk+j);
    kk+=n_vars;
  }

  for( i=1;i<=SF.NumPlayers();i++) 
    for(j=2;j<=SF.NumSequences(i);j++) 
      if(SF.ActionNumber(i,j)==support.NumActions(i,SF.InfosetNumber(i,j)) 
	 && SF.ActionNumber(i,j)>1) 
	equations+=Prob(i,j);
      
  // set up the rectangle of search
  gVector<T> bottoms(num_vars), tops(num_vars);
  bottoms = (T)0;
  tops = (T)1;
 
  gRectangle<T> Cube(bottoms, tops); 

  // start QuikSolv
  gWatch timer;
  timer.Start();

  QuikSolv<T> quickie(equations, params.status);
  if(params.trace>0) {
    (*params.tracefile) << "\nThe equilibrium equations are \n" 
      << quickie.UnderlyingEquations() ;
  }  

  // 2147483647 = 2^31-1 = MaxInt

  if(quickie.FindCertainNumberOfRoots(Cube,2147483647,params.stopAfter)) {
    if(params.trace>0) {
      (*params.tracefile) << "\nThe system has the following roots in [0,1]^"
	<< num_vars << " :\n" << quickie.RootList();
    }
  }
  else
    if(params.trace>0) {
      (*params.tracefile) << "The system\n" << quickie.UnderlyingEquations()
	<< " could not be resolved by FindRoots.\n";
    }
  timer.Stop();
  if(params.trace>0) {
    (*params.tracefile)  << "The QuikSolv computation of roots took " 
      << (int)timer.Elapsed() << " seconds.\n\n";
  }

  int index = SaveSolutions(quickie.RootList());
  time = watch.Elapsed();
  return index;	 
}

template <class T> bool 
EfgPolEnumModule<T>::ExtendsToNash(BehavSolution &/*bs*/)
{
  return true;
}

template <class T> int 
EfgPolEnumModule<T>::SaveSolutions(const gList<gVector<gDouble> > &list)
{

  int i,j,k,index=0;
  gPVector<double> x(SF.NumSequences());

  for(k=1;k<=list.Length();k++) {

    for(i=1;i<=EF.NumPlayers();i++) 
      for(j=1;j<=SF.NumSequences()[i];j++)
	x(i,j) = Prob(i,j,list[k]);
    if(params.trace > 1) 
      (*params.tracefile) << "\nk: " << k << " x: " << x;

    BehavSolution sol(SF.ToBehav(x), EfgAlg_POLENUM);
    if(ExtendsToNash(sol)) {
      index = solutions.Append(sol);
      solutions[index].SetEpsilon(0);
      solutions[index].SetIsNash(triTRUE);
    }
  }

  return index;
}


/*
template <class T> bool EfgPolEnumModule<T>::EqZero(T x) const
{
  if(x <= eps && x >= -eps) return 1;
  return 0;
}     
*/

template <class T> long EfgPolEnumModule<T>::NumEvals(void) const
{
  return nevals;
}

template <class T> double EfgPolEnumModule<T>::Time(void) const
{
  return time;
}

template <class T> EfgPolEnumParams &EfgPolEnumModule<T>::Parameters(void)
{
  return params;
}

template <class T>
const gList<BehavSolution> &EfgPolEnumModule<T>::GetSolutions(void) const
{
  return solutions;
}

template <class T> double EfgPolEnumModule<T>::
Prob(int p,int seq, const gVector<gDouble> &x) const
{
  int i,j,kk = 0;
  double value=0;

  for(i=1;i<p;i++) 
    kk+=(SF.NumSequences(i)-SF.NumInfosets()[i]-1);

  int iset = SF.InfosetNumber(p,seq);
  int act  = SF.ActionNumber(p,seq);

  if(seq==1)
    return (double)1;
  else if(act<support.NumActions(p,iset))
    return x[kk+seq-iset].ToDouble();
  else {    
    for(j=1;j<seq;j++) {
      if((SF.Constraints(p))(iset+1,j)==-(gNumber)1)
	value-=Prob(p,j,x);
      if((SF.Constraints(p))(iset+1,j)==(gNumber)1)
	value+=Prob(p,j,x);
    }
    return value;
  }
}

template <class T> gPoly<T> EfgPolEnumModule<T>::Prob(int p, int seq) const
{
  gPoly<T> equation(Space,Lex);
  gVector<int> exps(num_vars);
  int i,j,kk = 0;
  
  // gout << "\nin Prob(), i,j: " << p << " " << seq;
  // gout << " num_vars: " << num_vars; 
  for(i=1;i<p;i++) 
    kk+=(SF.NumSequences(i)-SF.NumInfosets()[i]-1);

  int iset = SF.InfosetNumber(p,seq);
  int act  = SF.ActionNumber(p,seq);

  if(seq==1) {
    exps=0;
    exp_vect const_exp(Space,exps);
    gMono<T> const_term((T)1,const_exp);
    gPoly<T> new_term(Space,const_term,Lex);
    equation+=new_term;
  }
  else if(act<support.NumActions(p,iset)) {
    exps=0;
    exps[kk+seq-iset]=1;
    exp_vect const_exp(Space,exps);
    gMono<T> const_term((T)1,const_exp);
    gPoly<T> new_term(Space,const_term,Lex);
    equation+=new_term;
  }
  else {
    for(j=1;j<seq;j++) {
      if((SF.Constraints(p))(iset+1,j)==(gNumber)-1)
	equation-=Prob(p,j);
      if((SF.Constraints(p))(iset+1,j)==(gNumber)1)
	equation+=Prob(p,j);
    }
  }
  return equation;
}

template <class T> gPoly<T> 
EfgPolEnumModule<T>::Payoff(int pl) const
{
  gIndexOdometer index(SF.NumSequences());
  gNumber pay;

  gPoly<T> equation(Space,Lex);
  while (index.Turn()) {
    pay=SF.Payoff(index.CurrentIndices(),pl);
    if( pay !=(gNumber)0) {
      gPoly<T> term(Space,(T)pay,Lex);
      int k;
      for(k=1;k<=EF.NumPlayers();k++) 
	term*=Prob(k,(index.CurrentIndices())[k]);
      equation+=term;
    }
  }
  if(params.trace >1)
    (*params.tracefile) << "\nPayoff( " << pl << "): " << equation;
  return equation;
}


/*

template <class T> gPoly<T> 
EfgPolEnumModule<T>::Equation(int i, int strat1, int strat2) const
{
  StrategyProfile profile(EF);

  EfgContIter A(support), B(support);
  A.Freeze(i);
  A.Set(i, strat1);
  B.Freeze(i);
  B.Set(i, strat2);
  gPoly<T> equation(Space,Lex);
  do {
    gPoly<T> term(Space,(T)1,Lex);
    profile = A.Profile();
    int k;
    for(k=1;k<=EF.NumPlayers();k++) 
      if(i!=k) 
	term*=Prob(k,support.Find(profile[k]));
    T coeff,ap,bp;
    ap = (T)EF.Payoff(A.GetOutcome(), i).Evaluate(values);
    bp = (T)EF.Payoff(B.GetOutcome(), i).Evaluate(values);
    coeff = ap - bp;
    term*=coeff;
    equation+=term;
    A.NextContingency();
  } while (B.NextContingency());
  return equation;
}
*/
