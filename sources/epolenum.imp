//
// FILE: epolenum.imp -- Polynomial Nash Enum module for Extensive form games
//
// $Id$
//

#include "gwatch.h"
#include "efg.h"
#include "sfg.h"

#include "epolenum.h"
#include "quiksolv.h"
#include "odometer.h"

template <class T> class EfgPolEnumModule  {
private:
  T eps;
  const Efg &EF;
  const EFSupport &support;
  EfgPolEnumParams params;
  gSpace *Space;
  term_order *Lex;
  int num_vars;
  long count,nevals;
  double time;
  gList<BehavSolution> solutions;
  const Sfg SF;
  bool is_singular;
  gArray<gArray<int> * > var;

  // The strategy is to develop the polynomial for each agent's expected
  // payoff as a function of the behavior strategies on the support,
  // eliminating the last last action probability for each information set.
  // The system is obtained by requiring that all of the partial
  // derivatives vanish, and that the sum of action probabilities at
  // each information set be less than one.
  gPoly<T>     ProbOfSequence(int pl,int seq)          const;
  gPoly<T>     Payoff(int pl)                          const;
  gPolyList<T> IndifferenceEquations()                 const;
  gPolyList<T> LastActionProbPositiveInequalities()    const;
  gPolyList<T> NashOnSupportEquationsAndInequalities() const;
  gList<gVector<gDouble> > 
               NashOnSupportSolnVectors(const gPolyList<T> &equations,
					const gRectangle<T> &Cube,
					gWatch &timer,
					gStatus &p_status);

  // Pass to the sequence form variables from the solution variables
  double NumProbOfSequence(int pl,int seq, const gVector<gDouble> &x) const;
  gPVector<double> SeqFormVectorFromSolFormVector(const gVector<gDouble> &x)
                                                                      const;

  bool ExtendsToANFNash(const BehavSolution &, gStatus &)             const;
  int SaveANFNashSolutions(const gList<gVector<gDouble> > &list, gStatus &);
  bool ExtendsToNash(const BehavSolution &, gStatus &)                const;
  int SaveNashSolutions(const gList<gVector<gDouble> > &list, gStatus &);

public:
  EfgPolEnumModule(const EFSupport &, const EfgPolEnumParams &p);
  ~EfgPolEnumModule();

  int EfgPolEnum(gStatus &);

  EfgPolEnumParams &Parameters(void);
  long             NumEvals(void)   const;
  double           Time(void)       const;
  bool             IsSingular(void) const;

  const gList<BehavSolution> &GetSolutions(void) const;
};

//-------------------------------------------------------------------------
//                    EfgPolEnumModule<T>: Member functions
//-------------------------------------------------------------------------

template <class T>
EfgPolEnumModule<T>::EfgPolEnumModule(const EFSupport &S,
				      const EfgPolEnumParams &p)
  : EF(S.Game()), support(S), params(p), count(0), nevals(0), SF(S),
    is_singular(false), var(S.Game().NumPlayers())
{ 
//  gEpsilon(eps,12);

  if(params.trace>1) {
    (*params.tracefile) << "\nNumSequences: " << support.TotalNumSequences();
    SF.Dump(*(params.tracefile));
  }
  num_vars = SF.TotalNumSequences()-SF.NumPlayerInfosets()-SF.NumPlayers();

  Space = new gSpace(num_vars);
  Lex = new term_order(Space, lex);

  int kk=0;
  int tnv = 0;

  for(int i=1;i<=EF.NumPlayers();i++) {
    var[i] = new gArray<int>(SF.NumSequences(i));
    (*(var[i]))[1] = 0;
    for(int seq = 2;seq<=SF.NumSequences(i);seq++) {
      int act  = SF.ActionNumber(i,seq);
      if(act<support.NumActions(SF.GetInfoset(i,seq)))
	(*(var[i]))[seq] = ++tnv;
      else
	(*(var[i]))[seq] = 0;

    }
    kk+=(SF.NumSequences(i)-SF.NumInfosets(i)-1);
  }
  assert(tnv==num_vars);
}

template <class T>
EfgPolEnumModule<T>::~EfgPolEnumModule()
{ 
  for(int i=1;i<=EF.NumPlayers();i++)
    delete var[i];
  delete Lex;
  delete Space;
}

template <class T> 
gPoly<T> EfgPolEnumModule<T>::ProbOfSequence(int p, int seq) const
{
  gPoly<T> equation(Space,Lex);
  gVector<int> exps(num_vars);
  int j = 0;
  
  int isetrow = SF.InfosetRowNumber(p,seq);
  int act  = SF.ActionNumber(p,seq);
  int varno = (*(var[p]))[seq];

  if(seq==1) {
    exps=0;
    exp_vect const_exp(Space,exps);
    gMono<T> const_term((T)1,const_exp);
    gPoly<T> new_term(Space,const_term,Lex);
    equation+=new_term;
  }
  else if(act<support.NumActions(SF.GetInfoset(p,seq))) { 
    assert (varno>=exps.First());
    assert (varno<=exps.Last());
    exps=0;
    exps[varno]=1;
    exp_vect const_exp(Space,exps);
    gMono<T> const_term((T)1,const_exp);
    gPoly<T> new_term(Space,const_term,Lex);
    equation+=new_term;
  }
  else {
    for(j=1;j<seq;j++) {
      if((SF.Constraints(p))(isetrow,j)==(gNumber)-1)
	equation-=ProbOfSequence(p,j);
      if((SF.Constraints(p))(isetrow,j)==(gNumber)1)
	equation+=ProbOfSequence(p,j);
    }
  }
  return equation;
}

template <class T> gPoly<T> 
EfgPolEnumModule<T>::Payoff(int pl) const
{
  gIndexOdometer index(SF.NumSequences());
  gNumber pay;

  gPoly<T> equation(Space,Lex);
  while (index.Turn()) {
    pay=SF.Payoff(index.CurrentIndices(),pl);
    if( pay !=(gNumber)0) {
      gPoly<T> term(Space,(T)pay,Lex);
      int k;
      for(k=1;k<=EF.NumPlayers();k++) 
	term*=ProbOfSequence(k,(index.CurrentIndices())[k]);
      equation+=term;
    }
  }
  if(params.trace >1)
    (*params.tracefile) << "\nPayoff( " << pl << "): " << equation;
  return equation;
}

template <class T>  
gPolyList<T> EfgPolEnumModule<T>::IndifferenceEquations() const
{
  gPolyList<T> equations(Space,Lex);

  int kk = 0;
  for (int pl = 1; pl <= SF.NumPlayers(); pl++) {
    gPoly<T> payoff = Payoff(pl);
    int n_vars = SF.NumSequences(pl) - SF.NumInfosets(pl) - 1; 
    for (int j = 1; j <= n_vars; j++) 
      equations += payoff.PartialDerivative(kk+j);
    kk+=n_vars;
  }

  return equations;
}

template <class T>  
gPolyList<T> EfgPolEnumModule<T>::LastActionProbPositiveInequalities() const
{
  gPolyList<T> equations(Space,Lex);

  for (int i = 1; i <= SF.NumPlayers(); i++) 
    for (int j = 2; j <= SF.NumSequences(i); j++) {
      int act_num = SF.ActionNumber(i,j);
      if ( act_num == support.NumActions(SF.GetInfoset(i,j)) && act_num > 1 ) 
	equations += ProbOfSequence(i,j);
    }

  return equations;
}

template <class T>  
gPolyList<T> EfgPolEnumModule<T>::NashOnSupportEquationsAndInequalities() const
{
  gPolyList<T> equations(Space,Lex);
  
  equations += IndifferenceEquations();
  equations += LastActionProbPositiveInequalities();

  return equations;
}


template <class T> gList<gVector<gDouble> > 
EfgPolEnumModule<T>::NashOnSupportSolnVectors(const gPolyList<T> &equations,
					      const gRectangle<T> &Cube,
					      gWatch &timer,
					      gStatus &p_status)
{
  QuikSolv<T> quickie(equations, p_status);
  if(params.trace>0) {
    (*params.tracefile) << "\nThe equilibrium equations are \n" 
      << quickie.UnderlyingEquations() ;
  }  

  // 2147483647 = 2^31-1 = MaxInt

  try {
    if(quickie.FindCertainNumberOfRoots(Cube,2147483647,params.stopAfter)) {
      if(params.trace>0) {
	(*params.tracefile) << "\nThe system has the following roots in [0,1]^"
			    << num_vars << " :\n" << quickie.RootList();
      }
    }
    else
      if(params.trace>0) {
	(*params.tracefile) << "The system\n" << quickie.UnderlyingEquations()
			    << " could not be resolved by FindRoots.\n";
      }
    timer.Stop();
    if(params.trace>0) {
      (*params.tracefile)  << "The QuikSolv computation of roots took " 
			   << (int)timer.Elapsed() << " seconds.\n\n";
    }
  }
  catch (gSignalBreak &) { }
  catch (gSquareMatrix<gDouble>::MatrixSingular) {
    is_singular = true;
  }
  
  return quickie.RootList();
}

template <class T> int EfgPolEnumModule<T>::EfgPolEnum(gStatus &p_status)
{
  gPolyList<T> equations = NashOnSupportEquationsAndInequalities();

  // set up the rectangle of search
  gVector<T> bottoms(num_vars), tops(num_vars);
  bottoms = (T)0;
  tops = (T)1;
  gRectangle<T> Cube(bottoms, tops); 

  // timing
  gWatch watch;
  gWatch timer;
  timer.Start();

  gList<gVector<gDouble> > solutionlist = NashOnSupportSolnVectors(equations,
								   Cube,
								   timer,
								   p_status);

  int index = SaveNashSolutions(solutionlist, p_status);
  time = watch.Elapsed();
  return index;	 
}

template <class T> gPVector<double> 
EfgPolEnumModule<T>::SeqFormVectorFromSolFormVector(const gVector<gDouble> &v)
                                                                      const
{
  gPVector<double> x(SF.NumSequences());

  for (int i = 1; i <= EF.NumPlayers(); i++) 
    for (int j = 1; j <= SF.NumSequences()[i]; j++)
      x(i,j) = NumProbOfSequence(i,j,v);
  
  return x;
}

template <class T> bool 
EfgPolEnumModule<T>::ExtendsToANFNash(const BehavSolution &bs, 
				            gStatus &m_status) const
{
  return bs.ExtendsToANFNash(bs.Support(),bs.Support(),m_status);
}

template <class T> int 
EfgPolEnumModule<T>::SaveANFNashSolutions(const gList<gVector<gDouble> > &list,
					  gStatus &p_status)
{
  int index=0;
  for (int k = 1; k <= list.Length(); k++) {
    gPVector<double> y = SeqFormVectorFromSolFormVector(list[k]);

    if(params.trace > 1) 
      (*params.tracefile) << "\nk: " << k << " y: " << y;

    BehavSolution sol(SF.ToBehav(y), algorithmEfg_POLENUM_EFG);

    if(ExtendsToNash(sol,p_status)) { 
      index = solutions.Append(sol);
      solutions[index].SetEpsilon(0);
      //    solutions[index].SetIsNash(triTRUE);
    }
  }
  return index;
}

template <class T> bool 
EfgPolEnumModule<T>::ExtendsToNash(const BehavSolution &bs, 
				            gStatus &m_status) const
{
  return bs.ExtendsToNash(bs.Support(),bs.Support(),m_status);
}

template <class T> int 
EfgPolEnumModule<T>::SaveNashSolutions(const gList<gVector<gDouble> > &list,
				       gStatus &p_status)
{
  int index=0;
  for (int k = 1; k <= list.Length(); k++) {
    gPVector<double> y = SeqFormVectorFromSolFormVector(list[k]);

    if(params.trace > 1) 
      (*params.tracefile) << "\nk: " << k << " y: " << y;

    BehavSolution sol(SF.ToBehav(y), algorithmEfg_POLENUM_EFG);

    if(ExtendsToNash(sol,p_status)) { 
      index = solutions.Append(sol);
      solutions[index].SetEpsilon(0);
    }
  }
  return index;
}


template <class T> long EfgPolEnumModule<T>::NumEvals(void) const
{
  return nevals;
}

template <class T> double EfgPolEnumModule<T>::Time(void) const
{
  return time;
}

template <class T> bool EfgPolEnumModule<T>::IsSingular(void) const
{
  return is_singular;
}

template <class T> EfgPolEnumParams &EfgPolEnumModule<T>::Parameters(void)
{
  return params;
}

template <class T>
const gList<BehavSolution> &EfgPolEnumModule<T>::GetSolutions(void) const
{
  return solutions;
}

template <class T> double EfgPolEnumModule<T>::
NumProbOfSequence(int p,int seq, const gVector<gDouble> &x) const
{
  int j = 0;
  double value=0;

  int isetrow = SF.InfosetRowNumber(p,seq);
  int act  = SF.ActionNumber(p,seq);
  int varno = (*(var[p]))[seq];

  if(seq==1)
    return (double)1;
  else if(act<support.NumActions(SF.GetInfoset(p,seq)))
    return x[varno].ToDouble();
  else {    
    for(j=1;j<seq;j++) {
      if((SF.Constraints(p))(isetrow,j)==-(gNumber)1)
	value-=NumProbOfSequence(p,j,x);
      if((SF.Constraints(p))(isetrow,j)==(gNumber)1)
	value+=NumProbOfSequence(p,j,x);
    }
    return value;
  }
}




