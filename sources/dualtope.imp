//
// FILE: dualtope.imp
//
// $Id$
//

//#include <stdio.h>
//#include <iostream.h>
#include "dualtope.h"

//------------------------------------------------------------------------
//     gHalfSpc: Constructors, destructor, constructive operators
//------------------------------------------------------------------------

template <class T> gHalfSpc<T>::gHalfSpc(const gSpace* space, 
					 const T& constant, 
					 const gVector<T>& normalvector)
: Space(space), 
  Constant(constant), 
  NormalVector(normalvector)
{
  assert(NormalVector.Length() == Dmnsn());
}

template <class T> gHalfSpc<T>::gHalfSpc(const gHalfSpc<T>& given)
: Space(given.Space), 
  Constant(given.Constant),
  NormalVector(given.NormalVector)
{
}

template <class T> gHalfSpc<T>::~gHalfSpc()
{
}

//------------------------------------------------------------------------
//     gHalfSpc: Information
//------------------------------------------------------------------------

template <class T> const gSpace* gHalfSpc<T>::TheSpace() const
{
  return Space;
}

template <class T> const int gHalfSpc<T>::Dmnsn() const
{
  return Space->Dmnsn();
}

template <class T> const gVector<T> gHalfSpc<T>::NormalVect() const
{
  return NormalVector;
}

template <class T> const T gHalfSpc<T>::Coefficient(const int& i) const
{
  assert (1 <= i && i <= Dmnsn());
  return NormalVector[i];
}

template <class T> const T gHalfSpc<T>::BoundaryValue() const
{
  return Constant;
}

//------------------------------------------------------------------------
//     gHalfSpc: Operators
//------------------------------------------------------------------------

template <class T> 
bool gHalfSpc<T>::operator == (const gHalfSpc<T>& rhs) const
{
  return (Constant == rhs.Constant && NormalVector == rhs.NormalVector);
}

template <class T> 
bool gHalfSpc<T>::operator != (const gHalfSpc<T>& rhs) const
{
  return !(*this == rhs);
}

//------------------------------------------------------------------------
//     gHalfSpc: Printing
//------------------------------------------------------------------------


template <class T> gOutput &operator<<(gOutput& f, const gHalfSpc<T>& h)
{
  assert (h.NormalVector.Length() >= 1);

  f << h.NormalVector[1] << "n1";
  for (int i = 2; i <= h.Dmnsn(); i++) 
    f << " + " << h.NormalVector[i] << "n" << i;
  f << " >= " << h.Constant;
  return f;
}

/* *********************** gDualTope ********************** */

//------------------------------------------------------------------------
//     gDualTope: Constructors, destructor, constructive operators
//------------------------------------------------------------------------

template <class T> 
gDualTope<T>::gDualTope(const gSpace* space, 
			const gList<gHalfSpc<T> >& list)
: Space(space), Inequalities(minimallist(list)), Nonempty(isnonempty())
{
  for (int i = 1; i <= Inequalities.Length(); i++)
    assert (Inequalities[i].TheSpace() == Space);
}

template <class T> 
gDualTope<T>::gDualTope(const gSpace* space, 
			const gRectangle<T>& r)
: Space(space), Inequalities(listfromrectangle(r)), Nonempty(isnonempty())
{
  assert (r.Dmnsn() == Dmnsn());
}

template <class T> gDualTope<T>::gDualTope(const gDualTope<T>& given)
: Space(given.Space), 
  Inequalities(given.Inequalities),
  Nonempty(given.Nonempty)
{
}

template <class T> gDualTope<T>::~gDualTope()
{
}

//------------------------------------------------------------------------
//     gDualTope: Initial Computations
//------------------------------------------------------------------------

template <class T> const bool gDualTope<T>::isnonempty() const
{
  gMatrix<T> A(NumberOfFacets(),Dmnsn()+1);
  for (int i = 1; i <= NumberOfFacets(); i++) {
    for (int j = 1; j <= Dmnsn(); j++) 
      A(i,j) = -Inequalities[i].Coefficient(j);
    A(i,Dmnsn() + 1) = (T)-1;
  }

  gVector<T> B(NumberOfFacets());
  for (int k = 1; k <= NumberOfFacets(); k++)
    B[k] = -Inequalities[k].BoundaryValue();

  gVector<T> C(Dmnsn() + 1);
  for (int m = 1; m <= Dmnsn(); m++)
    C[m] = (T)0;
  C[Dmnsn() + 1] = (T)1;

  gLPTableau2<T> testlp(A,B,C);
  assert (testlp.IsFeasible());

  if (!testlp.IsBounded() || testlp.OptimumCost() <= (T)0)
    return true; 
  else 
    return false;
}

template <class T> const gList<gHalfSpc<T> > 
gDualTope<T>::minimallist(const gList<gHalfSpc<T> >& list) const
{
  gList<gHalfSpc<T> > newlist(list);
  int index = 1;

  while (index <= newlist.Length()) {

    gMatrix<T> A(newlist.Length() - 1,Dmnsn());
    for (int j = 1; j <= Dmnsn(); j++) {
      for (int i = 1; i < index; i++) 
	A(i,j) =   -newlist[i].Coefficient(j);
      for (int i = index+1; i <= newlist.Length(); i++) 
        A(i-1,j) = -newlist[i].Coefficient(j);
    } 

    gVector<T> B(newlist.Length()-1);
    for (int k = 1; k < index; k++)
      B[k] =   -newlist[k].BoundaryValue();
    for (int k = index+1; k <= newlist.Length(); k++)
      B[k-1] = -newlist[k].BoundaryValue();

    gVector<T> C(newlist[index].NormalVect());

    gLPTableau2<T> testlp(A,B,C);

    if (!testlp.IsFeasible()) return newlist;

    if (!testlp.IsBounded() || 
	testlp.OptimumCost() < newlist[index].BoundaryValue())
      index++;
    else
      newlist.Remove(index);
  }

  return newlist;
}

template <class T> const gList<gHalfSpc<T> > 
gDualTope<T>::listfromrectangle(const gRectangle<T>& r) const
{
  gList<gHalfSpc<T> > newlist;

  for (int i = 1; i <= Dmnsn(); i++) {

    gVector<T> up(Dmnsn());
    for (int j = 1; j <= Dmnsn(); j++) up[j] = (T)0;
    up[i] = (T)1;
    T lowerbound = r.LowerBound()[i];
    newlist += gHalfSpc<T>(Space,lowerbound,up);

    gVector<T> down(Dmnsn());
    for (int j = 1; j <= Dmnsn(); j++) down[j] = (T)0;
    down[i] = (T)-1;
    T upperbound = r.UpperBound()[i];
    newlist += gHalfSpc<T>(Space,-upperbound,down);
  }

  return newlist;
}

//------------------------------------------------------------------------
//     gDualTope: Operators
//------------------------------------------------------------------------

template <class T> 
bool gDualTope<T>::operator == (const gDualTope<T>& rhs) const
{
  return (Inequalities == rhs.Inequalities);
}

template <class T> 
bool gDualTope<T>::operator != (const gDualTope<T>& rhs) const
{
  return !(*this == rhs);
}

//------------------------------------------------------------------------
//     gDualTope: Information
//------------------------------------------------------------------------

template <class T> const int gDualTope<T>::Dmnsn() const
{
  return Space->Dmnsn();
}

template <class T> const int gDualTope<T>::NumberOfFacets() const
{
  return Inequalities.Length();
}

template <class T> const bool gDualTope<T>::IsNonempty() const
{
  return Nonempty;
}

template <class T> const gDualTope<T> 
gDualTope<T>::IntersectedWith(const gDualTope<T>& that) const
{
  return gDualTope<T>(Space,this->Inequalities + that.Inequalities);
}

template <class T> 
const gRectangle<T> gDualTope<T>::BoundingRectangle() const
{
  gVector<T> lowerbds(Dmnsn());
  gVector<T> upperbds(Dmnsn());

  gMatrix<T> A(NumberOfFacets(),Dmnsn());
  for (int j = 1; j <= NumberOfFacets(); j++)
    for (int k = 1; k <= Dmnsn(); k++)
      A(j,k) = -Inequalities[j].Coefficient(k);

  gVector<T> B(NumberOfFacets());
  for (int j = 1; j <= NumberOfFacets(); j++)
    B[j] = -Inequalities[j].BoundaryValue();

  for (int i = 1; i <= Dmnsn(); i++) {
    gVector<T> C(Dmnsn());
    for (int m = 1; m <= Dmnsn(); m++)
      C[m] = (T)0;

    C[i] = (T)-1;
    gLPTableau2<T> upbound(A,B,C);
    assert(upbound.IsBounded());
    upperbds[i] = -upbound.OptimumCost();

    C[i] = (T)1;
    gLPTableau2<T> dnbound(A,B,C);
    assert(dnbound.IsBounded());
    lowerbds[i] = dnbound.OptimumCost();
  }

  return gRectangle<T>(lowerbds,upperbds);
}

//------------------------------------------------------------------------
//     gDualTope: Printing
//------------------------------------------------------------------------


template <class T> gOutput &operator<<(gOutput& f, const gDualTope<T>& p)
{
  for (int i = 1; i <= p.Inequalities.Length(); i++) 
    f << p.Inequalities[i] << "\n";
  return f;
}
