//
// FILE: nfg.imp -- Implementation of typed normal form
//
// $Id$
//

#include "nfg.h"
#include "nfplayer.h"
#include "nfstrat.h"


//---------------------------------------------------------------
// NFG: Constructors, Destructor, Operators
//---------------------------------------------------------------

template <class T> Nfg<T>::Nfg(const gArray<int> &dim)
  : BaseNfg(dim), payoffs(1, dim.Length())
{
  gVector<T> zeroes(dim.Length());
  zeroes = (T) 0;
  payoffs.SetRow(1, zeroes);
}

template <class T> Nfg<T>::Nfg(const Nfg<T> &N)
  : BaseNfg(N), payoffs(N.payoffs)
{ }

template <class T> Nfg<T>::~Nfg()
{ }


//------------------------
// Nfg: Member Functions
//------------------------

template <class T> bool Nfg<T>::IsConstSum(void) const
{
  int pl, index;
  T cvalue = (T) 0;
  T eps;
  gEpsilon(eps);

  for (pl = 1; pl <= players.Length(); pl++)
    cvalue += payoffs(1, pl);
  
  for (index = 2; index <= payoffs.NumRows(); index++)  {
    T thisvalue = (T) 0;

    for (pl = 1; pl <= players.Length(); pl++)
      thisvalue += payoffs(index, pl);

    if (thisvalue > cvalue + eps || thisvalue < cvalue - eps)
      return false;
  }
  
  return true;
}

template <class T> T Nfg<T>::MinPayoff(int pl) const
{
  int index, p, p1, p2;
  T minpay;
  
  if(pl) { p1=p2=pl;}
  else {p1=1;p2=players.Length();}

  minpay = payoffs(1, p1);
  for (index = 2; index <= payoffs.NumRows(); index++)  {
    for (p = p1; p <= p2; p++)
      if (payoffs(index, p) < minpay)
	minpay = payoffs(index, p);
  }
  return minpay;
}

template <class T> T Nfg<T>::MaxPayoff(int pl) const
{
  int index, p, p1, p2;
  T maxpay;

  if(pl) { p1=p2=pl;}
  else {p1=1;p2=players.Length();}

  maxpay = payoffs(1, p1);
  for (index = 2; index <= payoffs.NumRows(); index++)  {
    for (p = p1; p <= p2; p++)
      if (payoffs(index, p) > maxpay)
	maxpay = payoffs(index, p);
  }
  return maxpay;
}

template <class T> NFOutcome *Nfg<T>::NewOutcome(void)
{
  NFOutcome *outcome = new NFOutcome(outcomes.Length() + 1);
  outcomes.Append(outcome);

  gVector<T> zeroes(NumPlayers());
  zeroes = (T) 0;
  payoffs.AddRow(zeroes);

  return outcome;
}
  
template <class T> void Nfg<T>::SetPayoff(NFOutcome *outcome,
					  int pl, const T &value)
{
  payoffs(outcome->GetNumber(), pl) = value;
}

template <class T> const T &Nfg<T>::Payoff(NFOutcome *outcome, int pl) const
{
  return payoffs(outcome->GetNumber(), pl);
}


#include "nfgiter.h"

template <class T>
void Nfg<T>::WriteNfgFile(gOutput &f) const
{
  int i;

  f << "NFG 1 " << ((Type() == DOUBLE) ? 'D' : 'R');
  f << " \"" << title << "\" { ";

  for (i = 1; i <= players.Length(); i++)
    f << '"' << players[i]->name << "\" ";
  
  f << "}\n\n{ ";
  
  for (i = 1; i <= players.Length(); i++)   {
    f << "{ ";
    for (int j = 1; j <= players[i]->strategies.Length(); j++)
      f << '"' << players[i]->strategies[j]->name << "\" ";
    f << "}\n";
  }
  
  f << "}\n\n";


  int ncont = 1;
  for (i = 1; i <= players.Length(); i++)
    ncont *= players[i]->strategies.Length();

  for (i = 1; i <= ncont; i++)
    for (int j = 1; j <= players.Length(); j++)
      f << payoffs(results[i]->GetNumber(), j) << ' ';

  f << '\n';
}

#include "gpvector.h"
#include "mixed.h"

//---------------------------------------------------------------------------
//                    MixedProfile<T> member functions
//---------------------------------------------------------------------------

template <class T> MixedProfile<T>::MixedProfile(const Nfg<T> &NF)
  : gPVector<T>(NF.dimensions), N(&NF), support(NF)
{
  Centroid();
}

template <class T> MixedProfile<T>::MixedProfile(const Nfg<T> &NF,
						 const NFSupport &s)
  : gPVector<T>(s.NumStrats()), N(&NF), support(s)
{
  Centroid();
}

template <class T> MixedProfile<T>::MixedProfile(const Nfg<T> &NF,
						 const gPVector<T> &profile)
  : gPVector<T>(profile), N(&NF), support(NF)
{ }

template <class T> MixedProfile<T>::MixedProfile(const MixedProfile<T> &p)
  : gPVector<T>(p), N(p.N), support(p.support)
{ }

template <class T> MixedProfile<T>::~MixedProfile()   { }

template <class T>
MixedProfile<T> &MixedProfile<T>::operator=(const MixedProfile<T> &p)
{
  if (this != &p && N == p.N)   {
    // note that a dimensionality change will trigger a failed assertion
    // in the gPVector assignment operator
    support = p.support;
    gPVector<T>::operator=(p);
  }
  return *this;
}

template <class T> void MixedProfile<T>::Centroid(void) 
{
  T center;
  
  for (int i = 1; i <= N->NumPlayers(); i++)  {
    center = ((T) 1) / ((T) support.NumStrats(i));
    for (int j = 1; j <= support.NumStrats(i); j++)
      svptr[i][j] = center;
  }
}

template <class T> T MixedProfile<T>::LiapValue(void) const
{
  static const T BIG1 = (T) 100;
  static const T BIG2 = (T) 100;

  MixedProfile<T> p(*this);
  ((gVector<T> &) p).operator=(*this);
  MixedProfile<T> tmp(p);
  gPVector<T> payoff(p);
  T x, result((T) 0), avg, sum;
  payoff = (T) 0;

  result = (T) 0;
  for(int i = 1; i <= N->NumPlayers(); i++) {
    tmp.CopyRow(i, payoff);
    avg = sum = (T) 0;
    // then for each strategy for that player set it to 1 and evaluate
    int j;
    for (j = 1; j <= p.Support().NumStrats(i); j++) {
      tmp(i, j) = (T) 1;
      x = p(i, j);
      payoff(i, j) = tmp.Payoff(i);
      avg += x * payoff(i, j);
      sum += x;
      if (x>(T)0) x=0;
      result += BIG1*x*x;         // add penalty for neg probabilities
      tmp(i,j) = (T) 0;
    }
    tmp.CopyRow(i, p);
    for(j=1;j<=p.Support().NumStrats(i);j++) {
      x=payoff(i,j)-avg;
      if (x<=(T)0) x=(T)0;
      result += x*x;          // add penalty if not best response
    }
    x=sum - ((T) 1);
    result += BIG2*x*x ;          // add penalty for sum not equal to 1
  }
  return result;
}

template <class T> void MixedProfile<T>::Regret(gPVector<T> &value) const
{
  int i, j;
  T pay,x;
  
  for (i = 1; i <= N->NumPlayers(); i++) {
    pay = Payoff(i);
    for (j = 1; j <= N->NumStrats(i); j++) {
      x = Payoff(i, N->Strategies(i)[j]);
      if(x > pay)
	value(i, j) = x - pay;
      else value(i,j) = (T) 0;
    }
  }
}

template <class T> T MixedProfile<T>::MaxRegret(void) const
{
  int i;
  T maxgripe = (T)0;

  gPVector<T> v(N->NumStrats());
  Regret(v);
  for(i=v.First(); i<=v.Last(); i++)
    if(v[i] > maxgripe) maxgripe = v[i];
  return maxgripe;
}

template <class T> bool MixedProfile<T>::IsPure(void) const
{
  for (int i = 1; i <= svlen.Length(); i++)
    if (!IsPure(i))  return false;
  return true;
}

template <class T> bool MixedProfile<T>::IsPure(int pl) const
{
  T sum = (T) 0;

  T *val = svptr[pl];

  for (int i = 1; i <= svlen[pl]; sum += *(val++))
    if (*val != (T) 0 && *val != (T) 1)   return false;
  if (sum != (T) 1)  return false;  else return true;
}

template <class T> T MixedProfile<T>::Payoff(int pl) const
{
  return PPayoff(pl, 1, 1);
}

template <class T>
T MixedProfile<T>::Payoff(int pl, int player1, int strat1) const
{
  T value = (T) 0;
  PPayoff(pl, player1, strat1, 1,
	 support.Strategies(player1)[strat1]->index + 1, (T) 1.0, value);
  return value;
}

template <class T> T
MixedProfile<T>::Payoff(int pl, Strategy *strategy) const
{
  T value = (T) 0;
  PPayoff(pl, strategy->nfp->GetNumber(), strategy->number, 1,
	  strategy->index + 1, (T) 1.0, value);
  return value;
}

template <class T> T
MixedProfile<T>::Payoff( int pl, int player1, int strat1, int player2,
			int strat2 ) const
{
  if (player1 == player2) return (T) 0;
  T value = (T) 0;
  PPayoff(pl, player1, strat1, player2, strat2, 1,
	 support.Strategies(player1)[strat1]->index +
	 support.Strategies(player2)[strat2]->index + 1,
	 (T) 1.0, value);
  return value;
}

template <class T> 
void MixedProfile<T>::Payoff( int pl, int player1, gVector<T> &value) const
{
  value = (T) 0;
  PPayoff(pl, player1, 1, 1, (T) 1.0, value);
}

template <class T>
bool MixedProfile<T>::operator==(const MixedProfile<T> &mp) const
{
  return (N == mp.N && (const gPVector<T> &) *this == (const gPVector<T> &) mp);
}

template <class T> gOutput &operator<<(gOutput &f, const MixedProfile<T> &p)
{ p.Dump(f);  return f; }


//-------------------------------------- 
// Private Mixed Profile Members
//--------------------------------------

template <class T> 
T MixedProfile<T>::PPayoff(int pl, int index,
			  int i) const
{
  Strategy *s;
  int pindex = 0;

  if (i > N->NumPlayers())
    return ((Nfg<T> *) N)->payoffs(N->GetOutcome(index)->GetNumber(), pl);
  T sum = (T) 0;
  for (int j = 1; j <= support.NumStrats(i); j++) {
    s = support.Strategies(i)[j];
    if ((*this)(i, j) != (T) 0) {
      index += s->index - pindex; 
      pindex = s->index;
      sum += (*this)(i, j) * PPayoff(pl, index, i + 1);
    }
    
  }
  return sum;
}

template <class T>
void MixedProfile<T>::PPayoff(int pl, int const_pl, int const_st,
			   int cur_pl, long index, T prob, T &value) const
{
  Strategy *s;

  if (cur_pl == const_pl)
    PPayoff(pl, const_pl, const_st, cur_pl + 1, index,
	   prob, value);
  else if (cur_pl > N->NumPlayers())
    value += prob *
       ((Nfg<T> *) N)->payoffs(N->GetOutcome(index)->GetNumber(), pl); 
  else   {
    for (int j = 1; j <= support.NumStrats(cur_pl); j++)  {
      s = support.Strategies(cur_pl)[j];
      if ((*this)(cur_pl, j) > (T) 0)
	PPayoff(pl, const_pl, const_st, cur_pl + 1,
	       index + s->index, prob * (*this)(cur_pl, j), value);
    }
  }
} 


template <class T>
void MixedProfile<T>::PPayoff(int pl, int const_pl1, int const_st1,
			   int const_pl2, int const_st2,
			   int cur_pl, long index, T prob, T &value) const
{
  Strategy *s;

  if (cur_pl == const_pl1 || cur_pl == const_pl2)
    PPayoff(pl, const_pl1, const_st1, const_pl2, const_st2,
	   cur_pl + 1, index,prob, value);
  else if (cur_pl > N->NumPlayers())
    value += prob * 
       ((Nfg<T> *) N)->payoffs(N->GetOutcome(index)->GetNumber(), pl); 
  else   {
    for (int j = 1; j <= support.NumStrats(cur_pl); j++ ) {
      s = support.Strategies(cur_pl)[j];
      if ((*this)(cur_pl, j) > (T) 0)
	PPayoff(pl, const_pl1, const_st1, const_pl2, const_st2,
	       cur_pl + 1, index + s->index, prob * (*this)(cur_pl, j), 
	       value);
    }
  }
}

template <class T>
void MixedProfile<T>::PPayoff(int pl, int const_pl, int cur_pl, long index, 
			   T prob, gVector<T> &value) const
{
  Strategy *s;

  if (cur_pl == const_pl)
    PPayoff(pl, const_pl, cur_pl + 1, index,
	   prob, value);
  else if (cur_pl > N->NumPlayers())  {
    for (int j = 1; j <= support.NumStrats(const_pl); j++ ){ 
      s = support.Strategies(const_pl)[j];
      value[j] += prob * 
         ((Nfg<T> *) N)->payoffs(N->GetOutcome(index + s->index)->GetNumber(), pl); 
    }
  }
  else   {
    for (int j = 1; j <= support.NumStrats(cur_pl); j++) {
      s = support.Strategies(cur_pl)[j];
      if ((*this)(cur_pl, j) > (T) 0)
	PPayoff(pl, const_pl, cur_pl + 1,
	       index + s->index, prob * (*this)(cur_pl, j), value);
    }
  }
}








