//#
//# FILE: nfg.imp -- Implementation of type normal form
//#
//# $Id$
//#

#include "nfg.h"
#include "nfplayer.h"
#include "nfstrat.h"


//---------------------------------------------------------------
// NFG: Constructors, Destructor, Operators
//---------------------------------------------------------------

template <class T> Nfg<T>::Nfg(const gArray<int> &dim)
  : BaseNfg(dim), payoffs(dim.Length())
{
  int accum = 1,i;
  for (i = 1; i <= dim.Length(); i++)
    accum *= dim[i];
  for (i = 1; i <= dim.Length(); i++)
    payoffs[i] = new T[accum];
}

template <class T> Nfg<T>::~Nfg()
{
  for (int i = 1; i <= payoffs.Length(); i++)
    delete [] payoffs[i];
}

//------------------------
// Nfg: Member Functions
//------------------------

template <class T> void Nfg<T>::SetPayoff(int pl, const gArray<int> &profile,
					  const T &value)
{
  int index = 0;
  for (int i = 1; i <= profile.Length(); i++)
    index += players[i]->strategies[profile[i]]->index;
  payoffs[pl][index] = value;
}

template <class T> 
const T &Nfg<T>::Payoff(int pl, const gArray<int> &profile) const 
{
  int index = 0;
  for (int i = 1; i <= profile.Length(); i++)
    index += players[i]->strategies[profile[i]]->index;
  return (payoffs[pl][index]);
}

#include "nfgiter.h"

template <class T>
void Nfg<T>::WriteNfgFile(gOutput &f) const
{
  int i;

  f << "NFG 1 " << ((Type() == DOUBLE) ? 'D' : 'R');
  f << " \"" << title << "\" { ";

  for (i = 1; i <= players.Length(); i++)
    f << '"' << players[i]->name << "\" ";
  
  f << "}\n\n{ ";
  
  for (i = 1; i <= players.Length(); i++)   {
    f << "{ ";
    for (int j = 1; j <= players[i]->strategies.Length(); j++)
      f << '"' << players[i]->strategies[j]->name << "\" ";
    f << "}\n";
  }
  
  f << "}\n\n";


  int ncont = 1;
  for (i = 1; i <= players.Length(); i++)
    ncont *= players[i]->strategies.Length();

  for (i = 0; i < ncont; i++)
    for (int j = 1; j <= players.Length(); j++)
      f << payoffs[j][i] << ' ';

  f << '\n';
}

#include "gpvector.h"
template <class T> void Nfg<T>::Centroid(gPVector<T> &profile) const
{
  profile = gPVector<T>(dimensions);
  T center;
  
  for (int i = 1; i <= NumPlayers(); i++)  {
    center = ((T) 1) / ((T) NumStrats(i));
    for (int j = 1; j <= NumStrats(i); j++)
      profile(i, j) = center;
  }
}


#include "mixed.h"

//---------------------------------------------------------------------------
//                    MixedProfile<T> member functions
//---------------------------------------------------------------------------

template <class T> MixedProfile<T>::MixedProfile(const Nfg<T> &NF,
						 bool truncated)
: BaseMixedProfile(NF, truncated), Nf(&NF), gPVector<T>(NF.dimensions)
{
  NF.Centroid(*this);
}

template <class T> MixedProfile<T>::MixedProfile(const Nfg<T> &NF,
						 NFSupport &s)
: BaseMixedProfile(NF, false, s), Nf(&NF), gPVector<T>(NF.dimensions)
{
  NF.Centroid(*this);
}

template <class T> MixedProfile<T>::MixedProfile(const Nfg<T> &NF,
						 const gPVector<T> &profile)
  : BaseMixedProfile(NF, false), gPVector<T>(profile), Nf(&NF)
{ }

template <class T> MixedProfile<T>::MixedProfile(const MixedProfile<T> &p)
  : BaseMixedProfile(p), gPVector<T>(p)
{ }

template <class T> MixedProfile<T>::~MixedProfile()   { }

template <class T>
MixedProfile<T> &MixedProfile<T>::operator=(const MixedProfile<T> &p)
{
  BaseMixedProfile::operator=(p);
  gPVector<T>::operator=(p);
  return *this;
}

template <class T> bool MixedProfile<T>::IsPure(void) const
{
  for (int i = 1; i <= svlen.Length(); i++)
    if (!IsPure(i))  return false;
  return true;
}

template <class T> bool MixedProfile<T>::IsPure(int pl) const
{
  T sum = (T) 0;

  T *val = svptr[pl];

  for (int i = 1; i <= svlen[pl]; sum += *(val++))
    if (*val != (T) 0 && *val != (T) 1)   return false;
  if (sum != (T) 1)  return false;  else return true;
}

template <class T> T MixedProfile<T>::Payoff(int pl) const
{
  int n = N->NumPlayers();
  gArray<int> Player(n);
  for (int i = 1; i <= n; i++) Player[i] = i;
  StrategyProfile tmp(n);

  return Payoff(pl, tmp, Player, 1);
}

template <class T> T 
MixedProfile<T>::Payoff( int pl, int player1, int strat1 ) const
{
  T value = (T) 0;
  Payoff(pl, player1, strat1, 1,
	 stratset.GetStrategy(player1,strat1)->index, (T) 1.0, value);
  return value;
}

template <class T> T
MixedProfile<T>::Payoff( int pl, int player1, int strat1, int player2,
			int strat2 ) const
{
  if (player1 == player2) return (T) 0;
  T value = (T) 0;
  Payoff(pl, player1, strat1, player2, strat2, 1,
	 stratset.GetStrategy(player1,strat1)->index +
	 stratset.GetStrategy(player2,strat2)->index,
	 (T) 1.0, value);
  return value;
}

template <class T> 
void MixedProfile<T>::Payoff( int pl, int player1, gVector<T> &value) const
{
  value = (T) 0;
  Payoff(pl, player1, 1, 0, (T) 1.0, value);
}

template <class T> gOutput &operator<<(gOutput &f, const MixedProfile<T> &p)
{ p.Dump(f);  return f; }


template <class T> 
T MixedProfile<T>::Payoff(int pl, StrategyProfile &p, 
			  const gArray<int> &Player,
			  int i) const
{
  Strategy *s;

  if (i > N->NumPlayers()) return Payoff(pl, p);
  T temp;
  T sum = (T) 0;
  int k = Player[i], j = 1;
  for ( ; j <= stratset.GetStrategy(k).Length(); j++ ) {
    s = stratset.GetStrategy(k, j);
    if ((*this)(k, j) != (T) 0) {
      p.Set(k, s);
      temp = Payoff(pl, p, Player, i + 1);
      sum += (*this)(k, j) * temp;
    }
    
  }
  return sum;
}

template <class T>
void MixedProfile<T>::Payoff(int pl, int const_pl, int const_st,
			   int cur_pl, long index, T prob, T &value) const
{
  Strategy *s;

  if (cur_pl == const_pl)
    Payoff(pl, const_pl, const_st, cur_pl + 1, index,
	   prob, value);
  else if (cur_pl > N->NumPlayers())
    value += prob * (Nf->payoffs[pl][index]);
  else   {
    int j = 1;
    for ( ; j <= stratset.GetStrategy(cur_pl).Length(); j++ ){
      s = stratset.GetStrategy(cur_pl, j);
      if ((*this)(cur_pl, j) > (T) 0)
	Payoff(pl, const_pl, const_st, cur_pl + 1,
	       index + s->index, prob * (*this)(cur_pl, j), value);
    }
  }
} 


template <class T>
void MixedProfile<T>::Payoff(int pl, int const_pl1, int const_st1,
			   int const_pl2, int const_st2,
			   int cur_pl, long index, T prob, T &value) const
{
  Strategy *s;

  if (cur_pl == const_pl1 || cur_pl == const_pl2)
    Payoff(pl, const_pl1, const_st1, const_pl2, const_st2,
	   cur_pl + 1, index,prob, value);
  else if (cur_pl > Nf->NumPlayers())
    value += prob * (Nf->payoffs[pl][index]);
  else   {
    for (int j = 1; j <= stratset.GetStrategy(cur_pl).Length(); j++ ) {
      s = stratset.GetStrategy(cur_pl, j);
      if ((*this)(cur_pl, j) > (T) 0)
	Payoff(pl, const_pl1, const_st1, const_pl2, const_st2,
	       cur_pl + 1, index + s->index, prob * (*this)(cur_pl, j), 
	       value);
    }
  }
}

template <class T>
void MixedProfile<T>::Payoff(int pl, int const_pl, int cur_pl, long index, 
			   T prob, gVector<T> &value) const
{
  Strategy *s;

  if (cur_pl == const_pl)
    Payoff(pl, const_pl, cur_pl + 1, index,
	   prob, value);
  else if (cur_pl > N->NumPlayers())  {
    for (int j = 1; j <= stratset.GetStrategy(const_pl).Length(); j++ ){ 
      s = stratset.GetStrategy(const_pl,j);
      value[j] += prob * (Nf->payoffs[pl][index + s->index]);
    }
  }
  else   {
    for (int j = 1; j <= stratset.GetStrategy(cur_pl).Length(); j++) {
      s = stratset.GetStrategy(cur_pl,j);
      if ((*this)(cur_pl, j) > (T) 0)
	Payoff(pl, const_pl, cur_pl + 1,
	       index + s->index, prob * (*this)(cur_pl, j), value);
    }
  }
}

//-------------------------------------- 
// Private Mixed Profile Members
//--------------------------------------
template <class T>
const T &MixedProfile<T>::Payoff(int pl, const StrategyProfile &p) const
{
  return Nf->payoffs[pl][p.GetIndex()];
}






