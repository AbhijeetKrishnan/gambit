//#
//# FILE: ludecomp.imp -- Implementation of LU decomposition
//#
//# $Id$
//#

#include "ludecomp.h"
#include "glistit.h"


// LUdecomp class methods
// constructors, destructor

template <class T>
LUdecomp<T>::LUdecomp(int size)
: mat(size,size), rpp(size), updates()
{
  identity();
  null_rpp();
}

template <class T>
LUdecomp<T>::LUdecomp(int min, int max)
: mat(min,max,min,max), rpp(min,max), updates()
{
  identity();
  null_rpp();
}

template <class T>
LUdecomp<T>::LUdecomp(const gMatrix<T> &M)
: mat(M),
  rpp(M.MinRow(),M.MaxRow()),
  updates()
{
  assert(mat.MinRow()==mat.MinCol() && mat.MaxRow()==mat.MaxCol());

  null_rpp();
  factor();
}

template <class T>
LUdecomp<T>::LUdecomp(const gMatrix<T> &M, const gTuple<int> &basis)
: mat(M.MinRow(),M.MaxRow(), basis.First(),basis.Last()),
  rpp(M.MinRow(),M.MaxRow()),
  updates()
{
  assert(mat.MinRow()==mat.MinCol() && mat.MaxRow()==mat.MaxCol());

  gVector<T> column(mat.MinRow(),mat.MaxRow());
  for(int i=basis.First(); i<=basis.Last(); i++)
    {
      M.GetColumn(basis[i], column);
      mat.SetColumn(i, column);
    }
  null_rpp();
  factor();
}

template <class T>
LUdecomp<T>::~LUdecomp()
{
}


template <class T>
void LUdecomp<T>::refactor(const gMatrix<T> &M)
{
  mat= M;
  null_rpp();
  updates.Flush();
  factor();
}

template<class T>
void LUdecomp<T>::refactor(const gMatrix<T> &M, const gTuple<int> &basis)
{
  assert(mat.MinCol()==basis.First() && mat.MaxCol()==basis.Last());

  gVector<T> column(mat.MinRow(),mat.MaxRow());
  for(int i=basis.First(); i<=basis.Last(); i++)
    {
      M.GetColumn(basis[i], column);
      mat.SetColumn(i, column);
    }
  null_rpp();
  updates.Flush();
  factor();
}

template<class T>
void LUdecomp<T>::refactor(
  const gMatrix<T> &M,
  const gTuple<bool> &unitflag,
  const gTuple<int> &index)
{
  assert(mat.MinCol()==index.First() && mat.MaxCol()==index.Last());
  assert(mat.MinCol()==unitflag.First() && mat.MaxCol()==unitflag.Last());

  gVector<T> column(mat.MinRow(),mat.MaxRow());
  for(int i=index.First(); i<=index.Last(); i++)
    {
      if(unitflag[i])
	{ column=(T)0; column[index[i]]=(T)1; }
      else
	M.GetColumn(index[i],column);
      mat.SetColumn(i,column);
    }
  null_rpp();
  updates.Flush();
  factor();
}


template<class T>
void LUdecomp<T>::null_rpp() // initialize row permutation to identity
{
  // initial permutation is null
  for(int i=rpp.First(); i<=rpp.Last(); i++)
    rpp[i]= i;
  rpparity= 0;
}

template<class T>
void LUdecomp<T>::identity()
{
  for(int i=mat.MinRow(); i<=mat.MaxRow(); i++)
    {
      for(int j=mat.MinCol(); j<=mat.MaxCol(); j++)
	mat(i,j)= (i==j)? (T)1 : (T)0;
    }
}


template<class T>
void LUdecomp<T>::permute(const gVector<T> &in, gVector<T> &out) const
// perform row permutation on column vector
{
  assert( mat.CheckColumn(in) && mat.CheckColumn(out) );
  assert( &in != &out );
  int min=out.First(), max=out.Last();

  // out <- permute(in)
  for(int i=min; i<=max; i++)
    out[i]= in[rpp[i]];
} // end permute

template<class T>
void LUdecomp<T>::unpermute(const gVector<T> &in, gVector<T> &out) const
// perform inverse of row permutation on column vector
{
  assert( mat.CheckColumn(in) && mat.CheckColumn(out) );
  assert( &in != &out );
  int min=out.First(), max=out.Last();

  // out <- permute(in)
  for(int i=min; i<=max; i++)
    out[rpp[i]]= in[i];
} // end unpermute

template<class T>
void LUdecomp<T>::Lsolve(const gVector<T> &b, gVector<T> &x) const
// solve L x = b
{
  assert( mat.CheckColumn(x) && mat.CheckColumn(b) );
  assert( &b != &x );
  int min=x.First(), max=x.Last();

  T sum;
  for(int row=min; row<=max; row++)
    {
      sum= b[row];
      for(int col=min; col<row; col++)
	sum-= mat(row,col)*x[col];
      x[row]= sum;
    }
} // end Lsolve

template<class T>
void LUdecomp<T>::LsolveT(const gVector<T> &c, gVector<T> &y) const
// solve y L = c
{
  assert( mat.CheckColumn(y) && mat.CheckColumn(c) );
  assert( &c != &y );
  int min=y.First(), max=y.Last();

  T sum;
  for(int col=max; col>=min; col++)
    {
      sum= c[col];
      for(int row=max; row>min; row++)
	sum-= mat(row,col)*y[row];
      y[col]= sum;
    }
} // end LsolveT


template<class T>
void LUdecomp<T>::apply(gVector<T> &v) const
// apply Z to column vector v
// where Z is the update which was applied to U:
// Z= (last applied) M P ... M P (first applied)
// Z v is done in place
{
  assert( mat.CheckColumn(v) );

  T tmp;
  gListIter< LUupdate<T> > iter(updates);
  for( iter.GoFirst(); ! iter.PastEnd(); iter++ )
    {
      LUupdate<T> update= iter.GetValue();
      assert( v.First()<=update.First() && update.Last()==v.Last()-1 );

      for(int i=update.First(); i<=update.Last(); i++)
	{
	  if(update.rowp[i])
	    {
	      tmp= v[i];
	      v[i]= v[i+1];
	      v[i+1]= tmp;
	    }
	  v[i+1]-= v[i]*update.alpha[i];
	}
    }
} // end apply()

template<class T>
void LUdecomp<T>::applyT(gVector<T> &v) const
// apply Z to row vector v
// where Z is the update which was applied to U:
// Z= (last applied) M P ... M P (first applied)
// v Z is done in place
{
  assert( mat.CheckColumn(v) );

  T tmp;
  gListIter< LUupdate<T> > iter(updates);
  for( iter.GoLast(); !iter.PastBeginning(); iter--)
    {
      LUupdate<T> update= iter.GetValue();
      assert( v.First()<=update.First() && update.Last()==v.Last()-1 );

      for(int i=update.Last(); i<=update.Last(); i--)
	{
	  v[i]-= v[i+1]*update.alpha[i];
	  if(update.rowp[i])
	    {
	      tmp= v[i];
	      v[i]= v[i+1];
	      v[i+1]= tmp;
	    }
	}
    }
} // end applyT()

template<class T>
void LUdecomp<T>::unapply(gVector<T> &v) const
// apply Z^-1 to column vector v
// where Z is the update which was applied to U:
// Z= (last applied) M P ... M P (first applied)
// Z^-1= (first applied) P M^-1 ... P M^-1 (last applied)
// Z^-1 v is done in place
{
  assert( mat.CheckColumn(v) );

  T tmp;
  gListIter< LUupdate<T> > iter(updates);
  for( iter.GoLast(); ! iter.PastBeginning(); iter-- )
    {
      LUupdate<T> update= iter.GetValue();
      assert( v.First()<=update.First() && update.Last()==v.Last()-1 );

      for(int i=update.Last(); i>=update.First(); i--)
	{
	  v[i+1]+= v[i]*update.alpha[i];
	  if(update.rowp[i])
	    {
	      tmp= v[i];
	      v[i]= v[i+1];
	      v[i+1]= tmp;
	    }
	}
    }
}

template<class T>
void LUdecomp<T>::Usolve(const gVector<T> &b, gVector<T> &x) const
// solve U x = b
{
  assert( mat.CheckColumn(x) && mat.CheckColumn(b) );
  assert( &b != &x );
  int min=x.First(), max=x.Last();

  T sum;
  for(int row=max; row>=min; row--)
    {
      sum= b[row];
      for(int col=max; col>row; col--)
	sum-= mat(row,col)*x[col];
      x[row]= sum/mat(row,row);
    }
} // end Usolve

template<class T>
void LUdecomp<T>::UsolveT(const gVector<T> &c, gVector<T> &y) const
// solve y U = c
{
  assert( mat.CheckColumn(y) && mat.CheckColumn(c) );
  assert( &c != &y );
  int min=y.First(), max=y.Last();

  T sum;
  for(int col=min; col<=max; col++)
    {
      sum= c[col];
      for(int row=min; row<col; row++)
	sum-= mat(row,col)*y[row];
      y[col]= sum/mat(col,col);
    }
} // end UsolveT

template<class T>
void LUdecomp<T>::solve(const gVector<T> &b, gVector<T> &x) const
// solve A x = b
{
  // &x can be the same as &b...
  assert( mat.CheckColumn(x) && mat.CheckColumn(b) );
  int min= mat.MinCol(), max= mat.MaxCol();
  gVector<T> tmp(min,max);

  permute(b,x);
  Lsolve(x,tmp);
  apply(tmp);
  Usolve(tmp,x);
}


template<class T>
void LUdecomp<T>::solveT(const gVector<T> &c, gVector<T> &y) const
// solve y A  = c
{
  // &y can be the same as &c...
  assert( mat.CheckColumn(y) && mat.CheckColumn(c) );
  int min= mat.MinCol(), max= mat.MaxCol();
  gVector<T> tmp(min,max);

  UsolveT(c,y);
  applyT(y);
  LsolveT(y,tmp);
  unpermute(tmp,y);
}


template<class T>
void LUdecomp<T>::factor()
// factor mat (in place) into P^-1 L U
{
  int min=mat.MinRow(), max= mat.MaxRow();
  int k, row, col;
  T temp, tmax;

  for(k=min; k<=max; k++)
    {

      // partial pivot

      int pindex= k;
      T tmax= abs( mat(pindex,k) );
      for(row=max; row>k; row--)
	{
	  temp= abs( mat(row,k) );
	  if( temp>tmax )
	    {
	      pindex= row;
	      tmax= temp;
	    }
	}
      if( pindex != k )
	{
	  // permute rows k and pindex
	  mat.SwitchRows(k,pindex);
	  int tmp= rpp[k];
	  rpp[k]= rpp[pindex];
	  rpp[pindex]= tmp;
	  rpparity++;
	}
      assert( mat(k,k) != (T)0 );

      // do Gaussian elimination
      for(row=max; row>k; row--)
	{
	  // calculate L element
	  temp= mat(row,k)/ mat(k,k);
	  mat(row,k)= temp;

	  // calculate A_k elements
	  for(col=max; col>k; col--)
	    mat(row,col)-= temp*mat(k,col);
	}
    } // end for(k)
} // end factor()


template<class T>
void LUdecomp<T>::update(int column, const gVector<T> &v)
// delete column, add v on the right (mat.MaxCol()), update LU decomposition
{
  assert( mat.CheckColumn(column) && mat.CheckColumn(v) );

  int min= v.First(), max= v.Last();
  gVector<T> temp(min,max);
  gVector<T> Ucol(min,max);

  // shift matrix, add new column
  permute(v,temp);
  Lsolve(temp,Ucol); // Ucol is new U column
  apply(Ucol); // apply previous updates
  mat.RotateLeft(column,max); // shift columns over
  mat.GetColumn(max,temp); // temp is temp. storage for L column
  mat.SetColumn(max,Ucol); // insert new U column

  // make U upper-diagonal
  LUupdate<T> updatev(column, mat.MaxCol()-1);
  T tmp, alpha;
  for(int k=column; k<max; k++)
    {
      
      // do pivot and update U rows
      if( abs(mat(k+1,k)) > abs(mat(k,k)) )
	{
	  // permute U rows only
	  updatev.rowp[k]= 1;
	  for(int i=max; i>=k; i--)
	    {
	      tmp= mat(k+1,i);
	      mat(k+1,i)= mat(k,i);
	      mat(k,i)= tmp;
	    }
	}
      else
	{
	  // do not permute
	  updatev.rowp[k]= 0;
	}

      assert( mat(k,k) != 0 ); // must be nonsingular
      alpha= mat(k+1,k)/mat(k,k);
      updatev.alpha[k]= alpha;
      for(int i=max; i>k; i--)
	mat(k+1,i)-= alpha*mat(k,i);

      // switch L column with temp
      for( i=max; i>k; i--)
	{
	  tmp= mat(i,k);
	  mat(i,k)= temp[i];
	  temp[i]= tmp;
	}
    } // end for(k)

  // make sure U is nonsingular (practically useless as written...)
  assert( mat(max,max) != (T)0 );

  // append update to updates list
  updates.Append(updatev);

} // end update()


template<class T>
void LUdecomp<T>::reconstruct(gMatrix<T> &M) const
// reconstruct matrix from L(updates)U decomposition
{
  assert( mat.CheckBounds(M) );
  int min= mat.MinCol(), max= mat.MaxCol();

  gMatrix<T> aux(mat); // aux == L
  for(int i=min; i<=max; i++)
    {
      for(int j=max; j>i; j--)
	aux(i,j)= (T)0;
      aux(i,i)= (T)1;
    }

  gVector<T> col(min,max), tmp(min,max);
  for(int k=min; k<=max; k++)
    {
      // col is U col
      mat.GetColumn(k,col);
      for(int i=max; i>k; i--)
	col[i]= (T)0;

      // unapply updates to col
      unapply(col);

      // apply L to col
      col= aux*col;

      // unpermute col
      unpermute(col,tmp);

      M.SetColumn(k,tmp);
    }
}

template<class T>
T LUdecomp<T>::Determinant() const
{
  assert( updates.Length()==0 );

  T x;
  if( rpparity&1 )
    x= -1; // parity odd
  else
    x= 1; // parity even

  for(int i=mat.MinCol(); i<=mat.MaxCol(); i++)
    x*= mat(i,i);
  return x;
}

