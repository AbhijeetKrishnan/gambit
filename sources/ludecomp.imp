//
// FILE: ludecomp.imp -- implementation of the LUdecomp class
//
// $Id$
//
//

#include "ludecomp.h"

// ---------------------------------------------------------------------------
// Class EtaMatrix
// ---------------------------------------------------------------------------

template <class T>
gOutput& operator<<(gOutput &out, const EtaMatrix<T> &a)
{
  out << "column: " << a.col << '\n' << a.etadata << '\n';
  return out;
}

template <class T>
bool EtaMatrix<T>::operator==(const EtaMatrix<T> &a) const
{
  return ( col == a.col && etadata == a.etadata );
}

template <class T>
bool EtaMatrix<T>::operator!=(const EtaMatrix<T> &a) const
{
  return ( col != a.col || etadata != a.etadata );
}

// ---------------------------------------------------------------------------
// Class Decomp
// ---------------------------------------------------------------------------
// -------------------------
//  C-tors, D-tor, Operators
// -------------------------

// copy constructor

template <class T> 
LUdecomp<T>::LUdecomp( const LUdecomp<T> &a)
: A(a.A), basis(a.basis), IsBasisIdent(a.IsBasisIdent),
  scratch1(basis.First(), basis.Last()), scratch2(basis.First(), basis.Last()),
  refactor_number( a.refactor_number ), iterations(a.iterations),
  total_operations( a.total_operations),
  parent(&a), copycount(0)

{ 
  ((LUdecomp<T> &)*parent).copycount++;
}

// Decomposes given matrix

template <class T> 
LUdecomp<T>::LUdecomp( const gMatrix<T> &mat, int rfac = -1 )
: A(&mat), basis(mat.MinRow(), mat.MaxRow()), IsBasisIdent(true), 
  scratch1(basis.First(), basis.Last()), scratch2(basis.First(), basis.Last()),
  refactor_number(rfac), iterations(0), parent(NULL), copycount(0)
{
  int i;
  for ( i = mat.MinRow(); i <= mat.MaxRow(); i++ ) basis[i] = -i;
  int m = basis.Length();
  total_operations = (m - 1) * m * (2 * m - 1) / 6;
}

// Decomposes the selected columnts of the given matrix

template <class T>
LUdecomp<T>::LUdecomp( const gMatrix<T> &mat, const gBlock<int> &bas, 
		      int rfac = -1 )
: A(&mat), basis(bas), scratch1(basis.First(), basis.Last()),
  scratch2(basis.First(), basis.Last()),
  refactor_number(rfac), iterations(0), parent(NULL), copycount(0)
      
{
  assert ( bas.First() == mat.MinRow() && bas.Last() == mat.MaxRow() );
  IsBasisIdent = CheckBasis();

  refactor();
}

// Destructor
template <class T> LUdecomp<T>::~LUdecomp() 
{ 
  if ( parent != NULL )
    ((LUdecomp<T> &) *parent).copycount--;
  assert ( copycount == 0 );
}

// Assignment operator

template <class T>
LUdecomp<T>& LUdecomp<T>::operator=(const LUdecomp<T> &orig)
{
  if(this != &orig) {
    if (parent != NULL)
      ((LUdecomp<T> &) *parent).copycount--;
 
    A = orig.A;
    basis = orig.basis;
    
    L.Flush();
    P.Flush();
    E.Flush();
    U.Flush();

    IsBasisIdent = orig.IsBasisIdent;
    refactor_number = orig.refactor_number;
    iterations = orig.iterations;
    total_operations = orig.total_operations;
    parent = &orig;
    copycount = 0;
    ((LUdecomp<T> &)*parent).copycount++;
  }
  return *this;
}

// -------------------------
//  Public Members
// -------------------------


template <class T>
void LUdecomp<T>::update( int col, int matcol )
{

  assert( copycount == 0 );
  basis[col] = matcol;

  IsBasisIdent = CheckBasis();

  iterations++;
  if (( refactor_number > 0 && iterations >= refactor_number ) ||
      ( refactor_number == 0 && RefactorCheck()) )  
    refactor();
  else {

    if( matcol<0 ) { 
      scratch1=(T)0; 
      scratch1[-matcol]=(T)1; 
    }
    else (*A).GetColumn(matcol,scratch1);
    
    solve(scratch1,scratch1);
    E.Append( EtaMatrix<T>( col, scratch1 ) );
    
    total_operations += iterations * basis.Length() +  
      2 * basis.Length() * basis.Length();
    
  }
  
}


template <class T> 
void LUdecomp<T>::refactor( const gMatrix<T> &m, int rfac = -1 )
{

  int i;
  A = &m;
  for ( i = m.MinRow(); i <= m.MaxRow(); i++ ) basis[i] = -i;
  IsBasisIdent = true;

  L.Flush();
  U.Flush();
  E.Flush();
  P.Flush();

  iterations = 0;
  
  int z = basis.Length();
  total_operations = (z - 1) * z * (2 * z - 1) / 6;

  parent = NULL;
  if (parent != NULL) ((LUdecomp<T> &)*parent).copycount--;
  refactor_number = rfac;

}

template <class T> 
void LUdecomp<T>::refactor( ) 
{

//gout << " Refactored at : " << iterations << " ##########################\n";
  L.Flush();
  U.Flush();
  E.Flush();
  P.Flush();

  if ( !IsBasisIdent ) FactorBasis();

  iterations = 0;
  int m = basis.Length();
  total_operations = (m - 1) * m * (2 * m - 1) / 6;
  if (parent != NULL) ((LUdecomp<T> &)*parent).copycount--;
  parent = NULL;
  
}

template <class T> 
void LUdecomp<T>::refactor( const gMatrix<T> &mat, const gBlock<int> &bas,
			   int rfac = -1)
{

  assert ( bas.First() == mat.MinRow() && bas.Last() == mat.MaxRow() );

  A = &mat;
  basis = bas;

  IsBasisIdent = CheckBasis();
  
  refactor();

  refactor_number = rfac;
}

template <class T>
void LUdecomp<T>::solveT( const gVector<T> &c, gVector<T> &y ) const  
{

  assert ( c.First() == y.First() && c.Last() == y.Last() );
  assert ( c.First() == (*A).MinRow() && c.Last() == (*A).MaxRow());

  y = c;
  if ( IsBasisIdent != true ) {

    BTransE( y );

    if ( parent != NULL ) { 
      (*parent).solveT( y, y );
    }
    else {
      FTransU( y );
      yLP_Trans( y );
    }
  }
}

template <class T>
void LUdecomp<T>::solve( const gVector<T> &a, gVector<T> &d ) const
{

  assert ( a.First() == d.First() && a.Last() == d.Last() );
  assert ( a.First() == (*A).MinRow() && a.Last() == (*A).MaxRow() );
  
  d = a;
  if ( IsBasisIdent != true ) {
    
    if ( parent != NULL ) {
      (*parent).solve(a,d);
    }
    
    else {
      LPd_Trans( d );
      BTransU( d );
    }
    
    FTransE( d );
  }
}

template<class T>
void LUdecomp<T>::SetRefactor( int a )
{
  refactor_number = a;
}

// -----------------
//  Private Members
// -----------------


template<class T>
void LUdecomp<T>::FactorBasis()
{
  int i, j, piv;
  T pivVal;

  gMatrix<T> B((*A).MinRow(), (*A).MaxRow(), basis.First(), basis.Last());

  for( i = basis.First(); i <= basis.Last(); i++ ) {
    if ( basis[i] >= 0 ) {
      (*A).GetColumn( basis[i], scratch2 );
    }
    else {
      scratch2 = (T) 0;      
      scratch2[ -basis[i] ] = 1;
    }
    B.SetColumn( i, scratch2 );
  }
  
  for ( i = B.MinRow(); i <= B.MaxRow(); i++) {    
    pivVal = abs ( B(i, i));
    piv = i;
    for ( j = i+1; j <= B.MaxRow(); j++) {
      if (  B( j, i ) * B( j, i )  > pivVal * pivVal ) {
	piv = j;
	pivVal = B( j, i );
      }
    }
    P.Append(piv);
    B.SwitchRows(i,piv);

    scratch2 = (T) 0;
    scratch2[i] = (T) 1 / B( i, i );
    for ( j = i+1; j <= B.MaxRow(); j++ ) {
      scratch2[j] =  - B(j, i) / B(i,i);
    }
    L.Append( EtaMatrix<T>(i, scratch2) );
    GaussElem(B, i, i);

  }

  for ( j = B.MinCol(); j <= B.MaxCol(); j++ ) {
    B.GetColumn( j, scratch2 );
    U.Append( EtaMatrix<T>( j, scratch2 ));
  }
}

template<class T>
void LUdecomp<T>::GaussElem(gMatrix<T> &B, int row, int col)
{
  assert( B(row, col) != (T) 0);

  int i,j;

  for ( j = col+1; j <= B.MaxCol(); j++)
    B( row, j ) = B( row, j ) / B( row, col );

  for ( i = row+1; i <= B.MaxRow(); i++ ) 
    for ( j = col+1; j <= B.MaxCol(); j++ ) {
      B( i, j ) = B( i, j ) - ( B( i, col ) * B( row, j ) );
    }

  for ( i = row+1; i <= B.MaxRow(); i++ )
    B( i , col ) = 0;

  B( row, col ) = (T) 1;

}


template<class T>
void LUdecomp<T>::BTransE( gVector<T> &y ) const
{

  int i;
  for ( i = E.Length(); i >= 1; i-- ) {
    ((LUdecomp<T> &) *this).scratch2 = y;
    VectorEtaSolve(scratch2, E[i], y );
  }
}
  
template<class T>
void LUdecomp<T>::FTransU( gVector<T> &y ) const
{

  int i;
  for ( i = 1; i <= U.Length(); i++ ) {
    ((LUdecomp<T> &) *this).scratch2 = y;
    VectorEtaSolve(scratch2, U[i], y );
  }
}

template<class T>
void LUdecomp<T>::VectorEtaSolve( const gVector<T> &v,  
				 const EtaMatrix<T>  &eta, 
				 gVector<T> &y ) const
{

  int i, j;

  assert ( v.First() == y.First() && v.Last() == y.Last() );

  for ( i = v.First(); i <= v.Last(); i++ ) {
    y[i] = v[i];
    if ( i == eta.col ) {
      for ( j = v.First(); j <= v.Last(); j++ )
	if ( j != eta.col ) y[i] -= v[j] * eta.etadata[j];
      y[i] /= eta.etadata[i];
    }    
  }
}

template<class T>
void LUdecomp<T>::FTransE( gVector<T> &y ) const
{

  int i;
  for ( i = 1; i <= E.Length(); i++ ) {
    ((LUdecomp<T> &) *this).scratch2 = y;
    EtaVectorSolve(scratch2, E[i], y );
  }
}
  
template<class T>
void LUdecomp<T>::BTransU( gVector<T> &y ) const
{

  int i;
  for ( i = U.Length(); i >= 1; i-- ) {
    ((LUdecomp<T> &) *this).scratch2 = y;
    EtaVectorSolve(scratch2, U[i], y );
  }
}

template<class T>
void LUdecomp<T>::EtaVectorSolve( const gVector<T> &v,  
				 const EtaMatrix<T>  &eta, 
				 gVector<T> &d ) const
{
  int i;
  T temp;

  assert ( v.First() == d.First() && v.Last() == d.Last() );
  assert ( eta.etadata[eta.col] != (T)0 ); // or we would have a singular matrix
  
  temp = v[eta.col] / eta.etadata[eta.col];

  for ( i = v.First(); i <= v.Last(); i++) {
    if ( i == eta.col ) d[i] = temp;
    else {
      d[i] = v[i] - temp * eta.etadata[i];
    }
  }
}

template<class T>
void LUdecomp<T>::yLP_Trans( gVector<T> &y ) const
{
  int j;
  
  for (j = L.Length(); j >= 1; j--) {
    yLP_mult( y, j, ((LUdecomp<T> &) *this).scratch2 );
    y = scratch2;
  }
}


template<class T>
void LUdecomp<T>::yLP_mult( const gVector<T> &y, int j, gVector<T> &ans ) const
{
    
  assert ( ans.First() == y.First() && ans.Last() == y.Last() );
  T temp;
  int i, k, l;
  
  l = j + y.First() - 1;

  for (i = y.First(); i <= y.Last(); i++) {
    if ( i != L[j].col) ans[i] = y[i];
    else {
      for ( k = ans.First(), temp = (T) 0; k <= ans.Last(); k++) {
	temp += y[k] * L[j].etadata[k];
      }
      ans[i] = temp;
    }
  }

  temp = ans[l];
  ans[l] = ans[P[j]];
  ans[P[j]] = temp;

}

template<class T>
void LUdecomp<T>::LPd_Trans( gVector<T> &d ) const
{
  int j;
  for (j = 1; j <= L.Length(); j++) {
    LPd_mult( d, j, ((LUdecomp<T> &) *this).scratch2 );
    d = scratch2;
  }
}

template<class T>
void LUdecomp<T>::LPd_mult( gVector<T> &d, int j, gVector<T> &ans ) const
{
  
  assert ( d.First() == ans.First() && d.Last() == ans.Last() );

  T temp;

  int i, k;


  k = j + d.First() - 1;
  temp = d[k];
  d[k] = d[P[j]];
  d[P[j]] = temp;


  for (i = d.First(); i <= d.Last(); i++) {
    if ( i == L[j].col ) ans[i] = d[i] * L[j].etadata[i];
    else {
      ans[i] = d[i] + d[ L[j].col ] * L[j].etadata[i];
    }
  }

  d[P[j]] = d[k];  
  d[k] = temp;

  
}

template<class T>
bool LUdecomp<T>::CheckBasis() 
{
  int i,j;
  bool ret = true;

  for ( i = basis.First(); i <= basis.Last() && ret != false; 
       i++){
    ret = ret && ( basis[i] == -i );
  }

  if ( !ret ) {
    ret = true;
    for ( i = basis.First(); i <= basis.Last() && ret != false; i++ ) {
      if (basis[i] > 0) {
	for ( j = (*A).MinRow(); j <= (*A).MaxRow() && ret != false; j++ ) {
	  if ( i == j ) {
	    ret = ret && ( (*A)(j,basis[i])  == (T) 1 );
	  }
	  else {
	    ret = ret && ( (*A)(j,basis[i])  == (T) 0 );
	  }
	}
      }
      else if (basis[i] != -i ) ret = false;
    }
  }

  return ret;
}

template<class T>
bool LUdecomp<T>::RefactorCheck()
{
  int m = basis.Length();
  int i = iterations * (iterations * m + 2 * m * m );
  int k = total_operations + iterations * m + 2 * m * m;

//  gout << "basis size is " << m << '\n';
  
  bool tmp;

  tmp = ( i > k );
//  gout << "total ops : " <<  total_operations << '\n';
//  gout << "iteration : " <<  iterations << '\n';
//  gout << "Tk * k :" << i << '\n';
//  gout << "x + Tk :" << k << '\n';
//  gout << "tmp = " << tmp << '\n';
  return tmp;
}
  



