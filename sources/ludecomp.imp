//#
//# FILE: ludecomp.imp -- Implementation of LU decomposition
//#
//# $Id$
//#

#include "ludecomp.h"

// ---------------------------------------------------------------------------
// Class EtaMatrix
// ---------------------------------------------------------------------------

template <class T>
gOutput& operator<<(gOutput &out, const EtaMatrix<T> &a)
{
  out << "column: " << a.col << '\n' << a.etadata << '\n';
  return out;
}

template <class T>
bool EtaMatrix<T>::operator==(const EtaMatrix<T> &a) const
{
  return ( col == a.col && etadata == a.etadata );
}

template <class T>
bool EtaMatrix<T>::operator!=(const EtaMatrix<T> &a) const
{
  return ( col != a.col || etadata != a.etadata );
}

// ---------------------------------------------------------------------------
// Class Decomp
// ---------------------------------------------------------------------------
// -------------------------
//  C-tors, D-tor, Operators
// -------------------------

// copy constructor

template <class T> 
LUdecomp<T>::LUdecomp( const LUdecomp<T> &a )
: A(a.A), basis(a.basis), IsBasisIdent(a.IsBasisIdent),
  L(a.L), U(a.U), E(a.E), P(a.P)
{ }

// Decomposes given matrix

template <class T> 
LUdecomp<T>::LUdecomp( const gMatrix<T> &mat )
: A(&mat), basis(mat.MinRow(), mat.MaxRow()), IsBasisIdent(true)
{
  int i;
  for ( i = mat.MinRow(); i <= mat.MaxRow(); i++ ) basis[i] = -i;
}

// Decomposes the selected columnts of the given matrix

template <class T>
LUdecomp<T>::LUdecomp( const gMatrix<T> &mat, const gBlock<int> &bas )
: A(&mat), basis(bas)
{
  assert ( bas.First() == mat.MinRow() && bas.Last() == mat.MaxRow() );
  IsBasisIdent = CheckBasis();

  if ( !IsBasisIdent ) FactorBasis();
}

// Destructor
template <class T> LUdecomp<T>::~LUdecomp() 
{ }

// Assignment operator

template <class T>
LUdecomp<T>& LUdecomp<T>::operator=(const LUdecomp<T> &orig)
{
  if(this != &orig) {
    A= orig.A;
    basis = orig.basis;
    IsBasisIdent = orig.IsBasisIdent;
    L = orig.L;
    U=orig.U;
    E=orig.E;
    P=orig.P;
  }
  return *this;
}

// -------------------------
//  Public Members
// -------------------------


template <class T>
void LUdecomp<T>::update( int col, int matcol )
{
  int i;
  basis[col] = matcol;

  gVector<T> u( (*A).MinRow(), (*A).MaxRow() ); 
  gVector<T> x( (*A).MinRow(), (*A).MaxRow() );

  if( matcol<0 ) { 
    u=(T)0;
    x=(T)0; 
    x[-matcol]=(T)1; 
  }
  else (*A).GetColumn(matcol,x);

  for (i = 1; i <= E.Length(); i++ ) {
    EtaVectorSolve( x, E[i], u);
    x = u;
  }
    
  E.Append( EtaMatrix<T>( col, x ) );

  IsBasisIdent = CheckBasis();
}

template <class T>
void LUdecomp<T>::update( int col, const gVector<T> &a )
{
  int i;
  gVector<T> u(a.First(),a.Last()), x(a.First(), a.Last());
  

  for (i = 1, x = a; i <= E.Length(); i++ ) {
    EtaVectorSolve( x, E[i], u);
    x = u;
  }


  E.Append( EtaMatrix<T>( col, x ) );

  IsBasisIdent = CheckBasis();
}


template <class T> 
void LUdecomp<T>::refactor( const gMatrix<T> &m )
{
  int i;
  A = &m;
  for ( i = m.MinRow(); i <= m.MaxRow(); i++ ) basis[i] = -i;
  IsBasisIdent = true;

  L.Flush();
  U.Flush();
  E.Flush();
  P.Flush();


}

template <class T> 
void LUdecomp<T>::refactor( ) 
{
  // postponed for now
}

template <class T> 
void LUdecomp<T>::refactor( const gMatrix<T> &mat, const gBlock<int> &bas)
{

  assert ( bas.First() == mat.MinRow() && bas.Last() == mat.MaxRow() );

  A = &mat;
  basis = bas;

  L.Flush();
  U.Flush();
  E.Flush();
  P.Flush();

  IsBasisIdent = CheckBasis();
  
  if ( !IsBasisIdent ) FactorBasis();
}

template <class T>
void LUdecomp<T>::solveT( const gVector<T> &c, gVector<T> &y ) const
{

  assert ( c.First() == y.First() && c.Last() == y.Last() );
  assert ( c.First() == (*A).MinRow() && c.Last() == (*A).MaxRow());
  
  gVector<T> v(y.First(), y.Last());

  int i,j;

  y = c;
  if ( IsBasisIdent != true ) {

    for (i = E.Length(); i >= 1; i--) {
      v = y;
      VectorEtaSolve( v, E[i], y );
    }
    
    for (j = 1; j <= U.Length(); j++ ) {
      v = y; 
      VectorEtaSolve( v, U[j], y );
    }

    for (j = U.Length(); j >= 1; j--) {
      yLP_mult( y, j, v );
      y = v;
    }
  }
}

template <class T>
void LUdecomp<T>::solve( const gVector<T> &a, gVector<T> &d ) const
{

  assert ( a.First() == d.First() && a.Last() == d.Last() );
  assert ( a.First() == (*A).MinRow() && a.Last() == (*A).MaxRow() );

  gVector<T> v(d.First(), d.Last());
  
  int i,j;

  d = a;
  if ( IsBasisIdent != true ) {
    for (j = 1; j <= U.Length(); j++) {
      LPd_mult( d, j, v );
      d = v;
    }
    
    for (j = U.Length(); j >= 1; j--) {
      v = d;
      EtaVectorSolve( v, U[j], d );
    }
    
    for (i = 1; i <= E.Length(); i++) {
      v = d;
      EtaVectorSolve( v, E[i], d );
    }
  }
}

// -----------------
//  Private Members
// -----------------


template<class T>
void LUdecomp<T>::FactorBasis()
{
  int i,j, t, piv;
  T pivVal;

  gMatrix<T> B((*A).MinRow(), (*A).MaxRow(), basis.First(), basis.Last());

  gVector<T> column(B.MinRow(),B.MaxRow());
  for( i = basis.First(); i <= basis.Last(); i++ ) {
    assert ( basis[i] != 0 );
    if ( basis[i] > 0 ) {
      (*A).GetColumn( basis[i], column );
    }
    else {
      column = (T) 0;      
      column[ -basis[i] - (*A).MinCol() + (*A).MinRow()] = 1;
    }
    B.SetColumn( i, column );
  }
  
  for ( i = B.MinRow(), t = basis.First(); i <= B.MaxRow(); i++, t++ ) {    
    pivVal = abs ( B(i, t));
    piv = i;
    for ( j = i+1; j <= B.MaxRow(); j++) {
      if (  B( j, t ) * B( j, t )  > pivVal * pivVal ) {
	piv = j;
	pivVal = B( j, t );
      }
    }
    P.Append(piv);
    B.SwitchRows(i,piv);
  }

  gout << "P: ";
  for ( int k = 1; k <= P.Length(); k++)
    gout << P[k];
  
  gout << "/nreordered matrix is \n" << B << '\n';

  gVector<T> ecol(B.MinRow(), B.MaxRow());
  for ( i = B.MinRow(), t = basis.First(); i <= B.MaxRow(); i++, t++ ) {
    ecol = (T) 0;
    ecol[i] = (T) 1 / B( i, t );
    for ( j = i+1; j <= B.MaxRow(); j++ ) {
      ecol[j] =  - B(j, t) / B(i,t);
    }
    L.Append( EtaMatrix<T>(t, ecol) );
    GaussElem(B, i, t);
  }

  gout << "U matrix is \n" << B << '\n';

  gout << "L: \n";
  for ( int k = 1; k <= L.Length(); k++)
    gout << L[k] << '\n';

  for ( j = B.MinCol(); j <= B.MaxCol(); j++ ) {
    B.GetColumn( j, ecol );
    U.Append( EtaMatrix<T>( j, ecol ));
  }
}

template<class T>
void LUdecomp<T>::GaussElem(gMatrix<T> &B, int row, int col)
{
  assert( B(row, col) != (T) 0);

  int i,j;

  for ( j = col+1; j <= B.MaxCol(); j++)
    B( row, j ) = B( row, j ) / B( row, col );

  for ( i = row+1; i <= B.MaxRow(); i++ ) 
    for ( j = col+1; j <= B.MaxCol(); j++ ) {
      B( i, j ) = B( i, j ) - ( B( i, col ) * B( row, j ) );
      gout << "B(" << i << ',' << j << ") = " << B( i,col) << " * " <<B(row,j) << '\n';
    }
  for ( i = row+1; i <= B.MaxRow(); i++ )
    B( i , col ) = 0;

  B( row, col ) = (T) 1;

  gout << B << '\n';
  
}
      
template<class T>
void LUdecomp<T>::VectorEtaSolve( const gVector<T> &v,  
				 const EtaMatrix<T>  &eta, 
				 gVector<T> &y ) const
{

  int i, j;

  assert ( v.First() == y.First() && v.Last() == y.Last() );

  for ( i = v.First(); i <= v.Last(); i++ ) {
    y[i] = v[i];
    if ( i == eta.col ) {
      for ( j = v.First(); j <= v.Last(); j++ )
	if ( j != eta.col ) y[i] -= v[j] * eta.etadata[j];
      y[i] /= eta.etadata[i];
    }    
  }
}

template<class T>
void LUdecomp<T>::EtaVectorSolve( const gVector<T> &v,  
				 const EtaMatrix<T>  &eta, 
				 gVector<T> &d ) const
{
  int i,j;
  T temp;

  assert ( v.First() == d.First() && v.Last() == d.Last() );
  
  
  temp = v[eta.col] / eta.etadata[eta.col];

  for ( i = v.First(), j = eta.etadata.First(); i <= v.Last(); i++, j++) {
    if ( i == eta.col ) d[i] = temp;
    else {
      d[i] = v[i] - temp * eta.etadata[j];
    }
  }
}

template<class T>
void LUdecomp<T>::yLP_mult( const gVector<T> &y, int j, gVector<T> &ans ) const
{
    
  assert ( ans.First() == y.First() && ans.Last() == y.Last() );
  T temp;
  int i, k, l;
  
  l = j + y.First() - 1;

  for (i = y.First(); i <= y.Last(); i++) {
    if ( i != L[j].col) ans[i] = y[i];
    else {
      for ( k = ans.First(), temp = (T) 0; k <= ans.Last(); k++) {
	temp += y[k] * L[j].etadata[k];
      }
      ans[i] = temp;
    }
  }

  temp = ans[l];
  ans[l] = ans[P[j]];
  ans[P[j]] = temp;

}

template<class T>
void LUdecomp<T>::LPd_mult( const gVector<T> &d, int j, gVector<T> &ans ) const
{
  
  assert ( d.First() == ans.First() && d.Last() == ans.Last() );

  T temp;

  int i, k;

  gVector<T> tempvec(d);

  k = j + d.First() - 1;
  temp = tempvec[k];
  tempvec[k] = tempvec[P[j]];
  tempvec[P[j]] = temp;


  for (i = tempvec.First(); i <= tempvec.Last(); i++) {
    if ( i == L[j].col ) ans[i] = tempvec[i] * L[j].etadata[i];
    else {
      ans[i] = tempvec[i] + tempvec[ L[j].col ] * L[j].etadata[i];
    }
  }
}

template<class T> 
bool LUdecomp<T>::CheckBasis( const gBlock<int> &basis )
{
  int i;
  bool ret = true;
  for ( i = basis.First(); i <= basis.Last() && ret != false; 
       i++){
    ret = ret && ( basis[i] == -i );
  }
  return ret;
}

template<class T>
bool LUdecomp<T>::CheckBasis() 
{
  int i,j;
  bool ret = true;
  for ( i = basis.First(); i <= basis.Last() && ret != false; i++ ) {
    if (basis[i] > 0) {
      for ( j = (*A).MinRow(); j <= (*A).MaxRow() && ret != false; j++ ) {
	if ( i == j ) {
	  ret = ret && ( (*A)(j,basis[i])  == (T) 1 );
	}
	else {
	  ret = ret && ( (*A)(j,basis[i])  == (T) 0 );
	}
      }
    }
    else if (basis[i] != -( (*A).MinRow() + i )) ret = false;
  }
  return ret;
}

