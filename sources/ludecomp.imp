//
// FILE: ludecomp.imp -- implementation of the LUdecomp class
//                       and Basis class (for now).
// $Id$
//

#include "ludecomp.h"

// ---------------------------------------------------------------------------
// Class Basis
// ---------------------------------------------------------------------------

// -----------------------
// C-tor, D-tor, Operators
// -----------------------

template <class T> 
Basis<T>::Basis(const gMatrix<T> &mat)
: A(&mat), label( mat.MinRow(), mat.MaxRow() ), 
  cols( mat.MinCol(), mat.MaxCol() ), slacks( mat.MinRow(), mat.MaxRow() ), 
  arts(), artUnitEntry(),colBlocked(mat.MinCol(), mat.MaxCol() ),
  rowBlocked( mat.MinRow(), mat.MaxRow() )
{

  int i;
  for(i = cols.First(); i <= cols.Last(); i++) {
    cols[i] = 0;
    colBlocked[i] = false;
  }

  for(i = label.First(); i <= label.Last(); i++) {
    label[i]= - i;
    slacks[i] = i;
    rowBlocked[i] = false;
  }
  IsBasisIdent = true;
}

template <class T>
Basis<T>::Basis(const Basis<T> &bas)
: A(bas.A), label(bas.label), cols( bas.cols ), slacks( bas.slacks ),
  arts(bas.arts), artUnitEntry(bas.artUnitEntry),
  colBlocked(bas.colBlocked),rowBlocked(bas.rowBlocked),
  IsBasisIdent(bas.IsBasisIdent)
{ }

template <class T>
Basis<T>::~Basis()
{ }

template <class T>
Basis<T>& Basis<T>::operator=(const Basis<T> &orig)
{
  if(this != &orig) {
    A = orig.A;
    label = orig.label; 
    cols = orig.cols;
    slacks = orig.slacks;
    arts = orig.arts;
    artUnitEntry = orig.artUnitEntry;
    rowBlocked = orig.rowBlocked;
    colBlocked = orig.colBlocked;
    IsBasisIdent = orig.IsBasisIdent;

  }
  return *this;
}


// -------------------------
// Public Members
// -------------------------

template <class T>
int Basis<T>::Pivot(int outindex, int col)
{
  int outlabel = label[outindex];
 
  if ( -col >= label.First() && -col <= label.Last() ) slacks[-col] = outindex;
  else if ( col >= cols.First() && col <= cols.Last() ) cols[col] = outindex;
  else if ( col > cols.Last() && col <= cols.Last() + arts.Length() ) 
    arts[col - cols.Last()] = outindex;
  else assert(0); // not a valid column to pivot in.
  
  if ( -outlabel >= label.First() && -outlabel <= label.Last() ) 
    slacks[-outlabel] = 0;
  else if ( outlabel >= cols.First() && outlabel <= cols.Last() ) 
    cols[outlabel] = 0;
  else if ( outlabel > cols.Last() && 
	   outlabel <= cols.Last() + arts.Length() ) 
    arts[outlabel - cols.Last()] = 0;
  else assert(0); // not a valid column to pivot in.
  
  label[outindex] = col;
  CheckBasis();
  
  return outlabel;
}

template <class T>
bool Basis<T>::Member( int col ) const
{
  int ret;

  if ( -col >= label.First() && -col <= label.Last() ) ret = slacks[-col];
  else if ( col >= cols.First() && col <= cols.Last() ) ret = cols[col];
  else if ( col > cols.Last() && col <= cols.Last() + arts.Length() ) 
    ret = arts[col - cols.Last()];
  else ret = 0;

  return (ret != 0);
}


template <class T>
int Basis<T>::Find( int col ) const
{
  int ret;

  if ( -col >= label.First() && -col <= label.Last() ) ret = slacks[-col];
  else if ( col >= cols.First() && col <= cols.Last() ) ret = cols[col];
  else if ( col > cols.Last() && col <= cols.Last() + arts.Length() ) 
    ret = arts[col - cols.Last()];
  else ret = 0;
  
  assert (ret != 0);
  return ret;
}

template <class T>
int Basis<T>::Label(int index) const
{
  return  label[index];
}

template <class T>
void Basis<T>::Mark(int col )
{
  if ( -col >= label.First() && -col <= label.Last() ) 
    rowBlocked[-col] = true;
  else if ( col >= cols.First() && col <= cols.Last() ) 
    colBlocked[col] = true;
}

template <class T>
void Basis<T>::UnMark(int col )
{
  if ( -col >= label.First() && -col <= label.Last() ) 
    rowBlocked[-col] = false;
  else if ( col >= cols.First() && col <= cols.Last() ) 
    colBlocked[col] = false;
}

template <class T>
bool Basis<T>::IsBlocked(int col) const
{
  if ( -col >= label.First() && -col <= label.Last() ) 
    return rowBlocked[-col];
  else if ( col >= cols.First() && col <= cols.Last() ) 
    return colBlocked[col];
  return false;
}

template <class T>
void Basis<T>::BasisSelect(const gVector<T> &rowv, gVector<T> &colv) const
{
  assert(A->CheckColumn(colv) && A->CheckRow(rowv));

  for(int i=label.First(); i<=label.Last(); i++) {
    if(label[i]<0)
      colv[i]= 0;
    else
      colv[i]= rowv[label[i]];
  }
}

template <class T>
void Basis<T>::BasisSelect(const gVector<T> &unitv,
			   const gVector<T> &rowv,
			   gVector<T> &colv ) const
{
  assert(A->CheckColumn(colv)
	 && A->CheckColumn(unitv)
	 && A->CheckRow(rowv) );
  
  for(int i=label.First(); i<=label.Last(); i++) {
    if(label[i]<0)
      colv[i]= unitv[-label[i]];
    else
      colv[i]= rowv[label[i]];
  }
}

template <class T> 
bool Basis<T>::IsSpecialColumn( int col ) const
{
  return ( (-col >= label.First() && -col <= label.Last()) ||
	  ( col > cols.Last() && col <= cols.Last() + arts.Length()) ); 
}
 
template <class T>
void Basis<T>::GetColumn( int col, gVector<T> &ret ) const
{
  
  if ( IsSpecialColumn( col ) ) {
    if ( col < 0 ) {
      ret = (T) 0;
      ret[-col] = (T) 1;
    }
    else { // its an artificial variable
      ret = (T) 0;
      ret[artUnitEntry[col - cols.Last()]] = (T) 1;
    }
  }
  else 
    A->GetColumn(col, ret);
  
}


template <class T>
void Basis<T>::InsertArtificial( int art, int col )
{
  arts.Insert( 0, col - cols.Last() );
  artUnitEntry.Insert( art, col - cols.Last() );
}

template <class T>
int Basis<T>::AppendArtificial( int art )
{
  arts.Append(0);
  return artUnitEntry.Append(art) + cols.Last();
}

template <class T>
void Basis<T>::RemoveArtificial( int col )
{
  arts.Remove(col-cols.Last());
  artUnitEntry.Remove( col - cols.Last() );
}

template <class T>
void Basis<T>::FlushArtificial()
{
  arts.Flush();
  artUnitEntry.Flush();
}

template <class T>
int Basis<T>::LastArtificial()
{
  return ( artUnitEntry.Last() + cols.Last() );
}

template <class T> 
gOutput &operator<<(gOutput &to, const Basis<T> &v)
{
  v.Dump(to); return to;
}

template <class T>
void Basis<T>::Dump(gOutput &to) const
{ 
  to << "{";
  for(int i=label.First();i<=label.Last();i++) {
    to << "  " << label[i];  
  }
  to << " }";
}

template<class T>
void Basis<T>::CheckBasis() 
{
  int i;
  bool check = true;

  for ( i =label.First(); i <= label.Last() && check != false; 
       i++){
    check = check && ( label[i] == -i  || ( label[i] == i + cols.Last() ));
  }

//  if ( !check ) {
//    check = true;
//    for ( i = label.First(); i <= label.Last() && check != false; i++ ) {
//      if (basis[i] > 0) {
//	for ( j = (*A).MinRow(); j <= (*A).MaxRow() && check != false; j++ ) {
//	  if ( i == j ) {
//	    check = check && ( (*A)(j,label[i])  == (T) 1 );
//	  }
//	  else {
//	    check = check && ( (*A)(j,label[i])  == (T) 0 );
//	  }
//	}
//      }
//      else if (label[i] != -i ) check = false;
//    }
//  }

  IsBasisIdent = check;
}

template<class T>
bool Basis<T>::IsIdent()
{
  return IsBasisIdent;
}


// ---------------------------------------------------------------------------
// Class EtaMatrix
// ---------------------------------------------------------------------------

template <class T>
gOutput& operator<<(gOutput &out, const EtaMatrix<T> &a)
{
  out << "column: " << a.col << '\n' << a.etadata << '\n';
  return out;
}

template <class T>
bool EtaMatrix<T>::operator==(const EtaMatrix<T> &a) const
{
  return ( col == a.col && etadata == a.etadata );
}

template <class T>
bool EtaMatrix<T>::operator!=(const EtaMatrix<T> &a) const
{
  return ( col != a.col || etadata != a.etadata );
}

// ---------------------------------------------------------------------------
// Class LUdecomp
// ---------------------------------------------------------------------------
// -------------------------
//  C-tors, D-tor, Operators
// -------------------------

// copy constructor

template <class T> 
LUdecomp<T>::LUdecomp( const LUdecomp<T> &a, Basis<T> &bas)
: basis( bas ), 
  scratch1(basis.label.First(), basis.label.Last()), 
  scratch2(basis.label.First(), basis.label.Last()),
  refactor_number( a.refactor_number ), iterations(a.iterations),
  total_operations( a.total_operations),
  parent(&a), copycount(0)

{ 
  ((LUdecomp<T> &)*parent).copycount++;
}

// Decomposes given matrix

template <class T> 
LUdecomp<T>::LUdecomp( Basis<T> &bas,
		      int rfac = 0 )	
: basis(bas),  
  scratch1(basis.label.First(), basis.label.Last()), 
  scratch2(basis.label.First(), basis.label.Last()),
  refactor_number(rfac), iterations(0), parent(NULL), copycount(0)
{
  int m = basis.label.Length();
  total_operations = (m - 1) * m * (2 * m - 1) / 6;
}

// Destructor
template <class T> LUdecomp<T>::~LUdecomp() 
{ 
  if ( parent != NULL )
    ((LUdecomp<T> &) *parent).copycount--;
  assert ( copycount == 0 );
}



// -------------------------
//  Public Members
// -------------------------

// use this to copy ludecomps.... 
template <class T>
void LUdecomp<T>::Copy(const LUdecomp<T> &orig, Basis<T> &bas)
{
  if(this != &orig) {
    if (parent != NULL)
      ((LUdecomp<T> &) *parent).copycount--;
 
    basis = bas;
    
    L.Flush();
    P.Flush();
    E.Flush();
    U.Flush();

    refactor_number = orig.refactor_number;
    iterations = orig.iterations;
    total_operations = orig.total_operations;
    parent = &orig;
    copycount = 0;
    ((LUdecomp<T> &)*parent).copycount++;
  }
}

template <class T>
void LUdecomp<T>::update( int col, int matcol )
{

  assert( copycount == 0 );

  iterations++;
  if (( refactor_number > 0 && iterations >= refactor_number ) ||
      ( refactor_number == 0 && RefactorCheck()) )  
    refactor();
  else {
    basis.GetColumn( matcol, scratch1); 
    solve( scratch1, scratch1 );
    assert ( scratch1[col] != (T) 0 );
    E.Append( EtaMatrix<T>( col, scratch1 ) );
    
    total_operations += iterations * basis.label.Length() +  
      2 * basis.label.Length() * basis.label.Length();    
  }
  
}


template <class T> 
void LUdecomp<T>::refactor( ) 
{

  L.Flush();
  U.Flush();
  E.Flush();
  P.Flush();

  if ( !basis.IsIdent() ) FactorBasis();

  iterations = 0;
  int m = basis.label.Length();
  total_operations = (m - 1) * m * (2 * m - 1) / 6;
  if (parent != NULL) ((LUdecomp<T> &)*parent).copycount--;
  parent = NULL;
  
}

template <class T>
void LUdecomp<T>::solveT( const gVector<T> &c, gVector<T> &y ) const  
{

  assert ( c.First() == y.First() && c.Last() == y.Last() );
  assert ( c.First() == (*(basis.A)).MinRow() 
	  && c.Last() == (*(basis.A)).MaxRow());

  y = c;
  if ( basis.IsIdent() != true ) {

    BTransE( y );

    if ( parent != NULL ) { 
      (*parent).solveT( y, y );
    }
    else {
      FTransU( y );
      yLP_Trans( y );
    }
  }
}

template <class T>
void LUdecomp<T>::solve( const gVector<T> &a, gVector<T> &d ) const
{

  assert ( a.First() == d.First() && a.Last() == d.Last() );
  assert ( a.First() == (*(basis.A)).MinRow() 
	  && a.Last() == (*(basis.A)).MaxRow() );
  
  d = a;
  if ( basis.IsIdent() != true ) {
    
    if ( parent != NULL ) {
      (*parent).solve(a,d);
    }
    
    else {
      LPd_Trans( d );
      BTransU( d );
    }
    
    FTransE( d );
  }
}

template<class T>
void LUdecomp<T>::SetRefactor( int a )
{
  refactor_number = a;
}

// -----------------
//  Private Members
// -----------------


template<class T>
void LUdecomp<T>::FactorBasis()
{
  int i, j, piv;
  T pivVal;

  gMatrix<T> B((*(basis.A)).MinRow(), (*(basis.A)).MaxRow(), 
	       basis.label.First(), basis.label.Last());

  for( i = basis.label.First(); i <= basis.label.Last(); i++ ) {
    
    basis.GetColumn( basis.label[i], scratch2 );
    basis.CheckBasis();
    B.SetColumn( i, scratch2 );
  }
  
  for ( i = B.MinRow(); i <= B.MaxRow(); i++) {    
    pivVal = abs ( B(i, i));
    piv = i;
    for ( j = i+1; j <= B.MaxRow(); j++) {
      if (  B( j, i ) * B( j, i )  > pivVal * pivVal ) {
	piv = j;
	pivVal = B( j, i );
      }
    }
    P.Append(piv);
    B.SwitchRows(i,piv);
    
    scratch2 = (T) 0;
    scratch2[i] = (T) 1 / B( i, i );
    for ( j = i+1; j <= B.MaxRow(); j++ ) {
      scratch2[j] =  - B(j, i) / B(i,i);
    }
    L.Append( EtaMatrix<T>(i, scratch2) );
    GaussElem(B, i, i);

  }
  
  for ( j = B.MinCol(); j <= B.MaxCol(); j++ ) {
    B.GetColumn( j, scratch2 );
    U.Append( EtaMatrix<T>( j, scratch2 ));
  }
}

template<class T>
void LUdecomp<T>::GaussElem(gMatrix<T> &B, int row, int col)
{
  assert( B(row, col) != (T) 0);

  int i,j;

  for ( j = col+1; j <= B.MaxCol(); j++)
    B( row, j ) = B( row, j ) / B( row, col );

  for ( i = row+1; i <= B.MaxRow(); i++ ) 
    for ( j = col+1; j <= B.MaxCol(); j++ ) {
      B( i, j ) = B( i, j ) - ( B( i, col ) * B( row, j ) );
    }

  for ( i = row+1; i <= B.MaxRow(); i++ )
    B( i , col ) = 0;

  B( row, col ) = (T) 1;

}


template<class T>
void LUdecomp<T>::BTransE( gVector<T> &y ) const
{

  int i;
  for ( i = E.Length(); i >= 1; i-- ) {
    ((LUdecomp<T> &) *this).scratch2 = y;
    VectorEtaSolve(scratch2, E[i], y );
  }
}
  
template<class T>
void LUdecomp<T>::FTransU( gVector<T> &y ) const
{

  int i;
  for ( i = 1; i <= U.Length(); i++ ) {
    ((LUdecomp<T> &) *this).scratch2 = y;
    VectorEtaSolve(scratch2, U[i], y );
  }
}

template<class T>
void LUdecomp<T>::VectorEtaSolve( const gVector<T> &v,  
				 const EtaMatrix<T>  &eta, 
				 gVector<T> &y ) const
{

  int i, j;

  assert ( v.First() == y.First() && v.Last() == y.Last() );

  for ( i = v.First(); i <= v.Last(); i++ ) {
    y[i] = v[i];
    if ( i == eta.col ) {
      for ( j = v.First(); j <= v.Last(); j++ )
	if ( j != eta.col ) y[i] -= v[j] * eta.etadata[j];
      y[i] /= eta.etadata[i];
    }    
  }
}

template<class T>
void LUdecomp<T>::FTransE( gVector<T> &y ) const
{

  int i;
  for ( i = 1; i <= E.Length(); i++ ) {
    ((LUdecomp<T> &) *this).scratch2 = y;
    EtaVectorSolve(scratch2, E[i], y );
  }
}
  
template<class T>
void LUdecomp<T>::BTransU( gVector<T> &y ) const
{

  int i;
  for ( i = U.Length(); i >= 1; i-- ) {
    ((LUdecomp<T> &) *this).scratch2 = y;
    EtaVectorSolve(scratch2, U[i], y );
  }
}

template<class T>
void LUdecomp<T>::EtaVectorSolve( const gVector<T> &v,  
				 const EtaMatrix<T>  &eta, 
				 gVector<T> &d ) const
{
  int i;
  T temp;

  assert ( v.First() == d.First() && v.Last() == d.Last() );
  assert ( eta.etadata[eta.col] != (T)0 ); // or we would have a singular matrix
  
  temp = v[eta.col] / eta.etadata[eta.col];

  for ( i = v.First(); i <= v.Last(); i++) {
    if ( i == eta.col ) d[i] = temp;
    else {
      d[i] = v[i] - temp * eta.etadata[i];
    }
  }
}

template<class T>
void LUdecomp<T>::yLP_Trans( gVector<T> &y ) const
{
  int j;
  
  for (j = L.Length(); j >= 1; j--) {
    yLP_mult( y, j, ((LUdecomp<T> &) *this).scratch2 );
    y = scratch2;
  }
}


template<class T>
void LUdecomp<T>::yLP_mult( const gVector<T> &y, int j, gVector<T> &ans ) const
{
    
  assert ( ans.First() == y.First() && ans.Last() == y.Last() );
  T temp;
  int i, k, l;
  
  l = j + y.First() - 1;

  for (i = y.First(); i <= y.Last(); i++) {
    if ( i != L[j].col) ans[i] = y[i];
    else {
      for ( k = ans.First(), temp = (T) 0; k <= ans.Last(); k++) {
	temp += y[k] * L[j].etadata[k];
      }
      ans[i] = temp;
    }
  }

  temp = ans[l];
  ans[l] = ans[P[j]];
  ans[P[j]] = temp;

}

template<class T>
void LUdecomp<T>::LPd_Trans( gVector<T> &d ) const
{
  int j;
  for (j = 1; j <= L.Length(); j++) {
    LPd_mult( d, j, ((LUdecomp<T> &) *this).scratch2 );
    d = scratch2;
  }
}

template<class T>
void LUdecomp<T>::LPd_mult( gVector<T> &d, int j, gVector<T> &ans ) const
{
  
  assert ( d.First() == ans.First() && d.Last() == ans.Last() );

  T temp;

  int i, k;


  k = j + d.First() - 1;
  temp = d[k];
  d[k] = d[P[j]];
  d[P[j]] = temp;


  for (i = d.First(); i <= d.Last(); i++) {
    if ( i == L[j].col ) ans[i] = d[i] * L[j].etadata[i];
    else {
      ans[i] = d[i] + d[ L[j].col ] * L[j].etadata[i];
    }
  }

  d[P[j]] = d[k];  
  d[k] = temp;

  
}

template<class T>
bool LUdecomp<T>::CheckBasis() 
{
  int i;
  bool ret = true;

  for ( i = basis.label.First(); i <= basis.label.Last() && ret != false; 
       i++){
    ret = ret && ( basis.label[i] == -i );
  }

  return ret;
}

template<class T>
bool LUdecomp<T>::RefactorCheck()
{
  int m = basis.label.Length();
  int i = iterations * (iterations * m + 2 * m * m );
  int k = total_operations + iterations * m + 2 * m * m;

//  gout << "basis size is " << m << '\n';
  
  bool tmp;

  tmp = ( i > k );
//  gout << "total ops : " <<  total_operations << '\n';
//  gout << "iteration : " <<  iterations << '\n';
//  gout << "Tk * k :" << i << '\n';
//  gout << "x + Tk :" << k << '\n';
//  gout << "tmp = " << tmp << '\n';
  return tmp;
}
  



