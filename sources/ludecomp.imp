//
// FILE: ludecomp.imp -- implementation of the LUdecomp class
//                       and Basis class (for now).
// $Id$
//

#include "ludecomp.h"

// ---------------------------------------------------------------------------
// Class EtaMatrix
// ---------------------------------------------------------------------------

template <class T>
gOutput& operator<<(gOutput &out, const EtaMatrix<T> &a)
{
  out << "column: " << a.col << '\n' << a.etadata << '\n';
  return out;
}

template <class T>
bool EtaMatrix<T>::operator==(const EtaMatrix<T> &a) const
{
  return ( col == a.col && etadata == a.etadata );
}

template <class T>
bool EtaMatrix<T>::operator!=(const EtaMatrix<T> &a) const
{
  return ( col != a.col || etadata != a.etadata );
}

// ---------------------------------------------------------------------------
// Class LUdecomp
// ---------------------------------------------------------------------------
// -------------------------
//  C-tors, D-tor, Operators
// -------------------------

// copy constructor

template <class T> 
LUdecomp<T>::LUdecomp( const LUdecomp<T> &a, Basis<T> &bas)
: basis( bas ), 
  scratch1(basis.label.First(), basis.label.Last()), 
  scratch2(basis.label.First(), basis.label.Last()),
  refactor_number( a.refactor_number ), iterations(a.iterations),
  total_operations( a.total_operations),
  parent(&a), copycount(0)

{ 
  ((LUdecomp<T> &)*parent).copycount++;
}

// Decomposes given matrix

template <class T> 
LUdecomp<T>::LUdecomp( Basis<T> &bas,
		      int rfac = 0 )	
: basis(bas),  
  scratch1(basis.label.First(), basis.label.Last()), 
  scratch2(basis.label.First(), basis.label.Last()),
  refactor_number(rfac), iterations(0), parent(NULL), copycount(0)
{
  int m = basis.label.Length();
  total_operations = (m - 1) * m * (2 * m - 1) / 6;
}

// Destructor
template <class T> LUdecomp<T>::~LUdecomp() 
{ 
  if ( parent != NULL )
    ((LUdecomp<T> &) *parent).copycount--;
  assert ( copycount == 0 );
}



// -------------------------
//  Public Members
// -------------------------

// use this to copy ludecomps.... 
template <class T>
void LUdecomp<T>::Copy(const LUdecomp<T> &orig, Basis<T> &bas)
{
  if(this != &orig) {
    if (parent != NULL)
      ((LUdecomp<T> &) *parent).copycount--;
 
    basis = bas;
    
    L.Flush();
    P.Flush();
    E.Flush();
    U.Flush();

    refactor_number = orig.refactor_number;
    iterations = orig.iterations;
    total_operations = orig.total_operations;
    parent = &orig;
    copycount = 0;
    ((LUdecomp<T> &)*parent).copycount++;
  }
}

template <class T>
void LUdecomp<T>::update( int col, int matcol )
{

  assert( copycount == 0 );

  iterations++;
  if (( refactor_number > 0 && iterations >= refactor_number ) ||
      ( refactor_number == 0 && RefactorCheck()) )  
    refactor();
  else {
    basis.GetColumn( matcol, scratch1); 
    solve( scratch1, scratch1 );
    assert ( scratch1[col] != (T) 0 );
    E.Append( EtaMatrix<T>( col, scratch1 ) );
    
    total_operations += iterations * basis.label.Length() +  
      2 * basis.label.Length() * basis.label.Length();    
  }
  
}


template <class T> 
void LUdecomp<T>::refactor( ) 
{

  L.Flush();
  U.Flush();
  E.Flush();
  P.Flush();

  if ( !basis.IsIdent() ) FactorBasis();

  iterations = 0;
  int m = basis.label.Length();
  total_operations = (m - 1) * m * (2 * m - 1) / 6;
  if (parent != NULL) ((LUdecomp<T> &)*parent).copycount--;
  parent = NULL;
  
}

template <class T>
void LUdecomp<T>::solveT( const gVector<T> &c, gVector<T> &y ) const  
{

  assert ( c.First() == y.First() && c.Last() == y.Last() );
  assert ( c.First() == (*(basis.A)).MinRow() 
	  && c.Last() == (*(basis.A)).MaxRow());

  y = c;
  if ( basis.IsIdent() != true ) {

    BTransE( y );

    if ( parent != NULL ) { 
      (*parent).solveT( y, y );
    }
    else {
      FTransU( y );
      yLP_Trans( y );
    }
  }
}

template <class T>
void LUdecomp<T>::solve( const gVector<T> &a, gVector<T> &d ) const
{

  assert ( a.First() == d.First() && a.Last() == d.Last() );
  assert ( a.First() == (*(basis.A)).MinRow() 
	  && a.Last() == (*(basis.A)).MaxRow() );
  
  d = a;
  if ( basis.IsIdent() != true ) {
    
    if ( parent != NULL ) {
      (*parent).solve(a,d);
    }
    
    else {
      LPd_Trans( d );
      BTransU( d );
    }
    
    FTransE( d );
  }
}

template<class T>
void LUdecomp<T>::SetRefactor( int a )
{
  refactor_number = a;
}

// -----------------
//  Private Members
// -----------------


template<class T>
void LUdecomp<T>::FactorBasis()
{
  int i, j, piv;
  T pivVal;

  gMatrix<T> B((*(basis.A)).MinRow(), (*(basis.A)).MaxRow(), 
	       basis.label.First(), basis.label.Last());

  for( i = basis.label.First(); i <= basis.label.Last(); i++ ) {
    
    basis.GetColumn( basis.label[i], scratch2 );
    basis.CheckBasis();
    B.SetColumn( i, scratch2 );
  }
  
  for ( i = B.MinRow(); i <= B.MaxRow(); i++) {    
    pivVal = abs ( B(i, i));
    piv = i;
    for ( j = i+1; j <= B.MaxRow(); j++) {
      if (  B( j, i ) * B( j, i )  > pivVal * pivVal ) {
	piv = j;
	pivVal = B( j, i );
      }
    }
    P.Append(piv);
    B.SwitchRows(i,piv);
    
    scratch2 = (T) 0;
    scratch2[i] = (T) 1 / B( i, i );
    for ( j = i+1; j <= B.MaxRow(); j++ ) {
      scratch2[j] =  - B(j, i) / B(i,i);
    }
    L.Append( EtaMatrix<T>(i, scratch2) );
    GaussElem(B, i, i);

  }
  
  for ( j = B.MinCol(); j <= B.MaxCol(); j++ ) {
    B.GetColumn( j, scratch2 );
    U.Append( EtaMatrix<T>( j, scratch2 ));
  }
}

template<class T>
void LUdecomp<T>::GaussElem(gMatrix<T> &B, int row, int col)
{
  assert( B(row, col) != (T) 0);

  int i,j;

  for ( j = col+1; j <= B.MaxCol(); j++)
    B( row, j ) = B( row, j ) / B( row, col );

  for ( i = row+1; i <= B.MaxRow(); i++ ) 
    for ( j = col+1; j <= B.MaxCol(); j++ ) {
      B( i, j ) = B( i, j ) - ( B( i, col ) * B( row, j ) );
    }

  for ( i = row+1; i <= B.MaxRow(); i++ )
    B( i , col ) = 0;

  B( row, col ) = (T) 1;

}


template<class T>
void LUdecomp<T>::BTransE( gVector<T> &y ) const
{

  int i;
  for ( i = E.Length(); i >= 1; i-- ) {
    ((LUdecomp<T> &) *this).scratch2 = y;
    VectorEtaSolve(scratch2, E[i], y );
  }
}
  
template<class T>
void LUdecomp<T>::FTransU( gVector<T> &y ) const
{

  int i;
  for ( i = 1; i <= U.Length(); i++ ) {
    ((LUdecomp<T> &) *this).scratch2 = y;
    VectorEtaSolve(scratch2, U[i], y );
  }
}

template<class T>
void LUdecomp<T>::VectorEtaSolve( const gVector<T> &v,  
				 const EtaMatrix<T>  &eta, 
				 gVector<T> &y ) const
{

  int i, j;

  assert ( v.First() == y.First() && v.Last() == y.Last() );

  for ( i = v.First(); i <= v.Last(); i++ ) {
    y[i] = v[i];
    if ( i == eta.col ) {
      for ( j = v.First(); j <= v.Last(); j++ )
	if ( j != eta.col ) y[i] -= v[j] * eta.etadata[j];
      y[i] /= eta.etadata[i];
    }    
  }
}

template<class T>
void LUdecomp<T>::FTransE( gVector<T> &y ) const
{

  int i;
  for ( i = 1; i <= E.Length(); i++ ) {
    ((LUdecomp<T> &) *this).scratch2 = y;
    EtaVectorSolve(scratch2, E[i], y );
  }
}
  
template<class T>
void LUdecomp<T>::BTransU( gVector<T> &y ) const
{

  int i;
  for ( i = U.Length(); i >= 1; i-- ) {
    ((LUdecomp<T> &) *this).scratch2 = y;
    EtaVectorSolve(scratch2, U[i], y );
  }
}

template<class T>
void LUdecomp<T>::EtaVectorSolve( const gVector<T> &v,  
				 const EtaMatrix<T>  &eta, 
				 gVector<T> &d ) const
{
  int i;
  T temp;

  assert ( v.First() == d.First() && v.Last() == d.Last() );
  assert ( eta.etadata[eta.col] != (T)0 ); // or we would have a singular matrix
  
  temp = v[eta.col] / eta.etadata[eta.col];

  for ( i = v.First(); i <= v.Last(); i++) {
    if ( i == eta.col ) d[i] = temp;
    else {
      d[i] = v[i] - temp * eta.etadata[i];
    }
  }
}

template<class T>
void LUdecomp<T>::yLP_Trans( gVector<T> &y ) const
{
  int j;
  
  for (j = L.Length(); j >= 1; j--) {
    yLP_mult( y, j, ((LUdecomp<T> &) *this).scratch2 );
    y = scratch2;
  }
}


template<class T>
void LUdecomp<T>::yLP_mult( const gVector<T> &y, int j, gVector<T> &ans ) const
{
    
  assert ( ans.First() == y.First() && ans.Last() == y.Last() );
  T temp;
  int i, k, l;
  
  l = j + y.First() - 1;

  for (i = y.First(); i <= y.Last(); i++) {
    if ( i != L[j].col) ans[i] = y[i];
    else {
      for ( k = ans.First(), temp = (T) 0; k <= ans.Last(); k++) {
	temp += y[k] * L[j].etadata[k];
      }
      ans[i] = temp;
    }
  }

  temp = ans[l];
  ans[l] = ans[P[j]];
  ans[P[j]] = temp;

}

template<class T>
void LUdecomp<T>::LPd_Trans( gVector<T> &d ) const
{
  int j;
  for (j = 1; j <= L.Length(); j++) {
    LPd_mult( d, j, ((LUdecomp<T> &) *this).scratch2 );
    d = scratch2;
  }
}

template<class T>
void LUdecomp<T>::LPd_mult( gVector<T> &d, int j, gVector<T> &ans ) const
{
  
  assert ( d.First() == ans.First() && d.Last() == ans.Last() );

  T temp;

  int i, k;


  k = j + d.First() - 1;
  temp = d[k];
  d[k] = d[P[j]];
  d[P[j]] = temp;


  for (i = d.First(); i <= d.Last(); i++) {
    if ( i == L[j].col ) ans[i] = d[i] * L[j].etadata[i];
    else {
      ans[i] = d[i] + d[ L[j].col ] * L[j].etadata[i];
    }
  }

  d[P[j]] = d[k];  
  d[k] = temp;

  
}

template<class T>
bool LUdecomp<T>::CheckBasis() 
{
  int i;
  bool ret = true;

  for ( i = basis.label.First(); i <= basis.label.Last() && ret != false; 
       i++){
    ret = ret && ( basis.label[i] == -i );
  }

  return ret;
}

template<class T>
bool LUdecomp<T>::RefactorCheck()
{
  int m = basis.label.Length();
  int i = iterations * (iterations * m + 2 * m * m );
  int k = total_operations + iterations * m + 2 * m * m;

//  gout << "basis size is " << m << '\n';
  
  bool tmp;

  tmp = ( i > k );
//  gout << "total ops : " <<  total_operations << '\n';
//  gout << "iteration : " <<  iterations << '\n';
//  gout << "Tk * k :" << i << '\n';
//  gout << "x + Tk :" << k << '\n';
//  gout << "tmp = " << tmp << '\n';
  return tmp;
}
  



