//#
//# FILE: garray.imp - Implementation of gArray data type
//#
//# $Id$
//#

#include <stdlib.h>
#include <assert.h>
#include "garray.h"
#include "gambitio.h"


template <class T> gArray<T>::gArray(int len) : min(1), max(len)
{
  assert(len>=0);
  data = (len) ? new T[len] - 1 : 0;
}

template <class T> gArray<T>::gArray(int lo, int hi) : min(lo), max(hi)
{
  assert(max>=min);
  data = (max>=min) ? new T[max-min+1] - min : 0;
}

template <class T> gArray<T>::gArray(const gArray<T> &a) 
  : min(a.min), max(a.max)
{
  data = (max>=min) ? new T[max-min+1] - min : 0;
  for (int i = min; i <= max; i++)
    data[i] = a.data[i];
}

template <class T> gArray<T>::~gArray()
{
  if (max>=min)  delete [] (data + min);
}

template <class T> gArray<T> & gArray<T>::operator=(const gArray<T> &a)
{
  if (this != &a) {
    // We only reallocate if necessary.  This should be somewhat faster
    // if many objects are of the same length.  Furthermore, it is
    // _essential_ for the correctness of the gPVector and gDPVector
    // assignment operator, since it assumes the value of data does
    // not change.
    if (data && (min != a.min && max != a.max))  {
      delete [] (data + min);
      min = a.min;  max = a.max;
      data = (max >= min) ? new T[max - min + 1] - min : 0;
    }
    for (int i = min; i <= max; i++)
      data[i] = a.data[i];
  }
  return *this;
}

template <class T> int gArray<T>::Length(void)
{
return max - min + 1;
}	

template <class T> int gArray<T>::First(void)
{
return min;
}	

template <class T> int gArray<T>::Last(void)
{
return max;
}	

template <class T> const T &gArray<T>::operator[](int index) const
{
  assert(index >= min && index <= max);
  return data[index];
}	

template <class T> T &gArray<T>::operator[](int index)
{
  assert(index >= min && index <= max);
  return data[index];
}

template <class T> void gArray<T>::Dump(gOutput &f) const
{
  f << "{ ";
  for (int i = min; i <= max; i++)
    f << data[i] << ' ';
  f << '}';
}

template <class T> gOutput &operator<<(gOutput &f, const gArray<T> &a)
{
  a.Dump(f);
  return f;
}
