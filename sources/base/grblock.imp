//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of resizable 2-D rect array class
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include "base/base.h"

//------------------------------------------------------------------------
//            Constructors, destructor, constructive operators
//------------------------------------------------------------------------

template <class T> gbtRectBlock<T>::gbtRectBlock(void)   { }

template <class T> gbtRectBlock<T>::gbtRectBlock(unsigned int nrows,
                         unsigned int ncols)
  : gbtRectArray<T>(nrows, ncols)
{ }

template <class T> 
gbtRectBlock<T>::gbtRectBlock(int minr, int maxr, int minc, int maxc)
  : gbtRectArray<T>(minr, maxr, minc, maxc)
{ }

template <class T> gbtRectBlock<T>::gbtRectBlock(const gbtRectBlock<T> &r)
  : gbtRectArray<T>(r)
{ }

template <class T> gbtRectBlock<T>::~gbtRectBlock()
{ }

template <class T>
gbtRectBlock<T> &gbtRectBlock<T>::operator=(const gbtRectBlock<T> &a)
{
  gbtRectArray<T>::operator=(a);
  return *this;
}

//------------------------------------------------------------------------
//             The members
//------------------------------------------------------------------------

template <class T> void gbtRectBlock<T>::AddRow(const gbtArray<T> &v)
{
  if (v.First() != mincol || v.Last() != maxcol)   throw BadIndex();
  maxrow++;
  
  T *p = 0, **pp = 0;

  try   {
    p = new T[maxcol - mincol + 1];
    T *newrow = p - mincol;
    int i;
    for (i = mincol; i <= maxcol; i++)
      newrow[i]= v[i];

    pp = new T*[maxrow - minrow + 1];
    T **newidx = pp - minrow;

    for (i = minrow; i < maxrow; i++)
      newidx[i] = data[i];
    newidx[maxrow] = newrow;
    if (data)   delete [] (data + minrow);
    data = newidx;
  }
  catch (...)  {   // probably a failure of new
    if (p)   delete p;
    if (pp)  delete pp;
    maxrow--;
    throw;
  }
}

template <class T> void gbtRectBlock<T>::RemoveRow(int row)
{
  if (minrow > row || row > maxrow)   throw BadIndex();
  maxrow--;
  
  if (maxrow < minrow)   {
    delete [] (data[minrow] + mincol);
    delete [] (data + minrow);
    data = 0;
    return;
  }

  T** pp = new T*[maxrow - minrow + 1];
  T** newidx = pp - minrow;

  int i;
  for (i = minrow; i < row; i++)
    newidx[i] = data[i];
  delete [] (data[i] + mincol);
  for (; i <= maxrow; i++ )
    newidx[i] = data[i+1];
  delete [] (data + minrow);
  data = newidx;
}


template <class T> 
void gbtRectBlock<T>::AddColumn(const gbtArray<T> &v)
{
    if (v.First() != minrow || v.Last() != maxrow)   
        throw BadDim();
    
    maxcol++;
    
    T **new_data = 0;
    try  
    {
        new_data = new T *[maxrow - minrow + 1] - minrow;
        int i, j;

        for (i = minrow; i <= maxrow; new_data[i++] = 0);
        for (i = minrow; i <= maxrow; i++)    
        {
            new_data[i] = new T[maxcol - mincol + 1] - mincol;
            T *oldrow = data[i];

            for (j = mincol; j < maxcol; j++)
                new_data[i][j] = oldrow[j];

            new_data[i][maxcol] = v[i];

            data[i] = new_data[i];
            delete [] (oldrow + mincol);            
        }
    }
    catch (...)   // probably a failure of new
    {   
        if (new_data)   
        {
            for (int i = minrow; i <= maxrow; i++)
            {
                if (new_data[i])
                    delete (new_data[i] + mincol);
            }

            delete (new_data + minrow);
        }

        maxcol--;
        throw;
    }
}


template<class T> void gbtRectBlock<T>::RemoveColumn(int col)
{
  // note: RemoveColumn does not reallocate memory --
  // it shrinks the rows in place.
  if (mincol > col || col > maxcol)   throw BadIndex();

  maxcol--;
  for (int i = minrow; i <= maxrow; i++)  {
    T *row = data[i];
    for (int j = col; j <= maxcol; j++)
      row[j]= row[j+1];
  }
}

template <class T> void gbtRectBlock<T>::InsertRow(int row, const gbtArray<T> &v)
{
  if (v.First() != mincol || v.Last() != maxcol)   throw BadDim();
  if (minrow > row || row > maxrow + 1)   throw BadIndex();

  if (row == maxrow + 1)  {
    AddRow(v);
    return;
  }

  maxrow++;
  
  T *p = 0, **pp = 0;
  try  {   
    p = new T[maxcol - mincol + 1];
    T* newrow = p - mincol;
                int i;
    for (i = mincol; i <= maxcol; i++)
      newrow[i] = v[i];

    pp = new T*[maxrow - minrow + 1];
    T** newidx = pp - minrow;

    for (i = minrow; i < row; i++)
      newidx[i] = data[i];
    newidx[row] = newrow;
    for (i = row + 1; i <= maxrow; i++)
      newidx[i] = data[i-1];
    delete[] (data + minrow);
    data = newidx;
  }
  catch (...)   {  // probably a failure of new
    if (p)   delete p;
    if (pp)  delete pp;
    maxrow--;
    throw;
  }
}


template <class T>
void gbtRectBlock<T>::InsertColumn(int col, const gbtArray<T> &v)
{
    if (v.First() != minrow || v.Last() != maxrow)   
        throw BadDim();
    
    if (mincol > col || col > maxcol + 1)
        throw BadIndex();
    
    if (col == maxcol + 1) 
    {
        AddColumn(v);
        return;
    }
    
    maxcol++;
    
    T **new_data = 0;
    try  
    {
        new_data = new T *[maxrow - minrow + 1] - minrow;
        int i, j;
        
        for (i = minrow; i <= maxrow; new_data[i++] = 0);
        for (i = minrow; i <= maxrow; i++)    
        {
            new_data[i] = new T[maxcol - mincol + 1] - mincol;
            T *oldrow = data[i];
            
            for (j = mincol; j < col; j++)
                new_data[i][j] = oldrow[j];
            
            new_data[i][col] = v[i];
            
            for (j = col + 1; j <= maxcol; j++)
                new_data[i][j] = oldrow[j-1];
            
            data[i] = new_data[i];
            delete [] (oldrow + mincol);
        }
    }
    catch (...)   // probably a failure of new
    {   
        if (new_data)   
        {
            for (int i = minrow; i <= maxrow; i++)
            {
                if (new_data[i])   
                    delete (new_data[i] + mincol);
            }

            delete (new_data + minrow);
        }

        maxcol--;
        throw;
    }
}
