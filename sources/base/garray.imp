//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of gbtArray data type
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include <stdlib.h>
#include <assert.h>
#include "garray.h"


template <class T> gbtArray<T>::gbtArray(unsigned int len) 
  : mindex(1), maxdex(len), data((len) ? new T[len] - 1 : 0)   
{ }

template <class T> gbtArray<T>::gbtArray(int lo, int hi)
  : mindex(lo), maxdex(hi)
{
  if (maxdex + 1 < mindex)   throw BadRange();
  data = (maxdex >= mindex) ? new T[maxdex -mindex + 1] - mindex : 0;
}

template <class T> gbtArray<T>::gbtArray(const gbtArray<T> &a) 
  : mindex(a.mindex), maxdex(a.maxdex),
    data((maxdex >= mindex) ? new T[maxdex - mindex + 1] - mindex : 0)
{
  for (int i = mindex; i <= maxdex; i++)
    data[i] = a.data[i];
}

template <class T> gbtArray<T>::~gbtArray()
{
  if (maxdex >= mindex)  delete [] (data + mindex);
}

template <class T> gbtArray<T> & gbtArray<T>::operator=(const gbtArray<T> &a)
{
  if (this != &a) {
    // We only reallocate if necessary.  This should be somewhat faster
    // if many objects are of the same length.  Furthermore, it is
    // _essential_ for the correctness of the gbtPVector and gbtDPVector
    // assignment operator, since it assumes the value of data does
    // not change.
    if (!data || (data && (mindex != a.mindex || maxdex != a.maxdex)))  {
      if (data)   delete [] (data + mindex);
      mindex = a.mindex;   maxdex = a.maxdex;
      data = (maxdex >= mindex) ? new T[maxdex - mindex + 1] - mindex : 0;
    }

    for (int i = mindex; i <= maxdex; i++)
      data[i] = a.data[i];
  }

  return *this;
}

template <class T> int gbtArray<T>::Length(void) const
{
  return maxdex - mindex + 1;
}	

template <class T> int gbtArray<T>::First(void) const
{
  return mindex;
}	

template <class T> int gbtArray<T>::Last(void) const
{
  return maxdex;
}	

template <class T> const T &gbtArray<T>::operator[](int index) const
{
  if (index < mindex || index > maxdex) 
    throw BadIndex();
  return data[index];
}	

template <class T> T &gbtArray<T>::operator[](int index)
{
  if (index < mindex || index > maxdex)
    throw BadIndex();
  return data[index];
}

template <class T> void gbtArray<T>::Dump(gbtOutput &f) const
{
  f << "{ ";
  for (int i = mindex; i <= maxdex; i++)
    f << data[i] << ' ';
  f << '}';
}

template <class T> bool operator==(const gbtArray<T> &a, const gbtArray<T> &b)
{
  if (a.First() != b.First() || a.Last() != b.Last())   return false;
  for (int i = a.First(); i <= a.Last(); i++)
    if (a[i] != b[i])   return false;
  return true;
}

template <class T> bool operator!=(const gbtArray<T> &a, const gbtArray<T> &b)
{
  return !(a == b);
}

template <class T> gbtOutput &operator<<(gbtOutput &f, const gbtArray<T> &a)
{
  a.Dump(f);
  return f;
}


template <class T> gbtArray<T>::BadIndex::~BadIndex()
{ }

template <class T> gbtText gbtArray<T>::BadIndex::Description(void) const
{
  return "Bad index in gbtArray";
}

template <class T> gbtArray<T>::BadRange::~BadRange()
{ }

template <class T> gbtText gbtArray<T>::BadRange::Description(void) const
{
  return "Bad range in gbtArray";
}
