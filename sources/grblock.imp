//
// FILE: grblock.imp -- Implementation of resizable 2-D rect array class
//
//  $Id$
//

#include "grblock.h"
#include "garray.h"


//------------------------------------------------------------------------
//            Constructors, destructor, constructive operators
//------------------------------------------------------------------------

template <class T> gRectBlock<T>::gRectBlock(void)   { }

template <class T> gRectBlock<T>::gRectBlock(unsigned int nrows,
					     unsigned int ncols)
  : gRectArray<T>(nrows, ncols)
{ }

template <class T> 
gRectBlock<T>::gRectBlock(int minr, int maxr, int minc, int maxc)
  : gRectArray<T>(minr, maxr, minc, maxc)
{ }

template <class T> gRectBlock<T>::gRectBlock(const gRectBlock<T> &r)
  : gRectArray<T>(r)
{ }

template <class T> gRectBlock<T>::~gRectBlock()
{ }

template <class T>
gRectBlock<T> &gRectBlock<T>::operator=(const gRectBlock<T> &a)
{
  gRectArray<T>::operator=(a);
  return *this;
}

//------------------------------------------------------------------------
//             The members
//------------------------------------------------------------------------

template <class T> void gRectBlock<T>::AddRow(const gArray<T> &v)
{
  if (v.First() != mincol || v.Last() != maxcol)   throw BadIndex();
  maxrow++;
  
  T *p = 0, **pp = 0;

  try   {
    p = new T[maxcol - mincol + 1];
    T *newrow = p - mincol;
    int i;
    for (i = mincol; i <= maxcol; i++)
      newrow[i]= v[i];

    pp = new T*[maxrow - minrow + 1];
    T **newidx = pp - minrow;

    for (i = minrow; i < maxrow; i++)
      newidx[i] = data[i];
    newidx[maxrow] = newrow;
    if (data)   delete [] (data + minrow);
    data = newidx;
  }
  catch (...)  {   // probably a failure of new
    if (p)   delete p;
    if (pp)  delete pp;
    maxrow--;
    throw;
  }
}

template <class T> void gRectBlock<T>::RemoveRow(int row)
{
  if (minrow > row || row > maxrow)   throw BadIndex();
  maxrow--;
  
  if (maxrow < minrow)   {
    delete (data[minrow] + mincol);
    delete (data + minrow);
    data = 0;
    return;
  }

  T** pp = new T*[maxrow - minrow + 1];
  T** newidx = pp - minrow;

  int i;
  for (i = minrow; i < row; i++)
    newidx[i] = data[i];
  delete [] (data[i] + mincol);
  for (; i <= maxrow; i++ )
    newidx[i] = data[i+1];
  delete [] (data + minrow);
  data = newidx;
}

template <class T> void gRectBlock<T>::AddColumn(const gArray<T> &v)
{
  if (v.First() != minrow || v.Last() != maxrow)   throw BadDim();

  maxcol++;
  
  T **new_data = 0;
  try  {
    new_data = new T *[maxrow - minrow + 1] - minrow;
    int i;
    for (i = minrow; i <= maxrow; new_data[i++] = 0);
    for (i = minrow; i <= maxrow; i++)    {
      new_data[i] = new T[maxcol - mincol + 1] - mincol;
      T *oldrow = data[i];
      for (int j = mincol; j < maxcol; j++)
	new_data[i][j] = oldrow[j];
      new_data[i][maxcol] = v[i];
    }
  }
  catch (...)   {   // probably a failure of new
    if (new_data)   {
      for (int i = minrow; i <= maxrow; i++)
	if (new_data[i])   delete (new_data[i] + mincol);
      delete (new_data + minrow);
    }
    maxcol--;
    throw;
  }
}

template<class T> void gRectBlock<T>::RemoveColumn(int col)
{
  // note: RemoveColumn does not reallocate memory --
  // it shrinks the rows in place.
  if (mincol > col || col > maxcol)   throw BadIndex();

  maxcol--;
  for (int i = minrow; i <= maxrow; i++)  {
    T *row = data[i];
    for (int j = col; j <= maxcol; j++)
      row[j]= row[j+1];
  }
}

template <class T> void gRectBlock<T>::InsertRow(int row, const gArray<T> &v)
{
  if (v.First() != mincol || v.Last() != maxcol)   throw BadDim();
  if (minrow > row || row > maxrow + 1)   throw BadIndex();

  if (row == maxrow + 1)  {
    AddRow(v);
    return;
  }

  maxrow++;
  
  T *p = 0, **pp = 0;
  try  {   
    p = new T[maxcol - mincol + 1];
    T* newrow = p - mincol;
                int i;
    for (i = mincol; i <= maxcol; i++)
      newrow[i] = v[i];

    pp = new T*[maxrow - minrow + 1];
    T** newidx = pp - minrow;

    for (i = minrow; i < row; i++)
      newidx[i] = data[i];
    newidx[row] = newrow;
    for (i = row + 1; i <= maxrow; i++)
      newidx[i] = data[i-1];
    delete[] (data + minrow);
    data = newidx;
  }
  catch (...)   {  // probably a failure of new
    if (p)   delete p;
    if (pp)  delete pp;
    maxrow--;
    throw;
  }
}

template <class T>
void gRectBlock<T>::InsertColumn(int col, const gArray<T> &v)
{
  if (v.First() != minrow || v.Last() != maxrow)   throw BadDim();
  if (mincol > col || col > maxcol + 1)   throw BadIndex();

  if (col == maxcol + 1) {
    AddColumn(v);
    return;
  }

  maxcol++;
  
  T **new_data = 0;
  try  {
    new_data = new T *[maxrow - minrow + 1] - minrow;
    int i,j;
    for (i = minrow; i <= maxrow; new_data[i++] = 0);
    for (i = minrow; i <= maxrow; i++)    {
      new_data[i] = new T[maxcol - mincol + 1] - mincol;
      T *oldrow = data[i];
      for (j = mincol; j < col; j++)
	new_data[i][j] = oldrow[j];
      new_data[i][col] = v[i];
      for (j = col + 1; j <= maxcol; j++)
	new_data[i][j] = oldrow[j-1];
	  data[i] = new_data[i];
	  delete [] (oldrow + mincol);
    }
  }
  catch (...)   {   // probably a failure of new
    if (new_data)   {
      for (int i = minrow; i <= maxrow; i++)
	if (new_data[i])   delete (new_data[i] + mincol);
      delete (new_data + minrow);
    }
    maxcol--;
    throw;
  }
}

