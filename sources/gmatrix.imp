//#
//# FILE: gmatrix.imp -- Implementation of gMatrix method functions
//#
//# $Id$
//#

#include "gmatrix.h"

// inline member functions
template <class T>
T& gMatrix<T>::operator()(int row, int col) { 
  assert(Check(row,col));
  return data[row][col]; 
}
template <class T>
const T& gMatrix<T>::operator()(int row, int col) const {
  assert(Check(row,col));
  return data[row][col]; 
}

template <class T>
int gMatrix<T>::operator!=(const gMatrix<T> &M) const {
  return !((*this)==M);
}
template <class T>
int gMatrix<T>::operator!=( T s ) const {
  return !((*this)==s);
}

template <class T>
const int& gMatrix<T>::MinRow(void) const { return minrow; }
template <class T>
const int& gMatrix<T>::MaxRow(void) const { return maxrow; }
template <class T>
int gMatrix<T>::NumRows(void) const { return maxrow-minrow+1; }
  
template <class T>
const int& gMatrix<T>::MinCol(void) const { return mincol; }
template <class T>
const int& gMatrix<T>::MaxCol(void) const { return maxcol; }
template <class T>
int gMatrix<T>::NumColumns(void) const { return maxcol-mincol+1; }


template <class T> int gMatrix<T>::CheckRow(int row) const
{
  return (minrow <= row && row <= maxrow);
}

template <class T> int gMatrix<T>::CheckRow(const gVector<T> &v) const
{
  return (v.First() == mincol && v.Last() == maxcol);
}

template <class T> int gMatrix<T>::CheckColumn(int col) const
{
  return (mincol <= col && col <= maxcol);
}

template <class T> int gMatrix<T>::CheckColumn(const gVector<T> &v) const
{
  return (v.First() == minrow && v.Last() == maxrow);
}

template <class T> int gMatrix<T>::Check(int row, int col) const
{
  return (CheckRow(row) && CheckColumn(col));
}

template <class T> int gMatrix<T>::CheckBounds(const gMatrix<T> &m) const
{
  return (minrow == m.minrow && maxrow == m.maxrow &&
	  mincol == m.mincol && maxcol == m.maxcol);
}

template <class T> T **gMatrix<T>::AllocateIndex(void)
{
  T **p = new T*[maxrow - minrow + 1];
  assert(p);
  return (p - minrow);
}

template <class T> void gMatrix<T>::DeleteIndex(T **p)
{
  delete [] (p + minrow);
}

template <class T> T *gMatrix<T>::AllocateRow(void)
{
  T *p = new T[maxcol - mincol + 1];
  assert(p);
  return (p - mincol);
}

template <class T> void gMatrix<T>::DeleteRow(T *p)
{
  delete [] (p + mincol);
}

template <class T> gMatrix<T>::gMatrix(void)
  : minrow(1), maxrow(0), mincol(1), maxcol(0), data(0)
{ }

template <class T> gMatrix<T>::gMatrix(int rows, int cols)
  : minrow(1), maxrow(rows), mincol(1), maxcol(cols)
{
  assert(rows >= 0 && cols >= 0);
  AllocateData();
}

template <class T> gMatrix<T>::gMatrix(int rows, int cols, int minrows)
  : minrow(minrows), maxrow(minrows + rows - 1), mincol(1), maxcol(cols)
{
  assert(rows >= 0 && cols >= 0);
  AllocateData();
}

template <class T> gMatrix<T>::gMatrix(int rl, int rh, int cl, int ch)
  : minrow(rl), maxrow(rh), mincol(cl), maxcol(ch)
{
  assert(rh >= rl - 1 && ch >= cl - 1);
  AllocateData();
}

template <class T> gMatrix<T>::gMatrix(const gMatrix<T> &M)
{
  minrow=M.MinRow(); maxrow=M.MaxRow();
  mincol=M.MinCol(); maxcol=M.MaxCol();
  AllocateData();
  CopyData(M);
}
 
template <class T> gMatrix<T>::~gMatrix()
{
  DeleteData();
}


// output operations

template <class T> void
gMatrix<T>::Dump(gOutput &to) const
{
  to<<"matrix dump: "<<NumRows()<<" x "<<NumColumns()<<" :: "
    <<MinRow()<<".."<<MaxRow()<<" x "<<MinCol()<<".."<<MaxCol()<<"\n";
  for(int i = minrow; i <= maxrow; i++)
    {
      to << "[ ";
      for(int j = mincol; j <= maxcol; j++)
	to << (*this)(i,j) << " ";
      to << "]\n";
    }
}

/*  this is defined inline in gmatrix.h
template <class T> gOutput &operator<<(gOutput &to, const gMatrix<T> &M)
{
  M.Dump(to); return to;
}
*/



// internal data operations

template <class T> void
gMatrix<T>::DeleteData(void)
{
  if(data) {
    for(int i=minrow;i<=maxrow;i++)
      DeleteRow( data[i] );
    DeleteIndex( data );
  }
}

template <class T> void
gMatrix<T>::AllocateData(void)
{
  typedef T* foo;

  data= AllocateIndex();
  for(int i=minrow;i<=maxrow;i++) {
    data[i]= AllocateRow();
  }
}

template <class T> void
gMatrix<T>::CopyData(const gMatrix<T> &M)
{
  assert( CheckBounds(M) );

  for(int i=minrow;i<=maxrow;i++) {
/*
    for(int j=mincol;j<=maxcol;j++)
      (*this)(i,j)=M(i,j);
*/
    // inner loop
    T *src= M.data[i]+mincol;
    T *dst= data[i]+mincol;
    int j= maxcol-mincol+1;
    while( j-- )
      *(dst++)= *(src++);
    assert( (dst-1) == data[i]+maxcol ); // debug
    // end inner loop
    }
}

// copy operator
template <class T> gMatrix<T>&
gMatrix<T>::operator=(const gMatrix<T> &M)
{
  assert( CheckBounds(M) );
  if(this != &M)
    {
      CopyData(M);
    }
  return (*this);
}


// arithmetic operators
template <class T> gMatrix<T>
gMatrix<T>::operator+(const gMatrix<T> &M) const
{
  assert( CheckBounds(M) );
  gMatrix<T> tmp(minrow,maxrow, mincol, maxcol);
  for(int i=minrow; i<=maxrow; i++)
    {
/*
      for(int j=mincol; j<=maxcol; j++)
	tmp(i,j)= (*this)(i,j) + M(i,j);
*/
      // inner loop
      T *src1= data[i]+mincol;
      T *src2= M.data[i]+mincol;
      T *dst= tmp.data[i]+mincol;
      int j= maxcol-mincol+1;
      while( j-- )
	*(dst++)= *(src1++) + *(src2++);
      assert( (dst-1) == tmp.data[i]+maxcol ); // debug
      // end inner loop
    }
  return tmp;
}

template <class T> gMatrix<T>
gMatrix<T>::operator-(const gMatrix<T> &M) const
{
  assert( CheckBounds(M) );
  gMatrix<T> tmp(minrow,maxrow, mincol, maxcol);
  for(int i=minrow; i<=maxrow; i++)
    {
/*
      for(int j=mincol; j<=maxcol; j++)
	tmp(i,j)= (*this)(i,j) - M(i,j);
*/
      // inner loop
      T *src1= data[i]+mincol;
      T *src2= M.data[i]+mincol;
      T *dst= tmp.data[i]+mincol;
      int j= maxcol-mincol+1;
      while( j-- )
	*(dst++)= *(src1++) - *(src2++);
      assert( (dst-1) == tmp.data[i]+maxcol ); // debug
      // end inner loop
    }
  return tmp;
}

template <class T> gMatrix<T> &
gMatrix<T>::operator+=(const gMatrix<T> &M)
{
  assert( CheckBounds(M) );
  for(int i=minrow; i<=maxrow; i++)
    {
/*
      for(int j=mincol; j<=maxcol; j++)
	(*this)(i,j)+= M(i,j);
*/
    // inner loop
    T *src= M.data[i]+mincol;
    T *dst= data[i]+mincol;
    int j= maxcol-mincol+1;
    while( j-- )
      *(dst++)+= *(src++);
    assert( (dst-1) == data[i]+maxcol ); // debug
    // end inner loop
    }
  return (*this);
}

template <class T> gMatrix<T> &
gMatrix<T>::operator-=(const gMatrix<T> &M)
{
  assert( CheckBounds(M) );
  for(int i=minrow; i<=maxrow; i++)
    {
/*
      for(int j=mincol; j<=maxcol; j++)
	(*this)(i,j)-= M(i,j);
*/
    // inner loop
    T *src= M.data[i]+mincol;
    T *dst= data[i]+mincol;
    int j= maxcol-mincol+1;
    while( j-- )
      *(dst++)-= *(src++);
    assert( (dst-1) == data[i]+maxcol ); // debug
    // end inner loop
    }
  return (*this);
}

template <class T> void
gMatrix<T>::CMultiply(const gVector<T> &in, gVector<T> &out) const
{
  assert( CheckRow(in) && CheckColumn(out) );
  for(int i=minrow; i<=maxrow; i++)
    {
      T sum= (T)0;

      // inner loop
      T *src1= data[i] + mincol;
      T *src2= in.data + mincol;
      int j= maxcol-mincol+1;
      while( j-- )
	sum += *(src1++) * *(src2++);
      assert( src1-1 == data[i]+maxcol ); // debug
      // end inner loop

      out[i]= sum;
    }
}

template <class T> gMatrix<T>
gMatrix<T>::operator*(const gMatrix<T> &M) const
{
  assert( mincol==M.minrow && maxcol==M.maxrow );
  gMatrix<T> tmp(minrow,maxrow, M.mincol, M.maxcol);
  gVector<T> column(M.minrow,M.maxrow);
  gVector<T> result(minrow,maxrow);
  for(int j=M.mincol; j<=M.maxcol; j++)
    {
      M.GetColumn(j,column);
      CMultiply(column, result);
      tmp.SetColumn(j,result);
    }
  return tmp;
}

template <class T> gVector<T>
gMatrix<T>::operator*(const gVector<T> &v) const
{
  assert( CheckRow(v) );
  gVector<T> tmp(minrow, maxrow);
  CMultiply(v,tmp);
  return tmp;
}

template <class T> void
gMatrix<T>::RMultiply(const gVector<T> &in, gVector<T> &out) const
{
  assert( CheckColumn(in) && CheckRow(out) );
  out= (T)0;
  for(int i=minrow; i<=maxrow; i++)
    {
      T k= in[i];

      // inner loop
      T *src= data[i] + mincol;
      T *dst= out.data + mincol;
      int j= maxcol-mincol+1;
      while( j-- )
	*(dst++) += *(src++) * k;
      assert( src-1 == data[i] + maxcol ); // debug
      // end inner loop
    }
}

// transposed (row) vector*matrix multiplication operator
// a friend function of gMatrix
template <class T> gVector<T>
operator*(const gVector<T> &v, const gMatrix<T> &M)
{
  assert( M.CheckColumn(v) );
  gVector<T> tmp(M.mincol, M.maxcol);
  M.RMultiply(v,tmp);
  return tmp;
}


template <class T> gMatrix<T>
gMatrix<T>::operator*(T s) const
{
  gMatrix<T> tmp(minrow,maxrow, mincol,maxcol);
  for(int i=minrow; i<=maxrow; i++)
    {
/*
      for(int j=mincol; j<=maxcol; j++)
	tmp(i,j)= (*this)(i,j) * s;
*/
      // inner loop
      T *src= data[i]+mincol;
      T *dst= tmp.data[i]+mincol;
      int j= maxcol-mincol+1;
      while( j-- )
	*(dst++) = *(src++) * s;
      assert( (src-1) == data[i]+maxcol ); // debug
      // end inner loop
    }
  return tmp;
}

// in-place multiplication by square matrix
template <class T> gMatrix<T> &
gMatrix<T>::operator*=(const gMatrix<T> &M)
{
  assert( mincol==M.minrow && maxcol==M.maxrow );
  assert( M.minrow==M.mincol && M.maxrow==M.maxcol );
  gVector<T> row(mincol,maxcol);
  gVector<T> result(mincol,maxcol);
  for(int i=minrow; i<=maxrow; i++)
    {
      GetRow(i,row);
      M.RMultiply(row,result);
      SetRow(i,result);
    }
  return (*this);
}

template <class T> gMatrix<T> &
gMatrix<T>::operator*=( T s )
{
  for(int i=minrow; i<=maxrow; i++)
    {
/*
      for(int j=mincol; j<=maxcol; j++)
	(*this)(i,j) *= s;
*/
      // inner loop
      T *dst= data[i]+mincol;
      int j= maxcol-mincol+1;
      while( j-- )
	*(dst++) *= s;
      assert( (dst-1) == data[i]+maxcol ); // debug
      // end inner loop
    }
  return (*this);
}

template <class T> gMatrix<T>
gMatrix<T>::operator/(T s) const
{
  assert( s != (T)0 );
  gMatrix<T> tmp(minrow,maxrow, mincol,maxcol);
  for(int i=minrow; i<=maxrow; i++)
    {
/*
      for(int j=mincol; j<=maxcol; j++)
	tmp(i,j)= (*this)(i,j) / s;
*/
      // inner loop
      T *src= data[i]+mincol;
      T *dst= tmp.data[i]+mincol;
      int j= maxcol-mincol+1;
      while( j-- )
	*(dst++) = *(src++) / s;
      assert( (src-1) == data[i]+maxcol ); // debug
      // end inner loop
    }
  return tmp;
}

template <class T> gMatrix<T> &
gMatrix<T>::operator/=( T s )
{
  assert( s != (T)0 );
  for(int i=minrow; i<=maxrow; i++)
    {
/*
      for(int j=mincol; j<=maxcol; j++)
	(*this)(i,j) /= s;
*/
      // inner loop
      T *dst= data[i]+mincol;
      int j= maxcol-mincol+1;
      while( j-- )
	*(dst++) /= s;
      assert( (dst-1) == data[i]+maxcol ); // debug
      // end inner loop
    }
  return (*this);
}

// comparison operators

template <class T> int
gMatrix<T>::operator==(const gMatrix<T> &M) const
{
  assert( CheckBounds(M) );
  for(int i=minrow; i<=maxrow; i++)
    {
/*
      for(int j=mincol; j<=maxcol; j++)
	if( M(i,j) != (*this)(i,j) )
	  return 0;
*/
      // inner loop
      T *src1= M.data[i]+mincol;
      T *src2= data[i]+mincol;
      int j= maxcol-mincol+1;
      while( j-- )
	if( *(src1++) != *(src2++) )
	  return 0;
      assert( src1-1 == M.data[i]+maxcol ); // debug
      // end inner loop
    }
  return 1;
}

template <class T> int
gMatrix<T>::operator==(T s) const
{
  for(int i=minrow; i<=maxrow; i++)
    {
/*
      for(int j=mincol; j<=maxcol; j++)
	if( (*this)(i,j) != s )
	  return 0;
*/
      // inner loop
      T *src= data[i]+mincol;
      int j= maxcol-mincol+1;
      while( j-- )
	if( *(src++) != s )
	  return 0;
      assert( src-1 == data[i]+maxcol ); // debug
      // end inner loop
    }
  return 1;
}


// row manipulation
template <class T> void
gMatrix<T>::AddRow(const gVector<T> &v)
{
  assert( CheckRow(v) );
  maxrow++;
  T* newrow= AllocateRow();
  for( int i=mincol; i<=maxcol; i++ )
    newrow[i]= v[i];
  T** newidx= AllocateIndex();
  for( i=minrow; i<maxrow; i++ )
    newidx[i]= data[i];
  newidx[maxrow]= newrow;
  DeleteIndex(data);
  data= newidx;
}

template <class T> void
gMatrix<T>::RemoveRow(int row)
{
  assert( CheckRow(row) );
  maxrow--;
  T** newidx= AllocateIndex();
  for(int i=minrow; i<row; i++ )
    newidx[i]= data[i];
  DeleteRow(data[i]);
  for( ; i<=maxrow; i++ )
    newidx[i]= data[i+1];
  DeleteIndex(data);
  data= newidx;
}

// note:  this is redundant (identical to SetRow)
template <class T> void
gMatrix<T>::SwitchRow(int row, const gVector<T> &v)
{
  assert( CheckRow(row) && CheckRow(v) );
  T* rowptr= data[row];
  for(int i=mincol; i<=maxcol; i++)
    rowptr[i]= v[i];
}

template <class T> void
gMatrix<T>::SwitchRowWithVector(int row, gVector<T> &v)
{
  assert( CheckRow(row) && CheckRow(v) );

  T* rowptr= data[row];
  T tmp;
  for(int i=mincol; i<=maxcol; i++) {
    tmp= rowptr[i];
    rowptr[i]= v[i];
    v[i]= tmp;
  }
}

template <class T> void
gMatrix<T>::SwitchRows(int i, int j)
{
  // note: SwapRows has been changed to SwitchRows,
  // since that's the name in the original gMatrix class
  assert( CheckRow(i) && CheckRow(j) );
  T *temp;
      // Swap data rows
  temp=data[j];
  data[j]=data[i];
  data[i]=temp;
}

template <class T> gVector<T>
gMatrix<T>::GetRow(int row) const
{
  assert( CheckRow(row) );
  gVector<T> v(mincol, maxcol);
  T* rowptr= data[row];
  for(int i=mincol; i<=maxcol; i++)
    v.data[i]= rowptr[i];
  return v;
}

template <class T> void
gMatrix<T>::GetRow(int row, gVector<T> &v) const
{
  assert( CheckRow(row) );
  assert( CheckRow(v) );
  T* rowptr= data[row];
  for(int i=mincol; i<=maxcol; i++)
    v.data[i]= rowptr[i];
}

template <class T> void
gMatrix<T>::SetRow(int row, const gVector<T> &v)
{
  assert( CheckRow(row) );
  assert( CheckRow(v) );
  T* rowptr= data[row];
  for(int i=mincol; i<=maxcol; i++)
    rowptr[i]= v.data[i];
}

template <class T> void
gMatrix<T>::MakeIdent(void)
{
  for(int i=minrow;i<=maxrow;i++) 
    for(int j=mincol;j<=maxcol;j++) {
      if(i==j) (*this)(i,j) = (T) 1;
      else (*this)(i,j)=(T) 0;
    }
}

template <class T> void gMatrix<T>::RotateDown(int lo, int hi)
{
  assert( CheckRow(lo) && CheckRow(hi) );
  assert(lo<=hi);
      // Rotate data rows
  T *temp;
  temp=data[hi];
  for(int k=hi; k>lo; k--)
    data[k]=data[k-1];
  data[lo]=temp;
}

template <class T> void
gMatrix<T>::RotateUp(int lo, int hi)
{
  assert( CheckRow(lo) && CheckRow(hi) );
  assert(lo<=hi);
      // Rotate data rows
  T *temp;
  temp=data[lo];
  for(int k=lo; k<hi; k++)
    data[k]=data[k+1];
  data[hi]=temp;
}

template <class T> void
gMatrix<T>::RotateRight(int lo, int hi)
{
  assert( CheckColumn(lo) && CheckColumn(hi) );
  assert(lo<=hi);

  T temp;
  for(int i=MinRow(); i<=MaxRow(); i++)
    {
      T *row= data[i];
      temp= row[hi];
      for(int j=hi; j>lo; j--)
	row[j]= row[j-1];
      row[lo]= row[hi];
    }
}

template <class T> void
gMatrix<T>::RotateLeft(int lo, int hi)
{
  assert( CheckColumn(lo) && CheckColumn(hi) );
  assert(lo<=hi);

  T temp;
  for(int i=MinRow(); i<=MaxRow(); i++)
    {
      T *row= data[i];
      temp= row[lo];
      for(int j=lo; j<hi; j++)
	row[j]= row[j+1];
      row[hi]= temp;
    }
}

// column manipulation

template<class T> void
gMatrix<T>::AddColumn(const gVector<T> &v)
{
  assert( CheckColumn(v) );
  maxcol++;
  for(int i=minrow; i<=maxrow; i++)
    {
      T* newrow= AllocateRow();
      T* oldrow= data[i];
      for(int j=mincol; j<=maxcol; j++)
	newrow[j]= oldrow[j];
      newrow[maxcol]= v.data[i];
      DeleteRow(oldrow);
      data[i]= newrow;
    }
}

template<class T> void
gMatrix<T>::RemoveColumn(int col)
{
  // note: RemoveColumn does not reallocate memory --
  // it shrinks the rows in place.
  assert( CheckColumn(col) );
  maxcol--;
  for(int i=minrow; i<=maxrow; i++)
    {
      T* row= data[i];
      for(int j=col; j<=maxcol; j++)
	row[j]= row[j+1];
    }
}

// note: this is redundant (identical to SetColumn)
template<class T> void
gMatrix<T>::SwitchColumn(int col, const gVector<T> &v)
{
  assert( CheckColumn(col) && CheckColumn(v) );
  for(int i=minrow; i<=maxrow; i++)
    (*this)(i,col)= v[i];
}

template<class T> void
gMatrix<T>::SwitchColumnWithVector(int col, gVector<T> &v)
{
  assert( CheckColumn(col) && CheckColumn(v) );
  for(int i=minrow; i<=maxrow; i++)
    {
      T* a= data[i] + col;
      T* b= v.data + i;
      T tmp= *a;
      *a= *b;
      *b= tmp;
    }
}

template<class T> void
gMatrix<T>::SwitchColumns(int a, int b)
{
  assert( CheckColumn(a) && CheckColumn(b) );
  for(int i=minrow; i<=maxrow; i++)
    {
      T* row= data[i];
      T tmp= row[a];
      row[a]= row[b];
      row[b]= tmp;
    }
}

template<class T> gVector<T>
gMatrix<T>::GetColumn(int col) const
{
  assert( CheckColumn(col) );
  gVector<T> v(minrow, maxrow);
  for(int i=minrow; i<=maxrow; i++)
    v.data[i]= data[i][col];
  return v;
}

template <class T> void
gMatrix<T>::GetColumn(int col, gVector<T> &v) const
{
  assert( CheckColumn(col) );
  assert( CheckColumn(v) );
  for(int i=minrow; i<=maxrow; i++)
    v.data[i]= data[i][col];
}

template <class T> void
gMatrix<T>::SetColumn(int col, const gVector<T> &v)
{
  assert( CheckColumn(col) );
  assert( CheckColumn(v) );
  for(int i=minrow; i<=maxrow; i++)
    data[i][col]= v.data[i];
}


// more complex functions

template<class T> gMatrix<T>
gMatrix<T>::GetSlice(int rl, int rh, int cl, int ch) const
{
  assert( CheckRow(rl) && CheckRow(rh) && CheckColumn(cl) && CheckColumn(ch) );
  assert( rh >= rl-1 && ch >= cl-1 );
  gMatrix<T> m(rh-rl+1, ch-cl+1);
  for(int i=rl; i<=rh; i++)
    {
/*
      for(int j=cl; j<=ch; j++)
	m(i-rl,j-cl)= (*this)(i,j);
*/
      // inner loop
      T* src= data[i] + cl;
      T* dst= m.data[i-rl] + 1;
      int j= ch-cl+1;
      while( j-- )
	*(dst++)= *(src++);
      assert( dst-1 == m.data[i-rl] + (ch-cl+1) ); // debug
      assert( src-1 == data[i] + ch ); // debug
      // end inner loop
    }
  return m;
}

template<class T> gMatrix<T>
gMatrix<T>::GetSubMatrix(const gBlock<int> &rowV,
			  const gBlock<int> &colV) const
{
  int rows= rowV.Length();
  int cols= colV.Length();
  for(int i=1; i<=rows; i++)
    assert( CheckRow(rowV[i]) );
  for(int j=1; j<=cols; j++)
    assert( CheckColumn(colV[j]) );

  gMatrix<T> m( rows, cols );
  for(i=1; i<=rows; i++)
    {
      T* srcrow= data[ rowV[i] ];
      T* dstrow= m.data[i];
		for(j=1; j<=cols; j++)
	dstrow[j]= srcrow[ colV[j] ];
    }
  return m;
}

template<class T> gMatrix<T>
gMatrix<T>::Invert(void) const
{
  assert( mincol==minrow && maxcol==maxrow );
  gMatrix<T> copy(*this);
  gMatrix<T> inv(minrow,maxrow, mincol,maxcol);

  // initialize inverse matrix and prescale row vectors
  for(int i=minrow; i<=maxrow; i++)
    {
      T max= (T)0;
      for(int j=mincol; j<=maxcol; j++)
	{
	  T abs= copy.data[i][j];
	  if( abs < (T)0 )
	    abs= -abs;
	  if( abs > max )
	    max= abs;
	}
		assert( max!= (T) 0 );
      T scale= (T)1/max;
      for(j=mincol; j<=maxcol; j++)
	{
	  copy.data[i][j]*= scale;
	  if(i==j)
	    inv.data[i][j]= scale;
	  else
	    inv.data[i][j]= (T)0;
	}
    }

//gout<<"debug: Invert:\ncopy:\n"<<copy<<"inv:\n"<<inv<<"\n";
//char c; gin.get(c);
  for(i=mincol; i<=maxcol; i++)
    {
      // find pivot row
      T max= copy.data[i][i];
      if(max<(T)0)
	max= -max;
      int row= i;
      for(int j=i+1; j<=maxrow; j++)
	{
	  T abs= copy.data[j][i];
	  if( abs < (T)0 )
	    abs= -abs;
	  if( abs > max )
	    { max= abs; row= j; }
	}
      assert( max > (T)0 );
      copy.SwitchRows(i,row);
      inv.SwitchRows(i,row);
//gout<<"debug: swapped rows "<<i<<" and "<<row
//  <<":\ncopy:\n"<<copy<<"inv:\n"<<inv<<"\n";
      // scale pivot row
      T factor= (T)1/copy.data[i][i];
      for(int k=mincol; k<=maxcol; k++)
	{
	  copy.data[i][k]*= factor;
	  inv.data[i][k]*= factor;
	}

      // reduce other rows
      for(j=minrow; j<=maxrow; j++)
	{
	  if(j!=i)
	    {
	      T mult= copy.data[j][i];
	      for(k=mincol; k<=maxcol; k++)
		{
		  copy.data[j][k]-= copy.data[i][k]*mult;
		  inv.data[j][k]-= inv.data[i][k]*mult;
		}
	    }
	} // end for(j)
//gout<<"debug: after pivot #"<<i<<":\ncopy:\n"<<copy<<"inv:\n"<<inv<<"\n";
//gin.get(c);
    } // end for(i)

  return inv;
}

template<class T> gMatrix<T>
gMatrix<T>::ExternalPivot(int row, int col) const
{
  assert( CheckRow(row) && CheckColumn(col) );
  assert( data[row][col]!=(T)0 );

  gMatrix<T> m(minrow,maxrow,mincol,maxcol);

  T mult= (T)1/data[row][col];
  for(int j=mincol; j<=maxcol; j++)
    m.data[row][j]= data[row][j]*mult;
  for(int i=minrow; i<=maxrow; i++)
    {
      if( i!=row )
	{
	  mult= data[i][col];
/*
	  for(j=mincol; j<=maxcol; j++)
	    m.data[i][j]= data[i][j] - m.data[row][j]*mult;
*/
	  // inner loop
	  T* src1= data[i] + mincol;
	  T* src2= m.data[row] + mincol;
	  T* dst= m.data[i] + mincol;
	  j= maxcol-mincol+1;
	  while( j-- )
	    *(dst++)= *(src1++) - *(src2++) * mult;
	  assert( dst-1 == m.data[i] + maxcol ); // debug
	  assert( src1-1 == data[i] + maxcol ); // debug
	  assert( src2-1 == m.data[row] + maxcol ); // debug
	  // inner loop
	}
    }
  return m;
}

template<class T> void
gMatrix<T>::Pivot(int row, int col)
{
  assert( CheckRow(row) && CheckColumn(col) );
  assert( data[row][col]!=(T)0 );

  T mult= (T)1/data[row][col];
  for(int j=mincol; j<=maxcol; j++)
    data[row][j]*= mult;
  for(int i=minrow; i<=maxrow; i++)
    {
      if(i!=row)
	{
	  mult= data[i][col];
/*
	  for(j=mincol; j<=maxcol; j++)
	    data[i][j]-= data[row][j]*mult;
*/
	  // inner loop
	  T* src= data[row] + mincol;
	  T* dst= data[i] + mincol;
	  int j= maxcol-mincol+1;
	  while( j-- )
	    *(dst++)-= *(src++) * mult;
	  assert( dst-1 == data[i] + maxcol ); // debug
	  // end inner loop
	}
    }
}

template<class T> T
gMatrix<T>::Determinant(void) const
{
  assert(minrow==mincol && maxrow==maxcol);
  assert(NumRows()>0);
  if(NumRows()==1)
    return (*this)(minrow,mincol);
  if(NumRows()==2)
    return (*this)(minrow,mincol) * (*this)(maxrow,maxcol)
         - (*this)(minrow,maxcol) * (*this)(maxrow,mincol);

  T result= (T)0;
  int i,j;
  T l=(T)1;
  gBlock<int> rows, cols;
  for(i=minrow+1; i<=maxrow; i++)
    rows.Append(i);
  for(i=minrow; i<=maxrow; i++)
    {
      for(j=mincol; j<=maxcol; j++)
	if(j!=i) cols.Append(j);
      gMatrix<T> tmp= GetSubMatrix(rows,cols);
      result+= (tmp.Determinant()*l*(*this)(1,i));
      l*=(T)(-1);
      cols.Flush();
    }
  return result;
}


template <class T> gOutput &operator<<(gOutput &to, const gMatrix<T> &M)
{
  M.Dump(to); return to;
}
