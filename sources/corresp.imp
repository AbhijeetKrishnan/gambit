//
// FILE: corresp.imp -- Implementation of representation of correspondences
//
// $Id$
//

#include "corresp.h"

//========================================================================
// Correspondence<T,S>: Constructors, Destructor, Constructive Operators
//========================================================================

template <class T, class S> Correspondence<T,S>::Correspondence(void)
{ }

template <class T, class S>
Correspondence<T,S>::Correspondence(const Correspondence<T,S> &p_corr)
  : m_parameter(p_corr.m_parameter), m_data(p_corr.m_data)
{ }

template <class T, class S> Correspondence<T,S>::~Correspondence()
{ }

template <class T, class S> Correspondence<T,S> &
Correspondence<T,S>::operator=(const Correspondence<T,S> &p_corr)
{
  if (this != &p_corr) {
    m_parameter = p_corr.m_parameter;
    m_data = p_corr.m_data;
  }

  return *this;
}

//========================================================================
//                  Correspondence<T,S>: Data Access
//========================================================================

template <class T, class S>
int Correspondence<T,S>::NumComponents(void) const
{
  // For the current version, only correspondences with one component
  // are implemented
  return 1;
}

template <class T, class S>
T Correspondence<T,S>::MinParameter(int p_comp) const
{
  if (p_comp == 1) {
    return m_parameter[1];
  }
  else {
    return (T) 0;
  }
}

template <class T, class S>
T Correspondence<T,S>::MaxParameter(int p_comp) const
{
  if (p_comp == 1) {
    return m_parameter[m_parameter.Length()];
  }
  else {
    return (T) 0;
  }
}

template <class T, class S>
int Correspondence<T,S>::NumPoints(int p_comp) const
{
  if (p_comp == 1) {
    return m_parameter.Length();
  }
  else {
    return 0;
  }
}

template <class T, class S>
const T &Correspondence<T,S>::GetParameter(int p_comp, int p_index) const
{
  return m_parameter[p_index];
}

template <class T, class S>
const S &Correspondence<T,S>::GetPoint(int p_comp, int p_index) const
{
  return m_data[p_index];
}


//========================================================================
//                   Correspondence<T,S>: Editing
//========================================================================

template <class T, class S>
void Correspondence<T,S>::Append(int p_comp, const T &p_parameter,
				 const S &p_data)
{
  m_parameter.Append(p_parameter);
  m_data.Append(p_data);
}

