//#
//# FILE: behavsol.imp -- Behav strategy solution classes
//#
//# $Id$
//#


#include "behavsol.h"


template <class T> 
BehavSolution<T>::BehavSolution(const Efg<T>& e, bool truncated)
: BehavProfile<T>(e, truncated),
  _Creator(id_USER),
  _IsNash(T_DONTKNOW),
  _IsSubgamePerfect(T_DONTKNOW),
  _IsSequential(T_DONTKNOW),
  _GobitLambda(-1),
  _GobitValue(-1),
  _LiapValue(-1),
  _Beliefs()
{}

template <class T> 
BehavSolution<T>::BehavSolution(const Efg<T>& e, const gDPVector<T>& v)
: BehavProfile<T>(e, v),
  _Creator(id_USER),
  _IsNash(T_DONTKNOW),
  _IsSubgamePerfect(T_DONTKNOW),
  _IsSequential(T_DONTKNOW),
  _GobitLambda(-1),
  _GobitValue(-1),
  _LiapValue(-1),
  _Beliefs()
{}

template <class T> 
BehavSolution<T>::BehavSolution(const EFSupport& s)
: BehavProfile<T>(s),
  _Creator(id_USER),
  _IsNash(T_DONTKNOW),
  _IsSubgamePerfect(T_DONTKNOW),
  _IsSequential(T_DONTKNOW),
  _GobitLambda(-1),
  _GobitValue(-1),
  _LiapValue(-1),
  _Beliefs()
{}

template <class T> 
BehavSolution<T>::BehavSolution(const BehavProfile<T>& b, int creator)
: BehavProfile<T>(b),
  _Creator(creator),
  _IsNash(T_DONTKNOW),
  _IsSubgamePerfect(T_DONTKNOW),
  _IsSequential(T_DONTKNOW),
  _GobitLambda(-1),
  _GobitValue(-1),
  _LiapValue(-1),
  _Beliefs()
{}


template <class T> BehavSolution<T>::BehavSolution(const BehavSolution<T>& b)
: BehavProfile<T>(b),
  _Creator(b._Creator),
  _IsNash(b._IsNash),
  _IsSubgamePerfect(b._IsSubgamePerfect),
  _IsSequential(b._IsSequential),
  _GobitLambda(b._GobitLambda),
  _GobitValue(b._GobitValue),
  _LiapValue(b._LiapValue),
  _Beliefs(b._Beliefs)
{}

template <class T> BehavSolution<T>::~BehavSolution() {}

template <class T> void BehavSolution<T>::SetCreator(int c)
{ _Creator = c; }

template <class T> int BehavSolution<T>::Creator() const
{ return _Creator; }

template <class T> void BehavSolution<T>::SetIsNash(int i)
{ _IsNash = i; }

template <class T> int BehavSolution<T>::IsNash()
{ 
  if( _IsNash == T_DONTKNOW )
    _IsNash = BehavProfile<T>::IsNash();
  return _IsNash; 
}

template <class T> void BehavSolution<T>::SetIsSubgamePerfect(int i)
{ _IsSubgamePerfect = i; }

template <class T> int BehavSolution<T>::IsSubgamePerfect() const
{ return _IsSubgamePerfect; }

template <class T> void BehavSolution<T>::SetIsSequential(int i)
{ _IsSequential = i; }

template <class T> int BehavSolution<T>::IsSequential()
{
  if((_Creator == id_LIAP || _Creator == id_GOBIT) && IsNash() == T_YES)
    _IsSequential = T_YES;
  else
    _IsSequential = T_DONTKNOW;
  return _IsSequential;
}

template <class T> EFSupport BehavSolution<T>::Support() const
{ return behavsupport; }

template <class T> void BehavSolution<T>::SetGobit(T lambda, T value)
{
  _GobitLambda = lambda;
  _GobitValue = value;
}

template <class T> T BehavSolution<T>::GobitLambda() const
{ return _GobitLambda; }

template <class T> T BehavSolution<T>::GobitValue() const
{ return _GobitValue; }

template <class T> void BehavSolution<T>::SetLiap(T value)
{
  _LiapValue = value;
}

template <class T> T BehavSolution<T>::LiapValue()
{ 
  if(_LiapValue < 0)
    _LiapValue = BehavProfile<T>::LiapValue();
  return _LiapValue; 
}

template <class T> gDPVector<T> BehavSolution<T>::Beliefs()
{ return _Beliefs; }


template <class T> 
bool BehavSolution<T>::operator==(const BehavSolution<T> & s) const
{
  return BehavProfile<T>::operator==(s);
}

template <class T> void BehavSolution<T>::Dump(gOutput& f) const
{
  BehavProfile<T>::Dump(f);
  f << " Creator:"; DisplayID(f, _Creator);
  f << " IsNash:"; DisplayTriState(f, _IsNash);
  f << " IsSubgamePerfect:"; DisplayTriState(f, _IsSubgamePerfect);
  f << " IsSequential:"; DisplayTriState(f, _IsSequential);
  f << " Support:" << Support();
  f << " GobitLambda:" << _GobitLambda;
  f << " GobitValue:" << _GobitValue;
  f << " LiapValue:" << _LiapValue;
}

template <class T> gOutput &operator<<(gOutput &f, const BehavSolution<T> &s)
{ 
  s.Dump(f);  
  return f;
}


template <class T> void BehavSolution<T>::Invalidate()
{
  _Creator = id_USER;
  _IsNash = T_DONTKNOW;
  _IsSubgamePerfect = T_DONTKNOW;
  _IsSequential = T_DONTKNOW;
  _GobitLambda = -1;
  _GobitValue = -1;
  _LiapValue = -1;
}

template <class T> T& BehavSolution<T>::operator[](int i)
{ Invalidate(); return BehavProfile<T>::operator[](i); }

template <class T> T& BehavSolution<T>::operator()(int a, int b, int c)
{ Invalidate(); return BehavProfile<T>::operator()(a, b, c); }

template <class T> 
gDPVector<T>& BehavSolution<T>::operator=(const gDPVector<T>& v)
{ Invalidate(); return gDPVector<T>::operator=(v); }

template <class T> 
gDPVector<T>& BehavSolution<T>::operator=(const gPVector<T>& v)
{ assert(0); Invalidate(); return gDPVector<T>::operator=(v); }

template <class T> 
gDPVector<T>& BehavSolution<T>::operator=(const gVector<T>& v)
{ assert(0); Invalidate(); return gDPVector<T>::operator=(v); }

template <class T> 
gDPVector<T>& BehavSolution<T>::operator=(T i)
{ assert(0); Invalidate(); return gDPVector<T>::operator=(i); }

template <class T> 
gDPVector<T>& BehavSolution<T>::operator+=(const gDPVector<T>& v)
{ Invalidate(); return gDPVector<T>::operator+=(v); }

template <class T> 
gPVector<T>& BehavSolution<T>::operator+=(const gPVector<T>& v)
{ assert(0); Invalidate(); return gPVector<T>::operator+=(v); }

template <class T> 
gVector<T>& BehavSolution<T>::operator+=(const gVector<T>& v)
{ assert(0); Invalidate(); return gVector<T>::operator+=(v); }

template <class T> 
gDPVector<T>& BehavSolution<T>::operator-=(const gDPVector<T>& v)
{ Invalidate(); return gDPVector<T>::operator-=(v); }

template <class T> 
gPVector<T>& BehavSolution<T>::operator-=(const gPVector<T>& v)
{ assert(0); Invalidate(); return gPVector<T>::operator-=(v); }

template <class T> 
gVector<T>& BehavSolution<T>::operator-=(const gVector<T>& v)
{ assert(0); Invalidate(); return gVector<T>::operator-=(v); }

template <class T> gDPVector<T>& BehavSolution<T>::operator*=(T i)
{ Invalidate(); return gDPVector<T>::operator*=(i); }

template <class T> 
BehavProfile<T>& BehavSolution<T>::operator=(const BehavProfile<T>& v)
{ Invalidate(); return BehavProfile<T>::operator=(v); }
