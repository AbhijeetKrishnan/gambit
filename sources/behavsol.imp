//
// FILE: behavsol.imp -- Behav strategy solution classes
//
// $Id$
//


#include <assert.h>
#include "efgutils.h"
#include "behavsol.h"
#include "gmisc.h"

template <class T> 
BehavSolution<T>::BehavSolution(const Efg<T>& e)
  : BehavProfile<T>(e),
  _Creator(EfgAlg_USER),
  _IsNash(T_DONTKNOW),
  _IsSubgamePerfect(T_DONTKNOW),
  _IsSequential(T_DONTKNOW),
  _GobitLambda(-1),
  _GobitValue(-1),
  _LiapValue(-1),
  _Beliefs(0),
  _Id(0)
{
  gEpsilon(_Epsilon);

}


template <class T> 
BehavSolution<T>::BehavSolution(const Efg<T>& e, const gDPVector<T>& v)
  : BehavProfile<T>(e, v),
  _Creator(EfgAlg_USER),
  _IsNash(T_DONTKNOW),
  _IsSubgamePerfect(T_DONTKNOW),
  _IsSequential(T_DONTKNOW),
  _GobitLambda(-1),
  _GobitValue(-1),
  _LiapValue(-1),
  _Beliefs(0),
  _Regret(0),
  _Id(0)
{
  gEpsilon(_Epsilon);

}

template <class T> 
BehavSolution<T>::BehavSolution(const EFSupport& s)
  : BehavProfile<T>(s),
  _Creator(EfgAlg_USER),
  _IsNash(T_DONTKNOW),
  _IsSubgamePerfect(T_DONTKNOW),
  _IsSequential(T_DONTKNOW),
  _GobitLambda(-1),
  _GobitValue(-1),
  _LiapValue(-1),
  _Beliefs(0),
  _Regret(0),
  _Id(0)
{
  gEpsilon(_Epsilon);

}

template <class T> 
BehavSolution<T>::BehavSolution(const BehavProfile<T>& b, EfgAlgType creator)
: BehavProfile<T>(b),
  _Creator(creator),
  _IsNash(T_DONTKNOW),
  _IsSubgamePerfect(T_DONTKNOW),
  _IsSequential(T_DONTKNOW),
  _GobitLambda(-1),
  _GobitValue(-1),
  _LiapValue(-1),
  _Beliefs(0),
  _Regret(0),
  _Id(0)
{
  gEpsilon(_Epsilon);

}


template <class T> BehavSolution<T>::BehavSolution(const BehavSolution<T>& b)
: BehavProfile<T>(b),
  _Creator(b._Creator),
  _IsNash(b._IsNash),
  _IsSubgamePerfect(b._IsSubgamePerfect),
  _IsSequential(b._IsSequential),
  _Epsilon(b._Epsilon),
  _GobitLambda(b._GobitLambda),
  _GobitValue(b._GobitValue),
  _LiapValue(b._LiapValue),
  _Beliefs(0), _Regret(0),
  _Id(b._Id)
{
  if (b._Beliefs) _Beliefs = new gDPVector<T>(*b._Beliefs);
  if (b._Regret)  _Regret = new gDPVector<T>(*b._Regret);   
}

template <class T> BehavSolution<T>::~BehavSolution() 
{ 
  if (_Beliefs) delete _Beliefs;
  if (_Regret)  delete _Regret;
}

template <class T> void BehavSolution<T>::EvalEquilibria()
{
  if(_Creator == EfgAlg_LIAP || _Creator == EfgAlg_GOBIT)
    _IsSequential = T_YES;
  else
    _IsSequential = T_DONTKNOW;
  
  if (IsComplete()) 
    if( _IsNash == T_DONTKNOW )
      if(MaxGripe() <= _Epsilon)
	_IsNash = T_YES;
      else
	_IsNash = T_NO;
  
  if(_IsNash == T_NO)
    {
      _IsSubgamePerfect = T_NO;
      _IsSequential = T_NO;
    }
}

template <class T> unsigned int BehavSolution<T>::Id(void) const
{return _Id;}
template <class T> void BehavSolution<T>::SetId(unsigned int i)
{_Id=i;}

template <class T> void BehavSolution<T>::SetCreator(EfgAlgType c)
{ _Creator = c; }

template <class T> bool BehavSolution<T>::IsComplete(void) const
{ 
  T sum;
  for(int pl= 1; pl <=dvlen.Length(); pl++)
    for(int iset = 1;iset <=dvlen[pl]; iset++) { 
      sum = -(T)1;
      for(int act = 1;act <= svlen[dvidx[pl] + iset -1]; act++) 
	sum+= dvptr[pl][iset][act];
      if(sum > _Epsilon || sum < -_Epsilon) 
	return false;
    }
  return true;
}

template <class T> EfgAlgType BehavSolution<T>::Creator(void) const
{ return _Creator; }

template <class T> void BehavSolution<T>::SetIsNash(TriState i)
{ _IsNash = i; }

template <class T> TriState BehavSolution<T>::IsNash(void) const
{ ((BehavSolution<T> &) *this).EvalEquilibria(); return _IsNash; }

template <class T> void BehavSolution<T>::SetIsSubgamePerfect(TriState i)
{ _IsSubgamePerfect = i; }

template <class T> TriState BehavSolution<T>::IsSubgamePerfect(void) const
{
  ((BehavSolution<T> &) *this).EvalEquilibria(); 
  if((_Creator != EfgAlg_USER) && (_IsNash == T_YES) && (AllSubgamesMarked(*E)))
    ((BehavSolution<T> &) *this)._IsSubgamePerfect = T_YES;
  else
    ((BehavSolution<T> &) *this)._IsSubgamePerfect = T_DONTKNOW;

  return _IsSubgamePerfect; 
}

template <class T> void BehavSolution<T>::SetIsSequential(TriState i)
{ _IsSequential = i; }

template <class T> TriState BehavSolution<T>::IsSequential(void) const
{ ((BehavSolution<T> &) *this).EvalEquilibria(); return _IsSequential; }

template <class T> void BehavSolution<T>::SetGobit(T lambda, T value)
{
  _GobitLambda = lambda;
  _GobitValue = value;
}

template <class T> T BehavSolution<T>::GobitLambda(void) const
{ return _GobitLambda; }

template <class T> void BehavSolution<T>::SetEpsilon(T value)
{
  _Epsilon = value;
}

template <class T> T BehavSolution<T>::Epsilon(void) const
{ return _Epsilon; }

template <class T> T BehavSolution<T>::GobitValue(void) const
{ return _GobitValue; }

template <class T> void BehavSolution<T>::SetLiap(T value)
{ _LiapValue = value; }

template <class T> T BehavSolution<T>::LiapValue(void) const
{ 
  if (_LiapValue < (T)0)
    ((BehavSolution<T> &) *this)._LiapValue = BehavProfile<T>::LiapValue();
  return _LiapValue; 
}

template <class T> const gDPVector<T> &BehavSolution<T>::Beliefs(void) const
{ 
  if (! _Beliefs)
    ((BehavSolution<T> &) *this)._Beliefs =
      new gDPVector<T>(BehavProfile<T>::Beliefs());

  return *_Beliefs; 
}

template <class T> const gDPVector<T> &BehavSolution<T>::Regret(void) const
{
  if (!_Regret)  {
    ((BehavSolution<T> &) *this)._Regret =
      new gDPVector<T>(E->Dimensionality());
    Gripe(*((BehavSolution<T> &) *this)._Regret);
  }

  return *_Regret;
}

template <class T> 
bool BehavSolution<T>::operator==(const BehavSolution<T> & s) const
{
  return BehavProfile<T>::operator==(s);
}

template <class T> void BehavSolution<T>::Dump(gOutput& f) const
{
  BehavProfile<T>::Dump(f);
  f << " Creator:"; DisplayEfgAlgType(f, _Creator);
  f << " IsNash:"; DisplayTriState(f, _IsNash);
  f << " IsSubgamePerfect:"; DisplayTriState(f, _IsSubgamePerfect);
  f << " IsSequential:"; DisplayTriState(f, _IsSequential);
  f << " Support:" << GetEFSupport();
  f << " GobitLambda:" << _GobitLambda;
  f << " GobitValue:" << _GobitValue;
  f << " LiapValue:" << _LiapValue;
  if(_Beliefs) f << " Beliefs:" << *_Beliefs;
}

template <class T> gOutput &operator<<(gOutput &f, const BehavSolution<T> &s)
{ s.Dump(f); return f; }


template <class T> void BehavSolution<T>::Invalidate(void)
{
  _Creator = EfgAlg_USER;
  _IsNash = T_DONTKNOW;
  _IsSubgamePerfect = T_DONTKNOW;
  _IsSequential = T_DONTKNOW;
  _GobitLambda = -1;
  _GobitValue = -1;
  _LiapValue = -1;
  if (_Beliefs) { 
    delete _Beliefs;
    _Beliefs = 0;
  }
  
  if (_Regret)  {
    delete _Regret;
    _Regret = 0;
  }
}

template <class T> T& BehavSolution<T>::operator[](int i)
{ Invalidate(); return BehavProfile<T>::operator[](i); }

template <class T> const T& BehavSolution<T>::operator[](int i) const
{ return BehavProfile<T>::operator[](i); }

template <class T> T& BehavSolution<T>::operator()(int a, int b, int c)
{ Invalidate(); return BehavProfile<T>::operator()(a, b, c); }

template <class T> const T& BehavSolution<T>::operator()(int a, int b, int c) const
{ return BehavProfile<T>::operator()(a, b, c); }

template <class T>
BehavSolution<T>& BehavSolution<T>::operator=(const BehavSolution<T> &s)
{
  if (this != &s)   {
    BehavProfile<T>::operator=(s);
    _Creator = s._Creator;
    _IsNash = s._IsNash;
    _IsSubgamePerfect = s._IsSubgamePerfect;
    _IsSequential = s._IsSequential;
    _GobitLambda = s._GobitLambda;
    _GobitValue = s._GobitValue;
    _LiapValue = s._LiapValue;
    if (_Beliefs)   delete _Beliefs;
    if (s._Beliefs)
      _Beliefs = new gDPVector<T>(*s._Beliefs);
    else
      _Beliefs = 0;
    if (_Regret)   delete _Regret;
    if (s._Regret)
      _Regret = new gDPVector<T>(*s._Regret);
    else
      _Regret = 0;
  }

  return *this;
}
    
template <class T> 
BehavSolution<T>& BehavSolution<T>::operator=(const BehavProfile<T>& v)
{ 
  Invalidate(); 
  BehavProfile<T>::operator=(v);
  return *this;
}

template <class T>
BehavSolution<T>& BehavSolution<T>::operator=(const gDPVector<T>& v)
{ 
  Invalidate(); 
  gDPVector<T>::operator=(v);
  return *this;
}

template <class T> 
BehavSolution<T>& BehavSolution<T>::operator=(const gPVector<T>& v)
{    
  assert(0);
  Invalidate();
  gDPVector<T>::operator=(v);
  return *this;
}

template <class T> 
BehavSolution<T>& BehavSolution<T>::operator=(const gVector<T>& v)
{
  assert(0);
  Invalidate();
  gDPVector<T>::operator=(v);
  return *this;
}

template <class T> 
BehavSolution<T>& BehavSolution<T>::operator=(T x)
{ 
  assert(0);
  Invalidate();
  gDPVector<T>::operator=(x);
  return *this;
}

template <class T> 
BehavSolution<T>& BehavSolution<T>::operator+=(const gDPVector<T>& v)
{ 
  Invalidate(); 
  gDPVector<T>::operator+=(v); 
  return *this;
}

template <class T> 
BehavSolution<T>& BehavSolution<T>::operator+=(const gPVector<T>& v)
{
  assert(0);
  Invalidate(); 
  gPVector<T>::operator+=(v);
  return *this;
}

template <class T> 
BehavSolution<T>& BehavSolution<T>::operator+=(const gVector<T>& v)
{
  assert(0); 
  Invalidate();
  gVector<T>::operator+=(v);
  return *this;
}

template <class T> 
BehavSolution<T>& BehavSolution<T>::operator-=(const gDPVector<T>& v)
{ 
  Invalidate();
  gDPVector<T>::operator-=(v);
  return *this;
}

template <class T> 
BehavSolution<T>& BehavSolution<T>::operator-=(const gPVector<T>& v)
{
  assert(0);
  Invalidate();
  gPVector<T>::operator-=(v);
  return *this;
}

template <class T> 
BehavSolution<T>& BehavSolution<T>::operator-=(const gVector<T>& v)
{ 
  assert(0);
  Invalidate();
  gVector<T>::operator-=(v);
  return *this;
}

template <class T> BehavSolution<T>& BehavSolution<T>::operator*=(T x)
{ 
  Invalidate();
  gDPVector<T>::operator*=(x);
  return *this;
}





