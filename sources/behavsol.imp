//#
//# FILE: behavsol.imp -- Behav strategy solution classes
//#
//# $Id$
//#


#include <assert.h>
#include "efgutils.h"
#include "behavsol.h"
#include "gmisc.h"

template <class T> 
BehavSolution<T>::BehavSolution(const Efg<T>& e, bool truncated)
: BehavProfile<T>(e, truncated),
  _Creator(EfgAlg_USER),
  _IsNash(T_DONTKNOW),
  _IsSubgamePerfect(T_DONTKNOW),
  _IsSequential(T_DONTKNOW),
  _GobitLambda(-1),
  _GobitValue(-1),
  _LiapValue(-1),
  _Beliefs(0)
{}


template <class T> 
BehavSolution<T>::BehavSolution(const Efg<T>& e, const gDPVector<T>& v)
: BehavProfile<T>(e, v),
  _Creator(EfgAlg_USER),
  _IsNash(T_DONTKNOW),
  _IsSubgamePerfect(T_DONTKNOW),
  _IsSequential(T_DONTKNOW),
  _GobitLambda(-1),
  _GobitValue(-1),
  _LiapValue(-1),
  _Beliefs(0)
{}

template <class T> 
BehavSolution<T>::BehavSolution(const EFSupport& s)
: BehavProfile<T>(s),
  _Creator(EfgAlg_USER),
  _IsNash(T_DONTKNOW),
  _IsSubgamePerfect(T_DONTKNOW),
  _IsSequential(T_DONTKNOW),
  _GobitLambda(-1),
  _GobitValue(-1),
  _LiapValue(-1),
  _Beliefs(0)
{}

template <class T> 
BehavSolution<T>::BehavSolution(const BehavProfile<T>& b, EfgAlgType creator)
: BehavProfile<T>(b),
  _Creator(creator),
  _IsNash(T_DONTKNOW),
  _IsSubgamePerfect(T_DONTKNOW),
  _IsSequential(T_DONTKNOW),
  _GobitLambda(-1),
  _GobitValue(-1),
  _LiapValue(-1),
  _Beliefs(0)
{}


template <class T> BehavSolution<T>::BehavSolution(const BehavSolution<T>& b)
: BehavProfile<T>(b),
  _Creator(b._Creator),
  _IsNash(b._IsNash),
  _IsSubgamePerfect(b._IsSubgamePerfect),
  _IsSequential(b._IsSequential),
  _GobitLambda(b._GobitLambda),
  _GobitValue(b._GobitValue),
  _LiapValue(b._LiapValue),
  _Beliefs(0)
{
  if(b._Beliefs) _Beliefs = new gDPVector<T>(*b._Beliefs);
}

template <class T> BehavSolution<T>::~BehavSolution() 
{ 
  if(_Beliefs) delete _Beliefs;
}

template <class T> void BehavSolution<T>::EvalEquilibria()
{
  if(_Creator == EfgAlg_LIAP || _Creator == EfgAlg_GOBIT)
    _IsSequential = T_YES;
  else
    _IsSequential = T_DONTKNOW;

  if( _IsNash == T_DONTKNOW )
    if(BehavProfile<T>::IsNash())
      _IsNash = T_YES;
    else
      _IsNash = T_NO;

  if(_IsNash == T_NO)
  {
    _IsSubgamePerfect = T_NO;
    _IsSequential = T_NO;
  }
}

template <class T> void BehavSolution<T>::SetCreator(EfgAlgType c)
{ _Creator = c; }

template <class T> EfgAlgType BehavSolution<T>::Creator() const
{ return _Creator; }

template <class T> void BehavSolution<T>::SetIsNash(TriState i)
{ _IsNash = i; }

template <class T> TriState BehavSolution<T>::IsNash()
{ EvalEquilibria(); return _IsNash; }

template <class T> void BehavSolution<T>::SetIsSubgamePerfect(TriState i)
{ _IsSubgamePerfect = i; }

template <class T> TriState BehavSolution<T>::IsSubgamePerfect()
{
  EvalEquilibria(); 
  if((_Creator != EfgAlg_USER) && (_IsNash == T_YES) && (AllSubgamesMarked(*E)))
    _IsSubgamePerfect = T_YES;
  else
    _IsSubgamePerfect = T_DONTKNOW;

  return _IsSubgamePerfect; 
}

template <class T> void BehavSolution<T>::SetIsSequential(TriState i)
{ _IsSequential = i; }

template <class T> TriState BehavSolution<T>::IsSequential()
{ EvalEquilibria(); return _IsSequential; }

template <class T> void BehavSolution<T>::SetGobit(T lambda, T value)
{
  _GobitLambda = lambda;
  _GobitValue = value;
}

template <class T> T BehavSolution<T>::GobitLambda() const
{ return _GobitLambda; }

template <class T> T BehavSolution<T>::GobitValue() const
{ return _GobitValue; }

template <class T> void BehavSolution<T>::SetLiap(T value)
{ _LiapValue = value; }

template <class T> T BehavSolution<T>::LiapValue()
{ 
  if(_LiapValue < (T)0)
    _LiapValue = BehavProfile<T>::LiapValue();
  return _LiapValue; 
}

template <class T> gDPVector<T> BehavSolution<T>::Beliefs()
{ 
  if(! _Beliefs)
    _Beliefs = new gDPVector<T>(BehavProfile<T>::Beliefs());

  return *_Beliefs; 
}


template <class T> 
bool BehavSolution<T>::operator==(const BehavSolution<T> & s) const
{
  return BehavProfile<T>::operator==(s);
}

template <class T> void BehavSolution<T>::Dump(gOutput& f) const
{
  BehavProfile<T>::Dump(f);
  f << " Creator:"; DisplayEfgAlgType(f, _Creator);
  f << " IsNash:"; DisplayTriState(f, _IsNash);
  f << " IsSubgamePerfect:"; DisplayTriState(f, _IsSubgamePerfect);
  f << " IsSequential:"; DisplayTriState(f, _IsSequential);
  f << " Support:" << GetEFSupport();
  f << " GobitLambda:" << _GobitLambda;
  f << " GobitValue:" << _GobitValue;
  f << " LiapValue:" << _LiapValue;
  if(_Beliefs) f << " Beliefs:" << *_Beliefs;
}

template <class T> gOutput &operator<<(gOutput &f, const BehavSolution<T> &s)
{ s.Dump(f); return f; }


template <class T> void BehavSolution<T>::Invalidate()
{
  _Creator = EfgAlg_USER;
  _IsNash = T_DONTKNOW;
  _IsSubgamePerfect = T_DONTKNOW;
  _IsSequential = T_DONTKNOW;
  _GobitLambda = -1;
  _GobitValue = -1;
  _LiapValue = -1;
  if(_Beliefs) { 
    delete _Beliefs;
    _Beliefs = 0;
  }
}

template <class T> T& BehavSolution<T>::operator[](int i)
{ Invalidate(); return BehavProfile<T>::operator[](i); }

template <class T> const T& BehavSolution<T>::operator[](int i) const
{ return BehavProfile<T>::operator[](i); }

template <class T> T& BehavSolution<T>::operator()(int a, int b, int c)
{ Invalidate(); return BehavProfile<T>::operator()(a, b, c); }

template <class T> const T& BehavSolution<T>::operator()(int a, int b, int c) const
{ return BehavProfile<T>::operator()(a, b, c); }

template <class T>
gDPVector<T>& BehavSolution<T>::operator=(const gDPVector<T>& v)
{ Invalidate(); return gDPVector<T>::operator=(v); }

template <class T> 
gDPVector<T>& BehavSolution<T>::operator=(const gPVector<T>& v)
{ assert(0); Invalidate(); return gDPVector<T>::operator=(v); }

template <class T> 
gDPVector<T>& BehavSolution<T>::operator=(const gVector<T>& v)
{ assert(0); Invalidate(); return gDPVector<T>::operator=(v); }

template <class T> 
gDPVector<T>& BehavSolution<T>::operator=(T i)
{ assert(0); Invalidate(); return gDPVector<T>::operator=(i); }

template <class T> 
gDPVector<T>& BehavSolution<T>::operator+=(const gDPVector<T>& v)
{ Invalidate(); return gDPVector<T>::operator+=(v); }

template <class T> 
gPVector<T>& BehavSolution<T>::operator+=(const gPVector<T>& v)
{ assert(0); Invalidate(); return gPVector<T>::operator+=(v); }

template <class T> 
gVector<T>& BehavSolution<T>::operator+=(const gVector<T>& v)
{ assert(0); Invalidate(); return gVector<T>::operator+=(v); }

template <class T> 
gDPVector<T>& BehavSolution<T>::operator-=(const gDPVector<T>& v)
{ Invalidate(); return gDPVector<T>::operator-=(v); }

template <class T> 
gPVector<T>& BehavSolution<T>::operator-=(const gPVector<T>& v)
{ assert(0); Invalidate(); return gPVector<T>::operator-=(v); }

template <class T> 
gVector<T>& BehavSolution<T>::operator-=(const gVector<T>& v)
{ assert(0); Invalidate(); return gVector<T>::operator-=(v); }

template <class T> gDPVector<T>& BehavSolution<T>::operator*=(T i)
{ Invalidate(); return gDPVector<T>::operator*=(i); }

template <class T> 
BehavProfile<T>& BehavSolution<T>::operator=(const BehavProfile<T>& v)
{ Invalidate(); return BehavProfile<T>::operator=(v); }




