//
// FILE: behavsol.imp -- Behav strategy solution classes
//
// $Id$
//


#include <assert.h>
#include "efgutils.h"
#include "behavsol.h"
#include "gmisc.h"

BehavSolution::BehavSolution(const BehavProfile<double>& b, EfgAlgType creator)
  : BehavProfile<gNumber>(b.Support()),
    _Creator(creator), _IsNash(T_DONTKNOW), _IsSubgamePerfect(T_DONTKNOW),
    _IsSequential(T_DONTKNOW), _Epsilon((double)0), 
    _GobitLambda(-1), _GobitValue(-1),
    _LiapValue(-1), _Beliefs(0), _Regret(0), _Id(0)
{
  gEpsilon(_Epsilon);
  for (int i = 1; i <= b.Length(); i++)
    ((gVector<gNumber> &) *this)[i] = b[i];
}

BehavSolution::BehavSolution(const BehavProfile<gRational>& b, EfgAlgType creator)
  : BehavProfile<gNumber>(b.Support()),
    _Creator(creator), _IsNash(T_DONTKNOW), _IsSubgamePerfect(T_DONTKNOW),
    _IsSequential(T_DONTKNOW), _GobitLambda(-1), _GobitValue(-1),
    _LiapValue(-1), _Beliefs(0), _Regret(0), _Id(0)
{
  gEpsilon(_Epsilon);
  for (int i = 1; i <= b.Length(); i++)
    ((gVector<gNumber> &) *this)[i] = b[i];
}

BehavSolution::BehavSolution(const BehavProfile<gNumber>& b, EfgAlgType creator)
  : BehavProfile<gNumber>(b),
    _Creator(creator), _IsNash(T_DONTKNOW), _IsSubgamePerfect(T_DONTKNOW),
    _IsSequential(T_DONTKNOW), _GobitLambda(-1), _GobitValue(-1),
    _LiapValue(-1), _Beliefs(0), _Regret(0), _Id(0)
{
  gEpsilon(_Epsilon);
}

BehavSolution::BehavSolution(const BehavSolution& b)
  : BehavProfile<gNumber>(b), _Creator(b._Creator),
    _IsNash(b._IsNash), _IsSubgamePerfect(b._IsSubgamePerfect),
    _IsSequential(b._IsSequential), _Epsilon(b._Epsilon),
    _GobitLambda(b._GobitLambda), _GobitValue(b._GobitValue),
    _LiapValue(b._LiapValue), _Beliefs(0), _Regret(0), _Id(b._Id)
{
  if (b._Beliefs) _Beliefs = new gDPVector<gNumber>(*b._Beliefs);
  if (b._Regret)  _Regret = new gDPVector<gNumber>(*b._Regret);   
}

BehavSolution::~BehavSolution() 
{ 
  if (_Beliefs) delete _Beliefs;
  if (_Regret)  delete _Regret;
}

void BehavSolution::EvalEquilibria(void) const
{
  if (IsComplete()) 
    if( _IsNash == T_DONTKNOW )
      if(MaxGripe() <= _Epsilon)
	_IsNash = T_YES;
      else
	_IsNash = T_NO;
  
  if(_IsNash == T_NO)
    {
      _IsSubgamePerfect = T_NO;
      _IsSequential = T_NO;
    }
}

unsigned int BehavSolution::Id(void) const
{return _Id;}
void BehavSolution::SetId(unsigned int i)
{_Id=i;}

void BehavSolution::SetCreator(EfgAlgType c)
{ _Creator = c; }

bool BehavSolution::IsComplete(void) const
{ 
  gNumber sum;
  for(int pl= 1; pl <=dvlen.Length(); pl++)
    for(int iset = 1;iset <=dvlen[pl]; iset++) { 
      sum = -1;
      for(int act = 1;act <= svlen[dvidx[pl] + iset -1]; act++) 
	sum+= dvptr[pl][iset][act];
      if(sum > _Epsilon || sum < -_Epsilon) 
	return false;
    }
  return true;
}

EfgAlgType BehavSolution::Creator(void) const
{ return _Creator; }

void BehavSolution::SetIsNash(TriState i)
{ _IsNash = i; }

TriState BehavSolution::IsNash(void) const
{ EvalEquilibria(); return _IsNash; }

void BehavSolution::SetIsSubgamePerfect(TriState i)
{ _IsSubgamePerfect = i; }

TriState BehavSolution::IsSubgamePerfect(void) const
{
  EvalEquilibria(); 
  return _IsSubgamePerfect; 
}

void BehavSolution::SetIsSequential(TriState i)
{ _IsSequential = i; }

TriState BehavSolution::IsSequential(void) const
{ EvalEquilibria(); return _IsSequential; }

void BehavSolution::SetGobit(gNumber lambda, gNumber value)
{
  _GobitLambda = lambda;
  _GobitValue = value;
}

gNumber BehavSolution::GobitLambda(void) const
{ return _GobitLambda; }

void BehavSolution::SetEpsilon(gNumber value)
{
  _Epsilon = value;
}

gNumber BehavSolution::Epsilon(void) const
{ return _Epsilon; }

gNumber BehavSolution::GobitValue(void) const
{ return _GobitValue; }

void BehavSolution::SetLiap(gNumber value)
{ _LiapValue = value; }

gNumber BehavSolution::LiapValue(void) const
{ 
  if (_LiapValue < (gNumber)0)
    _LiapValue = BehavProfile<gNumber>::LiapValue();
  return _LiapValue; 
}

const gDPVector<gNumber> &BehavSolution::Beliefs(void) const
{ 
  if (! _Beliefs) 
    _Beliefs = new gDPVector<gNumber>(BehavProfile<gNumber>::Beliefs());

  return *_Beliefs; 
}

const gDPVector<gNumber> &BehavSolution::Regret(void) const
{
  if (!_Regret)  {
    _Regret = new gDPVector<gNumber>(E->NumActions());
    Gripe(*_Regret);
  }

  return *_Regret;
}

bool BehavSolution::Equals(const BehavProfile<double> &s) const
{ 
  gNumber eps(_Epsilon);
  gEpsilon(eps,4);  // this should be a function of _Epsilon
  bool flag=true;
  int i=s.First();
  while(flag==true && i<=s.Length()) {
    if(abs((*this)[i]-(gNumber)s[i]) > eps) 
      flag=false;
    i++;
  }
  return flag;
}

bool BehavSolution::operator==(const BehavSolution &s) const
{
  return BehavProfile<gNumber>::operator==(s);
}

void BehavSolution::Dump(gOutput& f) const
{
  BehavProfile<gNumber>::Dump(f);
  f << " Creator:"; DisplayEfgAlgType(f, _Creator);
  f << " IsNash:"; DisplayTriState(f, _IsNash);
  f << " IsSubgamePerfect:"; DisplayTriState(f, _IsSubgamePerfect);
  f << " IsSequential:"; DisplayTriState(f, _IsSequential);
  f << " Support:" << support;
  f << " GobitLambda:" << _GobitLambda;
  f << " GobitValue:" << _GobitValue;
  f << " LiapValue:" << _LiapValue;
  if(_Beliefs) f << " Beliefs:" << *_Beliefs;
}

gOutput &operator<<(gOutput &f, const BehavSolution &s)
{ s.Dump(f); return f; }


void BehavSolution::Invalidate(void)
{
  _Creator = EfgAlg_USER;
  _IsNash = T_DONTKNOW;
  _IsSubgamePerfect = T_DONTKNOW;
  _IsSequential = T_DONTKNOW;
  _GobitLambda = -1;
  _GobitValue = -1;
  _LiapValue = -1;
  if (_Beliefs) { 
    delete _Beliefs;
    _Beliefs = 0;
  }
  
  if (_Regret)  {
    delete _Regret;
    _Regret = 0;
  }
}

gNumber &BehavSolution::operator[](int i)
{ Invalidate(); return BehavProfile<gNumber>::operator[](i); }

const gNumber& BehavSolution::operator[](int i) const
{ return BehavProfile<gNumber>::operator[](i); }

gNumber& BehavSolution::operator()(int a, int b, int c)
{ Invalidate(); return BehavProfile<gNumber>::operator()(a, b, c); }

const gNumber& BehavSolution::operator()(int a, int b, int c) const
{ return BehavProfile<gNumber>::operator()(a, b, c); }

BehavSolution& BehavSolution::operator=(const BehavSolution &s)
{
  if (this != &s)   {
    BehavProfile<gNumber>::operator=(s);
    _Creator = s._Creator;
    _IsNash = s._IsNash;
    _IsSubgamePerfect = s._IsSubgamePerfect;
    _IsSequential = s._IsSequential;
    _GobitLambda = s._GobitLambda;
    _GobitValue = s._GobitValue;
    _LiapValue = s._LiapValue;
    if (_Beliefs)   delete _Beliefs;
    if (s._Beliefs)
      _Beliefs = new gDPVector<gNumber>(*s._Beliefs);
    else
      _Beliefs = 0;
    if (_Regret)   delete _Regret;
    if (s._Regret)
      _Regret = new gDPVector<gNumber>(*s._Regret);
    else
      _Regret = 0;
  }

  return *this;
}
    
