GCL Bugs

//------------------------------

Bug C5: Incorrect solutions, and crashing with large integers:

  46 mill:/home/mill/rdm/gambit/test newgcl
  Include["gclini.gcl"]
  Include["stdudfs.gcl"]
  GCL1:= p:={ { { 343519405, 57518365 }, { 905196150, 857537702 } },{ { 500889218, 1982990232 }, { 83903549, 1493083335 } } }
  GCL2:= << n:=Nfg[p]
  (Nfg) ""
  GCL3:= << AllNash[n]
  {  (MIXED) }
  GCL4:= << LcpSolve[n]
  gcl_mill: lemketab.cc:166: int LTableau<double>::ExitIndex(int): Assertion `c <= MaxRow()' failed.
  A segmentation fault has occurred

This looks like an algorithm bug.  I'll see if I can track it down
(rdm).  The following bug looks like the same thing: 

RDM: This was moved here from the GUI bug list (9/3/98).  The file is
in ~rdm/gambit/nfg/osborne.nfg

  222 mill:/home/mill/rdm/gambit/test newgcl
  Include["gclini.gcl"]
  Include["/home/mill/rdm/gambit/bin/stdudfs.gcl"]
  GCL1:= << n:=LoadNfg["../nfg/osborne.nfg"]
  (Nfg) "4 actions; minimal action 0.00; maximal action 0.50"
  GCL2:= << LcpSolve[n]
  gcl_mill: lemketab.cc:166: int LTableau<double>::ExitIndex(int): Assertion `c <= MaxRow()' failed.
  A segmentation fault has occurred

Note (RDM, 9/6/98) In this same section should be noted problems
solving "stengel.nfg" in Float.  This used to crash.  Since changing
to automatic Refactoring of Tableau, it doesn't crash, but finds 261
solutions many of which are *not* Nash equilibria.  On the other hand,
if you first divide all payoffs by a large number (like 1000000), to
get them in lower range, then it computes correctly.  So this problem
is related to the zero tolerance in the Tableau code, and should be
able to be "fixed" by proper scaling of the tableau before
computation.  However, this also points to an inherent limitation in
the Float code: There is no way to prevent this kind of problem from
occurring if there are legitimate entries in the normal form which
differ sufficiently greatly in magnitude.  Therefore we need to do two
things: 

1.  Make sure and check that all solutions returned are indeed Nash
equilibria.

2. Detect and warn the user when there may be a problem with floating
point calculations.


//------------------------------

Bug C8:  Bug in mixed dominance elimination.  

  311 mill:/home/mill/rdm/gambit/test2 newgcl
  Include["gclini.gcl"]
  Include["stdudfs.gcl"]
  GCL1:= << e:=LoadEfg["poker.efg"]
  (Efg) "A simple Poker game"
  GCL2:= << n := Nfg[e];
  (Nfg) "A simple Poker game"
  GCL3:= << s:=ElimAllDom[n,strong->True,mixed->True];
  gcl_mill: tableau.imp:385: void LPTableau<gRational>::SetCost(const class gVector<gRational> &): Assertion `c.Last()==(cost.Last()+unitcost.Length())' failed.
  A segmentation fault has occurred

//------------------------------

Bug C9a: The Include["x"] bug on billandal is fixed, but the other IO functions
are still having the same problem there:

  43 billandal:/home/mill/rdm/gambit/sources gcl_AIX
  Include["gclini.gcl"]
  Include["stdudfs.gcl"]
  GCL1:= << LoadNfg["x"]
  A segmentation fault has occurred

Also, when you quit the gcl on billandal, it seg faults.  As before,
none of these are a problem on mill or koo.  

COMMENT (magyar 8/29/98)  Appears to be a compiler bug with g++ 2.8.1 on
RS6k and catching exceptions.

//------------------------------

Bug C17  Bad line numbers for parse errors.  

  148 mill:/home/mill/rdm/gambit/test newgcl
  Include["gclini.gcl"]
  Include["stdudfs.gcl"]
  GCL1:= << Include["bcp.gcl"]    
  True
  parse error at line 56 in file bcp.gcl: identifier size

but line 56 is a comment.  

//------------------------------

Bug C18: Bug in LPSolve[] (or use the script gambit/test/csumsolve.gcl):

  GCL1:= << n:=LoadNfg["../nfg/cs1.nfg"]
  (Nfg) ""
  GCL2:= << m:=LpSolve[n,stopAfter->0]

  c: { 0.000000 0.000000 0.000000 1.000000 }
  uc: { 0.000000 0.000000 0.000000 0.000000 }
  col: 1 cost: 0.000000 label: 4 x: 1.000000
  col: 2 cost: -1.000000 label: -2 x: In function LpSolve[], in file "stdudfs.gcl" at line 463:
  In function LpSolve[], in file "console" at line 2:
  GCL EXCEPTION:Bad index in gArray; Caught in gcl.cc, main()

//--------------------------------------

Bug C20: Read[StdIn,x] hangs the machine (it had to be killed remotely)

  GCL1:= << Read[StdIn,x]
  GCL: Parameter 2 undefined in call to Read
  GCL2:= << x:=0
  0
  GCL3:= << Read[StdIn,x]
  Killed

//------------------------------

Bug C21: Algorithms producing nonsense on games of imperfect recall

  GCL1:= << e:=LoadEfg["myerson.efg"]
  (Efg) "Myerson - Game with no solution in behavioral strategies"
  GCL2:= << IsPerfectRecall[e]       
  False
  GCL3:= << b:=LcpSolve[e]              
  { (Behav) { { 0.000000 1.000000 }{ 0.250000 0.750000 } }{ { 0.500000 0.500000 } } }
  GCL4:= << IsNash[b]
  { False }
  GCL5:= << OneNash[e]   
  { (Behav) { { 0.500000 0.500000 }{ 1.000000 1.000000 } }{ { 0.500000 0.500000 } } }
  GCL6:= << IsNash[GCL5] 
  { Maybe }

//------------------------------

Bug C25:  Saving games loses precision.  


  GCL1:= << n:=NewNfg[{2,2},True]
  (Nfg) ""
  GCL2:= << SetPayoffs[Outcomes[n]_1,{1.0123456789,0.0}]
  (NFOutcome) 0x83917b0 "11"
  GCL3:= << SetNumericFormat[precis->10]
  True
  GCL4:= << Payoffs[n]
  { { { 1.0123456789, 0.0000000000 }, { 0, 0 } },
    { { 0, 0 }, { 0, 0 } } }
  GCL5:= << SaveNfg[n,"junk"]
  (Nfg) ""
  GCL6:= << nn:=LoadNfg["junk"]
  (Nfg) ""
  GCL7:= << Payoffs[nn]        
  { { { 1.0123460000, 0.0000000000 }, { 0, 0 } },
    { { 0, 0 }, { 0, 0 } } }

//-----------------------------

Bug C26:  Incomplete profiles, LiapValue, and so forth

GCL1:= << LoadEfg["D:/gambit/efg/e02.efg"]
(Efg) "Selten (IJGT, 75), Figure 2"
GCL2:= << LcpSolve[GCL1]
{ (Behav) { { 1.000000 0.000000 }{ 0.000000 0.000000 } }{ { 0.500000 0.500000 } } }
GCL3:= << LiapValue[GCL2]
{ 100.000000 }

This is actually a symptom of the "incomplete" profiles generated by
LcpSolve[EFG], Behav[NFG], and so forth.  The fix is to improve
BehavProfile<T> and BehavSolution to be smart enough to realize when
action probabilities at certain information sets are not specified.
(This bug affects the GUI as well, of course.)

//-----------------------------

Bug C27:  LpSolve failing when stopAfter > 1

Include["gclini.gcl"]
Include["/home/mill/rdm/gambit/bin/stdudfs.gcl"]
GCL1:= << n:=LoadNfg["../nfg/zero.nfg"]
(Nfg) "Two person 2 x 2 game with all zero payoffs"
GCL2:= << LpSolve[n]
{ (Mixed) { 1.000000 0.000000 }{ 1.000000 0.000000 } }
GCL3:= << LpSolve[n,stopAfter->2]

c: { 0.000000 0.000000 1.000000 }
uc: { 0.000000 0.000000 0.000000 }
col: 1 cost: 0.000000 label: 3 x: 1.000000
col: 2 cost: 0.000000 label: -2 x: In function LpSolve[], in file "/home/mill/rdm/gambit/bin/stdudfs.gcl" at line 461:
In function LpSolve[], in file "console" at line 3:
EXCEPTION: Bad index in gArray
GCL4:= << Quit


//-----------------------------

Bug C28:  Infinite loop in LcpSolve[nfg]

The following hangs the GCL:

  GCL1:= << k:=10;
  GCL2:= << n:=Randomize[NewNfg[{k,k},True],seed->142];
  GCL3:= << LcpSolve[n]


//-----------------------------

Bug C29:  Memory leak?  

On koo, the script from the cron job, ~rdm/gambit/test/qretest.gcl
leads to the following

  35 koo:/home/mill/rdm/gambit/test newgcl
  Include["gclini.gcl"]
  Include["/home/mill/rdm/gambit/bin/stdudfs.gcl"]
  GCL1:= << Include["eqre.gcl"]
  True
  Include["eqre.gcl"]
  Include["eqreml.gcl"]
  Include["loglike.gcl"]
  GCL2:= << EQre["bhg3"]

Here is a much simpler example that crashes on mill:

  GCL1:= << For[j:=1,j>0,j:=j+1, << j;];

If you run this, and then on a separate xterm, watch top on mill, you
will see that the SIZE and RES columns gradually grow as the program
continues, eventually reaching about 800M, at which point, the GCL
segfaults.  The same thing happens with 

  GCL1:= << While[True,<< True]


//---------------  These are not bugs but suggested improvements ------------

S1: A suggestion to add command line arguments.  Perhaps we should
have a -Ifilename flag to include a file?

On Mon, 11 May 1998, Olson Collin K wrote:

> One simple creature comfort that would make programming in Gambit zounds
> easier would be to take all of the command line arguemnts to gcl32 and
> automatically Include[] them.  So far as I can tell from the manual, there
> is no way to do this.
> 
> I prefer to code using my own text editor, and this feature would make it
> much easier to do my own coding from outside the gcl command console and
> allow me to write software that calls gcl iteratively, for example.


