//
// FILE: readefg.imp -- Type-dependent file-reading code
//
// $Id$
//

#include "gstack.h"
#include "readefg.h"


template <class T> class EfgFile : public EfgFileReader    {
  public:
    EfgFile(gInput &, Efg<T> *&);
    virtual ~EfgFile();

    int Parse(void);

    EFOutcome *NewOutcome(void);
    void SetOutcome(EFOutcome *, const gList<gRational> &);
    void SetActionProbs(Infoset *, const gList<gRational> &);
    bool CheckActionProbs(Infoset *, const gList<gRational> &);
    bool CheckOutcome(EFOutcome *, const gList<gRational> &);
};

template <class T> EfgFile<T>::EfgFile(gInput &f, Efg<T> *& E)
  : EfgFileReader(f,(BaseEfg *&) E)
{ }

template <class T> EfgFile<T>::~EfgFile()
{ }

template <class T> EFOutcome *EfgFile<T>::NewOutcome(void)
{
  return ((Efg<T> *) E)->NewOutcome();
}

template <class T> void EfgFile<T>::SetOutcome(EFOutcome *c,
					       const gList<gRational> &p)
{
  int outc;
  for (outc = 1; E->Outcomes()[outc] != c; outc++);
  for (int i = 1; i <= p.Length(); i++)
    ((Efg<T> *) E)->payoffs(outc, i) = p[i];
}

template <class T> void EfgFile<T>::SetActionProbs(Infoset *s,
						   const gList<gRational> &p)
{
  for (int i = 1; i <= p.Length(); i++)
    ((ChanceInfoset<T> &) *s).SetActionProb(i, p[i]);
}

template <class T> bool EfgFile<T>::CheckActionProbs(Infoset *s,
						     const gList<gRational> &p)
{
  for (int i = 1; i <= p.Length(); i++)
    if (((ChanceInfoset<T> &) *s).GetActionProb(i) != (T) p[i])  return false;
  return true;
}

template <class T> bool EfgFile<T>::CheckOutcome(EFOutcome *c,
						 const gList<gRational> &p)
{
  int outc;
  for (outc = 1; E->Outcomes()[outc] != c; outc++);
  for (int i = 1; i <= p.Length(); i++)
    if (((Efg<T> *) E)->payoffs(outc, i) != (T) p[i])   return false;
  return true;
}

template <class T> int EfgFile<T>::Parse(void)
{
  infile.seekp(0);
  static char *prologue = { "EFG 2 " };
  char c;
  for (unsigned int i = 0; i < strlen(prologue); i++)   {
    infile.get(c);
    if (c != prologue[i])   return 1;
  }

  infile.get(c);
  if (c != ((E->Type() == DOUBLE) ? 'D' : 'R'))   return 1;
  return yyparse();
}

template <class T> int ReadEfgFile(gInput &f, Efg<T> *& E)
{
  assert(!E);

  E = new Efg<T>;

  EfgFile<T> R(f, E);
  
  if (R.Parse())  {
    if (E)  {  delete E;  E = 0; }
    return 0;
  }

  return 1;
}



