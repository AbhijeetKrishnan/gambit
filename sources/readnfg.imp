//
// FILE: readnfg.imp -- Type-dependent file-reading code
//
// $Id$
//

#include "glist.h"
#include "readnfg.h"

template <class T> class NfgFile : public NfgFileReader   {
  private:
    DataType type;
    Nfg<double> *fooD;
    Nfg<gRational> *fooR;

  public:
    NfgFile(gInput &, Nfg<T> *&);
    virtual ~NfgFile();

    int Parse(void);
    bool CreateNfg(const gList<gString> &, const gList<gRational> &,
		   const gList<gString> &);
    void SetPayoff(int cont, int pl, const gRational &);
    DataType Type(void) const;
};

template <class T> NfgFile<T>::~NfgFile()
{ }

template <class T> bool NfgFile<T>::CreateNfg(const gList<gString> &players,
					      const gList<gRational> &dims,
					      const gList<gString> &strats)
{
  if (players.Length() != dims.Length())   return false;

  gArray<int> dim(dims.Length());
  ncont = 1;
  int i;
  for (i = 1; i <= dim.Length(); i++)  {
    dim[i] = (int) dims[i];
    ncont *= dim[i];
    if (dim[i] <= 0)   return false;
  }
  
  if (type == DOUBLE)   {
    Ndbl = new Nfg<double>(dim);
    int strat = 1;
    for (i = 1; i <= dim.Length(); i++)  {
      Ndbl->Players()[i]->SetName(players[i]);
      if (strats.Length() > 0)
        for (int j = 1; j <= dim[i]; j++)
  	  Ndbl->GameForm().Strategies(i)[j]->name = strats[strat++];
    }
  }
  else  {
    Nrat = new Nfg<gRational>(dim);
    int strat = 1;
    for (i = 1; i <= dim.Length(); i++)  {
      Nrat->Players()[i]->SetName(players[i]);
      if (strats.Length() > 0)
        for (int j = 1; j <= dim[i]; j++)
  	  Nrat->GameForm().Strategies(i)[j]->name = strats[strat++];
    }
  }

  return true;
}

template <class T> void NfgFile<T>::SetPayoff(int cont, int pl,
					      const gRational &value)
{
  if (type == DOUBLE)  {
    if (pl == 1)
      Ndbl->GameForm().SetOutcome(cont, Ndbl->Outcomes()[cont]);
    Ndbl->payoffs(cont, pl) = (T) value;
  }
  else  {
    if (pl == 1)
      Nrat->GameForm().SetOutcome(cont, Nrat->Outcomes()[cont]);
    Nrat->payoffs(cont, pl) = (T) value;
  }
}

template <class T> int NfgFile<T>::Parse(void)
{
  infile.seekp(0);
  static char *prologue = { "NFG 1 " };
  char c;
  for (unsigned int i = 0; i < strlen(prologue); i++)  {
    infile.get(c);
    if (c != prologue[i])  return 1;
  }

  infile.get(c);
  switch (c)   {
    case 'D':
      break;
    case 'R':
      break;
    default:
      return 1;
  }
  return yyparse();
}




