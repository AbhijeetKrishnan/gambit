//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of window to draw correspondence plots
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
// This code is based loosely upon the plot windows in PXI, which was
// Copyright (c) Eugene Grayver.  The author has graciously permitted its
// use as a model for these classes.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include <math.h>
#include <wx/wxprec.h>
#ifndef WX_PRECOMP
#include <wx/wx.h>
#endif  // WX_PRECOMP
#include "id.h"
#include "corplot.h"

// These are for the support widgets
#include "nfgsupport.h"
#include "efgsupport.h"

//========================================================================
//                          General comments
//========================================================================

// This file implements some plotting classes.  These are in general
// specialized for Gambit's purposes, which is to plot strategy profiles
// generated by path-following algorithms.  Currently (and traditionally),
// this has been to plot quantal response equilibria; however, it could
// be profitably used to plot the progress of any path-following algorithm,
// including Yamamoto's algorithm.

// The implementation has two major influences:
// o PXI, by Eugene Grayver.  This was the plotting program Eugene wrote
//   for Richard McKelvey and Tom Palfrey to plot quantal response equilibria.
//   PXI was developed independently of Gambit, but was distributed
//   on the Gambit website.  Eugene has given permission for the Gambit
//   project to incorporate the PXI code into Gambit proper.  The
//   implementation here is in some ways significantly different than
//   the original PXI, but many features have been kept.
//
// o The wxPlotWindow class from wxWindows.  Unfortunately, wxPlotWindow
//   is not at this writing particularly useful for making the types of
//   plots that Gambit requires.  However, this implementation has been
//   modeled, at least in terms of class structure, to be somewhat similar
//   to wxPlotWindow, with the idea that, should a suitable set of plotting
//   classes ever become part of wxWindows, Gambit would be in good position
//   to take advantage of them.  (Or, perhaps, someday a version of these
//   classes would become part of wxWindows; who knows?)

// At present, these classes are somewhat rudimentary.  There are several
// areas in which abstraction could be improved, and additional user
// interaction and customization could be added.  These should be important
// goals in the future development of this code.

//========================================================================
//                  Implementation of gbtCorBranchMixed
//========================================================================

//------------------------------------------------------------------------
//                     gbtCorBranchMixed: Lifecycle
//------------------------------------------------------------------------

gbtCorBranchMixed::gbtCorBranchMixed(void)
{ }

gbtCorBranchMixed::gbtCorBranchMixed(const gbtList<MixedSolution> &p_data)
  : m_data(p_data)
{
  m_shown = gbtArray<bool>(m_data[1].GetGame().ProfileLength());
  for (int i = 1; i <= m_shown.Length(); m_shown[i++] = true);
}

//------------------------------------------------------------------------
//                    gbtCorBranchMixed: Data access
//------------------------------------------------------------------------

int gbtCorBranchMixed::NumDimensions(void) const
{ return m_data[1].Profile()->Length(); }

int gbtCorBranchMixed::NumData(void) const
{ return m_data.Length(); }

double gbtCorBranchMixed::GetValue(int p_index, int p_dim) const
{ return (*m_data[p_index].Profile())[p_dim]; }

double gbtCorBranchMixed::GetParameter(int p_index) const
{ return m_data[p_index].QreLambda(); }

double gbtCorBranchMixed::GetMaxParameter(void) const
{ return m_data[m_data.Length()].QreLambda(); }

double gbtCorBranchMixed::GetMinParameter(void) const
{ return 0.0; }

gbtText gbtCorBranchMixed::GetLabel(int p_dim) const
{
  int index = 1;

  for (int pl = 1; pl <= m_data[1].GetGame().NumPlayers(); pl++) {
    gbtNfgPlayer player = m_data[1].GetGame().GetPlayer(pl);

    for (int st = 1; st <= player.NumStrategies(); st++) {
      if (index++ == p_dim) {
	return player.GetLabel() + ":" + player.GetStrategy(st).GetLabel();
      }
    }
  }
  return "";
}



//========================================================================
//                  Implementation of gbtCorBranchBehav
//========================================================================

//------------------------------------------------------------------------
//                     gbtCorBranchBehav: Lifecycle
//------------------------------------------------------------------------

gbtCorBranchBehav::gbtCorBranchBehav(void)
{ }

gbtCorBranchBehav::gbtCorBranchBehav(const gbtList<BehavSolution> &p_data)
  : m_data(p_data)
{
  m_shown = gbtArray<bool>(m_data[1].GetGame().ProfileLength());
  for (int i = 1; i <= m_shown.Length(); m_shown[i++] = true);
}

//------------------------------------------------------------------------
//                    gbtCorBranchBehav: Data access
//------------------------------------------------------------------------

int gbtCorBranchBehav::NumDimensions(void) const
{ return m_data[1].Profile()->Length(); }

int gbtCorBranchBehav::NumData(void) const
{ return m_data.Length(); }

double gbtCorBranchBehav::GetValue(int p_index, int p_dim) const
{ return (*m_data[p_index].Profile())[p_dim]; }

double gbtCorBranchBehav::GetParameter(int p_index) const
{ return m_data[p_index].QreLambda(); }

double gbtCorBranchBehav::GetMaxParameter(void) const
{ return m_data[m_data.Length()].QreLambda(); }

double gbtCorBranchBehav::GetMinParameter(void) const
{ return 0.0; }


//========================================================================
//                 Implementation of gbtCorPlotXAxis
//========================================================================

gbtCorPlotXAxis::gbtCorPlotXAxis(void)
  : m_numDivisions(10), m_minValue(0.0), m_maxValue(1.0),
    m_labelFont(10, wxSWISS, wxNORMAL, wxBOLD), m_labelColor(*wxBLUE)
{ }

//========================================================================
//                 Implementation of gbtCorPlotYAxis
//========================================================================

gbtCorPlotYAxis::gbtCorPlotYAxis(void)
  : m_numDivisions(10), m_minValue(0.0), m_maxValue(1.0),
    m_labelFont(10, wxSWISS, wxNORMAL, wxBOLD), m_labelColor(*wxBLUE)
{ }

//========================================================================
//                 Implementation of gbtCorPlotWindow
//========================================================================

BEGIN_EVENT_TABLE(gbtCorPlotWindow, wxScrolledWindow)
  EVT_PAINT(gbtCorPlotWindow::OnPaint)
END_EVENT_TABLE()

//------------------------------------------------------------------------
//                   gbtCorPlotWindow: Lifecycle
//------------------------------------------------------------------------

gbtCorPlotWindow::gbtCorPlotWindow(wxWindow *p_parent, 
				   const wxPoint &p_position,
				   const wxSize &p_size)
  : wxScrolledWindow(p_parent, -1, p_position, p_size),
    m_marginX(50), m_marginY(65)
{
  SetSizeHints(400, 300);
}

gbtCorPlotWindow::~gbtCorPlotWindow()
{ }

//------------------------------------------------------------------------
//                  gbtCorPlotWindow: Conversions
//------------------------------------------------------------------------

void gbtCorPlotWindow::DataToXY(double p_param, double p_value, 
				int &p_x, int &p_y) const
{
  int width, height;
  GetClientSize(&width, &height);
  height -= 2 * m_marginY;
  width -= 2 * m_marginX;
  p_y = (int) (m_marginY + (1.0 - p_value) * height);
  
  // This computes the location of p_param in terms of grid ticks
  double step = pow(m_xAxis.MaxValue() - m_xAxis.MinValue(),
		    1.0 / (double) m_xAxis.NumDivisions());
  double tickX = log(p_param - m_xAxis.MinValue() + 1.0) / log(step);
  p_x = (int) (m_marginX + tickX / (double) m_xAxis.NumDivisions() * width); 
}

//------------------------------------------------------------------------
//                    gbtCorPlotWindow: Drawing
//------------------------------------------------------------------------

void gbtCorPlotWindow::DrawXAxis(wxDC &p_dc)
{
  int width, height;
  GetClientSize(&width, &height);
  p_dc.DrawLine(m_marginX, height - m_marginY,
		width - m_marginX, height - m_marginY);
  int plotWidth = width - 2 * m_marginX;
  const int c_tickWidth = 5;
  double step = pow(m_xAxis.MaxValue() - m_xAxis.MinValue(),
		    1.0 / (double) m_xAxis.NumDivisions());
  double cumstep = step;

  p_dc.SetFont(m_xAxis.GetLabelFont());
  p_dc.SetTextForeground(m_xAxis.GetLabelColor());

  for (int i = 1; i <= m_xAxis.NumDivisions(); i++) {
    int xCoord = m_marginX + i * (plotWidth / m_xAxis.NumDivisions());
    p_dc.DrawLine(xCoord, height - m_marginY - c_tickWidth,
		  xCoord, height - m_marginY + c_tickWidth);
    double value = m_cor->GetMinParameter() + cumstep - 1.0;
    wxString label = wxString::Format((value < 10000.0) ? 
				      wxT("%6.2f") : wxT("%6.2e"), 
				      value);
    wxCoord textWidth, textHeight;
    p_dc.GetTextExtent(label, &textWidth, &textHeight);
    p_dc.DrawRotatedText(label,
			 xCoord - textHeight / 2,
			 height - m_marginY + 2 * c_tickWidth + textWidth, 90);
    cumstep *= step;
  }
}

void gbtCorPlotWindow::DrawYAxis(wxDC &p_dc)
{
  int width, height;
  GetClientSize(&width, &height);
  p_dc.DrawLine(m_marginX, m_marginY, m_marginX, height - m_marginY);
  int plotHeight = height - 2 * m_marginY;
  const int c_tickWidth = 5;

  p_dc.SetFont(m_xAxis.GetLabelFont());
  p_dc.SetTextForeground(m_xAxis.GetLabelColor());

  for (int i = 0; i <= m_yAxis.NumDivisions(); i++) {
    int yCoord = height - m_marginY - i * (plotHeight/m_yAxis.NumDivisions());
    p_dc.DrawLine(m_marginX - c_tickWidth, yCoord, 
		  m_marginX + c_tickWidth, yCoord);
    wxString label = wxString::Format(wxT("%3.2f"), 
				      (double) i /
				      (double) m_yAxis.NumDivisions());
    wxCoord textWidth, textHeight;
    p_dc.GetTextExtent(label, &textWidth, &textHeight);
    p_dc.DrawText(label, m_marginX - 2 * c_tickWidth - textWidth, 
		  yCoord - textHeight / 2);
  }
}

void gbtCorPlotWindow::DrawDimension(wxDC &p_dc, int p_dim)
{
  int lastX = -1, lastY = -1;
  for (int i = 1; i <= m_cor->NumData(); i++) {
    int x, y;
    DataToXY(m_cor->GetParameter(i), m_cor->GetValue(i, p_dim), x, y);
    if (lastX >= 0) {
      p_dc.DrawLine(lastX, lastY, x, y);
    }
    lastX = x;
    lastY = y;
  }
}

void gbtCorPlotWindow::DrawLegend(wxDC &p_dc)
{
  int width, height;
  GetClientSize(&width, &height);

  int shown = 1;

  for (int dim = 1; dim <= m_cor->NumDimensions(); dim++) {
    if (m_cor->IsDimensionShown(dim)) {
      static wxPen *pens[] = { wxRED_PEN, wxGREEN_PEN, wxCYAN_PEN,
			       wxLIGHT_GREY_PEN, wxBLACK_PEN };
      p_dc.SetPen(*pens[(dim - 1) % 5]);

      p_dc.SetFont(wxFont(10, wxSWISS, wxNORMAL, wxBOLD));
      p_dc.SetTextForeground(*wxBLUE);
      wxCoord tw,th;
      p_dc.GetTextExtent(wxString::Format(wxT("%s"),
					  (char *) m_cor->GetLabel(dim)), &tw, &th);
      p_dc.DrawLine(width - m_marginX - 50, 3*th*shown/2+th/2,
		    width - m_marginX - 40, 3*th*shown/2+th/2);
      p_dc.DrawText(wxString::Format(wxT("%s"),
				     (char *) m_cor->GetLabel(dim)), 
		    width - m_marginX - 35, 3*th*shown/2);
      shown++;
    }
  }
}

void gbtCorPlotWindow::OnPaint(wxPaintEvent &)
{
  wxPaintDC dc(this);
  OnDraw(dc);
}

void gbtCorPlotWindow::OnDraw(wxDC &p_dc)
{
  p_dc.SetBackground(*wxWHITE_BRUSH);
  p_dc.Clear();
  DrawXAxis(p_dc);
  DrawYAxis(p_dc);
  DrawLegend(p_dc);

  for (int dim = 1; dim <= m_cor->NumDimensions(); dim++) {
    if (m_cor->IsDimensionShown(dim)) {
      static wxPen *pens[] = { wxRED_PEN, wxGREEN_PEN, wxCYAN_PEN,
			       wxLIGHT_GREY_PEN, wxBLACK_PEN };
      p_dc.SetPen(*pens[(dim - 1) % 5]);
      DrawDimension(p_dc, dim);
    }
  }
}

//------------------------------------------------------------------------
//                   gbtCorPlotWindow: Accessors
//------------------------------------------------------------------------

void gbtCorPlotWindow::SetCorrespondence(gbtCorBranch *p_cor)
{ 
  m_cor = p_cor; 
  m_xAxis.SetMaxValue(m_cor->GetMaxParameter());
}

gbtCorBranch *gbtCorPlotWindow::GetCorrespondence(void) const
{ return m_cor; }


//========================================================================
//                 Implementation of gbtCorPlotFrame
//========================================================================

BEGIN_EVENT_TABLE(gbtCorPlotFrame, wxFrame)
  EVT_MENU(wxID_CLOSE, gbtCorPlotFrame::Close)
  EVT_MENU(GBT_MENU_FILE_EXPORT_BMP, gbtCorPlotFrame::OnFileExportBMP)
  EVT_MENU(GBT_MENU_FILE_EXPORT_JPEG, gbtCorPlotFrame::OnFileExportJPEG)
  EVT_MENU(GBT_MENU_FILE_EXPORT_PNG, gbtCorPlotFrame::OnFileExportPNG)
  EVT_MENU(GBT_MENU_FILE_EXPORT_POSTSCRIPT, gbtCorPlotFrame::OnFileExportPS)
  EVT_MENU(GBT_MENU_QRE_EDIT_SUPPORT, gbtCorPlotFrame::OnEditSupport)
END_EVENT_TABLE()

gbtCorPlotFrame::gbtCorPlotFrame(wxWindow *p_parent,
				 const wxPoint &p_position,
				 const wxSize &p_size)
  : wxFrame(p_parent, -1, _("QRE Correspondence Plot"), p_position, p_size)
{
  SetAutoLayout(true);

  m_plot = new gbtCorPlotWindow(this, wxDefaultPosition, p_size);

  wxBoxSizer *topSizer = new wxBoxSizer(wxHORIZONTAL);
  topSizer->Add(m_plot, 1, wxEXPAND, 0);

  wxMenu *fileMenu = new wxMenu;
  wxMenu *fileExportMenu = new wxMenu;
  fileExportMenu->Append(GBT_MENU_FILE_EXPORT_BMP, wxT("&BMP"),
			 _("Save a rendering of the plot as a Windows bitmap"));
  fileExportMenu->Append(GBT_MENU_FILE_EXPORT_JPEG, wxT("&JPEG"),
			 _("Save a rendering of the plot as a JPEG image"));
  fileExportMenu->Append(GBT_MENU_FILE_EXPORT_PNG, wxT("&PNG"),
			 _("Save a rendering of the plot as a PNG image"));
  fileExportMenu->Append(GBT_MENU_FILE_EXPORT_POSTSCRIPT, wxT("Post&Script"),
			 _("Save a printout of the plot in PostScript format"));
  fileExportMenu->Enable(GBT_MENU_FILE_EXPORT_POSTSCRIPT, wxUSE_POSTSCRIPT);
  fileMenu->Append(GBT_MENU_FILE_EXPORT, _("&Export"), fileExportMenu,
		   _("Export the game in various formats"));
  fileMenu->Append(wxID_CLOSE, _("&Close"), _("Close this window"));

  wxMenu *editMenu = new wxMenu;
  editMenu->Append(GBT_MENU_QRE_EDIT_SUPPORT, _("Support"),
		   _("Change the support of strategies shown"));

  wxMenuBar *menuBar = new wxMenuBar;
  menuBar->Append(fileMenu, _("&File"));
  menuBar->Append(editMenu, _("&Edit"));
  SetMenuBar(menuBar);
  
  SetSizer(topSizer);
  topSizer->Fit(this);
  topSizer->SetSizeHints(this);
  Layout();
  Show(true);
}

void gbtCorPlotFrame::OnFileExportBMP(wxCommandEvent &)
{
  wxFileDialog dialog(this, _("Choose output file"),
		      wxGetApp().CurrentDir(), wxT(""),
		      _("Windows bitmap files (*.bmp)|*.bmp"), wxSAVE);

  if (dialog.ShowModal() == wxID_OK) {
    wxMemoryDC dc;
    wxBitmap bitmap(m_plot->GetSize().GetWidth(),
		    m_plot->GetSize().GetHeight());
    dc.SelectObject(bitmap);
    m_plot->OnDraw(dc);
    if (!bitmap.SaveFile(dialog.GetPath(), wxBITMAP_TYPE_BMP)) {
      wxMessageBox(wxString::Format(_("An error occurred in writing '%s'."),
				    (const char *) dialog.GetPath().mb_str()),
		   _("Error"), wxOK, this);
    }
  }
}

void gbtCorPlotFrame::OnFileExportJPEG(wxCommandEvent &)
{
  wxFileDialog dialog(this, _("Choose output file"),
		      wxGetApp().CurrentDir(), wxT(""),
		      _("JPEG files (*.jpeg)|*.jpeg|JPEG files (*.jpg)|*.jpg"),
		      wxSAVE);

  if (dialog.ShowModal() == wxID_OK) {
    wxMemoryDC dc;
    wxBitmap bitmap(m_plot->GetSize().GetWidth(),
		    m_plot->GetSize().GetHeight());
    dc.SelectObject(bitmap);
    m_plot->OnDraw(dc);
    if (!bitmap.SaveFile(dialog.GetPath(), wxBITMAP_TYPE_JPEG)) {
      wxMessageBox(wxString::Format(_("An error occurred in writing '%s'."),
				    (const char *) dialog.GetPath().mb_str()),
		   _("Error"), wxOK, this);
    }
  }
}

void gbtCorPlotFrame::OnFileExportPNG(wxCommandEvent &)
{
  wxFileDialog dialog(this, _("Choose output file"),
		      wxGetApp().CurrentDir(), wxT(""),
		      _("PNG files (*.png)|*.png"), wxSAVE);

  if (dialog.ShowModal() == wxID_OK) {
    wxMemoryDC dc;
    wxBitmap bitmap(m_plot->GetSize().GetWidth(),
		    m_plot->GetSize().GetHeight());
    dc.SelectObject(bitmap);
    m_plot->OnDraw(dc);
    if (!bitmap.SaveFile(dialog.GetPath(), wxBITMAP_TYPE_PNG)) {
      wxMessageBox(wxString::Format(_("An error occurred in writing '%s'."),
				    (const char *) dialog.GetPath().mb_str()),
		   _("Error"), wxOK, this);
    }
  }
}

void gbtCorPlotFrame::OnFileExportPS(wxCommandEvent &)
{
#if wxUSE_POSTSCRIPT
  wxPrintData printData;

  wxFileDialog dialog(this, _("Choose output file"),
		      wxGetApp().CurrentDir(), wxT(""),
		      _("PostScript files (*.ps)|*.ps"), wxSAVE);

  if (dialog.ShowModal() == wxID_OK) {
    printData.SetFilename(dialog.GetPath());
  }
  else {
    return;
  }
  printData.SetPrintMode(wxPRINT_MODE_FILE);

  wxPostScriptDC dc(printData);
  dc.StartDoc(_("Quantal response correspondence"));
  dc.SetBackgroundMode(wxTRANSPARENT);
  dc.StartPage();

  // The actual size of the plot, in pixels
  int maxX = m_plot->GetSize().GetWidth();
  int maxY = m_plot->GetSize().GetHeight();

  // Margins
  int marginX = 50;
  int marginY = 50;

  maxX += 2 * marginX;
  maxY += 2 * marginY;

  // Get the size of the DC in pixels
  wxCoord w, h;
  dc.GetSize(&w, &h);

  // Calculate a scaling factor
  float scaleX = (float) w / (float) maxX;
  float scaleY = (float) h / (float) maxY;

  float actualScale = (scaleX < scaleY) ? scaleX : scaleY;

  // Calculate the position on the DC to center the plot
  float posX = (float) ((w - (m_plot->GetSize().GetWidth() * actualScale)) / 2.0);
  float posY = (float) ((h - (m_plot->GetSize().GetHeight() * actualScale)) / 2.0);

  // Set the scale and origin
  dc.SetUserScale(actualScale, actualScale);
  dc.SetDeviceOrigin((long) posX, (long) posY);

  // Draw!
  m_plot->OnDraw(dc);
  dc.EndPage();
  dc.EndDoc();
#endif  // wxUSE_POSTSCRIPT
}

//========================================================================
//              Implementation of gbtNfgCorPlotSupportDialog
//========================================================================

const int GBT_NFG_STRATEGY_WIDGET = 8000;

class gbtNfgCorPlotSupportDialog : public wxDialog {
private:
  gbtNfgSupport m_support;
  gbtNfgSupportWidget *m_supportWidget;

  // Event handlers
  void ToggleStrategy(wxTreeItemId);
  void OnTreeKeypress(wxTreeEvent &);
  void OnTreeItemActivated(wxTreeEvent &);

public:
  gbtNfgCorPlotSupportDialog(wxWindow *p_parent,
			     const gbtNfgSupport &p_support);


  // Only valid if ShowModal() returns wxID_OK
  const gbtNfgSupport &GetSupport(void) const { return m_support; }

  DECLARE_EVENT_TABLE()
};

BEGIN_EVENT_TABLE(gbtNfgCorPlotSupportDialog, wxDialog)
  EVT_TREE_KEY_DOWN(GBT_NFG_STRATEGY_WIDGET,
		    gbtNfgCorPlotSupportDialog::OnTreeKeypress)
  EVT_TREE_ITEM_ACTIVATED(GBT_NFG_STRATEGY_WIDGET,
			  gbtNfgCorPlotSupportDialog::OnTreeItemActivated)
END_EVENT_TABLE()

gbtNfgCorPlotSupportDialog::gbtNfgCorPlotSupportDialog(wxWindow *p_parent,
						       const gbtNfgSupport &p_support)
  : wxDialog(p_parent, -1, "Choose displayed support", wxDefaultPosition),
    m_support(p_support)
{
  SetAutoLayout(true);

  m_supportWidget = new gbtNfgSupportWidget(this, GBT_NFG_STRATEGY_WIDGET);
  m_supportWidget->SetSize(300, 300);
  m_supportWidget->SetSupport(p_support);

  wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
  topSizer->Add(m_supportWidget, 1, wxEXPAND, 0);
  
  wxBoxSizer *buttonSizer = new wxBoxSizer(wxHORIZONTAL);
  wxButton *okButton = new wxButton(this, wxID_OK, _("OK"));
  okButton->SetDefault();
  buttonSizer->Add(okButton, 0, wxALL, 5);
  buttonSizer->Add(new wxButton(this, wxID_CANCEL, _("Cancel")), 0, wxALL, 5);
  topSizer->Add(buttonSizer, 0, wxALL | wxCENTER, 5);

  SetSizer(topSizer);
  topSizer->Fit(this);
  topSizer->SetSizeHints(this);
  Layout();
  CenterOnParent();
}

void gbtNfgCorPlotSupportDialog::ToggleStrategy(wxTreeItemId p_id)
{
  gbtNfgAction strategy = m_supportWidget->GetStrategy(p_id);
  if (strategy.IsNull()) {
    return;
  }

  if (m_support.Contains(strategy)) {
    m_support.RemoveStrategy(strategy);
  }
  else {
    m_support.AddStrategy(strategy);
  }
  m_supportWidget->SetSupport(m_support);
}

void gbtNfgCorPlotSupportDialog::OnTreeKeypress(wxTreeEvent &p_event)
{
  if (p_event.GetKeyCode() == WXK_SPACE) {
    ToggleStrategy(m_supportWidget->GetSelection());
  }
}

void gbtNfgCorPlotSupportDialog::OnTreeItemActivated(wxTreeEvent &p_event)
{
  ToggleStrategy(p_event.GetItem());
}


//========================================================================
//                Implementation of gbtNfgCorPlotFrame
//========================================================================

gbtNfgCorPlotFrame::gbtNfgCorPlotFrame(const gbtNfgSupport &p_support,
				       wxWindow *p_parent,
				       const wxPoint &p_position,
				       const wxSize &p_size)
  : gbtCorPlotFrame(p_parent, p_position, p_size),
    m_support(p_support)
{ }


void gbtNfgCorPlotFrame::OnEditSupport(wxCommandEvent &)
{
  gbtNfgCorPlotSupportDialog dialog(this, m_support);

  if (dialog.ShowModal() == wxID_OK) {
    m_support = dialog.GetSupport();

    int index = 1;

    for (int pl = 1; pl <= m_support.GetGame().NumPlayers(); pl++) {
      gbtNfgPlayer player = m_support.GetGame().GetPlayer(pl);

      for (int st = 1; st <= player.NumStrategies(); st++) {
	GetCorrespondence()->ShowDimension(index++, 
					   m_support.Contains(player.GetStrategy(st)));
      }
    }

    m_plot->Refresh();
  }
}

//========================================================================
//              Implementation of gbtEfgCorPlotSupportDialog
//========================================================================

const int GBT_EFG_STRATEGY_WIDGET = 8000;

class gbtEfgCorPlotSupportDialog : public wxDialog {
private:
  gbtEfgSupport m_support;
  gbtEfgSupportWidget *m_supportWidget;

  // Event handlers
  void ToggleStrategy(wxTreeItemId);
  void OnTreeKeypress(wxTreeEvent &);
  void OnTreeItemActivated(wxTreeEvent &);

public:
  gbtEfgCorPlotSupportDialog(wxWindow *p_parent,
			     const gbtEfgSupport &p_support);


  // Only valid if ShowModal() returns wxID_OK
  const gbtEfgSupport &GetSupport(void) const { return m_support; }

  DECLARE_EVENT_TABLE()
};

BEGIN_EVENT_TABLE(gbtEfgCorPlotSupportDialog, wxDialog)
  EVT_TREE_KEY_DOWN(GBT_EFG_STRATEGY_WIDGET,
		    gbtEfgCorPlotSupportDialog::OnTreeKeypress)
  EVT_TREE_ITEM_ACTIVATED(GBT_EFG_STRATEGY_WIDGET,
			  gbtEfgCorPlotSupportDialog::OnTreeItemActivated)
END_EVENT_TABLE()

gbtEfgCorPlotSupportDialog::gbtEfgCorPlotSupportDialog(wxWindow *p_parent,
						       const gbtEfgSupport &p_support)
  : wxDialog(p_parent, -1, "Choose displayed support", wxDefaultPosition),
    m_support(p_support)
{
  SetAutoLayout(true);

  m_supportWidget = new gbtEfgSupportWidget(this, GBT_EFG_STRATEGY_WIDGET);
  m_supportWidget->SetSize(300, 300);
  m_supportWidget->SetSupport(p_support);

  wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
  topSizer->Add(m_supportWidget, 1, wxEXPAND, 0);
  
  wxBoxSizer *buttonSizer = new wxBoxSizer(wxHORIZONTAL);
  wxButton *okButton = new wxButton(this, wxID_OK, _("OK"));
  okButton->SetDefault();
  buttonSizer->Add(okButton, 0, wxALL, 5);
  buttonSizer->Add(new wxButton(this, wxID_CANCEL, _("Cancel")), 0, wxALL, 5);
  topSizer->Add(buttonSizer, 0, wxALL | wxCENTER, 5);

  SetSizer(topSizer);
  topSizer->Fit(this);
  topSizer->SetSizeHints(this);
  Layout();
  CenterOnParent();
}

void gbtEfgCorPlotSupportDialog::ToggleStrategy(wxTreeItemId p_id)
{
  gbtEfgAction action = m_supportWidget->GetAction(p_id);
  if (action.IsNull()) {
    return;
  }

  if (m_support.Contains(action)) {
    m_support.RemoveAction(action);
  }
  else {
    m_support.AddAction(action);
  }
  m_supportWidget->SetSupport(m_support);
}

void gbtEfgCorPlotSupportDialog::OnTreeKeypress(wxTreeEvent &p_event)
{
  if (p_event.GetKeyCode() == WXK_SPACE) {
    ToggleStrategy(m_supportWidget->GetSelection());
  }
}

void gbtEfgCorPlotSupportDialog::OnTreeItemActivated(wxTreeEvent &p_event)
{
  ToggleStrategy(p_event.GetItem());
}


//========================================================================
//                Implementation of gbtEfgCorPlotFrame
//========================================================================

gbtEfgCorPlotFrame::gbtEfgCorPlotFrame(const gbtEfgSupport &p_support,
				       wxWindow *p_parent,
				       const wxPoint &p_position,
				       const wxSize &p_size)
  : gbtCorPlotFrame(p_parent, p_position, p_size),
    m_support(p_support)
{ }


void gbtEfgCorPlotFrame::OnEditSupport(wxCommandEvent &)
{
  gbtEfgCorPlotSupportDialog dialog(this, m_support);

  if (dialog.ShowModal() == wxID_OK) {
    m_support = dialog.GetSupport();

    int index = 1;

    for (int pl = 1; pl <= m_support.NumPlayers(); pl++) {
      gbtEfgPlayer player = m_support.GetPlayer(pl);

      for (int iset = 1; iset <= player->NumInfosets(); iset++) {
	gbtEfgInfoset infoset = player->GetInfoset(iset);

	for (int act = 1; act <= infoset.NumActions(); act++) {
	  GetCorrespondence()->ShowDimension(index++, 
					     m_support.Contains(infoset.GetAction(act)));
	}
      }
    }

    m_plot->Refresh();
  }
}
