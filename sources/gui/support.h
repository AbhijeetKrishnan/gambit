//
// $Source$
// $Revision$
// $Date$
//
// DESCRIPTION:
// Declaration of support handling types
//
// This file is part of Gambit
// Copyright (c) 2003, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#ifndef SUPPORT_H
#define SUPPORT_H

//
// Support lists (for both extensive and normal forms) owe their origins to
// the refactoring of the code to manage the lists of computed supports.
// Generally, these are generated by dominance elimination, though the
// graphical interface permits custom support construction as well.
//
// The list classes themselves combine the following features:
//   o Storage of supports
//   o Iterators (i.e., a notion of "current support")
//   o Automatic creation of the full support (support list is never empty)
//
// The classses are designed to be abstract enough that they can be
// subclassed to support, for example, generation of supports dynamically
// on demand by appropriate dominance elimination code.
//

class gbtGameDocument;

class gbtEfgSupportList {
private:
  gbtGameDocument *m_doc;
  gbtList<gbtEfgSupport> m_supports;
  int m_current;

  void BuildDefaultSupport(void);

public:
  gbtEfgSupportList(gbtGameDocument *p_doc);
  ~gbtEfgSupportList();

  // General data access
  int Length(void) const { return m_supports.Length(); }
  const gbtEfgSupport &Get(int p_index) const { return m_supports[p_index]; }
  
  // Getting and setting the currently pointed-to support
  const gbtEfgSupport &GetCurrent(void) const { return m_supports[m_current]; }
  gbtEfgSupport &GetCurrent(void) { return m_supports[m_current]; }

  int GetCurrentIndex(void) const { return m_current; }
  void SetCurrentIndex(int p_index) { m_current = p_index; }

  // Adding and removing supports
  void Append(const gbtEfgSupport &);
  void Remove(void);
  void Flush(void);

  // Utilities
  gbtText GenerateUniqueLabel(void) const;
};

class gbtNfgSupportList {
private:
  gbtGameDocument *m_doc;
  gbtList<gbtNfgSupport> m_supports;
  int m_current;

  void BuildDefaultSupport(void);

public:
  gbtNfgSupportList(gbtGameDocument *p_doc);
  ~gbtNfgSupportList();

  // General data access
  int Length(void) const { return m_supports.Length(); }
  const gbtNfgSupport &Get(int p_index) const { return m_supports[p_index]; }
  
  // Getting and setting the currently pointed-to support
  const gbtNfgSupport &GetCurrent(void) const { return m_supports[m_current]; }
  gbtNfgSupport &GetCurrent(void) { return m_supports[m_current]; }

  int GetCurrentIndex(void) const { return m_current; }
  void SetCurrentIndex(int p_index) { m_current = p_index; }

  // Adding and removing supports
  void Append(const gbtNfgSupport &);
  void Remove(void);
  void Flush(void);

  // Utilities
  gbtText GenerateUniqueLabel(void) const;
};


#endif  // SUPPORT_H
