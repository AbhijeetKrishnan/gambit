//
// FILE: efgciter.imp -- Implementation of efg contingency iterator
//
// $Id$
//

#include "efgciter.h"

template <class T> EfgContIter<T>::EfgContIter(const EFSupport &s)
  : _frozen_pl(0), _frozen_iset(0),
    _efg((Efg<T> *) &s.BelongsTo()), _support(s),
    _efgidx(_efg->PureDimensionality()), _supidx(_efgidx),
    _payoff(_efg->NumPlayers())
{
  First();
}

template <class T> EfgContIter<T>::~EfgContIter()
{ }


template <class T> void EfgContIter<T>::First(void)
{
  for (int pl = 1; pl <= _efg->NumPlayers(); pl++)  {
    for (int iset = 1; iset <= _efg->PlayerList()[pl]->NumInfosets(); iset++)
      if (pl != _frozen_pl && iset != _frozen_iset)   {
	_supidx(pl, iset) = 1;
	_efgidx(pl, iset) = _support.ActionList(pl, iset)[1]->GetNumber();
      }
  }
}

template <class T> void EfgContIter<T>::Set(int pl, int iset, int act)
{
  if (pl != _frozen_pl || iset != _frozen_iset)   return;

  _supidx(pl, iset) = act;
  _efgidx(pl, iset) = _support.ActionList(pl, iset)[act]->GetNumber();
}

template <class T> int EfgContIter<T>::Next(int pl, int iset)
{
  if (pl != _frozen_pl || iset != _frozen_iset)   return 1;

  const gArray<Action *> &actions = _support.ActionList(pl, iset);
  
  if (_supidx(pl, iset) == actions.Length())   {
    _supidx(pl, iset) = 1;
    _efgidx(pl, iset) = actions[1]->GetNumber();
    return 0;
  }

  _supidx(pl, iset)++;
  _efgidx(pl, iset) = actions[_supidx(pl, iset)]->GetNumber();
  return 1;
}
  

template <class T> void EfgContIter<T>::Freeze(int pl, int iset)
{
  _frozen_pl = pl;
  _frozen_iset = iset;
  First();
}

template <class T> int EfgContIter<T>::NextContingency(void)
{
  int pl = _efg->NumPlayers();
  int iset = _efg->PlayerList()[pl]->NumInfosets();
    
  while (true)   {
    if (pl == _frozen_pl && iset == _frozen_iset)  {
      if (iset == 0)  {
	if (--pl == 0)   return 0;
	iset = _efg->PlayerList()[pl]->NumInfosets();
      }
      else
	iset--;
    }

    if (_supidx(pl, iset) < _support.NumActions(pl, iset))  {
      _supidx(pl, iset) += 1;
      _efgidx(pl, iset) = _support.ActionList(pl, iset)[_supidx(pl, iset)]->GetNumber();
      return 1;
    }

    _supidx(pl, iset) = 1;
    _efgidx(pl, iset) = _support.ActionList(pl, iset)[1]->GetNumber();

    iset--;
    if (iset == 0)  {
      if (--pl == 0)   return 0;
      iset = _efg->PlayerList()[pl]->NumInfosets();
    }
  }

  return 0;
}

template <class T> const T &EfgContIter<T>::Payoff(int pl) const
{
  _efg->Payoff(_efgidx, (gVector<T> &) _payoff);
  return _payoff[pl];
}

template <class T> void EfgContIter<T>::Dump(void) const
{
  _efgidx.Dump(gout);
}


