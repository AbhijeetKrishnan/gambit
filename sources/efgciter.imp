//
// FILE: efgciter.imp -- Implementation of efg contingency iterator
//
// $Id$
//

#include "efgciter.h"

template <class T> EfgContIter<T>::EfgContIter(const EFSupport &s)
  : _frozen_pl(0), _frozen_iset(0),
    _efg(&s.Game()), _support(s),
    _profile(s.Game()), _current(s.Game().NumInfosets()),
    _payoff(_efg->NumPlayers())
{
  First();
}

template <class T> EfgContIter<T>::~EfgContIter()
{ }


template <class T> void EfgContIter<T>::First(void)
{
  for (int pl = 1; pl <= _efg->NumPlayers(); pl++)  {
    for (int iset = 1; iset <= _efg->Players()[pl]->NumInfosets(); iset++)
      if (pl != _frozen_pl && iset != _frozen_iset)   {
	      _current(pl, iset) = 1;
      	_profile.Set(_support.Actions(pl, iset)[1]);
      }
  }
}

template <class T> void EfgContIter<T>::Set(int pl, int iset, int act)
{
  if (pl != _frozen_pl || iset != _frozen_iset)   return;

  _current(pl, iset) = act;
  _profile.Set(_support.Actions(pl, iset)[act]);
}

template <class T> int EfgContIter<T>::Next(int pl, int iset)
{
  if (pl != _frozen_pl || iset != _frozen_iset)   return 1;

  const gArray<Action *> &actions = _support.Actions(pl, iset);
  
  if (_current(pl, iset) == actions.Length())   {
    _current(pl, iset) = 1;
    _profile.Set(actions[1]);
    return 0;
  }

  _current(pl, iset)++;
  _profile.Set(actions[_current(pl, iset)]);
  return 1;
}
  

template <class T> void EfgContIter<T>::Freeze(int pl, int iset)
{
  _frozen_pl = pl;
  _frozen_iset = iset;
  First();
}

template <class T> int EfgContIter<T>::NextContingency(void)
{
  int pl = _efg->NumPlayers();


  while (pl > 0 && _efg->Players()[pl]->NumInfosets() == 0)
    --pl;

  if (pl == 0)   return 0;

  int iset = _efg->Players()[pl]->NumInfosets();
    
  while (true)   {
    if (pl == _frozen_pl && iset == _frozen_iset)  {
      if (iset == 1)  {
	do  {
	  --pl;
	}  while (pl > 0 && _efg->Players()[pl]->NumInfosets() == 0);

	if (pl == 0)   return 0;
	iset = _efg->Players()[pl]->NumInfosets();
      }
      else
	iset--;
    }

    if (_current(pl, iset) < _support.NumActions(pl, iset))  {
      _current(pl, iset) += 1;
      _profile.Set(_support.Actions(pl, iset)[_current(pl, iset)]);
      return 1;
    }

    _current(pl, iset) = 1;
    _profile.Set(_support.Actions(pl, iset)[1]);

    iset--;
    if (iset == 0)  {
      do  {
	--pl;
      }  while (pl > 0 && _efg->Players()[pl]->NumInfosets() == 0);

      if (pl == 0)   return 0;
      iset = _efg->Players()[pl]->NumInfosets();
    }
  }

  return 0;
}

template <class T> T EfgContIter<T>::Payoff(int pl) const
{
  _profile.Payoff(_payoff);
  return _payoff[pl];
}

template <class T> void EfgContIter<T>::Dump(gOutput &f) const
{
  _current.Dump(f);
}


