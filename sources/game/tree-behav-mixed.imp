//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of behavior profile class
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include "math/gvector.h"
#include "game.h"

#include "tree-game.h"
#include "tree-behav-mixed.h"
#include "tree-strategy-mixed.h"
#include "table-game.h"

//======================================================================
//         Implementation of class gbtTreeBehavProfileRep<T>
//======================================================================

//----------------------------------------------------------------------
//    class gbtTreeBehavProfileRep<T>: Constructor and destructor
//----------------------------------------------------------------------

template <class T> gbtTreeBehavProfileRep<T>::gbtTreeBehavProfileRep(const gbtTreeGameRep *p_game) 
  : m_refCount(0), 
    m_efg(const_cast<gbtTreeGameRep *>(p_game)),
    m_profile(p_game->NumActions()), m_cachedData(false),
    m_realizProbs(m_efg->NumNodes()),
    m_beliefs(m_efg->NumNodes()),
    m_nvals(m_efg->NumNodes()),
    m_bvals(m_efg->NumNodes()),
    m_nodeValues(m_efg->NumNodes(), m_efg->NumPlayers()),
    m_infosetValues(m_efg->NumInfosets()),
    m_actionValues(m_efg->NumActions())
{
  SetCentroid();
}


template <class T>
gbtTreeBehavProfileRep<T>::gbtTreeBehavProfileRep(const gbtTreeBehavProfileRep<T> &p_profile)
  : m_refCount(0), m_efg(p_profile.m_efg), m_profile(p_profile.m_profile),
    m_cachedData(false),
    m_realizProbs(p_profile.m_realizProbs), m_beliefs(p_profile.m_beliefs),
    m_nvals(p_profile.m_nvals), m_bvals(p_profile.m_bvals),
    m_nodeValues(p_profile.m_nodeValues),
    m_infosetValues(p_profile.m_infosetValues),
    m_actionValues(p_profile.m_actionValues)
{ }

template <class T>
gbtTreeBehavProfileRep<T>::gbtTreeBehavProfileRep(const gbtTreeMixedProfileRep<T> *p_profile)
  : m_refCount(0), m_efg(p_profile->m_game),
    m_profile(m_efg->NumActions()),
    m_cachedData(false),
    m_realizProbs(m_efg->NumNodes()),
    m_beliefs(m_efg->NumNodes()),
    m_nvals(m_efg->NumNodes()),
    m_bvals(m_efg->NumNodes()),
    m_nodeValues(m_efg->NumNodes(), m_efg->NumPlayers()),
    m_infosetValues(m_efg->NumInfosets()),
    m_actionValues(m_efg->NumActions())
{
  m_profile = (T) 0;

  gbtTreeNodeRep *n = m_efg->m_root;

  for (int pl = 1; pl <= m_efg->NumPlayers(); pl++)   {
    m_nvals = (T) 0;
    m_bvals = (T) 0;

    gbtTreePlayerRep *player = m_efg->m_players[pl];
    for (int st = 1; st <= player->NumStrategies(); st++)  {
      if ((*p_profile)(pl, st) > (T) 0)  {
	const gbtArray<int> &actions = player->m_strategies[st]->m_behav;
	m_bvals[n->GetId()] = (*p_profile)(pl, st);

	RealizationProbs(*p_profile, pl, actions, m_efg->m_root);
      }
    }
 
    m_nvals[1] = (T) 1;   // set the root nval
    BehaviorStrat(pl, n);
  }
}

template <class T> gbtTreeBehavProfileRep<T>::~gbtTreeBehavProfileRep()
{ }

template <class T>
gbtBehavProfileRep<T> *gbtTreeBehavProfileRep<T>::Copy(void) const
{
  return new gbtTreeBehavProfileRep(*this);
}

//----------------------------------------------------------------------
//  class gbtTreeBehavProfileRep<T>: Mechanism for reference counting
//----------------------------------------------------------------------

template <class T> void gbtTreeBehavProfileRep<T>::Reference(void)
{
  m_refCount++;
  m_efg->m_refCount++;
}

template <class T> bool gbtTreeBehavProfileRep<T>::Dereference(void)
{
  if (--m_efg->m_refCount == 0) {
    // Note that if this condition is true, this profile must be the
    // last reference to the game, so m_refCount will also be one
    // (and this function will return true)
    delete m_efg;
  }
  return (--m_refCount == 0);
}

//----------------------------------------------------------------------
//      class gbtTreeBehavProfileRep<T>: General information
//----------------------------------------------------------------------

template <class T> gbtGame gbtTreeBehavProfileRep<T>::GetGame(void) const
{
  return const_cast<gbtTreeGameRep *>(m_efg);
}

template <class T>
bool gbtTreeBehavProfileRep<T>::operator==(const gbtBehavProfileRep<T> &p_profile) const
{
  const gbtTreeBehavProfileRep<T> *profile = 
    dynamic_cast<const gbtTreeBehavProfileRep<T> *>(&p_profile);
  if (!profile)  throw gbtGameMismatchException();

  return (m_efg == profile->m_efg && m_profile == profile->m_profile);
}

//----------------------------------------------------------------------
// class gbtTreeBehavProfileRep<T>: Accessing the profile probabilities
//----------------------------------------------------------------------

template <class T>
T gbtTreeBehavProfileRep<T>::GetActionProb(const gbtGameAction &p_action) const
{ 
  if (p_action.IsNull())  throw gbtGameNullException();
  gbtTreeActionRep *action = dynamic_cast<gbtTreeActionRep *>(p_action.Get());
  if (!action || action->m_infoset->m_player->m_efg != m_efg) {
    throw gbtGameMismatchException();
  }

  if (action->m_infoset->m_player->m_id == 0) {
    return action->GetChanceProb();
  }
  else {
    return m_profile(action->m_infoset->m_player->m_id,
		     action->m_infoset->m_id, action->m_id);
  }
}

template <class T>
void gbtTreeBehavProfileRep<T>::SetActionProb(const gbtGameAction &p_action,
					       const T &p_prob)
{
  if (p_action.IsNull())  throw gbtGameNullException();
  gbtTreeActionRep *action = dynamic_cast<gbtTreeActionRep *>(p_action.Get());
  if (!action || action->m_infoset->m_player->m_efg != m_efg) {
    throw gbtGameMismatchException();
  }

  if (action->m_infoset->m_player->m_id == 0) {
    throw gbtGameMismatchException();
  }
  else {
    m_profile(action->m_infoset->m_player->m_id,
	      action->m_infoset->m_id, action->m_id) = p_prob;
  }
  m_cachedData = false;
}

template <class T> void gbtTreeBehavProfileRep<T>::SetCentroid(void)
{
  for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) {
    for (int iset = 1; iset <= m_efg->GetPlayer(pl)->NumInfosets(); iset++) {
      T center = (T) 1 / (T) m_efg->GetPlayer(pl)->GetInfoset(iset)->NumActions();
      for (int act = 1; act <= m_efg->GetPlayer(pl)->GetInfoset(iset)->NumActions(); act++) {
	m_profile(pl, iset, act) = center;
      }
    }
  }
}

//----------------------------------------------------------------------
//       class gbtTreeBehavProfileRep<T>: Payoff information
//----------------------------------------------------------------------

//!
//! Recursive helper function for computing expected payoffs.
//!
template <class T>
void gbtTreeBehavProfileRep<T>::GetPayoff(gbtTreeNodeRep *p_node,
					  T prob, gbtTreePlayerRep *player, 
					  T &value) const
{
  gbtTreeInfosetRep *infoset = p_node->m_infoset;

  if (p_node->m_outcome) {
    value += prob * (T) p_node->m_outcome->m_payoffs[player->m_id];
  }

  if (p_node->m_children.Length() > 0) {
    for (int act = 1; act <= infoset->m_actions.Length(); act++) {
      if (infoset->m_player->m_id == 0) {
	GetPayoff(p_node->m_children[act],
		  prob * (T) infoset->m_chanceProbs[act],
		  player, value);
      }
      else {
	GetPayoff(p_node->m_children[act],
		  prob * m_profile(infoset->m_player->m_id, infoset->m_id, act),
		  player, value);
      }
    }
  }
}

template <class T> 
T gbtTreeBehavProfileRep<T>::GetPayoff(const gbtGamePlayer &p_player) const
{
  if (p_player.IsNull())  throw gbtGameNullException();
  gbtTreePlayerRep *player = dynamic_cast<gbtTreePlayerRep *>(p_player.Get());
  if (!player || player->m_efg != m_efg) throw gbtGameMismatchException();

  T value = (T) 0;
  GetPayoff(m_efg->m_root, (T) 1, player, value);
  return value;
}

template <class T>
T gbtTreeBehavProfileRep<T>::GetNodeValue(const gbtGameNode &p_node,
					  const gbtGamePlayer &p_player) const
{ 
  if (p_node.IsNull() || p_player.IsNull()) {
    throw gbtGameNullException();
  }
  gbtTreePlayerRep *player = dynamic_cast<gbtTreePlayerRep *>(p_player.Get());
  if (!player || player->m_efg != m_efg) throw gbtGameMismatchException();
  
  gbtTreeNodeRep *node = dynamic_cast<gbtTreeNodeRep *>(p_node.Get());
  if (!node || node->m_efg != m_efg) throw gbtGameMismatchException();

  ComputeSolutionData();
  return m_nodeValues(p_node->GetId(), p_player->GetId());
}

template <class T> T
gbtTreeBehavProfileRep<T>::GetInfosetValue(const gbtGameInfoset &p_infoset) const
{ 
  if (p_infoset.IsNull())  throw gbtGameNullException();
  gbtTreeInfosetRep *infoset = 
    dynamic_cast<gbtTreeInfosetRep *>(p_infoset.Get());
  if (!infoset || infoset->m_player->m_efg != m_efg || 
      infoset->m_player->m_id == 0) {
    throw gbtGameMismatchException();
  }

  ComputeSolutionData();
  return m_infosetValues(infoset->m_player->m_id, infoset->m_id);
}

template <class T>
T gbtTreeBehavProfileRep<T>::GetActionValue(const gbtGameAction &p_action) const
{ 
  if (p_action.IsNull())  throw gbtGameNullException();
  gbtTreeActionRep *action = dynamic_cast<gbtTreeActionRep *>(p_action.Get());
  if (!action || action->m_infoset->m_player->m_efg != m_efg ||
      action->m_infoset->m_player->m_id == 0) {
    throw gbtGameMismatchException();
  }

  ComputeSolutionData();
  return m_actionValues(action->m_infoset->m_player->m_id,
			action->m_infoset->m_id, action->m_id);
}

template <class T>
T gbtTreeBehavProfileRep<T>::DiffActionValue(const gbtGameAction &p_action,
				   const gbtGameAction &p_oppAction) const
{
  ComputeSolutionData();
  T deriv = (T) 0;
  gbtGameInfoset infoset = p_action->GetInfoset();
  gbtGamePlayer player = p_action->GetInfoset()->GetPlayer();
  T isetProb = (T) 0;

  for (int i = 1; i <= infoset->NumMembers(); i++) {
    gbtGameNode member = infoset->GetMember(i);
    isetProb += m_realizProbs[member->GetId()];
    deriv += DiffRealizProb(member, p_oppAction) *
      (m_nodeValues(member->GetChild(p_action->GetId())->GetId(),
		    player->GetId()) -
       m_actionValues(p_action->GetInfoset()->GetPlayer()->GetId(),
		      p_action->GetInfoset()->GetId(),
		      p_action->GetId()));

    deriv += m_realizProbs[member->GetId()] *
      DiffNodeValue(member->GetChild(p_action->GetId()), player, p_oppAction);
  }

  return deriv / isetProb;
}

template <class T>
T gbtTreeBehavProfileRep<T>::DiffRealizProb(const gbtGameNode &p_node,
				  const gbtGameAction &p_oppAction) const
{
  ComputeSolutionData();
  T deriv = (T) 1;
  bool isPrec = false;
  gbtGameNode node = p_node;
  while (!node->GetParent().IsNull()) {
    gbtGameAction prevAction = node->GetPriorAction();
    if (prevAction != p_oppAction) {
      deriv *= GetActionProb(prevAction);
    }
    else {
      isPrec = true;
    }
    node = node->GetParent();
  }
 
  return (isPrec) ? deriv : (T) 0.0;
}

template <class T>
T gbtTreeBehavProfileRep<T>::DiffNodeValue(const gbtGameNode &p_node, 
				 const gbtGamePlayer &p_player,
				 const gbtGameAction &p_oppAction) const
{
  ComputeSolutionData();

  if (p_node->NumChildren() > 0) {
    gbtGameInfoset infoset = p_node->GetInfoset();

    if (infoset == p_oppAction->GetInfoset()) {
      // We've encountered the action; since we assume perfect recall,
      // we won't encounter it again, and the downtree value must
      // be the same.
      return m_nodeValues(p_node->GetChild(p_oppAction->GetId())->GetId(),
			  p_player->GetId());
    }
    else {
      T deriv = (T) 0;
      for (int act = 1; act <= infoset->NumActions(); act++) {
	deriv += (DiffNodeValue(p_node->GetChild(act), p_player, p_oppAction) *
		  m_profile(infoset->GetPlayer()->GetId(), infoset->GetId(), act));
      }
      return deriv;
    }
  }
  else {
    // If we reach a terminal node and haven't encountered p_oppAction,
    // derivative wrt this path is zero.
    return (T) 0;
  }
}

template <class T> 
T gbtTreeBehavProfileRep<T>::GetLiapValue(bool p_penalty) const
{
  static const T BIG1 = (T) 10000;
  static const T BIG2 = (T) 100;

  T x, result = ((T) 0), avg, sum;
  
  // HACK: force it to recompute data.  FIX THIS.
  m_cachedData = false;
  ComputeSolutionData();

  for (int i = 1; i <= m_efg->NumPlayers(); i++) {
    for (int iset = 1; iset <= m_efg->GetPlayer(i)->NumInfosets(); iset++) {
      gbtGameInfoset infoset = m_efg->GetPlayer(i)->GetInfoset(iset);
      avg = sum = (T)0;

      for (int act = 1; act <= infoset->NumActions(); act++) {
	x = m_profile(infoset->GetPlayer()->GetId(), infoset->GetId(), act);
	avg += x * m_actionValues(infoset->GetPlayer()->GetId(),
				  infoset->GetId(), act);
	sum += x;
	if (x > (T)0)  x = (T)0;
	if (p_penalty) {
	  // add penalty for negative probabilities
	  result += BIG1 * x * x;
	}
      }

      for (int act = 1; act <= infoset->NumActions(); act++) {
	x = m_actionValues(infoset->GetPlayer()->GetId(),
			   infoset->GetId(), act) - avg;
	if (x < (T)0) x = (T)0;
	result += x * x;          // add penalty if not best response
      }
      x = sum - (T)1;
      if (p_penalty) {
	// add penalty for sum not equal to 1
	result += BIG2 * x * x;      
      }
    }
  }
  return result;
}


//----------------------------------------------------------------------
//     class gbtTreeBehavProfileRep<T>: Probability information
//----------------------------------------------------------------------

template <class T>
T gbtTreeBehavProfileRep<T>::GetRealizProb(const gbtGameNode &p_node) const
{ 
  if (p_node.IsNull())  throw gbtGameNullException();
  gbtTreeNodeRep *node = dynamic_cast<gbtTreeNodeRep *>(p_node.Get());
  if (!node || node->m_efg != m_efg)  throw gbtGameMismatchException();

  ComputeSolutionData();
  return m_realizProbs[node->m_id];
}

template <class T>
T gbtTreeBehavProfileRep<T>::GetBeliefProb(const gbtGameNode &p_node) const
{ 
  if (p_node.IsNull())  throw gbtGameNullException();
  gbtTreeNodeRep *node = dynamic_cast<gbtTreeNodeRep *>(p_node.Get());
  if (!node || node->m_efg != m_efg)  throw gbtGameMismatchException();

  ComputeSolutionData();
  return m_beliefs[node->m_id];
}

template <class T>
T gbtTreeBehavProfileRep<T>::GetInfosetProb(const gbtGameInfoset &p_infoset) const
{ 
  if (p_infoset.IsNull())  throw gbtGameNullException();
  gbtTreeInfosetRep *infoset = dynamic_cast<gbtTreeInfosetRep *>(p_infoset.Get());
  if (!infoset || infoset->m_player->m_efg != m_efg) {
    throw gbtGameMismatchException();
  }

  ComputeSolutionData();
  T isetProb = (T) 0;
  for (int i = 1; i <= infoset->m_members.Length(); i++) {
    isetProb += m_realizProbs[infoset->m_members[i]->m_id];
  }
  return isetProb;
}


//----------------------------------------------------------------------
//     class gbtTreeBehavProfileRep<T>: Private member functions
//----------------------------------------------------------------------

template <class T>
void gbtTreeBehavProfileRep<T>::ComputeSolutionDataPass2(gbtTreeNodeRep *p_node) const
{
  if (!p_node->GetOutcome().IsNull()) {
    for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) { 
      m_nodeValues(p_node->GetId(), pl) += 
	p_node->GetOutcome()->GetPayoff(m_efg->GetPlayer(pl));
    }
  }

  gbtGameInfoset iset = p_node->GetInfoset();

  if (!iset.IsNull()) {
    T isetProb = (T) 0.0;
    for (int i = 1; i <= iset->NumMembers(); i++) {
      isetProb += m_realizProbs[iset->GetMember(i)->GetId()];
    }
    if (isetProb != isetProb * (T) 0) {
      m_beliefs[p_node->m_id] = m_realizProbs[p_node->m_id] / isetProb;
    }
    
    // push down payoffs from outcomes attached to non-terminal nodes 
    for (int child = 1; child <= p_node->NumChildren(); child++) { 
      m_nodeValues.SetRow(p_node->GetChild(child)->GetId(),
			  m_nodeValues.Row(p_node->m_id));
    }    

    for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) {
      m_nodeValues(p_node->m_id, pl) = (T) 0;
    }

    for (int child = 1; child <= p_node->NumChildren(); child++)  {
      ComputeSolutionDataPass2(p_node->m_children[child]);

      gbtGameAction act = p_node->GetChild(child)->GetPriorAction();
      T prob = (T) 0;
      if (act->GetInfoset()->GetPlayer()->IsChance()) {
	prob = act->GetChanceProb();
      }
      else {
	prob = m_profile(act->GetInfoset()->GetPlayer()->GetId(),
			 act->GetInfoset()->GetId(),
			 act->GetId());
      }



      for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) {
	m_nodeValues(p_node->m_id, pl) +=
	  prob * m_nodeValues(p_node->GetChild(child)->GetId(), pl);
      }

      if (!iset->IsChanceInfoset()) {
	T &cpay = m_actionValues(act->GetInfoset()->GetPlayer()->GetId(),
				 act->GetInfoset()->GetId(),
				 act->GetId());
	T isetProb = (T) 0;
	for (int i = 1; i <= iset->NumMembers(); i++) {
	  isetProb += m_realizProbs[iset->GetMember(i)->GetId()];
	}
	if (isetProb != isetProb * (T) 0) {
	  cpay += (m_beliefs[p_node->m_id] * 
		   m_nodeValues(p_node->GetChild(child)->GetId(),
				iset->GetPlayer()->GetId()));
	}
	else {
	  cpay = (T) 0;
	}
      }
    }
  }
}

// compute realization probabilities for nodes and isets.  
template <class T> void
gbtTreeBehavProfileRep<T>::ComputeSolutionDataPass1(gbtTreeNodeRep *p_node) const
{
  if (!p_node->GetParent().IsNull()) {
    gbtGameAction action = p_node->GetPriorAction();
    T prob = (T) 0;
    if (action->GetInfoset()->GetPlayer()->IsChance()) {
      prob = action->GetChanceProb();
    }
    else {
      prob = m_profile(action->GetInfoset()->GetPlayer()->GetId(),
		       action->GetInfoset()->GetId(),
		       action->GetId());
    }
    m_realizProbs[p_node->m_id] = (m_realizProbs[p_node->m_parent->m_id] *
				   prob);
  }
  else {
    m_realizProbs[p_node->m_id] = (T) 1;
  }
  
  if (!p_node->GetInfoset().IsNull()) {
    for (int i = 1; i <= p_node->NumChildren(); i++) {
      ComputeSolutionDataPass1(p_node->m_children[i]);
    }
  }
}

template <class T> void
gbtTreeBehavProfileRep<T>::ComputeSolutionData(void) const
{
  if (!m_cachedData) {
    m_actionValues = (T) 0;
    m_nodeValues = (T) 0;
    m_infosetValues = (T) 0;
    ComputeSolutionDataPass1(m_efg->m_root);
    ComputeSolutionDataPass2(m_efg->m_root);

    for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) {
      for (int iset = 1; iset <= m_efg->NumInfosets()[pl]; iset++) {
	gbtGameInfoset infoset = m_efg->GetPlayer(pl)->GetInfoset(iset);

	m_infosetValues(infoset->GetPlayer()->GetId(),
			infoset->GetId()) = (T) 0;
	for (int act = 1; act <= infoset->NumActions(); act++) {
	  gbtGameAction action = infoset->GetAction(act);
	  m_infosetValues(infoset->GetPlayer()->GetId(),
			  infoset->GetId()) += m_profile(action->GetInfoset()->GetPlayer()->GetId(), action->GetInfoset()->GetId(), action->GetId()) * m_actionValues(action->GetInfoset()->GetPlayer()->GetId(), action->GetInfoset()->GetId(), action->GetId());
	}

      }
    }
    m_cachedData = true;
  }
}

template <class T>
void gbtTreeBehavProfileRep<T>::BehaviorStrat(int pl, gbtTreeNodeRep *n)
{
  for (int i = 1; i <= n->NumChildren(); i++)   {
    gbtTreeNodeRep *child = n->m_children[i];
    if (!n->GetPlayer().IsNull() && n->GetPlayer()->GetId() == pl) {
      if (m_nvals[n->GetId()] > (T) 0 && 
	  m_nvals[child->GetId()] > (T) 0)  {
	(*this)(n->GetPlayer()->GetId(), n->GetInfoset()->GetId(), i) =
	  m_nvals[child->GetId()] / m_nvals[n->GetId()];
      }
    }
    BehaviorStrat(pl, child);
  }
}

template <class T> void
gbtTreeBehavProfileRep<T>::RealizationProbs(const gbtTreeMixedProfileRep<T> &mp,
					    int pl,
					    const gbtArray<int> &actions,
					    gbtTreeNodeRep *node)
{
  T prob;

  for (int i = 1; i <= node->NumChildren(); i++)   {
    if (!node->GetPlayer().IsNull() && !node->GetPlayer()->IsChance())   {
      if (node->m_infoset->m_player->m_id == pl)  {
	if (actions[node->m_infoset->m_id] == i) {
	  prob = (T) 1;
	}
	else {
	  prob = (T) 0;
	}
      }
      else {
	prob = (T) 1 / (T) node->GetInfoset()->NumActions();
      }	
    }
    else  {   // n.GetPlayer() == 0
      prob = node->GetInfoset()->GetAction(i)->GetChanceProb();
    }

    gbtTreeNodeRep *child = node->m_children[i];
    m_bvals[child->m_id] = prob * m_bvals[node->m_id];
    m_nvals[child->m_id] += m_bvals[child->m_id];

    RealizationProbs(mp, pl, actions, child);
  }    
	
}



