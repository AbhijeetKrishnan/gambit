//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of mixed strategy profile class for table games
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include "game.h"
#include "table-game.h"
#include "tree-game.h"
#include "table-strategy-mixed.h"

//======================================================================
//        Implementation of class gbtTableMixedProfileRep<T>
//======================================================================

//----------------------------------------------------------------------
//     class gbtTableMixedProfileRep<T>: Constructor and destructor
//----------------------------------------------------------------------

template <class T> 
gbtTableMixedProfileRep<T>::gbtTableMixedProfileRep(const gbtTableGameRep *p_game)
  : m_refCount(0), 
    m_game(const_cast<gbtTableGameRep *>(p_game)),
    m_profile(p_game->NumStrategies())
{
  SetCentroid();
}

template <class T> gbtTableMixedProfileRep<T>::~gbtTableMixedProfileRep()
{ }

template <class T>
gbtMixedProfileRep<T> *gbtTableMixedProfileRep<T>::Copy(void) const
{
  gbtTableMixedProfileRep<T> *ret = new gbtTableMixedProfileRep<T>(m_game);
  ret->m_profile = m_profile;
  return ret;
}

//----------------------------------------------------------------------
//  class gbtTableMixedProfileRep<T>: Mechanism for reference counting
//----------------------------------------------------------------------

template <class T> void gbtTableMixedProfileRep<T>::Reference(void)
{
  m_refCount++;
  m_game->m_refCount++;
}

template <class T> bool gbtTableMixedProfileRep<T>::Dereference(void)
{
  if (--m_game->m_refCount == 0) {
    // Note that if this condition is true, this profile must be the
    // last reference to the game, so m_refCount will also be one
    // (and this function will return true)
    delete m_game;
  }
  return (--m_refCount == 0);
}

//----------------------------------------------------------------------
//      class gbtTableMixedProfileRep<T>: General information
//----------------------------------------------------------------------

template <class T> bool
gbtTableMixedProfileRep<T>::operator==(const gbtMixedProfileRep<T> &mp) const
{
  const gbtTableMixedProfileRep<T> *profile = 
    dynamic_cast<const gbtTableMixedProfileRep<T> *>(&mp);
  if (!profile)  return false;
  return (m_game == profile->m_game && m_profile == profile->m_profile);
}

//----------------------------------------------------------------------
//  class gbtTableMixedProfileRep<T>: Accessing profile probabilities
//----------------------------------------------------------------------

template <class T> T
gbtTableMixedProfileRep<T>::GetStrategyProb(const gbtGameStrategy &p_strategy) const
{
  if (p_strategy.IsNull())  throw gbtGameNullException();
  gbtTableStrategyRep *strategy =
    dynamic_cast<gbtTableStrategyRep *>(p_strategy.Get());
  if (!strategy || strategy->m_infoset->m_player->m_nfg != m_game) {
    throw gbtGameMismatchException();
  }
  return m_profile(strategy->m_infoset->m_player->m_id, strategy->m_id);
}

template <class T> void
gbtTableMixedProfileRep<T>::SetStrategyProb(const gbtGameStrategy &p_strategy,
					    const T &p_prob)
{
  if (p_strategy.IsNull())  throw gbtGameNullException();
  gbtTableStrategyRep *strategy =
    dynamic_cast<gbtTableStrategyRep *>(p_strategy.Get());
  if (!strategy || strategy->m_infoset->m_player->m_nfg != m_game) {
    throw gbtGameMismatchException();
  }
  m_profile(strategy->m_infoset->m_player->m_id, strategy->m_id) = p_prob;
}

template <class T> void gbtTableMixedProfileRep<T>::SetCentroid(void) 
{
  for (int pl = 1; pl <= m_game->m_players.Length(); pl++)  {
    gbtTablePlayerRep *player = m_game->m_players[pl];
    T center = ((T) 1) / ((T) player->NumStrategies());
    for (int st = 1; st <= player->NumStrategies(); 
	 m_profile(pl, st++) = center);
  }
}

//----------------------------------------------------------------------
//      class gbtTableMixedProfileRep<T>: Payoff information
//----------------------------------------------------------------------

//!
//! The recursive helper function for computing the expected
//! payoff of the profile to a player
//!
template <class T>
T gbtTableMixedProfileRep<T>::GetPayoff(gbtTablePlayerRep *p_player, 
					long index, int pl) const
{
  if (pl > m_game->m_players.Length())  {
    if (m_game->m_results[index]) {
      return m_game->m_results[index]->m_payoffs[p_player->m_id];
    }
    else {
      return (T) 0;
    }
  }
  T sum = (T) 0;
  gbtTablePlayerRep *thisPlayer = m_game->m_players[pl];
  for (int st = 1; st <= thisPlayer->m_infosets[1]->m_actions.Length(); st++) {
    if (m_profile(pl, st) > (T) 0) {
      gbtTableStrategyRep *s = thisPlayer->m_infosets[1]->m_actions[st];
      sum += (m_profile(pl, st) * 
	      GetPayoff(p_player, index + s->m_index, pl + 1));
    }
  }
  return sum;
}

template <class T> 
T gbtTableMixedProfileRep<T>::GetPayoff(const gbtGamePlayer &p_player) const
{
  if (p_player.IsNull())  throw gbtGameNullException();
  gbtTablePlayerRep *player = dynamic_cast<gbtTablePlayerRep *>(p_player.Get());
  if (!player || player->m_nfg != m_game) throw gbtGameMismatchException();
  return GetPayoff(player, 1, 1);
}

//!
//! The recursive helper function for computing the first derivative of
//! payoffs with respect to a strategy probability.
//!
template <class T>
T gbtTableMixedProfileRep<T>::GetPayoffDeriv(gbtTablePlayerRep *p_player,
					     gbtTablePlayerRep *p_constPlayer,
					     long index, int pl) const
{
  if (pl == p_constPlayer->m_id) {
    return GetPayoffDeriv(p_player, p_constPlayer, index, pl + 1);
  }
  else if (pl > m_game->m_players.Length())  {
    if (m_game->m_results[index]) {
      return (T) m_game->m_results[index]->m_payoffs[p_player->m_id];
    }
    else {
      return (T) 0;
    }
  }
  else {
    T sum = (T) 0;
    gbtTablePlayerRep *thisPlayer = m_game->m_players[pl];
    for (int st = 1; 
	 st <= thisPlayer->m_infosets[1]->m_actions.Length(); st++) {
      if (m_profile(pl, st) > (T) 0) {
	gbtTableStrategyRep *s = thisPlayer->m_infosets[1]->m_actions[st];
	sum += (m_profile(pl, st) *
		GetPayoffDeriv(p_player, p_constPlayer, 
			       index + s->m_index, pl + 1));
      }
    }
    return sum;
  }
}

template <class T> T
gbtTableMixedProfileRep<T>::GetPayoffDeriv(const gbtGamePlayer &p_player,
					   const gbtGameStrategy &p_strategy) const
{
  if (p_player.IsNull() || p_strategy.IsNull())  throw gbtGameNullException();
  gbtTablePlayerRep *player = dynamic_cast<gbtTablePlayerRep *>(p_player.Get());
  if (!player || player->m_nfg != m_game) throw gbtGameMismatchException();

  gbtTableStrategyRep *strategy =
    dynamic_cast<gbtTableStrategyRep *>(p_strategy.Get());
  if (!strategy || strategy->m_infoset->m_player->m_nfg != m_game) {
    throw gbtGameMismatchException();
  }

  return GetPayoffDeriv(player, strategy->m_infoset->m_player, 
			strategy->m_index + 1, 1);
}

//!
//! The recursive helper function for computing the second derivative of
//! payoffs with respect to strategy probabilities.
//!
template <class T>
T gbtTableMixedProfileRep<T>::GetPayoffDeriv(gbtTablePlayerRep *p_player,
					     gbtTablePlayerRep *p_constPlayer1,
					     gbtTablePlayerRep *p_constPlayer2,
					     long index, int pl) const
{
  if (pl == p_constPlayer1->m_id || pl == p_constPlayer2->m_id) {
    return GetPayoffDeriv(p_player, p_constPlayer1, p_constPlayer2,
			  index, pl + 1);
  }
  else if (pl > m_game->m_players.Length())  {
    if (m_game->m_results[index]) {
      return (T) m_game->m_results[index]->m_payoffs[p_player->m_id];
    }
    else {
      return (T) 0;
    }
  }
  else   {
    T sum = (T) 0;
    gbtTablePlayerRep *thisPlayer = m_game->m_players[pl];
    for (int st = 1; 
	 st <= thisPlayer->m_infosets[1]->m_actions.Length(); st++) {
      if (m_profile(pl, st) > (T) 0) {
	gbtTableStrategyRep *s = m_game->m_players[pl]->m_infosets[1]->m_actions[st];
	sum += (m_profile(pl, st) *
		GetPayoffDeriv(p_player, p_constPlayer1, p_constPlayer2,
			       index + s->m_index, pl + 1));
      }
    }
    return sum;
  }
}

template <class T> T
gbtTableMixedProfileRep<T>::GetPayoffDeriv(const gbtGamePlayer &p_player,
					   const gbtGameStrategy &p_strategy1,
					   const gbtGameStrategy &p_strategy2) const
{
  if (p_player.IsNull() || p_strategy1.IsNull() || p_strategy2.IsNull()) {
    throw gbtGameNullException();
  }

  gbtTablePlayerRep *player = dynamic_cast<gbtTablePlayerRep *>(p_player.Get());
  if (!player || player->m_nfg != m_game) throw gbtGameMismatchException();

  gbtTableStrategyRep *s1 = 
    dynamic_cast<gbtTableStrategyRep *>(p_strategy1.Get());
  if (!s1 || s1->m_infoset->m_player->m_nfg != m_game) {
    throw gbtGameMismatchException();
  }

  gbtTableStrategyRep *s2 = 
    dynamic_cast<gbtTableStrategyRep *>(p_strategy2.Get());
  if (!s2 || s2->m_infoset->m_player->m_nfg != m_game) {
    throw gbtGameMismatchException();
  }

  if (s1->m_infoset->m_player == s2->m_infoset->m_player)  return (T) 0;

  return GetPayoffDeriv(player, 
			s1->m_infoset->m_player, s2->m_infoset->m_player,
			s1->m_index + s2->m_index + 1, 1);
}

template <class T> 
T gbtTableMixedProfileRep<T>::GetLiapValue(bool penalize) const
{
  static const T BIG1 = (T) 100;
  static const T BIG2 = (T) 100;

  gbtTableMixedProfileRep<T> p(*this);
  p.m_profile = m_profile;
  gbtTableMixedProfileRep<T> tmp(p);
  gbtPVector<T> payoff(p.m_profile);
  T x, result((T) 0), avg, sum;
  payoff = (T) 0;

  for (int i = 1; i <= m_game->NumPlayers(); i++) {
    tmp.m_profile.CopyRow(i, payoff);
    avg = sum = (T) 0;
    // then for each strategy for that player set it to 1 and evaluate
    int j;
    for (j = 1; j <= m_game->GetPlayer(i)->NumStrategies(); j++) {
      tmp(i, j) = (T) 1;
      x = p(i, j);
      payoff(i, j) = tmp.GetPayoff(m_game->GetPlayer(i));
      avg += x * payoff(i, j);
      sum += x;
      if (x>(T)0) x=0;
      if (penalize) {
	result += BIG1*x*x;         // add penalty for neg probabilities
      }
      tmp(i,j) = (T) 0;
    }
    tmp.m_profile.CopyRow(i, p.m_profile);
    for(j = 1; j <= m_game->GetPlayer(i)->NumStrategies(); j++) {
      x=payoff(i,j)-avg;
      if (x<=(T)0) x=(T)0;
      result += x*x;          // add penalty if not best response
    }
    x=sum - ((T) 1);
    if (penalize) {
      result += BIG2*x*x;          // add penalty for sum not equal to 1
    }
  }
  return result;
}

template <class T> 
std::ostream &operator<<(std::ostream &f, const gbtTableMixedProfileRep<T> &p)
{ p.Dump(f);  return f; }



