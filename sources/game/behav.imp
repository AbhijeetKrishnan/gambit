//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of behavior profile classes
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//


#include "math/gvector.h"
#include "game.h"
#include "behav.h"
#include "actiter.h"
#include "efgcont.h"
#include "gamebase.h"

#include "mixed.h"

//-------------------------------------------------------------------------
//   gbtBehavProfileBase<T>: Constructors, Destructor
//-------------------------------------------------------------------------

template <class T>
gbtBehavProfileBase<T>::gbtBehavProfileBase(const gbtBehavProfileBase<T> &p_profile)
  : m_profile(p_profile.m_profile),
    m_support(p_profile.m_support),
    m_cachedData(false),
    m_realizProbs(p_profile.m_realizProbs), m_beliefs(p_profile.m_beliefs),
    m_nvals(p_profile.m_nvals), m_bvals(p_profile.m_bvals),
    m_nodeValues(p_profile.m_nodeValues),
    m_infosetValues(p_profile.m_infosetValues),
    m_actionValues(p_profile.m_actionValues),
    m_gripe(p_profile.m_gripe)
{
  InitProfile();
}

template <class T>
gbtBehavProfileBase<T>::gbtBehavProfileBase(const gbtEfgSupportBase &p_support)
  : m_profile(p_support.NumActions()), 
    m_support(new gbtEfgSupportBase(p_support)),
    m_cachedData(false),
    m_realizProbs(p_support.NumNodes()),
    m_beliefs(p_support.NumNodes()),
    m_nvals(p_support.NumNodes()),
    m_bvals(p_support.NumNodes()),
    m_nodeValues(p_support.NumNodes(), p_support.NumPlayers()),
    m_infosetValues(p_support.NumInfosets()),
    m_actionValues(p_support.NumActions()),
    m_gripe(p_support.NumActions())
{
  InitProfile();
  SetCentroid();
}

template <class T>
gbtBehavProfileBase<T>::gbtBehavProfileBase(const gbtMixedProfileTree<T> &p_profile)
  : m_profile(p_profile.m_efgSupport->NumActions()), 
    m_support(new gbtEfgSupportBase(*p_profile.m_efgSupport)),
    m_cachedData(false),
    m_realizProbs(p_profile.m_efgSupport->NumNodes()),
    m_beliefs(p_profile.m_efgSupport->NumNodes()),
    m_nvals(p_profile.m_efgSupport->NumNodes()),
    m_bvals(p_profile.m_efgSupport->NumNodes()),
    m_nodeValues(p_profile.m_efgSupport->NumNodes(),
		 p_profile.m_efgSupport->NumPlayers()),
    m_infosetValues(p_profile.m_efgSupport->NumInfosets()),
    m_actionValues(p_profile.m_efgSupport->NumActions()),
    m_gripe(p_profile.m_efgSupport->NumActions())
{
  InitProfile();

  ((gbtVector<T> &) *this).operator=((T)0); 

  gbtGameNode n = m_support->GetRoot();
  gbtNfgSupport support = p_profile.m_nfgSupport;

  for (int pl = 1; pl <= support->NumPlayers(); pl++)   {
    m_nvals = (T) 0;
    m_bvals = (T) 0;

    gbtGamePlayer player = support->GetPlayer(pl);
    for (int st = 1; st <= player->NumStrategies(); st++)  {
      if (p_profile(pl, st) > (T) 0)  {
	const gbtArray<int> &actions = player->GetStrategy(st)->GetBehavior();

	m_bvals[n->GetId()] = p_profile(pl, st);

	RealizationProbs(p_profile, pl, actions, m_support->GetRoot());
      }
    }
 
    m_nvals[1] = (T) 1;   // set the root nval
    BehaviorStrat(pl, n);
  }
}

template <class T> gbtBehavProfileBase<T>::~gbtBehavProfileBase()
{ }

//-------------------------------------------------------------------------
//   gbtBehavProfileBase<T>: Operator overloading
//-------------------------------------------------------------------------

template <class T>
bool gbtBehavProfileBase<T>::operator==(const gbtBehavProfileRep<T> &p_profile) const
{
  return (m_support == 
	  dynamic_cast<const gbtBehavProfileBase<T> &>(p_profile).m_support &&
	  m_profile ==
	  dynamic_cast<const gbtBehavProfileBase<T> &>(p_profile).m_profile);
}

//-------------------------------------------------------------------------
//   gbtBehavProfileBase<T>: Initialization, Validation
//-------------------------------------------------------------------------

template <class T>
void gbtBehavProfileBase<T>::InitPayoffs(void) const
{
  m_realizProbs = (T) 0.0;
  m_beliefs = (T) 0.0;
  m_nodeValues = (T) 0.0;
  m_infosetValues = (T) 0.0;
  m_actionValues = (T) 0.0;
  m_gripe = (T) 0.0;
}

template <class T>
void gbtBehavProfileBase<T>::InitProfile(void)
{
  InitPayoffs();
}

template <class T> void gbtBehavProfileBase<T>::SetCentroid(void)
{
  T center;

  for (int pl = 1; pl <= NumPlayers(); pl++) {
    for (int iset = 1; iset <= GetPlayer(pl)->NumInfosets(); iset++) {
      if (m_support->GetPlayer(pl)->GetInfoset(iset)->NumActions() > 0) {
	center = ((T) 1 / (T) m_support->GetPlayer(pl)->GetInfoset(iset)->NumActions());
	for (int act = 1; act <= m_support->GetPlayer(pl)->GetInfoset(iset)->NumActions(); act++) {
	  m_profile(pl, iset, act) = center;
	}
      }
    }
  }
}

//-------------------------------------------------------------------------
//   gbtBehavProfileBase<T>: General data access -- private functions
//-------------------------------------------------------------------------

template <class T>
T gbtBehavProfileBase<T>::ActionProb(const gbtGameAction &action) const
{
  if (action->GetInfoset()->GetPlayer()->IsChance()) {
    return action->GetChanceProb();
  }
  else if (!m_support->Contains(action)) {
    return (T) 0.0;
  }
  else {
    return (*this)(action->GetInfoset()->GetPlayer()->GetId(),
		   action->GetInfoset()->GetId(),
		   m_support->GetIndex(action));
  }
}

template <class T>
T &gbtBehavProfileBase<T>::RealizProb(const gbtGameNode &node) const
{
  return m_realizProbs[node->GetId()];
}

template <class T>
T &gbtBehavProfileBase<T>::RealizProb(const gbtGameNode &node)
{
  return m_realizProbs[node->GetId()];
}

template <class T>
T &gbtBehavProfileBase<T>::BeliefProb(const gbtGameNode &node) const
{
  return m_beliefs[node->GetId()];
}

template <class T>
T &gbtBehavProfileBase<T>::BeliefProb(const gbtGameNode &node)
{
  return m_beliefs[node->GetId()];
}


template <class T>
T gbtBehavProfileBase<T>::IsetProb(const gbtGameInfoset &iset) const
{
  T prob = (T) 0;
  for (int i = 1; i <= iset->NumMembers(); i++) {
    prob += RealizProb(iset->GetMember(i));
  }
  return prob;
}

template <class T>
T &gbtBehavProfileBase<T>::IsetValue(const gbtGameInfoset &iset) const
{
  return m_infosetValues(iset->GetPlayer()->GetId(), iset->GetId());
}

template <class T>
T &gbtBehavProfileBase<T>::IsetValue(const gbtGameInfoset &iset)
{
  return m_infosetValues(iset->GetPlayer()->GetId(), iset->GetId());
}


template <class T> 
T &gbtBehavProfileBase<T>::Regret(const gbtGameAction &act) const
{
  return m_gripe(act->GetInfoset()->GetPlayer()->GetId(),
		 act->GetInfoset()->GetId(), act->GetId());
}	

template <class T> T &gbtBehavProfileBase<T>::Regret(const gbtGameAction &act)
{
  return m_gripe(act->GetInfoset()->GetPlayer()->GetId(),
		 act->GetInfoset()->GetId(), act->GetId());
}

//-------------------------------------------------------------------------
//   gbtBehavProfileBase<T>: General data access -- public functions
//-------------------------------------------------------------------------

template <class T>
const T &gbtBehavProfileBase<T>::GetRealizProb(const gbtGameNode &node) const
{ 
  ComputeSolutionData();
  return RealizProb(node);
}

template <class T>
const T &gbtBehavProfileBase<T>::GetBeliefProb(const gbtGameNode &node) const
{ 
  ComputeSolutionData();
  return BeliefProb(node);
}

template <class T>
gbtVector<T> gbtBehavProfileBase<T>::GetNodeValue(const gbtGameNode &node) const
{ 
  ComputeSolutionData();
  return NodeValues(node);
}

template <class T>
T gbtBehavProfileBase<T>::GetInfosetProb(const gbtGameInfoset &iset) const
{ 
  ComputeSolutionData();
  return IsetProb(iset);
}

template <class T> const T &
gbtBehavProfileBase<T>::GetInfosetValue(const gbtGameInfoset &iset) const
{ 
  ComputeSolutionData();
  return IsetValue(iset);
}

template <class T>
T &gbtBehavProfileBase<T>::operator()(const gbtGameAction &p_action)
{
  return m_profile(p_action->GetInfoset()->GetPlayer()->GetId(),
		   p_action->GetInfoset()->GetId(),
		   p_action->GetId());
}

template <class T>
const T &gbtBehavProfileBase<T>::operator()(const gbtGameAction &p_action) const
{
  return m_profile(p_action->GetInfoset()->GetPlayer()->GetId(),
		   p_action->GetInfoset()->GetId(),
		   p_action->GetId());
}

template <class T>
T gbtBehavProfileBase<T>::GetActionProb(const gbtGameAction &act) const
{ 
  return ActionProb(act);
}


template <class T>
const T &gbtBehavProfileBase<T>::GetActionValue(const gbtGameAction &act) const
{ 
  ComputeSolutionData();
  return ActionValue(act);
}

template <class T>
const T &gbtBehavProfileBase<T>::GetRegret(const gbtGameAction &act) const
{ 
  ComputeSolutionData();
  return Regret(act);
}

//-------------------------------------------------------------------------
//   gbtBehavProfileBase<T>: Computation of interesting quantities
//-------------------------------------------------------------------------

//--------------
// Payoff
//--------------

template <class T>
T gbtBehavProfileBase<T>::Payoff(const gbtGameOutcome &p_outcome,
				int pl) const
{ 
  return p_outcome->GetPayoff(m_support->GetPlayer(pl));
}

template <class T>
void gbtBehavProfileBase<T>::Payoff(const gbtGameNode &node,
			     T prob, int player, T &value) const
{
  gbtGameInfoset iset = node->GetInfoset();

  if (!node->GetOutcome().IsNull()) {
    value += prob * Payoff(gbtGameOutcome(node->GetOutcome()), player);
  }

  if (node->NumChildren() > 0) {
    for (gbtActionIterator action(m_support, iset); !action.End(); action++) {
      Payoff(node->GetChild(*action),
	     prob * ActionProb(*action), player, value);
    }
  }
}

template <class T> T 
gbtBehavProfileBase<T>::GetPayoff(const gbtGamePlayer &p_player) const
{
  T value = (T) 0;
  Payoff(m_support->GetRoot(), (T) 1, p_player->GetId(), value);
  return value;
}

//---------------
// Derivatives
//---------------

//
// The following routines compute the derivatives of quantities as
// the probability of the action 'p_oppAction' is changed.
// See Turocy (2001), "Computing the Quantal Response Equilibrium
// Correspondence" for details.
// These assume that the profile is interior (totally mixed),
// and that the game is of perfect recall
//

template <class T>
T gbtBehavProfileBase<T>::DiffActionValue(const gbtGameAction &p_action,
				   const gbtGameAction &p_oppAction) const
{
  ((gbtBehavProfileBase<T> *) this)->ComputeSolutionData();
  T deriv = (T) 0;
  gbtGameInfoset infoset = p_action->GetInfoset();
  gbtGamePlayer player = p_action->GetInfoset()->GetPlayer();

  for (int i = 1; i <= infoset->NumMembers(); i++) {
    gbtGameNode member = infoset->GetMember(i);
    deriv += DiffRealizProb(member, p_oppAction) *
      (NodeValue(member->GetChild(p_action->GetId()), player->GetId()) -
       ActionValue(p_action));

    deriv += RealizProb(member) *
      DiffNodeValue(member->GetChild(p_action->GetId()), player, p_oppAction);
  }

  return deriv / IsetProb(p_action->GetInfoset());
}

template <class T>
T gbtBehavProfileBase<T>::DiffRealizProb(const gbtGameNode &p_node,
				  const gbtGameAction &p_oppAction) const
{
  ((gbtBehavProfileBase<T> *) this)->ComputeSolutionData();
  T deriv = (T) 1;
  bool isPrec = false;
  gbtGameNode node = p_node;
  while (!node->GetParent().IsNull()) {
    gbtGameAction prevAction = node->GetPriorAction();
    if (prevAction != p_oppAction) {
      deriv *= GetActionProb(prevAction);
    }
    else {
      isPrec = true;
    }
    node = node->GetParent();
  }
 
  return (isPrec) ? deriv : (T) 0.0;
}

template <class T>
T gbtBehavProfileBase<T>::DiffNodeValue(const gbtGameNode &p_node, 
				 const gbtGamePlayer &p_player,
				 const gbtGameAction &p_oppAction) const
{
  ((gbtBehavProfileBase<T> *) this)->ComputeSolutionData();

  if (p_node->NumChildren() > 0) {
    gbtGameInfoset infoset = p_node->GetInfoset();

    if (infoset == p_oppAction->GetInfoset()) {
      // We've encountered the action; since we assume perfect recall,
      // we won't encounter it again, and the downtree value must
      // be the same.
      return m_nodeValues(p_node->GetChild(p_oppAction->GetId())->GetId(),
			  p_player->GetId());
    }
    else {
      T deriv = (T) 0;
      for (int act = 1; act <= infoset->NumActions(); act++) {
	deriv += (DiffNodeValue(p_node->GetChild(act), p_player, p_oppAction) *
		  ActionProb(infoset->GetAction(act)));
      }
      return deriv;
    }
  }
  else {
    // If we reach a terminal node and haven't encountered p_oppAction,
    // derivative wrt this path is zero.
    return (T) 0;
  }
}

// 
// Computation of Cached solution data
// 

template <class T>
void gbtBehavProfileBase<T>::ComputeSolutionDataPass2(const gbtGameNode &node) const
{
  if (!node->GetOutcome().IsNull()) {
    for (int pl = 1; pl <= m_support->NumPlayers(); pl++) { 
      m_nodeValues(node->GetId(), pl) += Payoff(node->GetOutcome(), pl);
    }
  }

  gbtGameInfoset iset = node->GetInfoset();

  if (!iset.IsNull()) {
    if (IsetProb(iset) != IsetProb(iset) * (T) 0)
      BeliefProb(node) = RealizProb(node) / IsetProb(iset);
    
    // push down payoffs from outcomes attached to non-terminal nodes 
    for (int child = 1; child <= node->NumChildren(); child++) { 
      m_nodeValues.SetRow(node->GetChild(child)->GetId(),
			  m_nodeValues.Row(node->GetId()));
    }    

    for (int pl = 1; pl <= m_support->NumPlayers(); pl++) {
      m_nodeValues(node->GetId(), pl) = (T) 0;
    }

    for (int child = 1; child <= node->NumChildren(); child++)  {
      ComputeSolutionDataPass2(node->GetChild(child));

      //      gbtVector<T> s = NodeValue(children[child]);

      gbtGameAction act = node->GetChild(child)->GetPriorAction();

      for (int pl = 1; pl <= m_support->NumPlayers(); pl++) {
	m_nodeValues(node->GetId(), pl) +=
	  ActionProb(act) * m_nodeValues(node->GetChild(child)->GetId(), pl);
      }

      if (!iset->IsChanceInfoset()) {
	T &cpay = ActionValue(act);
	if (IsetProb(iset) != IsetProb(iset) * (T) 0) {
	  cpay += BeliefProb(node) * m_nodeValues(node->GetChild(child)->GetId(),
						  iset->GetPlayer()->GetId());
	}
	else {
	  cpay = (T) 0;
	}
      }
    }
  }
}

// compute realization probabilities for nodes and isets.  
template <class T>
void gbtBehavProfileBase<T>::ComputeSolutionDataPass1(const gbtGameNode &node) const
{
  if (!node->GetParent().IsNull()) {
    RealizProb(node) = (RealizProb(node->GetParent()) *
			ActionProb(node->GetPriorAction()));
  }
  else {
    RealizProb(node) = (T) 1;
  }
  
  if (!node->GetInfoset().IsNull()) {
    for (int i = 1; i <= node->NumChildren(); i++) {
      ComputeSolutionDataPass1(node->GetChild(i));
    }
  }
}

template <class T>
void gbtBehavProfileBase<T>::ComputeSolutionData(void) const
{
  if (!m_cachedData) {
    m_actionValues = (T) 0;
    m_nodeValues = (T) 0;
    m_infosetValues = (T) 0;
    m_gripe = (T) 0;
    ComputeSolutionDataPass1(m_support->GetRoot());
    ComputeSolutionDataPass2(m_support->GetRoot());

    for (int pl = 1; pl <= m_support->NumPlayers(); pl++) {
      for (int iset = 1; iset <= m_support->NumInfosets()[pl]; iset++) {
	gbtGameInfoset infoset = m_support->GetPlayer(pl)->GetInfoset(iset);

	IsetValue(infoset) = (T) 0;
	for (int act = 1; act <= infoset->NumActions(); act++) {
	  gbtGameAction action = infoset->GetAction(act);
	  IsetValue(infoset) += ActionProb(action) * ActionValue(action);
	}

	for (int act = 1; act <= infoset->NumActions(); act++) {
	  gbtGameAction action = infoset->GetAction(act);
	  Regret(action) = (ActionValue(action) - IsetValue(infoset)) * IsetProb(infoset);
	}
      }
    }
    m_cachedData = true;
  }
}

template <class T>
void gbtBehavProfileBase<T>::BehaviorStrat(int pl, const gbtGameNode &n)
{
  for (int i = 1; i <= n->NumChildren(); i++)   {
    gbtGameNode child = n->GetChild(i);
    if (!n->GetPlayer().IsNull() && n->GetPlayer()->GetId() == pl) {
      if (m_nvals[n->GetId()] > (T) 0 && 
	  m_nvals[child->GetId()] > (T) 0)  {
	(*this)(n->GetPlayer()->GetId(),
		n->GetInfoset()->GetId(), 
		m_support->GetIndex(n->GetInfoset()->GetAction(i))) =
	  m_nvals[child->GetId()] / m_nvals[n->GetId()];
      }
    }
    BehaviorStrat(pl, child);
  }
}

template <class T>
void gbtBehavProfileBase<T>::RealizationProbs(const gbtMixedProfileTree<T> &mp,
					  int pl,
					  const gbtArray<int> &actions,
					  const gbtGameNode &node)
{
  static const T tremble = (T) 0;
  T prob;

  for (int i = 1; i <= node->NumChildren(); i++)   {
    if (!node->GetPlayer().IsNull() && !node->GetPlayer()->IsChance())   {
      if (node->GetPlayer()->GetId() == pl)  {
	if (actions[node->GetInfoset()->GetId()] == i)
	  prob = (T) 1 - tremble + tremble / (T) node->NumChildren();
	else
	  prob = tremble / (T) node->NumChildren();
      }
      else if (m_support->Contains(node->GetInfoset()->GetAction(i)))
	prob = (T) 1 / (T) m_support->GetPlayer(node->GetPlayer()->GetId())->GetInfoset(node->GetInfoset()->GetId())->NumActions();
      else
	prob = (T) 0;
    }
    else  {   // n.GetPlayer() == 0
      prob = node->GetInfoset()->GetChanceProb(i);
    }

    gbtGameNode child = node->GetChild(i);
    m_bvals[child->GetId()] = prob * m_bvals[node->GetId()];
    m_nvals[child->GetId()] += m_bvals[child->GetId()];

    RealizationProbs(mp, pl, actions, child);
  }    
	
}

template <class T> T gbtBehavProfileBase<T>::GetLiapValue(bool p_penalty) const
{
  static const T BIG1 = (T) 10000;
  static const T BIG2 = (T) 100;

  T x, result = ((T) 0), avg, sum;
  
  // HACK: force it to recompute data.  FIX THIS.
  m_cachedData = false;
  ComputeSolutionData();

  for (int i = 1; i <= m_support->NumPlayers(); i++) {
    for (int iset = 1; iset <= m_support->GetPlayer(i)->NumInfosets(); iset++) {
      gbtGameInfoset infoset = m_support->GetPlayer(i)->GetInfoset(iset);
      avg = sum = (T)0;

      for (gbtActionIterator action(m_support, infoset);
	   !action.End(); action++) {
	x = ActionProb(*action);
	avg += x * ActionValue(*action);
	sum += x;
	if (x > (T)0)  x = (T)0;
	if (p_penalty) {
	  // add penalty for negative probabilities
	  result += BIG1 * x * x;
	}
      }

      for (gbtActionIterator action(m_support, infoset); 
	   !action.End(); action++) {
	x = ActionValue(*action) - avg;
	if (x < (T)0) x = (T)0;
	result += x * x;          // add penalty if not best response
      }
      x = sum - (T)1;
      if (p_penalty) {
	// add penalty for sum not equal to 1
	result += BIG2 * x * x;      
      }
    }
  }
  return result;
}

template <class T>
gbtBehavProfileRep<T> *gbtBehavProfileBase<T>::Copy(void) const
{
  return new gbtBehavProfileBase<T>(*this);
}

template <class T>
gbtBehavProfileBase<T>::operator gbtMixedProfile<T>(void) const
{
  return gbtMixedProfile<T>(new gbtMixedProfileTree<T>(*this));
}

template <class T> gbtBehavProfile<double> 
gbtBehavProfileBase<T>::NewBehavProfile(double) const
{
  gbtBehavProfileBase<double> *profile = 
    new gbtBehavProfileBase<double>(*m_support);
  for (int i = 1; i <= BehavProfileLength(); i++) {
    (*profile)[i] = (double) m_profile[i];
  }

  return profile;
}

template <class T> gbtBehavProfile<gbtRational>
gbtBehavProfileBase<T>::NewBehavProfile(const gbtRational &) const
{
  gbtBehavProfileBase<gbtRational> *profile = 
    new gbtBehavProfileBase<gbtRational>(*m_support);
  for (int i = 1; i <= BehavProfileLength(); i++) {
    (*profile)[i] = m_profile[i];
  }

  return profile;
}

template <class T> gbtBehavProfile<gbtNumber> 
gbtBehavProfileBase<T>::NewBehavProfile(const gbtNumber &) const
{
  gbtBehavProfileBase<gbtNumber> *profile = 
    new gbtBehavProfileBase<gbtNumber>(*m_support);
  for (int i = 1; i <= BehavProfileLength(); i++) {
    (*profile)[i] = gbtNumber(m_profile[i]);
  }

  return profile;
}


//-----------------
//   Output
//-----------------

template <class T> gbtOutput &operator<<(gbtOutput &p_file,
					 const gbtBehavProfile<T> &p_profile)
{
  return p_file;
}

