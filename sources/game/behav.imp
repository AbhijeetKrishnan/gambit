//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of behavior profile classes
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//


#include "math/gvector.h"
#include "efg.h"
#include "efgutils.h"
#include "behav.h"
#include "actiter.h"

#include "nfg.h"
#include "mixed.h"
#include "lexicon.h"

//-------------------------------------------------------------------------
//                    PureBehavProfile<T> member functions
//-------------------------------------------------------------------------

template <class T> PureBehavProfile<T>::PureBehavProfile(const efgGame &efg)
  : E(&efg), profile(efg.NumPlayers())
{
  for (int pl = 1; pl <= efg.NumPlayers(); pl++)  {
    gbtEfgPlayer player = efg.GetPlayer(pl);
    profile[pl] = new gArray<gbtEfgAction>(player.NumInfosets());
    for (int iset = 1; iset <= player.NumInfosets(); iset++) {
      (*profile[pl])[iset] = player.GetInfoset(iset)->GetAction(1);
    }
  }
}

template <class T>
PureBehavProfile<T>::PureBehavProfile(const PureBehavProfile<T> &p)
  : E(p.E), profile(p.profile.Length())
{
  for (int pl = 1; pl <= profile.Length(); pl++)   {
    profile[pl] = new gArray<gbtEfgAction>(p.profile[pl]->Length());
    for (int iset = 1; iset <= profile[pl]->Length(); iset++)
      (*profile[pl])[iset] = (*p.profile[pl])[iset];
  }
}

template <class T> PureBehavProfile<T>::~PureBehavProfile()
{
  for (int pl = 1; pl <= profile.Length(); delete profile[pl++]);
}

template <class T> 
PureBehavProfile<T> &PureBehavProfile<T>::operator=(const PureBehavProfile<T> &p) 
{
  if (this != &p && E == p.E)   {
    for(int pl = 1; pl <= profile.Length(); pl++)
    for(int iset = 1; iset <= profile[pl]->Length(); iset++)
    (*profile[pl])[iset] = (*p.profile[pl])[iset];
  }
  return *this;
}

template <class T>
T PureBehavProfile<T>::operator()(const gbtEfgAction &action) const
{
  if ((*profile[action.GetInfoset()->GetPlayer().GetId()])
      [action.GetInfoset()->GetNumber()] == action)
    return (T) 1;
  else
    return (T) 0;
}

template <class T> void PureBehavProfile<T>::Set(const gbtEfgAction &action)
{
  (*profile[action.GetInfoset()->GetPlayer().GetId()])
    [action.GetInfoset()->GetNumber()] = action;
}

/*
template <class T>
void PureBehavProfile<T>::Set(const gbtEfgPlayer &player,
                              const gArray<gbtEfgAction> &actions)
{
  *profile[player.GetId()] = actions;
}
*/

template <class T>
gbtEfgAction PureBehavProfile<T>::GetAction(const Infoset *infoset) const
{
  return (*profile[infoset->GetPlayer().GetId()])[infoset->GetNumber()];
}

/* - The following is an attempt to eliminate all the extra work of
computing a vector of payoffs when only one agent's payoff is of
interest.  It runs into a problem that I don't know how to solve,
namely that compilation leads to a request for a cast from gNumber to
gRational. amm-8.98

template <class T>
void PureBehavProfile<T>::IndPayoff(const Node *n, 
				 const int &pl, 
				 const T prob, 
				       T &payoff) const
{
  if (n->IsTerminal())
    payoff += prob * (*payoffs)(n->GetOutcome()->GetNumber(), pl);
  
  if (n->IsNonterminal() && n->GetPlayer()->IsChance())
    for (int i = 1; i <= n->NumChildren(); i++) {
      IndPayoff(n->GetChild(i), pl,
	     prob * (T) E->GetChanceProb(n->GetInfoset(), i), payoff);
    }
  else if (n->IsNonterminal())
    IndPayoff(n->GetChild((*profile[n->GetPlayer()->GetNumber()])[n->GetInfoset()->GetNumber()]->GetNumber()), pl,
	   prob, payoff);
}
*/

// The following could be shortened by using the player-specific one above.
// Whether this would be more efficient in fact is unknown. - AMM 7.6.98

template <class T>
const T PureBehavProfile<T>::Payoff(const Node *n, const int &pl) const
{
  gArray<T> payoff(E->NumPlayers());
  for (int i = 1; i <= E->NumPlayers(); i++)
    payoff[i] = (T)0;
  Payoff(n, (T)1, payoff);
  return payoff[pl];
}

template <class T>
void PureBehavProfile<T>::Payoff(const Node *n, const T prob, 
				 gArray<T> &payoff) const
{
  if (n->IsTerminal()) {
    for (int pl = 1; pl <= E->NumPlayers(); pl++) {
      payoff[pl] += prob * E->Payoff(E->GetOutcome(n))[pl];
    }
  }
  else {
    if (n->GetPlayer().IsChance()) {
      for (int i = 1; i <= n->NumChildren(); i++) {
	Payoff(n->GetChild(i),
	       prob * (T) E->GetChanceProb(n->GetInfoset(), i), payoff);
      }
    }
    else {
      Payoff(n->GetChild(GetAction(n->GetInfoset())), prob, payoff);
    }
  }
}

template <class T>
void PureBehavProfile<T>::InfosetProbs(Node *n, T prob, gPVector<T> &probs) const
{
  if (n->GetInfoset() && n->GetPlayer().IsChance()) {
    for (int i = 1; i <= n->NumChildren(); i++) {
      InfosetProbs(n->GetChild(i),
		   prob * (T) E->GetChanceProb(n->GetInfoset(), i), probs);
    }
  }
  else if (n->GetInfoset())  {
    probs(n->GetPlayer().GetId(), n->GetInfoset()->GetNumber()) += prob;
    InfosetProbs(n->GetChild((*profile[n->GetPlayer().GetId()])[n->GetInfoset()->GetNumber()].GetId()),
		 prob, probs);
  }
}

template <class T>
void PureBehavProfile<T>::Payoff(gArray<T> &payoff) const
{
  for (int pl = 1; pl <= payoff.Length(); payoff[pl++] = (T) 0);
  Payoff(E->RootNode(), (T) 1, payoff);
}

template <class T>
void PureBehavProfile<T>::InfosetProbs(gPVector<T> &probs) const
{
  ((gVector<T> &) probs).operator=((T) 0);
  InfosetProbs(E->RootNode(), (T) 1, probs);
}

template <class T>
const T PureBehavProfile<T>::Payoff(const gbtEfgOutcome &p_outcome,
				    const int &pl) const
{
  if (!p_outcome.IsNull()) {
    return E->Payoff(p_outcome)[pl];
  }
  else {
    return (T) 0;
  }
}

//-------------------------------------------------------------------------
//   BehavProfile<T>: Constructors, Destructor
//-------------------------------------------------------------------------

template <class T>
BehavProfile<T>::BehavProfile(const BehavProfile<T> &p_profile)
  : gDPVector<T>(p_profile), m_efg(p_profile.m_efg),
    m_support(p_profile.m_support),
    m_cached_data(false),
    m_realizProbs(p_profile.m_realizProbs), m_beliefs(p_profile.m_beliefs),
    m_nvals(p_profile.m_nvals), m_bvals(p_profile.m_bvals),
    m_nodeValues(p_profile.m_nodeValues),
    m_infosetValues(p_profile.m_infosetValues),
    m_actionValues(p_profile.m_actionValues),
    m_gripe(p_profile.m_gripe)
{
  InitProfile();
}

template <class T> BehavProfile<T>::BehavProfile(const EFSupport &p_support) 
  : gDPVector<T>(p_support.NumActions()), 
    m_efg(&p_support.GetGame()),
    m_support(p_support),
    m_cached_data(false),
    m_realizProbs(NumNodes(p_support.GetGame())),
    m_beliefs(NumNodes(p_support.GetGame())),
    m_nvals(NumNodes(p_support.GetGame())), 
    m_bvals(NumNodes(p_support.GetGame())),
    m_nodeValues(NumNodes(p_support.GetGame()),
		 p_support.GetGame().NumPlayers()),
    m_infosetValues(p_support.GetGame().NumInfosets()),
    m_actionValues(p_support.GetGame().NumActions()),
    m_gripe(p_support.GetGame().NumActions())
{
  InitProfile();
  Centroid();
}

template <class T>
BehavProfile<T>::BehavProfile(const MixedProfile<T> &p_profile)
  : gDPVector<T>(p_profile.GetGame().AssociatedEfg()->NumActions()), 
    m_efg(p_profile.GetGame().AssociatedEfg()),
    m_support(*m_efg),  
    m_cached_data(false),
    m_realizProbs(NumNodes(*p_profile.GetGame().AssociatedEfg())),
    m_beliefs(NumNodes(*p_profile.GetGame().AssociatedEfg())),
    m_nvals(NumNodes(*p_profile.GetGame().AssociatedEfg())),
    m_bvals(NumNodes(*p_profile.GetGame().AssociatedEfg())),
    m_nodeValues(NumNodes(*p_profile.GetGame().AssociatedEfg()),
		 p_profile.GetGame().AssociatedEfg()->NumPlayers()),
    m_infosetValues(p_profile.GetGame().AssociatedEfg()->NumInfosets()),
    m_actionValues(p_profile.GetGame().AssociatedEfg()->NumActions()),
    m_gripe(p_profile.GetGame().AssociatedEfg()->NumActions())
{
  //  gout << "\nin BehavProfile(const MixedProfile<T> &p_profile)";

  InitProfile();

  if (m_efg->AssociatedAfg() == &p_profile.GetGame())   {
    ((gVector<T> &) *this).operator=((gVector<T> &) p_profile);
    return;
  }

  ((gVector<T> &) *this).operator=((T)0); 

  Node *n = m_efg->RootNode();
  const gbtNfgSupport &support = p_profile.Support();
  const Nfg &nfg = p_profile.GetGame();

  for (int pl = 1; pl <= nfg.NumPlayers(); pl++)   {
    m_nvals = (T) 0;
    m_bvals = (T) 0;

    for (int st = 1; st <= support.NumStrats(pl); st++)  {
      int snum = support.GetStrategy(pl, st).GetId();
      if (p_profile(pl, st) > (T) 0)  {
	const gArray<int> *const actions = m_efg->GetLexicon()->strategies[pl][snum];

	m_bvals[n->number] = p_profile(pl, st);

	RealizationProbs(p_profile, *m_efg, pl, actions, m_efg->RootNode());
      }
    }
 
    m_nvals[1] = (T) 1;   // set the root nval
    BehaviorStrat(*m_efg, pl, n);
  }
}

template <class T> BehavProfile<T>::~BehavProfile()
{ }

//-------------------------------------------------------------------------
//   BehavProfile<T>: Operator overloading
//-------------------------------------------------------------------------

template <class T>
BehavProfile<T> &BehavProfile<T>::operator=(const BehavProfile<T> &p_profile)
{
  if (this != &p_profile && m_efg == p_profile.m_efg)   {
    Invalidate();
    // note that a dimensionality change will trigger an exception
    // in the gDPVector assignment operator
    gDPVector<T>::operator=(p_profile);
    m_support = p_profile.m_support;
  }
  return *this;
}

template <class T>
bool BehavProfile<T>::operator==(const BehavProfile<T> &p_profile) const
{
  return (m_efg == p_profile.m_efg &&
	  (gDPVector<T> &) *this == (gDPVector<T> &) p_profile);
}

//-------------------------------------------------------------------------
//   BehavProfile<T>: Initialization, Validation
//-------------------------------------------------------------------------

template <class T>
void BehavProfile<T>::InitPayoffs(void) const
{
  m_realizProbs = (T) 0.0;
  m_beliefs = (T) 0.0;
  m_nodeValues = (T) 0.0;
  m_infosetValues = (T) 0.0;
  m_actionValues = (T) 0.0;
  m_gripe = (T) 0.0;
}

template <class T>
void BehavProfile<T>::InitProfile(void)
{
  InitPayoffs();
}

template <class T> void BehavProfile<T>::Centroid(void) const
{
  T center;

  for (int pl = 1; pl <= dvlen.Length(); pl++)
    for (int iset = 1; iset <= dvlen[pl]; iset++)
      if (m_support.NumActions(pl,iset) > 0) {
	center = ((T) 1 / (T) m_support.NumActions(pl, iset));
	int act;
	for (act = 1; act <= svlen[dvidx[pl] + iset - 1]; act++)
	  dvptr[pl][iset][act] = center;
      }
}

//-------------------------------------------------------------------------
//   BehavProfile<T>: General data access -- private functions
//-------------------------------------------------------------------------

template <class T>
T BehavProfile<T>::ActionProb(const gbtEfgAction &action) const
{
  if (action.GetInfoset()->GetPlayer().IsChance()) {
    return m_efg->GetChanceProb(action);
  }
  else if (!m_support.Contains(action)) {
    return (T) 0.0;
  }
  else {
    return (*this)(action.GetInfoset()->GetPlayer().GetId(),
		   action.GetInfoset()->GetNumber(),
		   m_support.GetIndex(action));
  }
}

template <class T>
const T &BehavProfile<T>::RealizProb(const Node *node) const
{
  return m_realizProbs[node->number];
}

template <class T>
T &BehavProfile<T>::RealizProb(const Node *node)
{
  return m_realizProbs[node->number];
}

template <class T>
const T &BehavProfile<T>::BeliefProb(const Node *node) const
{
  return m_beliefs[node->number];
}

template <class T>
T &BehavProfile<T>::BeliefProb(const Node *node)
{
  return m_beliefs[node->number];
}


template <class T>
T BehavProfile<T>::IsetProb(const Infoset *iset) const
{
  T prob = (T) 0;
  for (int i = 1; i <= iset->NumMembers(); i++) {
    prob += RealizProb(iset->GetMember(i));
  }
  return prob;
}

template <class T>
const T &BehavProfile<T>::IsetValue(const Infoset *iset) const
{
  return m_infosetValues(iset->GetPlayer().GetId(), iset->GetNumber());
}

template <class T>
T &BehavProfile<T>::IsetValue(const Infoset *iset)
{
  return m_infosetValues(iset->GetPlayer().GetId(), iset->GetNumber());
}


template <class T> 
const T &BehavProfile<T>::Regret(const gbtEfgAction &act) const
{
  return m_gripe(act.GetInfoset()->GetPlayer().GetId(),
		 act.GetInfoset()->GetNumber(), act.GetId());
}	

template <class T> T &BehavProfile<T>::Regret(const gbtEfgAction &act)
{
  return m_gripe(act.GetInfoset()->GetPlayer().GetId(),
		 act.GetInfoset()->GetNumber(), act.GetId());
}

//-------------------------------------------------------------------------
//   BehavProfile<T>: General data access -- public functions
//-------------------------------------------------------------------------

template <class T>
const T &BehavProfile<T>::GetRealizProb(const Node *node)
{ 
  ComputeSolutionData();
  return RealizProb(node);
}



template <class T>
const T &BehavProfile<T>::GetBeliefProb(const Node *node)
{ 
  ComputeSolutionData();
  return BeliefProb(node);
}

template <class T>
gVector<T> BehavProfile<T>::GetNodeValue(const Node *node)
{ 
  ComputeSolutionData();
  return NodeValues(node);
}

template <class T>
T BehavProfile<T>::GetIsetProb(const Infoset *iset)
{ 
  ComputeSolutionData();
  return IsetProb(iset);
}

template <class T>
const T &BehavProfile<T>::GetIsetValue(const Infoset *iset)
{ 
  ComputeSolutionData();
  return IsetValue(iset);
}

template <class T>
T BehavProfile<T>::GetActionProb(const gbtEfgAction &act) const
{ 
  return ActionProb(act);
}


template <class T>
const T &BehavProfile<T>::GetActionValue(const gbtEfgAction &act) const
{ 
  // Hack to cast away const; ComputeSolutionData() should be
  // const, but some stuff needs fixed before that can happen
  ((BehavProfile *) this)->ComputeSolutionData();
  return ActionValue(act);
}

template <class T>
const T &BehavProfile<T>::GetRegret(const gbtEfgAction &act)
{ 
  ComputeSolutionData();
  return Regret(act);
}

//-------------------------------------------------------------------------
//   BehavProfile<T>: Computation of interesting quantities
//-------------------------------------------------------------------------

//--------------
// Payoff
//--------------


template <class T>
void BehavProfile<T>::Payoff(Node *node, T prob, int player, T &value) const
{
  Infoset * iset = node->infoset;

  if (node->outcome) {
    value += prob * Payoff(gbtEfgOutcome(node->outcome), player);
  }

  if (node->children.Length())  {
    for (gbtActionIterator action(m_support, iset); !action.End(); action++) {
      Payoff(node->GetChild(*action),
	     prob * ActionProb(*action), player, value);
    }
  }
}

template <class T> T BehavProfile<T>::Payoff(int player) const
{
  T value = (T) 0;
  Payoff(m_efg->RootNode(), (T) 1, player, value);
  return value;
}

//---------------
// Derivatives
//---------------

//
// The following routines compute the derivatives of quantities as
// the probability of the action 'p_oppAction' is changed.
// See Turocy (2001), "Computing the Quantal Response Equilibrium
// Correspondence" for details.
// These assume that the profile is interior (totally mixed),
// and that the game is of perfect recall
//

template <class T>
T BehavProfile<T>::DiffActionValue(const gbtEfgAction &p_action,
				   const gbtEfgAction &p_oppAction) const
{
  ((BehavProfile<T> *) this)->ComputeSolutionData();
  T deriv = (T) 0;
  Infoset *infoset = p_action.GetInfoset();
  gbtEfgPlayer player = p_action.GetInfoset()->GetPlayer();

  for (int i = 1; i <= infoset->NumMembers(); i++) {
    Node *member = infoset->GetMember(i);
    deriv += DiffRealizProb(member, p_oppAction) *
      (NodeValue(member->GetChild(p_action.GetId()), player.GetId()) -
       ActionValue(p_action));

    deriv += RealizProb(member) *
      DiffNodeValue(member->GetChild(p_action.GetId()), player, p_oppAction);
  }

  return deriv / IsetProb(p_action.GetInfoset());
}

template <class T>
T BehavProfile<T>::DiffRealizProb(const Node *p_node,
				  const gbtEfgAction &p_oppAction) const
{
  ((BehavProfile<T> *) this)->ComputeSolutionData();
  T deriv = (T) 1;
  bool isPrec = false;
  const Node *node = p_node;
  while (node->GetParent()) {
    gbtEfgAction prevAction = node->GetAction();
    if (prevAction != p_oppAction) {
      deriv *= GetActionProb(prevAction);
    }
    else {
      isPrec = true;
    }
    node = node->GetParent();
  }
 
  return (isPrec) ? deriv : (T) 0.0;
}

template <class T>
T BehavProfile<T>::DiffNodeValue(const Node *p_node, 
				 const gbtEfgPlayer &p_player,
				 const gbtEfgAction &p_oppAction) const
{
  ((BehavProfile<T> *) this)->ComputeSolutionData();

  if (p_node->NumChildren() > 0) {
    Infoset *infoset = p_node->GetInfoset();

    if (infoset == p_oppAction.GetInfoset()) {
      // We've encountered the action; since we assume perfect recall,
      // we won't encounter it again, and the downtree value must
      // be the same.
      return m_nodeValues(p_node->GetChild(p_oppAction.GetId())->number,
			  p_player.GetId());
    }
    else {
      T deriv = (T) 0;
      for (int act = 1; act <= infoset->NumActions(); act++) {
	deriv += (DiffNodeValue(p_node->GetChild(act), p_player, p_oppAction) *
		  ActionProb(infoset->GetAction(act)));
      }
      return deriv;
    }
  }
  else {
    // If we reach a terminal node and haven't encountered p_oppAction,
    // derivative wrt this path is zero.
    return (T) 0;
  }
}

// 
// Computation of Cached solution data
// 

template <class T>
void BehavProfile<T>::ComputeSolutionDataPass2(const Node *node)
{
  if (node->outcome) {
    for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) { 
      m_nodeValues(node->number, pl) += Payoff(node->outcome, pl);
    }
  }

  Infoset * iset = node->infoset;

  if(iset) {
    if (IsetProb(iset) != IsetProb(iset) * (T) 0)
      BeliefProb(node) = RealizProb(node) / IsetProb(iset);
    
    // push down payoffs from outcomes attached to non-terminal nodes 
    for (int child = 1; child <= node->NumChildren(); child++) { 
      m_nodeValues.SetRow(node->GetChild(child)->number, 
			  m_nodeValues.Row(node->number));
    }    

    for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) {
      m_nodeValues(node->number, pl) = (T) 0;
    }

    for (int child = 1; child <= node->NumChildren(); child++)  {
      ComputeSolutionDataPass2(node->GetChild(child));

      //      gVector<T> s = NodeValue(children[child]);

      gbtEfgAction act = node->GetChild(child)->GetAction();

      for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) {
	m_nodeValues(node->number, pl) +=
	  ActionProb(act) * m_nodeValues(node->GetChild(child)->number, pl);
      }

      if (!iset->IsChanceInfoset()) {
	T &cpay = ActionValue(act);
	if (IsetProb(iset) != IsetProb(iset) * (T) 0) {
	  cpay += BeliefProb(node) * m_nodeValues(node->GetChild(child)->number, iset->GetPlayer().GetId());
	}
	else {
	  cpay = (T) 0;
	}
      }
    }
  }
}

// compute realization probabilities for nodes and isets.  
template <class T>
void BehavProfile<T>::ComputeSolutionDataPass1(const Node *node)
{
  if (node->GetParent()) {
    RealizProb(node) = RealizProb(node->GetParent()) * ActionProb(node->GetAction());
  }
  else {
    RealizProb(node) = (T) 1;
  }
  
  if (node->GetInfoset()) {
    for (int i = 1; i <= node->NumChildren(); i++) {
      ComputeSolutionDataPass1(node->GetChild(i));
    }
  }
}

template <class T>
void BehavProfile<T>::ComputeSolutionData(void)
{
  if (!m_cached_data) {
    m_actionValues = (T) 0;
    m_nodeValues = (T) 0;
    m_infosetValues = (T) 0;
    m_gripe = (T) 0;
    ComputeSolutionDataPass1(m_efg->RootNode());
    ComputeSolutionDataPass2(m_efg->RootNode());

    for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) {
      for (int iset = 1; iset <= m_efg->NumInfosets()[pl]; iset++) {
	Infoset *infoset = m_efg->GetPlayer(pl).GetInfoset(iset);

	IsetValue(infoset) = (T) 0;
	for (int act = 1; act <= infoset->NumActions(); act++) {
	  gbtEfgAction action = infoset->GetAction(act);
	  IsetValue(infoset) += ActionProb(action) * ActionValue(action);
	}

	for (int act = 1; act <= infoset->NumActions(); act++) {
	  gbtEfgAction action = infoset->GetAction(act);
	  Regret(action) = (ActionValue(action) - IsetValue(infoset)) * IsetProb(infoset);
	}
      }
    }
    m_cached_data = true;
  }
}

template <class T>
void BehavProfile<T>::BehaviorStrat(const efgGame &E, int pl,
				    Node *n)
{
  for (int i = 1; i <= n->children.Length(); i++)   {
    Node *child = n->children[i];
    if (!n->GetPlayer().IsNull() && n->GetPlayer().GetId() == pl)
      if (m_nvals[n->number] > (T) 0 && 
	  m_nvals[child->number] > (T) 0)  {
	(*this)(n->GetPlayer().GetId(),
		n->GetInfoset()->GetNumber(), 
		Support().GetIndex(n->GetInfoset()->GetAction(i))) =
	  m_nvals[child->number] / m_nvals[n->number];
      }
    BehaviorStrat(E, pl, child);
  }
}

template <class T>
void BehavProfile<T>::RealizationProbs(const MixedProfile<T> &mp,
				       const efgGame &E, int pl,
				       const gArray<int> *const actions,
				       Node *node)
{
  static const T tremble = (T) 0;
  T prob;

  for (int i = 1; i <= node->children.Length(); i++)   {
    if (!node->GetPlayer().IsNull() && !node->GetPlayer().IsChance())   {
      if (node->GetPlayer().GetId() == pl)  {
	if ((*actions)[node->GetInfoset()->GetNumber()] == i)
	  prob = (T) 1 - tremble + tremble / (T) node->NumChildren();
	else
	  prob = tremble / (T) node->NumChildren();
      }
      else if (Support().Contains(node->GetInfoset()->GetAction(i)))
	prob = (T) 1 / (T) Support().NumActions(node->GetPlayer().GetId(),
						node->GetInfoset()->GetNumber());
      else
	prob = (T) 0;
    }
    else  {   // n.GetPlayer() == 0
      prob = E.GetChanceProb(node->GetInfoset(), i).operator gRational();
    }

    Node *child = node->children[i];
    m_bvals[child->number] = prob * m_bvals[node->number];
    m_nvals[child->number] += m_bvals[child->number];

    RealizationProbs(mp, E, pl, actions, child);
  }    
	
}

template <class T> gDPVector<T> BehavProfile<T>::Beliefs(void)
{
  ComputeSolutionData();
  gDPVector<T> bprobs(m_efg->NumMembers());
  bprobs = (T) 0;

  for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) {
    gbtEfgPlayer player = m_efg->GetPlayer(pl);
    for (int iset = 1; iset <= player.NumInfosets(); iset++) {
      Infoset *infoset = player.GetInfoset(iset);
      for (int i = 1; i <= infoset->NumMembers(); i++) 
	bprobs(player.GetId(),infoset->GetNumber(),i) = 
	  BeliefProb(infoset->GetMember(i));
    }
  }

  return bprobs;
}

template <class T> T BehavProfile<T>::LiapValue(bool p_penalty)
{
  static const T BIG1 = (T) 10000;
  static const T BIG2 = (T) 100;

  T x, result = ((T) 0), avg, sum;
  
  // HACK: force it to recompute data.  FIX THIS.
  m_cached_data = false;
  ComputeSolutionData();

  for (int i = 1; i <= m_efg->NumPlayers(); i++) {
    for (int iset = 1; iset <= m_efg->GetPlayer(i).NumInfosets(); iset++) {
      Infoset *infoset = m_efg->GetPlayer(i).GetInfoset(iset);
      avg = sum = (T)0;

      for (gbtActionIterator action(m_support, infoset);
	   !action.End(); action++) {
	x = ActionProb(*action);
	avg += x * ActionValue(*action);
	sum += x;
	if (x > (T)0)  x = (T)0;
	if (p_penalty) {
	  // add penalty for negative probabilities
	  result += BIG1 * x * x;
	}
      }

      for (gbtActionIterator action(m_support, infoset); 
	   !action.End(); action++) {
	x = ActionValue(*action) - avg;
	if (x < (T)0) x = (T)0;
	result += x * x;          // add penalty if not best response
      }
      x = sum - (T)1;
      if (p_penalty) {
	// add penalty for sum not equal to 1
	result += BIG2 * x * x;      
      }
    }
  }
  return result;
}

template <class T> T BehavProfile<T>::QreValue(const gVector<T> &lambda, bool &_domain_err)
{
  static const T PENALTY = (T)10000;
  T BigNum = (T)500;
  
  //  gDPVector<T> _cpay(m_support.NumActions());

  T val = (T)0, prob, psum, z,factor;

  // HACK: force it to recompute data.  FIX THIS.
  m_cached_data = false;
  ComputeSolutionData();

  for (int pl = 1; pl <= m_efg->NumPlayers(); pl++)  {
    for (int iset = 1; iset <= m_efg->GetPlayer(pl).NumInfosets(); iset++)  {
      Infoset *infoset = m_efg->GetPlayer(pl).GetInfoset(iset);
      prob = (T)0;
      psum = (T)0;

      for (gbtActionIterator action(m_support, infoset);
	   !action.End(); action++)  {
	z = lambda[pl] * ActionValue(*action);
	factor=(T)1;
	if(z>BigNum) {factor+=z-BigNum;z=BigNum;_domain_err=true;}
	if(z<-BigNum) {factor+=z+BigNum;z=-BigNum;_domain_err=true;}
	z = ((T)exp(z))*factor;
	psum += z;
	//	_cpay(pl,iset,act) = z;
	ActionValue(*action) = z;
      }
      
      for (gbtActionIterator action(m_support, infoset);
	   !action.End(); action++) {
	z = ActionProb(*action);
	prob += z;
	if (z < (T)0)
	  val += PENALTY * z * z;
	z -= ActionValue(*action) / psum;
	//	z -= _cpay(pl,iset,act) / psum;
	val += z * z;
      }
      z = (T)1 - prob;
      val += (T)100 * z * z;
    }
  }

  // HACK: this procedure screws up action values.  FIX THIS.
  m_cached_data = false;

  return val;
}

template <class T>
T BehavProfile<T>::MaxRegret(void)
{ 
  ComputeSolutionData();
  T ret = (T) 0;
  for (int act = 1; act <= m_gripe.Length(); act++) {
    if (m_gripe[act] > ret) {
      ret = m_gripe[act];
    }
  }
  return ret;
}


template <class T> void BehavProfile<T>::Dump(gOutput &p_file) const
{
  gDPVector<T>::Dump(p_file);
}



template <class T> BehavProfile<T>::BadStuff::~BadStuff()
{ }

template <class T> gText BehavProfile<T>::BadStuff::Description(void) const
{
  return "Solution not installed in BehavProfile";
}

//-----------------
//   Output
//-----------------

template <class T> gOutput &operator<<(gOutput &p_file,
				       const BehavProfile<T> &p_profile)
{
  p_profile.Dump(p_file);
  return p_file;
}

//------------------------------------------------------------------------
//  BehavAssessment<T>: Constructors, Destructor, Constructive Operators
//------------------------------------------------------------------------

template <class T>
BehavAssessment<T>::BehavAssessment(const EFSupport &p_support)
  : BehavProfile<T>(p_support), m_beliefs(p_support.GetGame().NumMembers())
{
  m_beliefs = BehavProfile<T>::Beliefs();
}

template <class T>
BehavAssessment<T>::BehavAssessment(const BehavProfile<T> &p_profile)
  : BehavProfile<T>(p_profile), m_beliefs(p_profile.GetGame().NumMembers())
{ 
  m_beliefs = BehavProfile<T>::Beliefs();
}

template <class T>
BehavAssessment<T>::BehavAssessment(const BehavAssessment<T> &p_assess)
  : BehavProfile<T>(p_assess), m_beliefs(p_assess.m_beliefs)
{ }

template <class T> BehavAssessment<T>::~BehavAssessment()
{ }

template <class T> BehavAssessment<T> &
BehavAssessment<T>::operator=(const BehavAssessment<T> &p_assess)
{
  if (this != &p_assess && &GetGame() == &p_assess.GetGame()) {
    BehavProfile<T>::operator=(p_assess);
    m_beliefs = p_assess.m_beliefs;
  }
  return *this;
}

//------------------------------------------------------------------------
//        BehavAssessment<T>: Access and manipulation of beliefs
//------------------------------------------------------------------------

template <class T> gDPVector<T> BehavAssessment<T>::Beliefs(void) const
{ return m_beliefs; }

template <class T> gDPVector<T> &BehavAssessment<T>::Beliefs(void)
{ return m_beliefs; }

//----------------
// CondPayoff
//----------------

template <class T>
void BehavAssessment<T>::CondPayoff(Node *p_node,
				    T p_prob,
				    gPVector<T> &p_probs,
				    gDPVector<T> &p_payoff) const
{
  int npl =
    (p_node->GetInfoset()) ? p_node->GetPlayer().GetId() : -1;
  int iset = 
    (p_node->GetInfoset()) ? p_node->GetInfoset()->GetNumber() : 0;
  
  if (p_node->outcome) {
    for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) { 
      m_nodeValues(p_node->number, pl) +=
	Payoff(p_node->outcome, pl);
    }
  }

  int nc = p_node->children.Length();
  for (int child = 1; child <= nc; child++) {
    m_nodeValues.SetRow(p_node->children[child]->number,
			m_nodeValues.Row(p_node->number));
  }
  
  gVector<T> tmp(m_efg->NumPlayers());
  tmp = (T) 0;
  
  if (nc == 0)   return;

  if (npl == 0)   {
    for (int child = 1; child <= nc; child++)  {
      CondPayoff(p_node->children[child],
		 p_prob *
		 ActionProb(p_node->GetChild(child)->GetAction()),
		 //		 ChanceProb(p_node->GetInfoset(),child),
		 p_probs, p_payoff);
      
      for (int pl = 1; pl <= m_efg->NumPlayers(); pl++)
	tmp[pl] += 
	  ActionProb(p_node->GetChild(child)->GetAction()) *
	  //	  ChanceProb(p_node->GetInfoset(), child) *
	  m_nodeValues(p_node->GetChild(child)->number, pl);
    }
    m_nodeValues.SetRow(p_node->number, tmp);
  }
  else  {    // player decision node
    // This implementation differs from the one in BehavProfile<T>
    // since we have well-defined belief probabilities off the equilibrium
    // path.  So, we must traverse the whole tree, and cannot ignore
    // the (zero-probability) actions which do not appear in the support
    for (int child = 1; child <= p_node->NumChildren(); child++) {
      int act = m_support.GetIndex(p_node->GetInfoset()->GetAction(child));
      T newprob;
      if (act)
	newprob = (*this)(npl, iset, act);
      else
	newprob = (T) 0;
      CondPayoff(p_node->children[child], p_prob * newprob,
		 p_probs, p_payoff);
      for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) {
	tmp[pl] += newprob * m_nodeValues(p_node->children[child]->number, pl);
      }
      
      int mnum;
      for (mnum = 1;
	   p_node->GetInfoset()->GetMember(mnum) != p_node;
	   mnum++);
      p_payoff(npl, iset, child) += 
	m_beliefs(npl, iset, mnum) * m_nodeValues(p_node->children[child]->number, npl);
      m_nodeValues.SetRow(p_node->number, tmp);
    }
  }    
  
  if (npl > 0) {
    p_probs(npl, p_node->GetInfoset()->GetNumber()) += p_prob;
  }
}


template <class T>
void BehavAssessment<T>::CondPayoff(gDPVector<T> &p_payoff,
				    gPVector<T> &p_probs) const
{
  ((gVector<T> &) p_payoff).operator=((T) 0);
  ((gVector<T> &) p_probs).operator=((T) 0);

  for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) {
    m_nodeValues(1, pl) = (T) 0;
  }
  CondPayoff(m_efg->RootNode(), (T) 1, p_probs, p_payoff);

  // We can dispense with the normalization step found in the analogous
  // place in BehavProfile<T> since the beliefs are assumed to be 
  // normalized to sum to 1.  (If they don't, things are weird anyway.)
}

//------------------------------------------------------------------------
//                     BehavAssessment<T>: Output
//------------------------------------------------------------------------

template <class T> void BehavAssessment<T>::Dump(gOutput &p_file) const
{
  BehavProfile<T>::Dump(p_file);
  p_file << ' ';
  p_file << m_beliefs;
}

template <class T> gOutput &operator<<(gOutput &p_file,
				       const BehavAssessment<T> &p_assess)
{
  p_assess.Dump(p_file);
  return p_file;
}


