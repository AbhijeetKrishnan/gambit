//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Compute dominated mixed strategies on normal forms
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include "base/gnullstatus.h"

template <class T>
bool ComputeMixedDominated(const gbtNfgSupport &S, gbtNfgSupport &R,
			   int pl, bool strong, T /*junk*/,
			   gbtOutput &tracefile, gbtStatus &status)
{
  gbtNfgContIterator s(S);

  double d1,d2;
  d1 = (double) (pl-1) / (double) S->NumPlayers();
  d2 = (double) pl / (double) S->NumPlayers();
  
  gbtArray<bool> dom(S->GetPlayer(pl)->NumStrategies());
  
  T eps;
  gEpsilon(eps);
  
  gbtVector<T> dominator(S->GetPlayer(pl)->NumStrategies());
  
  int st,i,k,n;
  
  if (strong)   {
    T COpt;
    bool ret = false;
    int strats = S->GetPlayer(pl)->NumStrategies();
    int contingencies = 1;
    for (k = 1; k <= S->NumPlayers(); k++) {
      if(k!=pl) contingencies*=S->GetPlayer(k)->NumStrategies();
    }
    
    gbtMatrix<T> A(1,contingencies+1,1,strats);
    gbtVector<T> B(1,contingencies+1);
    gbtVector<T> C(1,strats);
    
    n = contingencies + 1;
    for (k = 1; k < strats; k++) {
      C[k] = (T) 0;
      A(n, k) = (T) 1;
    }
    A(n, k) = (T) 0;
    B[n] = (T) 1;
    C[k] = (T) 1;
    
    s.First();
    for (n = 1; n <= contingencies; n++) {
      s.Freeze(S->GetPlayer(pl)->GetStrategy(1));
      B[n] = -s.GetPayoff(S->GetPlayer(pl));
      for (k = 2; k <= strats; k++) {
	s.Next(S->GetPlayer(pl));
	A(n, k - 1) = -s.GetPayoff(S->GetPlayer(pl));
      }
      A(n, strats) = (T) 1;
      s.NextContingency();
    }
    
    for (k = 1; k <= strats; k++) {
      status.Get();
      double s1 = (double)k/(double)(strats);
      status.SetProgress((1.0-s1)*d1 + s1*d2);
      // tracefile << '\n' << (gbtRectArray<T> &)A << '\n';
      // tracefile << B << '\n';
      // tracefile << C << '\n';
      gbtLPSolver<T> Tab(A, B, C, 1, status);
      
      COpt = Tab.OptimumCost();
      tracefile << "\nPlayer = " << pl << " Strat = "<< k;
      // tracefile << " F = " << Tab.IsFeasible();
      // tracefile << " x = " << Tab.OptimumVector();
      // tracefile << " Obj = " << COpt;
      
      dom[k] = false;
      
      if (Tab.IsFeasible() && COpt > eps) {
	tracefile << " Strongly Dominated by ";
	gbtVector<T> xx(Tab.OptimumVector());
	for(i=1,st=1;st<=strats;st++) {
	  if(st==k) dominator[st] = (T)0;
	  else {
	    dominator[st] = xx[i];
	    i++;
	  }
	}
	tracefile << dominator;
	ret = true;
	dom[k] = true;
      }
      if (k<strats)
	A.SwitchColumn(k,B);
    }
    // tracefile << "\n";
    
    if (!ret) 
      return false;
    
    for (k = 1; k <= strats; k++) {
      if (dom[k]) {
	R->RemoveStrategy(S->GetPlayer(pl)->GetStrategy(k));
      }
    }
    
    return true;
  }
  else  {    // look for weak domination
    T C0 = (T) 0, COpt, TmpC;
    bool ret = false;
    int strats = S->GetPlayer(pl)->NumStrategies();
    int contingencies = 1;
    for (k = 1; k <= S->NumPlayers(); k++) {
      if (k != pl) {
	contingencies *= S->GetPlayer(k)->NumStrategies();
      }
    }
    
    gbtMatrix<T> A(1,contingencies+1,1,strats-1);
    gbtVector<T> B(1,contingencies+1);
    gbtVector<T> C(1,strats-1);
    
    n=contingencies+1;
    for(k=1;k<strats;k++) {
      C[k] = (T) 0;
      A(n,k)=(T) 1;
    }
    B[n]=(T)1;
    
    s.First();
    for(n=1;n<=contingencies;n++) {
      s.Freeze(S->GetPlayer(pl)->GetStrategy(1));
      B[n]=-s.GetPayoff(S->GetPlayer(pl));
      C0 -= B[n];
      for(k=2;k<=strats;k++) {
	s.Next(S->GetPlayer(pl));
	A(n,k-1)=-s.GetPayoff(S->GetPlayer(pl));
	C[k-1]-=A(n,k-1);
      }
      s.NextContingency();
    }
    
    for (k = 1; k <= strats; k++) {
      status.Get();
      double s1 = (double)k/(double)(strats);
      status.SetProgress((1.0-s1)*d1 + s1*d2);
      // tracefile << '\n' << (gbtRectArray<T> &)A << '\n';
      // tracefile << B << '\n';
      // tracefile << C << '\n';
      gbtLPSolver<T> Tab(A, B, C, 1, status);
      
      COpt = Tab.OptimumCost();
      tracefile << "\nPlayer = " << pl << " Strat = "<< k;
      // tracefile << " F = " << Tab.IsFeasible();
      // tracefile << " x = " << Tab.OptimumVector();
      // tracefile << " Obj = " << COpt;
      
      dom[k] = false;
      
      if (Tab.IsFeasible() && (COpt >= C0-eps && COpt <=C0+eps))
	tracefile << " Duplicated strategy? ";
      else if (Tab.IsFeasible() && COpt > C0+eps) {
	tracefile << " Weakly Dominated by ";
	gbtVector<T> xx(Tab.OptimumVector());
	for(i=1,st=1;st<=strats;st++) {
	  if(st==k) dominator[st] = (T)0;
	  else {
	    dominator[st] = xx[i];
	    i++;
	  }
	}
	tracefile << dominator;
	ret = true;
	dom[k] = true;
      }
      // else  tracefile << "\n\n";
      if(k<strats) {
	A.SwitchColumn(k,B);
	TmpC=C0; C0=C[k]; C[k]=TmpC;
      }
      
    }
    // tracefile << "\n";
    
    if (!ret) 
      return false;
    
    for (k = 1; k <= strats; k++) {
      if (dom[k]) {
	R->RemoveStrategy(S->GetPlayer(pl)->GetStrategy(k));
      }
    }
    
    return true;
  }
  
}

template <class T>
bool IsMixedDominated(const gbtNfgSupport &S, gbtGameStrategy str,
		      bool strong, T /*junk*/,
		      gbtOutput &tracefile)
{
  int pl = str->GetPlayer()->GetId();
  int whichstrat = str->GetId();
  int strats = S->GetPlayer(pl)->NumStrategies();

  gbtNfgContIterator s(S);
    
  T eps;
  gEpsilon(eps);
  
  gbtVector<T> dominator(S->GetPlayer(pl)->NumStrategies());
  
  int st,i,k,n;
  bool ret = false;
  int contingencies = 1;
  for (k = 1; k <= S->NumPlayers(); k++) {
    if (k != pl) {
      contingencies *= S->GetPlayer(k)->NumStrategies();
    }
  }  
  
  if (strong)   {
    T COpt;
    gbtMatrix<T> A(1,contingencies+1,1,strats);
    gbtVector<T> B(1,contingencies+1);
    gbtVector<T> C(1,strats);
    
    n = contingencies + 1;
    for (k = 1; k < strats; k++) {
      C[k] = (T) 0;
      A(n, k) = (T) 1;
    }
    A(n, k) = (T) 0;
    B[n] = (T) 1;
    C[k] = (T) 1;
    
    s.First();
    for (n = 1; n <= contingencies; n++) {
      s.Freeze(S->GetPlayer(pl)->GetStrategy(whichstrat));
      B[n] = -s.GetPayoff(S->GetPlayer(pl));
      for (k = 1; k <= strats; k++) 
	if (k< whichstrat) {
	  s.Freeze(S->GetPlayer(pl)->GetStrategy(k));
	  A(n, k) = -s.GetPayoff(S->GetPlayer(pl));
	}
	else if (k > whichstrat) {
	  s.Freeze(S->GetPlayer(pl)->GetStrategy(k));
	  A(n, k - 1) = -s.GetPayoff(S->GetPlayer(pl));
	}
      A(n, strats) = (T) 1;
      s.NextContingency();
    }
    
    // tracefile << '\n' << (gbtRectArray<T> &)A << '\n';
    // tracefile << B << '\n';
    // tracefile << C << '\n';
    gbtNullStatus status;
    gbtLPSolver<T> Tab(A, B, C, 1, status);
    COpt = Tab.OptimumCost();
    tracefile << "\nPlayer = " << pl << " Strat = "<< whichstrat;
    // tracefile << " F = " << Tab.IsFeasible();
    // tracefile << " x = " << Tab.OptimumVector();
    // tracefile << " Obj = " << COpt;
    
    if (Tab.IsFeasible() && COpt > eps) {
      tracefile << " Strongly Dominated by ";
      gbtVector<T> xx(Tab.OptimumVector());
      for(i=1,st=1;st<=strats;st++) {
	if(st==whichstrat) dominator[st] = (T)0;
	else {
	  dominator[st] = xx[i];
	  i++;
	}
      }
      tracefile << dominator;
      ret = true;
    }
    // tracefile << "\n";
    
    if (!ret) 
      return false;
    
    return true;
  }
  else  {    // look for weak domination
    T C0 = (T) 0, COpt;

    gbtMatrix<T> A(1,contingencies+1,1,strats-1);
    gbtVector<T> B(1,contingencies+1);
    gbtVector<T> C(1,strats-1);
    
    n=contingencies+1;
    for(k=1;k<strats;k++) {
      C[k] = (T) 0;
      A(n,k)=(T) 1;
    }
    B[n]=(T)1;
    
    s.First();
    for(n=1;n<=contingencies;n++) {
      s.Freeze(S->GetPlayer(pl)->GetStrategy(whichstrat));
      B[n]=-s.GetPayoff(S->GetPlayer(pl));
      C0 -= B[n];
      for(k=1;k<=strats;k++) 
	if(k<whichstrat) {
	  s.Freeze(S->GetPlayer(pl)->GetStrategy(k));
	  A(n,k)=-s.GetPayoff(S->GetPlayer(pl));
	  C[k]-=A(n,k);
	}
	else if (k > whichstrat) {
	  s.Freeze(S->GetPlayer(pl)->GetStrategy(k));
	  A(n,k-1)=-s.GetPayoff(S->GetPlayer(pl));
	  C[k-1]-=A(n,k-1);
	}
      s.NextContingency();
    }
    
    // tracefile << '\n' << (gbtRectArray<T> &)A << '\n';
    // tracefile << B << '\n';
    // tracefile << C << '\n';
    gbtNullStatus status;
    gbtLPSolver<T> Tab(A, B, C, 1, status);
    
    COpt = Tab.OptimumCost();
    tracefile << "\nPlayer = " << pl << " Strat = "<< whichstrat;
    // tracefile << " F = " << Tab.IsFeasible();
    // tracefile << " x = " << Tab.OptimumVector();
    // tracefile << " Obj = " << COpt;
    
    if (Tab.IsFeasible() && (COpt >= C0-eps && COpt <=C0+eps))
      tracefile << " Duplicated strategy? ";
    else if (Tab.IsFeasible() && COpt > C0+eps) {
      tracefile << " Weakly Dominated by ";
      gbtVector<T> xx(Tab.OptimumVector());
      for(i=1,st=1;st<=strats;st++) {
	if(st==whichstrat) dominator[st] = (T)0;
	else {
	  dominator[st] = xx[i];
	  i++;
	}
      }
      tracefile << dominator;
      ret = true;
    }
    // else  tracefile << "\n\n";
    // tracefile << "\n";
    
    if (!ret) 
      return false;
    
    return true;
  }
  
}

#include "game/mixed.h"

template <class T>
bool IsMixedDominated(const gbtMixedProfile<T> &pr, int pl,
		      bool strong, gbtOutput &tracefile)
{
  int strats = pr->GetPlayer(pl)->NumStrategies();
  gbtVector<T> prob = pr->GetStrategy(pr->GetPlayer(pl));
  assert( prob.Length() == strats);

  gbtNfgContIterator s(pr);
  
  T eps,x;
  gEpsilon(eps);
  
  gbtVector<T> dominator(pr->GetPlayer(pl)->NumStrategies());
  
  int st,i,k,n;
  bool ret = false;
  int contingencies = 1;
  for (k = 1; k <= pr->NumPlayers(); k++) {
    if(k!=pl) contingencies *= pr->GetPlayer(k)->NumStrategies();
  }
  
  if (strong)   {
    T COpt;
    gbtMatrix<T> A(1,contingencies+1,1,strats+1);
    gbtVector<T> B(1,contingencies+1);
    gbtVector<T> C(1,strats+1);
    
    n = contingencies + 1;
    for (k = 1; k <= strats; k++) {
      C[k] = (T) 0;
      A(n, k) = (T) 1;
    }
    A(n, k) = (T) 0;
    B[n] = (T) 1;
    C[k] = (T) 1;
    
    s.First();
    for (n = 1; n <= contingencies; n++) {
      B[n]=(T)0;
      for(int j=1;j<=strats;j++) {
	s.Freeze(pr->GetPlayer(pl)->GetStrategy(j));
	T x1 = s.GetPayoff(pr->GetPlayer(pl));
	T x2 = prob[j];
	x = -x1*x2;
	B[n] += -s.GetPayoff(pr->GetPlayer(pl));
      }
      for (k = 1; k <= strats; k++) {
	s.Freeze(pr->GetPlayer(pl)->GetStrategy(k));
	A(n, k) = -s.GetPayoff(pr->GetPlayer(pl));
      }
      A(n, strats+1) = (T) 1;
      s.NextContingency();
    }
    // tracefile << '\n' << (gbtRectArray<T> &)A << '\n';
    // tracefile << B << '\n';
    // tracefile << C << '\n';
    gbtNullStatus status;
    gbtLPSolver<T> Tab(A, B, C, 1, status);
    COpt = Tab.OptimumCost();
    tracefile << "\nPlayer = " << pl << " Strat: " << prob;
    // tracefile << " F = " << Tab.IsFeasible();
    // tracefile << " x = " << Tab.OptimumVector();
    // tracefile << " Obj = " << COpt;
    
    if (Tab.IsFeasible() && COpt > eps) {
      tracefile << " Strongly Dominated by ";
      gbtVector<T> xx(Tab.OptimumVector());
      for(i=1,st=1;st<=strats;st++) {
	dominator[st] = xx[i];
	i++;
      }
      tracefile << dominator;
      ret = true;
    }
    // tracefile << "\n";
    
    if (!ret) 
      return false;
    
    return true;
  }
  else  {    // look for weak domination
    T C0 = (T) 0, COpt;

    gbtMatrix<T> A(1,contingencies+1,1,strats);
    gbtVector<T> B(1,contingencies+1);
    gbtVector<T> C(1,strats);
    
    n=contingencies+1;
    for(k=1;k<=strats;k++) {
      C[k] = (T) 0;
      A(n,k)=(T) 1;
    }
    B[n]=(T)1;
    
    s.First();
    for(n=1;n<=contingencies;n++) {
      B[n]=(T)0;
      for(int j=1;j<=strats;j++) {
	s.Freeze(pr->GetPlayer(pl)->GetStrategy(j));
	T x1 = s.GetPayoff(pr->GetPlayer(pl));
	T x2 = prob[j];
	x = - x1 * x2;
	// x=-nfg->Payoff(s.GetOutcome(), pl)*prob[j];
	B[n]+=x;
	C0 -= x;
      }
      for(k=1;k<=strats;k++) {
	s.Freeze(pr->GetPlayer(pl)->GetStrategy(pl));
	x=-s.GetPayoff(pr->GetPlayer(pl));
	A(n,k)=x;
	C[k]-=x;
      }
      s.NextContingency();
    }
    
    // tracefile << '\n' << (gbtRectArray<T> &)A << '\n';
    // tracefile << B << '\n';
    // tracefile << C << '\n';
    gbtNullStatus status;
    gbtLPSolver<T> Tab(A, B, C, 1, status);
    
    COpt = Tab.OptimumCost();
    tracefile << "\nPlayer = " << pl << " Strat: " << prob;
    // tracefile << " F = " << Tab.IsFeasible();
    // tracefile << " x = " << Tab.OptimumVector();
    // tracefile << " Obj = " << COpt;
    
    //if (Tab.IsFeasible() && (COpt >= C0-eps && COpt <=C0+eps))
    //  tracefile << " Duplicated strategy? ";
    // else 
    if (Tab.IsFeasible() && COpt > C0+eps) {
      tracefile << " Weakly Dominated by ";
      gbtVector<T> xx(Tab.OptimumVector());
      for(i=1,st=1;st<=strats;st++) {
	dominator[st] = xx[i];
	i++;
      }
      tracefile << dominator;
      ret = true;
    }
    // else  tracefile << "\n\n";
    // tracefile << "\n";
    
    if (!ret) 
      return false;
    
    return true;
  }
}
