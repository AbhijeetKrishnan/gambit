//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of mixed strategy profile classes
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include "nfgsupport.h"
#include "mixed.h"
#include "gamebase.h"

//---------------------------------------------------------------------------
//                    gbtMixedProfile<T> member functions
//---------------------------------------------------------------------------

template <class T> gbtMixedProfile<T>::gbtMixedProfile(const gbtNfgSupport &s)
  : gbtPVector<T>(s.NumStrategies()), m_nfg(s.GetGame()), support(s)
{
  Centroid();
}

template <class T> gbtMixedProfile<T>::gbtMixedProfile(const gbtMixedProfile<T> &p)
  : gbtPVector<T>(p), m_nfg(p.m_nfg), support(p.support)
{ }

template <class T> gbtMixedProfile<T>::~gbtMixedProfile()
{
}

template <class T>
gbtMixedProfile<T> &gbtMixedProfile<T>::operator=(const gbtMixedProfile<T> &p)
{
  if (this != &p && m_nfg == p.m_nfg)   {
    // note that a dimensionality change will trigger a failed assertion
    // in the gbtPVector assignment operator
    support = p.support;
    gbtPVector<T>::operator=(p);
  }
  return *this;
}

template <class T> void gbtMixedProfile<T>::Centroid(void) 
{
  T center;
  
  for (int i = 1; i <= m_nfg->NumPlayers(); i++)  {
    center = ((T) 1) / ((T) support.NumStrats(i));
    for (int j = 1; j <= support.NumStrats(i); j++)
      svptr[i][j] = center;
  }
}

template <class T> T gbtMixedProfile<T>::LiapValue(void) const
{
  static const T BIG1 = (T) 100;
  static const T BIG2 = (T) 100;

  gbtMixedProfile<T> p(*this);
  ((gbtVector<T> &) p).operator=(*this);
  gbtMixedProfile<T> tmp(p);
  gbtPVector<T> payoff(p);
  T x, result((T) 0), avg, sum;
  payoff = (T) 0;

  for (int i = 1; i <= m_nfg->NumPlayers(); i++) {
    tmp.CopyRow(i, payoff);
    avg = sum = (T) 0;
    // then for each strategy for that player set it to 1 and evaluate
    int j;
    for (j = 1; j <= p.Support().NumStrats(i); j++) {
      tmp(i, j) = (T) 1;
      x = p(i, j);
      payoff(i, j) = tmp.Payoff(i);
      avg += x * payoff(i, j);
      sum += x;
      if (x>(T)0) x=0;
      result += BIG1*x*x;         // add penalty for neg probabilities
      tmp(i,j) = (T) 0;
    }
    tmp.CopyRow(i, p);
    for(j=1;j<=p.Support().NumStrats(i);j++) {
      x=payoff(i,j)-avg;
      if (x<=(T)0) x=(T)0;
      result += x*x;          // add penalty if not best response
    }
    x=sum - ((T) 1);
    result += BIG2*x*x ;          // add penalty for sum not equal to 1
  }
  return result;
}

template <class T> void gbtMixedProfile<T>::Regret(gbtPVector<T> &value) const
{
  int i, j;
  T pay,x;
  
  for (i = 1; i <= m_nfg->NumPlayers(); i++) {
    pay = Payoff(i);
    for (j = 1; j <= m_nfg->NumStrats(i); j++) {
      x = Payoff(i, m_nfg->GetPlayer(i)->GetStrategy(j));
      if(x > pay)
	value(i, j) = x - pay;
      // use pay - pay instead of zero for correct precision
      else value(i,j) = pay - pay; 
    }
  }
}

template <class T> T gbtMixedProfile<T>::MaxRegret(void) const
{
  int i;
  T maxgripe = (T)0;

  gbtPVector<T> v(m_nfg->NumStrategies());
  Regret(v);
  for(i=v.First(); i<=v.Last(); i++)
    if(v[i] > maxgripe) maxgripe = v[i];
  return maxgripe;
}

template <class T> T gbtMixedProfile<T>::Payoff(int pl) const
{
  if (dynamic_cast<gbtGameBase *>(m_nfg.Get())->m_results.Length() > 0) {
    return PPayoff(pl, 1, 1);
  }
  else {
    return gbtBehavProfile<T>(*this).Payoff(pl);
  }
}

template <class T> T
gbtMixedProfile<T>::Payoff(int pl, gbtGameStrategy strategy) const
{
  if (dynamic_cast<gbtGameBase *>(m_nfg.Get())->m_results.Length() > 0) {
    T value = (T) 0;
    PPayoff(pl, strategy->GetPlayer()->GetId(), strategy->GetId(), 1,
	    strategy->GetIndex() + 1, (T) 1, value);
    return value;
  }
  else {
    gbtMixedProfile<T> foo(*this);
    for (int st = 1; st <= support.NumStrats(strategy->GetPlayer()->GetId());
	 foo(strategy->GetPlayer()->GetId(), st++) = 0);
    foo(strategy->GetPlayer()->GetId(), support.GetIndex(strategy)) = 1;
    return gbtBehavProfile<T>(foo).Payoff(pl);
  }
}

template <class T> T
gbtMixedProfile<T>::Payoff(int pl, 
			int player1, int strat1, 
			int player2, int strat2) const
{
  if (player1 == player2) return (T) 0;
  if (dynamic_cast<gbtGameBase *>(m_nfg.Get())->m_results.Length() > 0) {
    T value = (T) 0;
    PPayoff(pl, player1, strat1, player2, strat2, 1,
	    support.GetStrategy(player1, strat1)->GetIndex() +
	    support.GetStrategy(player2, strat2)->GetIndex() + 1,
	    (T) 1, value);
    return value;
  }
  else {
    gbtMixedProfile<T> foo(*this);
    for (int st = 1; st <= support.NumStrats(player1); foo(player1, st++) = 0);
    for (int st = 1; st <= support.NumStrats(player2); foo(player2, st++) = 0);
    foo(player1, strat1) = 1;
    foo(player2, strat2) = 1;
    return gbtBehavProfile<T>(foo).Payoff(pl);
  }
}

template <class T> 
void gbtMixedProfile<T>::Payoff(int pl, int player1, gbtVector<T> &value) const
{
  if (dynamic_cast<gbtGameBase *>(m_nfg.Get())->m_results.Length() > 0) {
    value = (T) 0;
    PPayoff(pl, player1, 1, 1, (T) 1, value);
  }
  else {
    for (int st = 1; st <= Support().NumStrats(player1); st++) {
      value[st] = Payoff(pl, Support().GetStrategy(player1, st));
    }
  }
}

template <class T>
bool gbtMixedProfile<T>::operator==(const gbtMixedProfile<T> &mp) const
{
  return (m_nfg == mp.m_nfg &&
	  (const gbtPVector<T> &) *this == (const gbtPVector<T> &) mp);
}

template <class T> gbtOutput &operator<<(gbtOutput &f, const gbtMixedProfile<T> &p)
{ p.Dump(f);  return f; }


//-------------------------------------- 
// Private Mixed Profile Members
//--------------------------------------

template <class T>
T gbtMixedProfile<T>::PPayoff(int pl, int index, int i) const
{
  int pindex = 0;

  if (i > m_nfg->NumPlayers())  {
    if (!m_nfg->GetOutcomeIndex(index).IsNull()) {
      return m_nfg->GetOutcomeIndex(index)->GetPayoff(m_nfg->GetPlayer(pl));
    }
    else {
      return (T) 0;
    }
  }
  T sum = (T) 0;
  for (int j = 1; j <= support.NumStrats(i); j++) {
    gbtGameStrategy s = support.GetStrategy(i, j);
    if ((*this)(i, j) != (T) 0) {
      index += s->GetIndex() - pindex;
      pindex = s->GetIndex();
      sum += (*this)(i, j) * PPayoff(pl, index, i + 1);
    }
  }
  return sum;
}

template <class T>
void gbtMixedProfile<T>::PPayoff(int pl, int const_pl, int const_st,
				int cur_pl, long index, T prob, T &value) const
{
  if (cur_pl == const_pl)
    PPayoff(pl, const_pl, const_st, cur_pl + 1, index,
	    prob, value);
  else if (cur_pl > m_nfg->NumPlayers())  {
    if (!m_nfg->GetOutcomeIndex(index).IsNull()) {
      value += prob * Payoff(m_nfg->GetOutcomeIndex(index), pl);
    }
  }
  else   {
    for (int j = 1; j <= support.NumStrats(cur_pl); j++)  {
      gbtGameStrategy s = support.GetStrategy(cur_pl, j);
      if ((*this)(cur_pl, j) > (T) 0)
	PPayoff(pl, const_pl, const_st, cur_pl + 1,
		index + s->GetIndex(), prob * (*this)(cur_pl, j), value);
    }
  }
}


template <class T>
void gbtMixedProfile<T>::PPayoff(int pl, int const_pl1, int const_st1,
				int const_pl2, int const_st2,
				int cur_pl, long index, T prob, T &value) const
{
  if (cur_pl == const_pl1 || cur_pl == const_pl2)
    PPayoff(pl, const_pl1, const_st1, const_pl2, const_st2,
	    cur_pl + 1, index,prob, value);
  else if (cur_pl > m_nfg->NumPlayers())  {
    if (!m_nfg->GetOutcomeIndex(index).IsNull()) {
      value += prob * Payoff(m_nfg->GetOutcomeIndex(index), pl);
    }
  }
  else   {
    for (int j = 1; j <= support.NumStrats(cur_pl); j++ ) {
      gbtGameStrategy s = support.GetStrategy(cur_pl, j);
      if ((*this)(cur_pl, j) > (T) 0)
	PPayoff(pl, const_pl1, const_st1, const_pl2, const_st2,
		cur_pl + 1, index + s->GetIndex(), prob * (*this)(cur_pl, j),
		value);
    }
  }
}

template <class T>
void gbtMixedProfile<T>::PPayoff(int pl, int const_pl, int cur_pl, long index, 
			   T prob, gbtVector<T> &value) const
{
  if (cur_pl == const_pl)
    PPayoff(pl, const_pl, cur_pl + 1, index,
	   prob, value);
  else if (cur_pl > m_nfg->NumPlayers())  {
    for (int j = 1; j <= support.NumStrats(const_pl); j++ ){ 
      gbtGameStrategy s = support.GetStrategy(const_pl, j);
      if (!m_nfg->GetOutcomeIndex(index + s->GetIndex()).IsNull()) {
	value[j] += prob * Payoff(m_nfg->GetOutcomeIndex(index + s->GetIndex()), pl);
      }
    }
  }
  else   {
    for (int j = 1; j <= support.NumStrats(cur_pl); j++) {
      gbtGameStrategy s = support.GetStrategy(cur_pl, j);
      if ((*this)(cur_pl, j) > (T) 0)
	PPayoff(pl, const_pl, cur_pl + 1,
		index + s->GetIndex(), prob * (*this)(cur_pl, j), value);
    }
  }
}

template <class T>
gbtMixedProfile<T>::gbtMixedProfile(const gbtBehavProfile<T> &p_profile)
  : gbtPVector<T>(p_profile.GetGame()->NumStrategies()),
    m_nfg(p_profile.GetGame()), support(m_nfg)
{
  gbtGame efg = p_profile.GetGame();
  for (int pl = 1; pl <= m_nfg->NumPlayers(); pl++)  {
    gbtGamePlayer player = m_nfg->GetPlayer(pl);
    for (int st = 1; st <= player->NumStrategies(); st++)  {
      T prob = (T) 1;
      const gbtArray<int> &behav = player->GetStrategy(st)->GetBehavior();

      for (int iset = 1; iset <= efg->GetPlayer(pl)->NumInfosets(); iset++) {
	if (behav[iset] > 0)
	  prob *= p_profile(pl, iset, behav[iset]);
      }
      (*this)(pl, st) = prob;
    }
  }
}
