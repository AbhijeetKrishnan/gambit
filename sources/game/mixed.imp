//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of mixed strategy profile classes
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include "nfgsupport.h"
#include "nfgcont.h"
#include "mixed.h"
#include "gamebase.h"

template <class T> void gbtMixedProfileRep<T>::SetCentroid(void) 
{
  for (int pl = 1; pl <= NumPlayers(); pl++)  {
    gbtGamePlayer player = GetPlayer(pl);
    T center = ((T) 1) / ((T) player->NumStrategies());
    for (int st = 1; st <= player->NumStrategies(); 
	 (*this)(pl, st++) = center);
  }
}

template <class T> T gbtMixedProfileRep<T>::GetLiapValue(void) const
{
  static const T BIG1 = (T) 100;
  static const T BIG2 = (T) 100;

  gbtMixedProfile<T> p(Copy());
  gbtMixedProfile<T> tmp(p->Copy());
  gbtPVector<T> payoff(NumStrategies());
  T x, result((T) 0), avg, sum;
  payoff = (T) 0;

  for (int i = 1; i <= NumPlayers(); i++) {
    gbtGamePlayer player = GetPlayer(i);
    tmp->CopyStrategy(GetPlayer(i), payoff);
    avg = sum = (T) 0;
    // then for each strategy for that player set it to 1 and evaluate
    int j;
    for (j = 1; j <= player->NumStrategies(); j++) {
      tmp(i, j) = (T) 1;
      x = p(i, j);
      payoff(i, j) = tmp->GetPayoff(tmp->GetPlayer(i));
      avg += x * payoff(i, j);
      sum += x;
      if (x>(T)0) x=0;
      result += BIG1*x*x;         // add penalty for neg probabilities
      tmp(i,j) = (T) 0;
    }
    tmp->CopyStrategy(tmp->GetPlayer(i), p);
    for (j = 1; j <= player->NumStrategies(); j++) {
      x=payoff(i,j)-avg;
      if (x<=(T)0) x=(T)0;
      result += x*x;          // add penalty if not best response
    }
    x=sum - ((T) 1);
    result += BIG2*x*x ;          // add penalty for sum not equal to 1
  }
  return result;
}

template <class T> 
void gbtMixedProfileRep<T>::GetRegret(gbtPVector<T> &value) const
{
  for (int i = 1; i <= NumPlayers(); i++) {
    T pay = GetPayoff(GetPlayer(i));
    for (int j = 1; j <= GetPlayer(i)->NumStrategies(); j++) {
      T x = GetStrategyValue(GetPlayer(i)->GetStrategy(j));
      if (x > pay) {
	value(i, j) = x - pay;
      }
      else {
	// use pay - pay instead of zero for correct precision
	value(i,j) = pay - pay; 
      }
    }
  }
}

//---------------------------------------------------------------------------
//                    gbtMixedProfileTable<T> member functions
//---------------------------------------------------------------------------

template <class T>
gbtMixedProfileTable<T>::gbtMixedProfileTable(const gbtNfgSupportBase &p_support)
  : m_profile(p_support.NumStrategies()), 
    m_support(new gbtNfgSupportBase(p_support))
{
  SetCentroid();
}

template <class T> 
gbtMixedProfileTable<T>::gbtMixedProfileTable(const gbtMixedProfileTable<T> &p_profile)
  : m_profile(p_profile.m_profile), 
    m_support(new gbtNfgSupportBase(*p_profile.m_support))
{ }


template <class T> T 
gbtMixedProfileTable<T>::GetPayoff(const gbtGamePlayer &p_player) const
{
  return PPayoff(p_player->GetId(), 1, 1);
}

template <class T> T
gbtMixedProfileTable<T>::GetPayoff(const gbtGamePlayer &p_player,
				   const gbtGameStrategy &p_strategy) const
{
  T value = (T) 0;
  PPayoff(p_player->GetId(),
	  p_strategy->GetPlayer()->GetId(), p_strategy->GetId(), 1,
	  p_strategy->GetIndex() + 1, (T) 1, value);
  return value;
}

template <class T> T
gbtMixedProfileTable<T>::GetPayoff(const gbtGamePlayer &p_player,
				   const gbtGameStrategy &p_strategy1,
				   const gbtGameStrategy &p_strategy2) const
{
  if (p_strategy1->GetPlayer() == p_strategy2->GetPlayer()) return (T) 0;
  T value = (T) 0;
  PPayoff(p_player->GetId(), 
	  p_strategy1->GetPlayer()->GetId(), p_strategy1->GetId(),
	  p_strategy2->GetPlayer()->GetId(), p_strategy2->GetId(), 1,
	  p_strategy1->GetIndex() + p_strategy2->GetIndex() + 1,
	  (T) 1, value);
  return value;
}

template <class T> T
gbtMixedProfileTable<T>::GetStrategyValue(const gbtGameStrategy &p_strategy) const
{
  return GetPayoff(p_strategy->GetPlayer(), p_strategy);
}

template <class T> T &
gbtMixedProfileTable<T>::operator()(const gbtGameStrategy &p_strategy)
{
  return m_profile(p_strategy->GetPlayer()->GetId(), p_strategy->GetId());
}

template <class T> const T &
gbtMixedProfileTable<T>::operator()(const gbtGameStrategy &p_strategy) const
{
  return m_profile(p_strategy->GetPlayer()->GetId(), p_strategy->GetId());
}

template <class T>
bool gbtMixedProfileTable<T>::operator==(const gbtMixedProfileRep<T> &mp) const
{
  return (m_support ==
	  dynamic_cast<const gbtMixedProfileTable<T> &>(mp).m_support &&
	  m_profile == 
	  dynamic_cast<const gbtMixedProfileTable<T> &>(mp).m_profile);
}


//-------------------------------------- 
// Private Mixed Profile Members
//--------------------------------------

template <class T>
T gbtMixedProfileTable<T>::PPayoff(int pl, int index, int i) const
{
  int pindex = 0;

  if (i > m_support->NumPlayers())  {
    if (m_support->m_nfg->m_results[index]) {
      return m_support->m_nfg->m_results[index]->GetPayoff(m_support->GetPlayer(pl));
    }
    else {
      return (T) 0;
    }
  }
  T sum = (T) 0;
  gbtGamePlayer player = m_support->GetPlayer(i);
  for (int j = 1; j <= player->NumStrategies(); j++) {
    gbtGameStrategy s = player->GetStrategy(j);
    if ((*this)(i, j) != (T) 0) {
      index += s->GetIndex() - pindex;
      pindex = s->GetIndex();
      sum += (*this)(i, j) * PPayoff(pl, index, i + 1);
    }
  }
  return sum;
}

template <class T>
void gbtMixedProfileTable<T>::PPayoff(int pl, int const_pl, int const_st,
				int cur_pl, long index, T prob, T &value) const
{
  if (cur_pl == const_pl)
    PPayoff(pl, const_pl, const_st, cur_pl + 1, index,
	    prob, value);
  else if (cur_pl > m_support->NumPlayers())  {
    if (m_support->m_nfg->m_results[index]) {
      value += prob * Payoff(m_support->m_nfg->m_results[index], pl);
    }
  }
  else   {
    gbtGamePlayer player = m_support->GetPlayer(cur_pl);
    for (int j = 1; j <= player->NumStrategies(); j++)  {
      gbtGameStrategy s = player->GetStrategy(j);
      if ((*this)(cur_pl, j) > (T) 0)
	PPayoff(pl, const_pl, const_st, cur_pl + 1,
		index + s->GetIndex(), prob * (*this)(cur_pl, j), value);
    }
  }
}


template <class T>
void gbtMixedProfileTable<T>::PPayoff(int pl, int const_pl1, int const_st1,
				int const_pl2, int const_st2,
				int cur_pl, long index, T prob, T &value) const
{
  if (cur_pl == const_pl1 || cur_pl == const_pl2)
    PPayoff(pl, const_pl1, const_st1, const_pl2, const_st2,
	    cur_pl + 1, index,prob, value);
  else if (cur_pl > m_support->NumPlayers())  {
    if (m_support->m_nfg->m_results[index]) {
      value += prob * Payoff(m_support->m_nfg->m_results[index], pl);
    }
  }
  else   {
    gbtGamePlayer player = m_support->GetPlayer(cur_pl);
    for (int j = 1; j <= player->NumStrategies(); j++) {
      gbtGameStrategy s = player->GetStrategy(j);
      if ((*this)(cur_pl, j) > (T) 0)
	PPayoff(pl, const_pl1, const_st1, const_pl2, const_st2,
		cur_pl + 1, index + s->GetIndex(), prob * (*this)(cur_pl, j),
		value);
    }
  }
}

template <class T>
void gbtMixedProfileTable<T>::PPayoff(int pl, int const_pl, int cur_pl, long index, 
			   T prob, gbtVector<T> &value) const
{
  if (cur_pl == const_pl)
    PPayoff(pl, const_pl, cur_pl + 1, index,
	   prob, value);
  else if (cur_pl > m_support->NumPlayers())  {
    gbtGamePlayer player = m_support->GetPlayer(const_pl);
    for (int j = 1; j <= player->NumStrategies(); j++) { 
      gbtGameStrategy s = player->GetStrategy(j);
      if (m_support->m_nfg->m_results[index + s->GetIndex()]) {
	value[j] += prob * Payoff(m_support->m_nfg->m_results[index + s->GetIndex()], pl);
      }
    }
  }
  else   {
    gbtGamePlayer player = m_support->GetPlayer(cur_pl);
    for (int j = 1; j <= player->NumStrategies(); j++) {
      gbtGameStrategy s = player->GetStrategy(j);
      if ((*this)(cur_pl, j) > (T) 0)
	PPayoff(pl, const_pl, cur_pl + 1,
		index + s->GetIndex(), prob * (*this)(cur_pl, j), value);
    }
  }
}

template <class T>
T gbtMixedProfileTable<T>::Payoff(const gbtGameOutcome &p_outcome,
				  int pl) const
{ 
  return p_outcome->GetPayoff(m_support->GetPlayer(pl));
}


template <class T>
gbtNfgContingency gbtMixedProfileTable<T>::NewContingency(void) const
{
  return m_support->NewContingency(); 
}

template <class T>
gbtMixedProfileRep<T> *gbtMixedProfileTable<T>::Copy(void) const
{
  return new gbtMixedProfileTable<T>(*this);
}


template <class T> gbtMixedProfile<double> 
gbtMixedProfileTable<T>::NewMixedProfile(double) const
{
  gbtMixedProfileTable<double> *profile = 
    new gbtMixedProfileTable<double>(*m_support);
  for (int i = 1; i <= MixedProfileLength(); i++) {
    (*profile)[i] = (double) m_profile[i];
  }

  return profile;
}

template <class T> gbtMixedProfile<gbtRational>
gbtMixedProfileTable<T>::NewMixedProfile(const gbtRational &) const
{
  gbtMixedProfileTable<gbtRational> *profile = 
    new gbtMixedProfileTable<gbtRational>(*m_support);
  for (int i = 1; i <= MixedProfileLength(); i++) {
    (*profile)[i] = m_profile[i];
  }

  return profile;
}

template <class T> gbtMixedProfile<gbtNumber>
gbtMixedProfileTable<T>::NewMixedProfile(const gbtNumber &) const
{
  gbtMixedProfileTable<gbtNumber> *profile = 
    new gbtMixedProfileTable<gbtNumber>(*m_support);
  for (int i = 1; i <= MixedProfileLength(); i++) {
    (*profile)[i] = gbtNumber(m_profile[i]);
  }

  return profile;
}

template <class T>
gbtMixedProfileTable<T>::operator gbtBehavProfile<T>(void) const
{
  throw gbtGameUndefinedOperation();
}

//---------------------------------------------------------------------------
//                    gbtMixedProfileTree<T> member functions
//---------------------------------------------------------------------------

template <class T>
gbtMixedProfileTree<T>::gbtMixedProfileTree(const gbtEfgSupportBase &p_efgSupport)
  : m_profile(gbtNfgSupportBase(p_efgSupport.m_efg).NumStrategies()),
    m_efgSupport(new gbtEfgSupportBase(p_efgSupport)),
    m_nfgSupport(new gbtNfgSupportBase(p_efgSupport.m_efg))
{
  SetCentroid();
}

template <class T> 
gbtMixedProfileTree<T>::gbtMixedProfileTree(const gbtMixedProfileTree<T> &p_profile)
  : m_profile(p_profile.m_profile),
    m_efgSupport(new gbtEfgSupportBase(*p_profile.m_efgSupport)),
    m_nfgSupport(new gbtNfgSupportBase(*p_profile.m_nfgSupport))
{ }


template <class T> T
gbtMixedProfileTree<T>::GetPayoff(const gbtGamePlayer &p_player) const
{
  return gbtBehavProfileBase<T>(*this).GetPayoff(p_player);
}

template <class T> T
gbtMixedProfileTree<T>::GetPayoff(const gbtGamePlayer &p_player,
				  const gbtGameStrategy &p_strategy) const
{
  gbtMixedProfileTree<T> foo(*m_efgSupport);
  gbtGamePlayer player = m_efgSupport->GetPlayer(p_strategy->GetPlayer()->GetId());
  for (int st = 1; st <= player->NumStrategies();
       foo(p_strategy->GetPlayer()->GetId(), st++) = 0);
  foo(p_strategy->GetPlayer()->GetId(), m_nfgSupport->GetIndex(p_strategy)) = 1;
  return gbtBehavProfileBase<T>(foo).GetPayoff(p_player);
}

template <class T> T
gbtMixedProfileTree<T>::GetPayoff(const gbtGamePlayer &p_player,
				  const gbtGameStrategy &p_strategy1,
				  const gbtGameStrategy &p_strategy2) const
{
  if (p_strategy1->GetPlayer() == p_strategy2->GetPlayer()) return (T) 0;
  gbtMixedProfileTree<T> foo(*m_efgSupport);
  for (int st = 1; st <= m_efgSupport->GetPlayer(p_strategy1->GetPlayer()->GetId())->NumStrategies();
       foo(p_strategy1->GetPlayer()->GetId(), st++) = 0);
  for (int st = 1; st <= m_efgSupport->GetPlayer(p_strategy2->GetPlayer()->GetId())->NumStrategies();
       foo(p_strategy2->GetPlayer()->GetId(), st++) = 0);
  foo(p_strategy1) = 1;
  foo(p_strategy2) = 1;
  return gbtBehavProfileBase<T>(foo).GetPayoff(p_player);
}

template <class T>
bool gbtMixedProfileTree<T>::operator==(const gbtMixedProfileRep<T> &mp) const
{
  return (*m_nfgSupport ==
	  *dynamic_cast<const gbtMixedProfileTree<T> &>(mp).m_nfgSupport &&
	  m_profile == 
	  dynamic_cast<const gbtMixedProfileTree<T> &>(mp).m_profile);
}

template <class T>
gbtMixedProfileTree<T>::gbtMixedProfileTree(const gbtBehavProfileBase<T> &p_profile)
  : m_profile(p_profile.m_support->m_efg->NumStrategies()),
    m_efgSupport(new gbtEfgSupportBase(*p_profile.m_support)),
    m_nfgSupport(new gbtNfgSupportBase(p_profile.m_support->m_efg))
{
  for (int pl = 1; pl <= m_nfgSupport->NumPlayers(); pl++)  {
    gbtGamePlayer player = m_nfgSupport->GetPlayer(pl);
    for (int st = 1; st <= player->NumStrategies(); st++)  {
      T prob = (T) 1;
      const gbtArray<int> &behav = player->GetStrategy(st)->GetBehavior();

      for (int iset = 1; iset <= player->NumInfosets(); iset++) {
	if (behav[iset] > 0)
	  prob *= p_profile(pl, iset, behav[iset]);
      }
      (*this)(pl, st) = prob;
    }
  }
}

template <class T>
gbtNfgContingency gbtMixedProfileTree<T>::NewContingency(void) const
{
  return m_nfgSupport->NewContingency(); 
}

template <class T>
gbtMixedProfileRep<T> *gbtMixedProfileTree<T>::Copy(void) const
{
  return new gbtMixedProfileTree<T>(*this);
}

template <class T> T
gbtMixedProfileTree<T>::GetStrategyValue(const gbtGameStrategy &p_strategy) const
{
  return GetPayoff(p_strategy->GetPlayer(), p_strategy);
}

template <class T> T &
gbtMixedProfileTree<T>::operator()(const gbtGameStrategy &p_strategy)
{
  return m_profile(p_strategy->GetPlayer()->GetId(), p_strategy->GetId());
}

template <class T> const T &
gbtMixedProfileTree<T>::operator()(const gbtGameStrategy &p_strategy) const
{
  return m_profile(p_strategy->GetPlayer()->GetId(), p_strategy->GetId());
}

template <class T> gbtMixedProfile<double> 
gbtMixedProfileTree<T>::NewMixedProfile(double) const
{
  gbtMixedProfileTree<double> *profile = 
    new gbtMixedProfileTree<double>(*m_efgSupport);
  for (int i = 1; i <= MixedProfileLength(); i++) {
    (*profile)[i] = (double) m_profile[i];
  }

  return profile;
}

template <class T> gbtMixedProfile<gbtRational>
gbtMixedProfileTree<T>::NewMixedProfile(const gbtRational &) const
{
  gbtMixedProfileTree<gbtRational> *profile = 
    new gbtMixedProfileTree<gbtRational>(*m_efgSupport);
  for (int i = 1; i <= MixedProfileLength(); i++) {
    (*profile)[i] = m_profile[i];
  }

  return profile;
}

template <class T> gbtMixedProfile<gbtNumber>
gbtMixedProfileTree<T>::NewMixedProfile(const gbtNumber &) const
{
  gbtMixedProfileTree<gbtNumber> *profile = 
    new gbtMixedProfileTree<gbtNumber>(*m_efgSupport);
  for (int i = 1; i <= MixedProfileLength(); i++) {
    (*profile)[i] = gbtNumber(m_profile[i]);
  }

  return profile;
}

template <class T>
gbtMixedProfileTree<T>::operator gbtBehavProfile<T>(void) const
{
  return new gbtBehavProfileBase<T>(*this);
}

template <class T> gbtOutput &operator<<(gbtOutput &f, 
					 const gbtMixedProfile<T> &p)
{ return f; }


