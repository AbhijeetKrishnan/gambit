//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation for N-dimensional arrays
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include <assert.h>
#include "base/base.h"
#include "gnarray.h"

template <class T> gbtNDArray<T>::gbtNDArray(void)
  : storage_size(0), storage(0)
{ }

template <class T> gbtNDArray<T>::gbtNDArray(const gbtArray<int> &d)
  : dim(d)
{
  if (dim.Length() <= 0)   {
    storage = 0;
    storage_size = 0;
  }
  else   {
    assert(dim.First() == 1);
    storage_size = 1;
    int i;
    for (i = 1; i <= dim.Length(); i++)   {
      assert(dim[i] >= 1);
      storage_size *= dim[i];
    }

    storage = new  T[storage_size];
    for (i = 0; i < storage_size; storage[i++] = 0);
  }
}

template <class T> gbtNDArray<T>::gbtNDArray(const gbtNDArray<T> &a)
  : storage_size(a.storage_size), dim(a.dim)
{
  storage = (storage_size > 0) ? new  T[storage_size] : 0;
  for (int i = 0; i < storage_size; i++)
    storage[i] = a.storage[i];
}

template <class T> gbtNDArray<T>::~gbtNDArray()
{
  if (storage)    delete [] storage;
}

template <class T>
gbtNDArray<T> &gbtNDArray<T>::operator=(const gbtNDArray<T> &a)
{
  if (this != &a)   {
    if (storage)    delete [] storage;
    dim = a.dim;
    storage_size = a.storage_size;
    storage = (storage_size > 0) ? new T[storage_size] : 0;
    for (int i = 0; i < storage_size; i++)
      storage[i] = a.storage[i];
  }
  return *this;
}

/*
template <class T> T gbtNDArray<T>::operator[](const gbtVector<int> &v) const
{
  assert(dim.Length() > 0 && dim.Length() == v.Length());
  int i,location,offset;
  
  for (i = 1, location = 0, offset = 1; i <= dim.Length(); i++)   {
    assert(v[i] > 0 && v[i] <= dim[i]);
    location += (v[i] - 1) * offset;
    offset *= dim[i];
  }
  
  return storage[location];
}

template <class T> T &gbtNDArray<T>::operator[](const gbtVector<int> &v)
{
  assert(dim.Length() > 0 && dim.Length() == v.Length());
  int i, location, offset;
  
  for (i = 1, location = 0, offset = 1; i <= dim.Length(); i++)   {
    assert(v[i] > 0 && v[i] <= dim[i]);
    location += (v[i] - 1) * offset;
    offset *= dim[i];
  }
  
  return storage[location];
}
*/

template <class T> T gbtNDArray<T>::operator[](const gbtArray<int> &v) const
{
  assert(dim.Length() > 0 && dim.Length() == v.Length());
  int i, location, offset;
  
  for (i = 1, location = 0, offset = 1; i <= dim.Length(); i++)   {
    assert(v[i] > 0 && v[i] <= dim[i]);
    location += (v[i] - 1) * offset;
    offset *= dim[i];
  }

  return storage[location];
}

template <class T> T &gbtNDArray<T>::operator[](const gbtArray<int> &v)
{
  assert(dim.Length() > 0 && dim.Length() == v.Length());
  int i, location, offset;
  
  for (i = 1, location = 0, offset = 1; i <= dim.Length(); i++)   {
    assert(v[i] > 0 && v[i] <= dim[i]);
    location += (v[i] - 1) * offset;
    offset *= dim[i];
  }

  return storage[location];
}

template <class T> void gbtNDArray<T>::Output(gbtOutput &f) const
{
  if (dim.Length() > 0)   {
    for (int i = dim.Length(); i > 0; f << i-- << ' ');
    f << '\n';
    
    gbtVector<int> v(1, dim.Length());
    DumpFrom(f, 1, v);
    f << '\n';
  }
}

template <class T> 
void gbtNDArray<T>::DumpFrom(gbtOutput &f, int offset, gbtVector<int> &v) const
{
  for (int i = 1; i <= dim[offset]; i++)   {
    v[offset] = i;
    if (offset == dim.Length())
      f << (*this)[v] << ' ';
    else
      DumpFrom(f, offset + 1, v);
  }
}

/*
template <class T> 
void gbtNDArray<T>::Input(gbtInput &f, const gbtVector<int> &norder, int i)
{
  gbtVector<int> strat(1, i);
  ReadFrom(f, norder, strat, i);
}


template <class T> 
void gbtNDArray<T>::ReadFrom(gbtInput &f, const gbtVector<int> &norder,
			  gbtVector<int> &strat, int i)
{
  for (int j = 1; j <= dim[norder[i]]; j++)   {
    strat[norder[i]] = j;
    if (i > 1)
      ReadFrom(f, norder, strat, i - 1);
    else 
      f >> (*this)[strat];
  }
}
*/

template <class T> const T &gbtNDArray<T>::operator[](long l) const
{
  assert(l >= 0 && l < storage_size);
  return storage[l];
}

template <class T> T &gbtNDArray<T>::operator[](long l) 
{
  assert(l >= 0 && l < storage_size);
  return storage[l];
}

template <class T> const gbtArray<int> &gbtNDArray<T>::Dimensionality(void) const
{
  return dim;
}


//-------------------------------------------

#ifdef UNUSED

template <class T> gIndexedNArray<T>::gIndexedNArray(void)
{
  index = 0;
}

template <class T> 
gIndexedNArray<T>::gIndexedNArray(const gbtVector<int> &d)
  : gbtNDArray<T>(d)
{
  long offset = 1;
  
  index = new gbtArray<long>[dim.Length()];
  for (int i = 1; i <= dim.Length(); i++)  {
    for (int j = 0; j < dim[i]; j++)
      index[i - 1] += j * offset;
    offset *= dim[i];
  }
}

template <class T>
gIndexedNArray<T>::gIndexedNArray(const gIndexedNArray<T> &a)
  : gbtNDArray<T>(a)
{
  index = new gbtArray<long>[dim.Length()];
  for (int i = 0; i < dim.Length(); i++)
    index[i] = a.index[i];
}

template <class T> gIndexedNArray<T>::~gIndexedNArray()
{
  if (index)   delete [] index;
}

template <class T> 
gIndexedNArray<T> &gIndexedNArray<T>::operator=(const gIndexedNArray<T> &a)
{
  if (this != &a)   {
    gbtNDArray<T>::operator=(a);
    
    if (index)   delete [] index;
    index = new gbtArray<long>[dim.Length()];
    for (int i = 0; i < dim.Length(); i++)
      index[i] = a.index[i];
  }
  return *this;
}

template <class T>
T gIndexedNArray<T>::operator=(const gbtVector<int> &v) const
{
  long location = 0;
  
  assert(dim.Length() > 0 && dim.Length() == v.Length());
  
  for (int i = 1; i <= dim.Length(); i++)   {
    assert(v[i] > 0 && v[i] <= dim[i]);
    location += index[i - 1][v[i]];
  }
  
  return storage[location];
}

template <class T>
T &gIndexedNArray<T>::operator=(const gbtVector<int> &v)
{
  long location = 0;

  assert(dim.Length() > 0 && dim.Length() == v.Length());
  
  for (int i = 1; i <= dim.Length(); i++)   {
    assert(v[i] > 0 && v[i] <= dim[i]);
    location += index[i - 1][v[i]];
  }

  return storage[location];
}

#endif   // UNUSED
