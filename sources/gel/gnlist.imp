//
// FILE: gnlist.imp -- Implementation of nested list class
//
//

#include "gnlist.h"


template <class T> gText gNestedList<T>::InternalError::Description(void) const
{ return "gNestedList internal error at line " + ToText(line); }

//---------------------------------------------------------------
//                       CAUTION
// 
//  Be sure you read the description of the data structure
//  in gnlist.h before changing these methods!
//
//---------------------------------------------------------------

template <class T> gNestedList<T>::gNestedList(const gList<int>& dim)
  : m_Dim(dim)
{
  if (m_Dim.Length() == 1 && m_Dim[1] == 0)
    m_Data.Append(0);
  else  {
    for (int i = 1; i <= dim.Length(); i++)
      for (int j = 1; j <= abs(dim[i]) - 1; j++)
        m_Data.Append(0);
  }
}

  //------------------------------------------------------------------
  // GetElementInfo
  // 
  // Return values:
  //   If the element requested is itself a list, then:
  //     islist = true
  //     el_start and el_end point to the start and the ending index numbers
  //       in Data()
  //     k_start and k_end point to the opening and closing braces,
  //       respectively, corresponding to the sublist in Dim()
  //   otherwise
  //     islist = false
  //     el_start = el_end, both pointing to the element in Data()
  //     k_start and k_end are undefined
  //-----------------------------------------------------------------
template <class T> 
void gNestedList<T>::GetElementInfo( int el, 
				     bool& islist, 
				     int& k_start, int& k_end, 
				     int& el_start, int& el_end ) const
{
  // el_* are for indices into the data list
  el_start = 0;
  el_end = 0;

  // k_* are for indices into the dimention list
  k_start = 0;
  k_end = 0;

  // whether the element requested is itself a list or not
  islist = false;


  if (0 >= el ||
      el > NumElements() ||
      m_Dim.Length() <= 1 ||
      m_Dim[1] != 1)
    throw InternalError(__LINE__);

  k_end = 1;
  int depth = 1;
  int steps = (int) abs( Dim()[2] ) - 1;

  for (int index = 1; index <= el; ++index )
  {
    k_start = k_end+1;
    el_start = el_end+1;      

    while( steps == 0 )
    {
      ++k_end;
      if( Dim()[k_end] > 0 )
	++depth;
      else
	--depth;
      steps = (int) abs( Dim()[k_end+1] ) - 1;
    }

    ++el_end;
    --steps;

    if( depth == 1 )
    {
      islist = false;
    }
    else
    {
      islist = true;

      while( depth != 1 )
      {
	++k_end;
	if( Dim()[k_end] > 0 )
	  ++depth;
	else
	  --depth;
	el_end += steps;
	steps = (int) abs( Dim()[k_end+1] ) - 1;
      }
    }
  }

}

template <class T> 
void gNestedList<T>::Output( gOutput& out ) const 
{
  int i;
  int j;
  int el = 1;

  if( m_Dim[1] == 0 ) // not a list
  {
    if (m_Dim.Length() != 1)
      throw InternalError(__LINE__);
    if (Data()[1] != NULL)
      out << Data()[1];    
    else
      out << "(NULL)";
  }
  else // is a list
  {
    for (i = 1; i <= m_Dim.Length(); ++i )
    {
      if (m_Dim[i] == 0)
        throw InternalError(__LINE__);
      for (j = 0; j < abs( m_Dim[i] ) - 1; ++j )
      {
	if (Data()[el] != NULL)
	  out << Data()[el];
	else
	  out << "(NULL)";

	if( j != abs( m_Dim[i] ) - 2 || m_Dim[i] > 0 )
	  out << ", ";
	else
	  out << ' ';
	++el;
      }
      if( m_Dim[i] > 0 )
	out << "{ ";
      else if( i == m_Dim.Length() || 
	       ( i < m_Dim.Length() && m_Dim[i+1] == -1 ) )
	out << "} ";
      else
	out << "}, ";
    }
  }
}



template <class T> 
gNestedList<T> gNestedList<T>::NthElement( int el ) const
{
  // el_* are for indices into the data list
  int el_start = 0;
  int el_end = 0;

  // k_* are for indices into the dimention list
  int k_start = 0;
  int k_end = 0;
  
  // whether the element requested is itself a list or not
  bool islist = false;

  // get the index values for the given element number
  GetElementInfo( el, islist, k_start, k_end, el_start, el_end );  


  gList<int> dim;
  if( !islist )
    dim.Append( 0 );
  else
  {
    for(int k = k_start; k <= k_end; ++k )
      dim.Append( m_Dim[k] );
    dim[1] = 1;
  }

  gNestedList<T> ret(dim);
  for (int i = 1; i <= el_end - el_start + 1; i++)
    ret[i] = Data()[i + el_start - 1];
//  for(int i = el_start; i <= el_end; ++i )
//    ret.Append( Data()[ i ] );
  return ret;
}



template <class T>
int gNestedList<T>::NumElements( void ) const
{
  int num = 0;
  
  // current depth
  int depth = 0;

  if( m_Dim.Length() <= 1 )
    return 0;

  if (m_Dim[1] != 1)
    throw InternalError(__LINE__);

  // k is for index into the dimension list
  for (int k = 1; k <= m_Dim.Length(); ++k )
  {
    if (m_Dim[k] == 0)
      throw InternalError(__LINE__);
    if( depth == 1 )
      num += (int) abs( m_Dim[k] ) - 1;
    else if( m_Dim[k] < 0 && depth == 2)
      ++num;
      
    if( m_Dim[k] > 0 )
      ++depth;
    else
      --depth;
  }

  if (num <= 0)
    throw InternalError(__LINE__);
  return num;
}




template <class T> 
bool gNestedList<T>::Contains( const gNestedList<T>& t ) const
{
  int i;
  for (i = 1; i <= NumElements(); ++i )
    if( NthElement( i ) == t )
      return true;
  return false;
}


template <class T> 
void gNestedList<T>::Remove( int el )
{
  // el_* are for indices into the data list
  int el_start = 0;
  int el_end = 0;

  // k_* are for indices into the dimention list
  int k_start = 0;
  int k_end = 0;
  
  // whether the element requested is itself a list or not
  bool islist = false;

  // get the index values for the given element number
  GetElementInfo( el, islist, k_start, k_end, el_start, el_end );


  if( !islist )
  {
    if (el_start != el_end ||
        k_end >= Dim().Length())
      throw InternalError(__LINE__);
    m_Data.Remove( el_start );
    m_Dim[k_end+1] += (m_Dim[k_end+1]>0?1:-1) * -1;
  }
  else  {
    if (1 >= k_start ||
        k_end >= Dim().Length())
      throw InternalError(__LINE__);
    for( int i = el_end; i >= el_start; --i )
      m_Data.Remove( i );
    m_Dim[k_end+1] += (m_Dim[k_end+1]>0?1:-1)*((int) abs( Dim()[k_start] ) - 1 );
    for( int k = k_end; k >= k_start; --k )
      m_Dim.Remove( k );
  }
}

template <class T> int gNestedList<T>::Depth( void ) const
{
  if( m_Dim.Length() <= 1 )
    return 0;

  int n = NumElements();
  int mindepth = 1;
  if( 0 < n )
    mindepth = NthElement( 1 ).Depth() + 1;
  for (int i = 2; i <= n; i++)   {
    int depth = NthElement( i ).Depth() + 1;
    if( depth < mindepth )
	    mindepth = depth;
  }
  return mindepth;
}

template <class T> bool gNestedList<T>::operator==(const gNestedList<T> &b) const
{ return (Dim() == b.Dim() && Data() == b.Data()); }

template <class T> bool gNestedList<T>::operator!=(const gNestedList<T> &b) const
{ return !(*this == b); }

