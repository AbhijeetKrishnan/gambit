//
// FILE: quiksolv.imp -- Implementation of quicksolv classes
// 
// $Id$
//

#include "quiksolv.h"

//---------------------------------------------------------------
//                      class: QuikSolv
//---------------------------------------------------------------

//---------------------------
// Constructors / Destructors
//---------------------------

template <class T> QuikSolv<T>::QuikSolv(const gPolyList<T>& given,
					 gStatus &p_status) 
  : System(given), 
    gDoubleSystem(given.AmbientSpace(),given.TermOrder(),
		  given.NormalizedList()),
    NoEquations( gmin(System.Dmnsn(),System.Length()) ),
    NoInequalities( gmax(System.Length() - System.Dmnsn(),0) ),
    TreesOfPartials(gDoubleSystem),
    HasBeenSolved(false), 
    Roots(),
    isMultiaffine(System.IsMultiaffine()),
    Equation_i_uses_var_j(Eq_i_Uses_j()),
    m_status(p_status)
{ }

template <class T> QuikSolv<T>::QuikSolv(const gPolyList<T>& given,
					 const int&          no_eqs,
					 gStatus &p_status) 
  : System(given), 
    gDoubleSystem(given.AmbientSpace(),given.TermOrder(),
		  given.NormalizedList()),
    NoEquations(no_eqs),
    NoInequalities(System.Length() - no_eqs),
    TreesOfPartials(gDoubleSystem),
    HasBeenSolved(false), 
    Roots(),
    isMultiaffine(System.IsMultiaffine()),
    Equation_i_uses_var_j(Eq_i_Uses_j()),
    m_status(p_status)
{ }

template<class T> QuikSolv<T>::QuikSolv(const QuikSolv& qs)
  : System(qs.System), 
    gDoubleSystem(qs.gDoubleSystem),
    NoEquations(qs.NoEquations),
    NoInequalities(qs.NoEquations),
    TreesOfPartials(qs.TreesOfPartials), 
    HasBeenSolved(qs.HasBeenSolved), 
    Roots(qs.Roots),
    isMultiaffine(qs.isMultiaffine),
    Equation_i_uses_var_j(qs.Equation_i_uses_var_j),
    m_status(qs.m_status)
  
{ }

template<class T> QuikSolv<T>::~QuikSolv()
{ }

//-------------------------------------------------------
//      Supporting Calculations for the Constructors
//-------------------------------------------------------

template <class T> gRectArray<bool> QuikSolv<T>::Eq_i_Uses_j() const
{
  gRectArray<bool> answer(System.Length(),Dmnsn());
  for (int i = 1; i <= System.Length(); i++)
    for (int j = 1; j <= Dmnsn(); j++)
      if (System[i].DegreeOfVar(j) > 0)
	answer(i,j) = true;
      else
	answer(i,j) = false;
  return answer;
}


//---------------------------
// Is a root impossible?
//---------------------------

template<class T> 
bool QuikSolv<T>::SystemHasNoRootsIn(const gRectangle<gDouble>& r,
				     gArray<int>& precedence)        const
{
  for (int i = 1; i <= System.Length(); i++) {

    if ( (precedence[i] <= NoEquations && 
	              TreesOfPartials[precedence[i]].PolyHasNoRootsIn(r)) ||
         (precedence[i] >  NoEquations && 
	   TreesOfPartials[precedence[i]].PolyEverywhereNegativeIn(r)) ) {
      if (i != 1) { // We have found a new "most likely to never vanish"
	int tmp = precedence[i];
	for (int j = 1; j <= i-1; j++) 
	  precedence[i - j + 1] = precedence[i - j];
	precedence[1] = tmp;
      }
      return true; 
    }
  }
  return false;
}

//--------------------------------------
// Does Newton's method lead to a root?
//--------------------------------------

template <class T>
bool QuikSolv<T>::NewtonRootInRectangle(const gRectangle<gDouble>& r,
					      gVector<gDouble>& point) const
{
  assert (NoEquations == System.Dmnsn());

  gVector<gDouble> zero(Dmnsn());
  for (int i = 1; i <= Dmnsn(); i++) zero[i] = (gDouble)0;

  gVector<gDouble> oldevals = TreesOfPartials.ValuesOfRootPolys(point,
								NoEquations);

  if ( oldevals == zero ) 
    if (r.Contains(point)) return true;
    else                   return false;

  gRectangle<gDouble> bigr = r.SameCenterDoubleSideLengths();

  //  gVector<gDouble> Del(Dmnsn());
  gVector<gDouble> newpoint(Dmnsn());

  while (true) {
    try {
      newpoint = NewtonPolishOnce(point);
    }
    catch (gSquareMatrix<gDouble>::MatrixSingular) {
      bool nonsingular = false;
      int direction = 1;
      while (direction < Dmnsn() && !nonsingular) {
	gVector<gDouble> perturbed_point(point);
	if (r.UpperBoundOfCoord(direction) > point[direction])
	  perturbed_point[direction] += 
	    (r.UpperBoundOfCoord(direction) - point[direction])/10;
	else
	  perturbed_point[direction] += 
	    (r.LowerBoundOfCoord(direction) - point[direction])/10;
	nonsingular = true;

	try {
	  newpoint = point + 
	    (NewtonPolishOnce(perturbed_point) - perturbed_point);
	}
	catch (gSquareMatrix<gDouble>::MatrixSingular) {
	  nonsingular = false;
	}
	direction++;
      }
      if (!nonsingular) {
	gVector<gDouble> perturbed_point(point);
	if (r.UpperBoundOfCoord(direction) > point[direction])
	  perturbed_point[direction] += 
	    (r.UpperBoundOfCoord(direction) - point[direction])/10;
	else
	  perturbed_point[direction] += 
	    (r.LowerBoundOfCoord(direction) - point[direction])/10;
	newpoint = point + 
	  (NewtonPolishOnce(perturbed_point) - perturbed_point);
      }
    }

    if ( !bigr.Contains(newpoint) ) return false;
    point = newpoint;
    
    gVector<gDouble> newevals = TreesOfPartials.ValuesOfRootPolys(point,
								  NoEquations);

    if (newevals * newevals > oldevals * oldevals) return false;
    if ( newevals == zero )
      if (r.Contains(point)) {
	point = SlowNewtonPolishOnce(point);
	point = SlowNewtonPolishOnce(point);
	return true;
      }
      else                   return false;                

    oldevals = newevals;
  }
}

template <class T>
bool QuikSolv<T>::NewtonRootNearRectangle(const gRectangle<gDouble>& r,
				    	        gVector<gDouble>& point) const
{
  gVector<gDouble> zero(NoEquations);
  for (int i = 1; i <= NoEquations; i++) zero[i] = (gDouble)0;

  gVector<gDouble> oldevals = TreesOfPartials.ValuesOfRootPolys(point,
								NoEquations);

  gRectangle<gDouble> bigr = r.CubeContainingCrcmscrbngSphere();

  if ( oldevals == zero ) 
    if (bigr.Contains(point)) return true;
    else                      return false;

  while (true) {
    gVector<gDouble> newpoint = SlowNewtonPolishOnce(point);
    if ( !bigr.Contains(newpoint) ) 
      return false;
    point = newpoint;
    gVector<gDouble> newevals = TreesOfPartials.ValuesOfRootPolys(point,
								  NoEquations);
    if ( newevals == zero )
      if (r.Contains(point)) return true;
      else                   return false;                

    oldevals = newevals;
  }
}

//------------------------------------
// Is the Newton root the only root?
//------------------------------------

template<class T>
   gDouble QuikSolv<T>::MaxDistanceFromPointToVertexAfterTransformation(
				      const gRectangle<gDouble>& r,
				      const gVector<gDouble>& p,
				      const gSquareMatrix<gDouble>& M)    const
{
  assert( r.Contains(p) );

  gDouble max = (gDouble)0;

  gArray<int> ListOfTwos(Dmnsn());
  for (int i = 1; i <= Dmnsn(); i++) ListOfTwos[i] = 2;
  gIndexOdometer ListOfTopBottoms(ListOfTwos);

  while (ListOfTopBottoms.Turn()) {
    gVector<gDouble> diffs(Dmnsn());
    for (int i = 1; i <= Dmnsn(); i++)
      if (ListOfTopBottoms[i] == 2)
	diffs[i] = r.CartesianFactor(i).UpperBound() - p[i];
      else 
	diffs[i] = p[i] - r.CartesianFactor(i).LowerBound();
    gVector<gDouble> new_diffs = M * diffs;
    gDouble squared_length = new_diffs * new_diffs;
    if (max < squared_length)
       max = squared_length;
  }

  return sqrt((gDouble)max);
}

template<class T>
bool QuikSolv<T>::HasNoOtherRootsIn(const gRectangle<gDouble>& r,
			  const gVector<gDouble>& p,
			  const gSquareMatrix<gDouble>& M)  const
{
  assert (NoEquations == System.Dmnsn());

  gPolyList<gDouble> system1 = gDoubleSystem.TranslateOfSystem(p);

  gPolyList<gDouble> system2 = system1.SystemInNewCoordinates(M);

  gDouble radius = MaxDistanceFromPointToVertexAfterTransformation(r,p,M);

  gDouble max = (gDouble)0;
  for (int i = 1; i <= Dmnsn(); i++) 
    max += system2[i].MaximalValueOfNonlinearPart(radius);

  if (max >= radius) return false;
  else               return true;
}


//--------------------------------------------
// Does Newton's method yield a unique root?
//--------------------------------------------

template <class T>
bool QuikSolv<T>::NewtonRootIsOnlyInRct(const gRectangle<gDouble>& r,
					gVector<gDouble>& point) const
{
  assert (NoEquations == System.Dmnsn());

  if ( NewtonRootInRectangle(r,point) ) {
    gSquareMatrix<gDouble> Df = TreesOfPartials.SquareDerivativeMatrix(point);
    if ( HasNoOtherRootsIn(r,point,Df.Inverse()) ) return true;
    else                                           return false;
  }
  else                                             return false;
}


//----------------------------------
//        Operators
//----------------------------------

template<class T> 
QuikSolv<T>& QuikSolv<T>::operator=(const QuikSolv<T> & rhs)
{
  assert (System == rhs.System);

  if (*this != rhs) {
    HasBeenSolved = rhs.HasBeenSolved;
    Roots         = rhs.Roots;
  }
  return *this;
}

template<class T>  
bool QuikSolv<T>::operator==(const QuikSolv<T> & rhs) const
{
    if (System        != rhs.System        ||
	HasBeenSolved != rhs.HasBeenSolved ||
	Roots         != rhs.Roots)
         return false;
    else return true;
}

template<class T>  
bool QuikSolv<T>::operator!=(const QuikSolv<T> & rhs) const
{
  return !(*this == rhs);
}

//-------------------------------------------
//          Improve Accuracy of Root
//-------------------------------------------

template <class T> gVector<gDouble> 
QuikSolv<T>::NewtonPolishOnce(const gVector<gDouble>& point) const
{
  gVector<gDouble> oldevals = TreesOfPartials.ValuesOfRootPolys(point,
								NoEquations);
  gMatrix<gDouble> Df = TreesOfPartials.DerivativeMatrix(point,NoEquations);
  gSquareMatrix<gDouble> M(Df * Df.Transpose());
  
  gVector<gDouble> Del = - (Df.Transpose() * M.Inverse()) * oldevals;

  return point + Del;
}

template <class T> gVector<gDouble> 
QuikSolv<T>::SlowNewtonPolishOnce(const gVector<gDouble>& point) const
{
  gVector<gDouble> oldevals = TreesOfPartials.ValuesOfRootPolys(point,
								NoEquations);
  gMatrix<gDouble> Df = TreesOfPartials.DerivativeMatrix(point,NoEquations);
  gSquareMatrix<gDouble> M(Df * Df.Transpose());
  
  gVector<gDouble> Del = - (Df.Transpose() * M.Inverse()) * oldevals;

  bool done = false;
  while (!done) {
    gVector<gDouble> 
      newevals(TreesOfPartials.ValuesOfRootPolys(point + Del,NoEquations));
    if (newevals * newevals <= oldevals * oldevals) done = true;
    else for (int i = 1; i <= Del.Length(); i++) Del[i] /= 2;
  }

  return point + Del;
}

template<class T>   gVector<gDouble> 
QuikSolv<T>::NewtonPolishedRoot(const gVector<gDouble> &initial) const
{
  gList<gInterval<gDouble> > interval_list;
  for (int i = 1; i <= Dmnsn(); i++) 
    interval_list += gInterval<gDouble>(initial[i] - (gDouble)1, 
					initial[i] + (gDouble)1);
  gRectangle<gDouble> box(interval_list);
  gVector<gDouble> point(initial);
  if (!NewtonRootInRectangle(box,point))
    throw NewtonError();
  point = SlowNewtonPolishOnce(point);
  point = SlowNewtonPolishOnce(point);
  return point;
}

//-------------------------------------------
//          Check for Singularity
//-------------------------------------------

template<class T> bool
QuikSolv<T>::MightHaveSingularRoots() const
{
  assert (NoEquations == System.Dmnsn());

  gPoly<gDouble> newpoly = 
    gDoubleSystem.ReductionOf(  gDoubleSystem.DetOfDerivativeMatrix(),
			      *(gDoubleSystem.TermOrder()));

  if (newpoly.IsZero()) return true;

  gList<gPoly<gDouble> > newlist(gDoubleSystem.UnderlyingList());

  newlist += newpoly;
  gPolyList<gDouble> larger_system(gDoubleSystem.AmbientSpace(),
			     gDoubleSystem.TermOrder(),
			     newlist);
  gIdeal<gDouble> test_ideal(gDoubleSystem.TermOrder(),larger_system);

  return !(test_ideal.IsEntireRing());
}

//-------------------------------------------
//           The Central Calculation
//-------------------------------------------

template<class T> bool
QuikSolv<T>::FindRoots(const gRectangle<T>& r, const int& max_iterations) 
{
  assert (NoEquations == System.Dmnsn());

  int zero = 0;
  return FindCertainNumberOfRoots(r,max_iterations,zero);
}

template<class T> bool
QuikSolv<T>::FindCertainNumberOfRoots(const gRectangle<T>& r, 
				      const int& max_iterations,
				      const int& max_no_roots) 
{
  assert (NoEquations == System.Dmnsn());

  gList<gVector<gDouble> >* rootlistptr = new gList<gVector<gDouble> >();

  if (NoEquations == 0) {
    gVector<gDouble> answer(0);
    *rootlistptr += answer; 
    Roots = *rootlistptr;  
    HasBeenSolved = true;
    return true;
  }


  gArray<int> precedence(System.Length());  
            // Orders search for nonvanishing poly
  for (int i = 1; i <= System.Length(); i++) precedence[i] = i;

  int iterations = 0;

  int* no_found = new int(0);
  FindRootsRecursion(rootlistptr,
		     TogDouble(r), 
		     max_iterations, 
		     precedence, 
		     iterations,
		     max_no_roots,
		     no_found);

  if (iterations < max_iterations) { 
    Roots = *rootlistptr; 
    HasBeenSolved = true; 
    return true; 
  }

  return false;

/* - This is the code one could use in the event of failure.
  gSolver<T> bigsolver(System.TermOrder(), System);

  if ( !bigsolver.IsZeroDimensional() ) return false;
  else {
    gList<gVector<gDouble> > rootlist;
    rootlist = bigsolver.Roots();
    gList<gVector<gDouble> > roots;
    for (int j = 1; j <= rootlist.Length(); j++)
      if (TogDouble(r).Contains(rootlist[j])) roots += rootlist[j];
    Roots = roots;
  }
  return true;
*/

}


template <class T> void // gList<gVector<gDouble> >  
QuikSolv<T>::FindRootsRecursion(      gList<gVector<gDouble> >* rootlistptr,
				const gRectangle<gDouble>& r, 
				const int& max_iterations,
				      gArray<int>& precedence,
				      int& iterations,
				const int& max_no_roots,
				      int* roots_found)    const
{
  assert (NoEquations == System.Dmnsn());

  // Check for user interrupt
  //  m_status.SetProgress(50.0);
  m_status.Get();

  if ( SystemHasNoRootsIn(r, precedence) ) 
    return;

  gVector<gDouble> point = r.Center();

  if ( NewtonRootIsOnlyInRct(r, point) ) {
    int i;
    for (i = NoEquations + 1; i <= System.Length(); i++)
      if (TreesOfPartials[i].ValueOfRootPoly(point) < (gDouble)0)
	return;

    bool already_found = false;
    for (i = 1; i <= rootlistptr->Length(); i++)
      if (point == (*rootlistptr)[i])
	already_found = true;
    if (!already_found) {
      *rootlistptr += point;
      (*roots_found)++;
    }
    return;
  }

  int N = r.NumberOfCellsInSubdivision();
  for (int i = 1; i <= N; i++)
    if (max_no_roots == 0 || *roots_found < max_no_roots) {
      if (iterations >= max_iterations) return;
      else {
	iterations++;
	FindRootsRecursion(rootlistptr,
			   r.SubdivisionCell(i),
			   max_iterations, 
			   precedence, 
			   iterations,
			   max_no_roots,
			   roots_found);
      } 
    }
  return; 
}



template <class T> const bool
QuikSolv<T>::ARootExistsRecursion(const gRectangle<gDouble>& r, 
					gVector<gDouble>& sample,
				  const gRectangle<gDouble>& smallrect, 
				        gArray<int>& precedence)    const
{
  if (smallrect.MaximalSideLength() == (gDouble)0.0) {
    sample = smallrect.Center();
    return true;
  }

  if ( SystemHasNoRootsIn(smallrect, precedence) ) 
    return false;		        

  gVector<gDouble> point = smallrect.Center();
  if (NewtonRootNearRectangle(smallrect,point))
    if (r.Contains(point)) {
      bool satisfies_inequalities(true);
      for (int i = NoEquations + 1; i <= System.Length(); i++)
	if (satisfies_inequalities)
	  if (TreesOfPartials[i].ValueOfRootPoly(point) < (gDouble)0)
	    satisfies_inequalities = false;
      if (satisfies_inequalities) {
	sample = point;
	return true;
      }
    }

  int N = smallrect.NumberOfCellsInSubdivision();
  for (int i = 1; i <= N; i++) 
    if (ARootExistsRecursion(r,
			     sample,
			     smallrect.SubdivisionCell(i),
			     precedence))
      return true;

  return false; 
}

template <class T> bool
QuikSolv<T>::ARootExists (const gRectangle<T>& r, 
			        gVector<gDouble>& sample) const
{
  if (NoEquations == 0) {
    gVector<gDouble> answer(0);
    sample = answer;
    return true;
  }

  gRectangle<gDouble> r_double(TogDouble(r));
  gArray<int> precedence(System.Length());  
            // Orders search for nonvanishing poly
  for (int i = 1; i <= System.Length(); i++) precedence[i] = i;

  return ARootExistsRecursion(r_double, sample, r_double, precedence);
}

//----------------------------------
//           Printing
//----------------------------------

template <class T> void QuikSolv<T>::Output(gOutput &output) const
{
  output << "The system is\n" << System;
  if (HasBeenSolved) 
    output << "It has been solved with roots:\n" << Roots;
  else output << "It has not been solved.";
}

template <class T>
gOutput &operator<<(gOutput &p_file, const QuikSolv<T> &p_solver)
{
  p_solver.Output(p_file);
  return p_file;
}

template <class T> QuikSolv<T>::NewtonError::~NewtonError()
{ }

template <class T> gText QuikSolv<T>::NewtonError::Description(void) const 
{
  return "Newton method failed to polish approximate root";
}

