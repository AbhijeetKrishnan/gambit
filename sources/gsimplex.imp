//
// FILE: gsimplex.imp -- Implementation of gSimplex
//
// $Id$
//

#include "gsimplex.h"


//--------------------------------------------------------------------------
//                   gSimplex -- constructors and destructor
//--------------------------------------------------------------------------

template<class T> gSimplex<T>::gSimplex(const gSimplex<T>& given) 
: vertices(given.vertices)
{
}

template<class T> gSimplex<T>::gSimplex(const gList< gVector<T> >& given)
: vertices(given)
{
}

template<class T> gSimplex<T>::~gSimplex() 
{
}

//--------------------------------------------------------------------------
//                          gSimplex -- operators
//--------------------------------------------------------------------------


template<class T> gSimplex<T>& 
gSimplex<T>::operator = (const gSimplex<T>& /* rhs */)
{
  gout << "For const'ness, operator = not allowed for gSimplex\n";
  exit (0);
  return *this;
}


template<class T> bool gSimplex<T>::operator == (const gSimplex<T>& rhs)
     const
{
  for (int i = 1; i <= NumberOfVertices(); i++) {
    bool match = false;
    int j = 1;
    while (!match && j <= rhs.NumberOfVertices()) {
      if (vertices[i] == rhs.vertices[j])
	match = true;
      j++;
    }
    if (!match) 
      return false;
  }

  for (int j = 1; j <= NumberOfVertices(); j++) {
    bool match = false;
    int i = 1;
    while (!match && j <= rhs.NumberOfVertices()) {
      if (rhs.vertices[j] == vertices[i])
	match = true;
      j++;
    }
    if (!match) 
      return false;
  }

  return true;
}

template<class T> bool gSimplex<T>::operator != (const gSimplex<T>& rhs)
     const
{
  return !(*this == rhs);
}

//--------------------------------------------------------------------------
//                             gSimplex -- information
//--------------------------------------------------------------------------

template<class T> const int gSimplex<T>::AmbientDmnsn() const 
{ 
  return vertices[1].Length();
}

template<class T> const int gSimplex<T>::NumberOfVertices() const 
{ 
  return vertices.Length();
}

template<class T> const gVector<T> gSimplex<T>::LowerBound() const 
{ 
  gVector<T> answer(AmbientDmnsn());
  for (int i = 1; i <= AmbientDmnsn(); i++) 
    answer[i] = LowerBoundOfCoord(i);
  return answer;
}


template<class T> const gVector<T> gSimplex<T>::UpperBound() const 
{ 
  gVector<T> answer(AmbientDmnsn());
  for (int i = 1; i <= AmbientDmnsn(); i++) 
    answer[i] = UpperBoundOfCoord(i);
  return answer;
}

template<class T> const T gSimplex<T>::LowerBoundOfCoord(const int& i) const 
{ 
  assert (1 <= i && i <= AmbientDmnsn());
  T answer = vertices[1][i];
  for (int j = 2; j <= NumberOfVertices(); j++)
    if (vertices[j][i] < answer) answer = vertices[j][i];
  return answer;
}

template<class T> const T gSimplex<T>::UpperBoundOfCoord(const int& i) const 
{ 
  assert (1 <= i && i <= AmbientDmnsn());
  T answer = vertices[1][i];
  for (int j = 2; j <= NumberOfVertices(); j++)
    if (vertices[j][i] > answer) answer = vertices[j][i];
  return answer;
}

template<class T> const T gSimplex<T>::HeightInCoord(const int& i) const 
{ 
  return UpperBoundOfCoord(i) - LowerBoundOfCoord(i);
}

template<class T> 
const gSimplex<T> gSimplex<T>::SameCenterDoubleSideLengths() const 
{ 
  gVector<T> center(Center());
  gList<gVector<T> > new_vertices;
  for (int i = 1; i <= NumberOfVertices()+1; i++) {
    gVector<T> new_vertex(vertices[i]);
    new_vertex += vertices[i];
    new_vertex -= center;
    new_vertices += new_vertex;
  }
  return gSimplex<T>(new_vertices);
}

template<class T> bool gSimplex<T>::Contains(const gVector<T>& point) const 
{   
  assert (point.Length() == AmbientDmnsn());

  gMatrix<T> A(AmbientDmnsn()+1,NumberOfVertices());
  for (int j = 1; j <= NumberOfVertices(); j++) {
    for (int i = 1; i <= AmbientDmnsn(); i++)
      A(i,j) = vertices[j][i];
    A(AmbientDmnsn()+1,j) = (T)1;
  }

  gVector<T> B(AmbientDmnsn()+1);
  for (int i = 1; i <= AmbientDmnsn(); i++)
    B[i] = point[i];
  B[AmbientDmnsn()+1] = (T)1;
  
  gVector<T> C(NumberOfVertices());
  for (int i = 1; i <= NumberOfVertices(); i++)
    C[i] = (T)0;

  gLPTableau3<T> TestFeasible(A,B,C);

  if (TestFeasible.IsFeasible())
    return true;
  else
    return false;
}

template<class T> bool gSimplex<T>::Contains(const gSimplex<T>& S) const 
{ 
  assert (S.AmbientDmnsn() == AmbientDmnsn());

  for (int i = 1; i <= NumberOfVertices(); i++)
    if ( !Contains(S.vertices[i]) )
      return false;
  return true;
}

template<class T> const T gSimplex<T>::Volume() const 
{ 
  assert(NumberOfVertices() == AmbientDmnsn() + 1);

  gSquareMatrix<T> edges(AmbientDmnsn());
  for (int i = 1; i <= AmbientDmnsn(); i++)
    for (int j = 1; j <= AmbientDmnsn(); j++)
      edges(i,j) = vertices[i][j] - vertices[AmbientDmnsn()+1][j];
  T answer = fabs(edges.Determinant());

  for (int i = 2; i <= AmbientDmnsn(); i++)
    answer /= (T)i;

  return answer;
}

template<class T> const gVector<T> gSimplex<T>::Center() const 
{ 
// The following is complex and time consuming, but necessary to prevent
// "splintering" in which the longest dimension shrinks by only
// n/(n+1) on each subdivision.

  gVector<T> weights(NumberOfVertices());

  for (int i = 1; i <= NumberOfVertices(); i++)
    for (int j = 1; j <= NumberOfVertices(); j++)
      weights[i] += (Vertex(i) - Vertex(j)).NormSquared();
  
  T sum((T)0);
  for (int i = 1; i <= NumberOfVertices(); i++)
    sum += weights[i];
  for (int i = 1; i <= NumberOfVertices(); i++)
    weights[i] /= sum;

  gVector<T> answer(AmbientDmnsn());
  for (int j = 1; j <= AmbientDmnsn(); j++)
    answer[j] = (T)0;

  for (int i = 1; i <= NumberOfVertices(); i++)
    answer += Vertex(i) * weights[i];

  return answer;
}

template<class T> const gRectangle<T> gSimplex<T>::BoundingRectangle() const 
{ 
  gVector<T> bottoms(AmbientDmnsn());
  gVector<T> tops(AmbientDmnsn());
  for (int i = 1; i <= AmbientDmnsn(); i++) {
    bottoms[i] = LowerBoundOfCoord(i);
    tops[i]    = UpperBoundOfCoord(i);
  }
  return gRectangle<T>(bottoms,tops);
}

template<class T> const gList<gVector<T> > gSimplex<T>::VertexList() const 
{ 
  return vertices;
}

template<class T> const gVector<T> gSimplex<T>::Vertex(const int& i) const 
{ 
  return vertices[i];
}

template<class T> 
const int gSimplex<T>::NumberOfCellsInSubdivision() const 
{ 
  int answer = 1;
  for (int i = 2; i <= NumberOfVertices(); i++)
    answer *= i;
  return answer;
}

template<class T> 
const gSimplex<T> gSimplex<T>::SubdivisionCell(const int& index) const 
{ 
  int tmp = index;
  gArray<int> indices(NumberOfVertices() - 1);
  for (int i = 2; i <= NumberOfVertices(); i++) {
    indices[1 + NumberOfVertices() - i] = tmp % i;
    tmp -= indices[1 + NumberOfVertices() - i];
    tmp /= i;
  }
 
  gList<gVector<T> > new_vertices;
  gList<gVector<T> > undeleted(VertexList());
  for (int i = 1; i < NumberOfVertices(); i++) {
    gSimplex<T> face(undeleted);
    new_vertices += face.Center();
    undeleted.Remove(i);
  }
  new_vertices += undeleted[1];

  return gSimplex<T>(new_vertices);
}

//----------------------------------
//           Conversion
//----------------------------------

template<class T>  
gSimplex<gDouble>  TogDouble(const gSimplex<T>& given) 
{
  gList<gVector<gDouble> > vertices_in_gDouble;
  for (int i = 1; i <= given.NumberOfVertices(); i++) 
    vertices_in_gDouble += TogDouble(given.Vertex(i));
  return gSimplex<gDouble>(vertices_in_gDouble);
}

//--------------------------------------------------------------------------
//                        gSimplex -- printing
//--------------------------------------------------------------------------

template<class T> gOutput& operator << (gOutput& output, 
					const gSimplex<T>& S)
{
  output << "ConvexHull( ";
  for (int i = 1; i <= S.NumberOfVertices() - 1; i++)
    output << S.Vertex(i);
  return output;
}
