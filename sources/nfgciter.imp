//
// FILE: contiter.imp -- Implementation of contingency iterator
//
// $Id$
//

#include "nfgciter.h"
#include "nfg.h"
#include "nfstrat.h"
#include "nfplayer.h"

//-------------------------------------
// NfgContIter<T>: Constructor, Destructor
//-------------------------------------

template <class T> NfgContIter<T>::NfgContIter(const NFSupport *s)
  : current_strat((s->sups).Length()), N((Nfg<T> *) s->sups[1]->nfp->N), 
    profile(new StrategyProfile(s->sups.Length())),
    thawed(s->sups.Length())
{
  for (int i = 1; i <= thawed.Length(); i++)
    thawed[i] = i;
  stratset = s;
  First();
}

template <class T> NfgContIter<T>::~NfgContIter()
{
  delete profile;
}

//------------------------------
// NfgContIter<T>: Member Functions
//------------------------------

template <class T> void NfgContIter<T>::First(void)
{
  for (int i = 1; i <= thawed.Length(); i++){
    profile->Set(thawed[i], stratset->GetStrategy(thawed[i], 1));
    current_strat[thawed[i]] = 1;
  }	
}

template <class T> void NfgContIter<T>::Set(int pl, int num)
{
  if (!frozen.Contains(pl))   return;

  profile->Set(pl, stratset->GetStrategy(pl, num));
  current_strat[pl] = num;
}

template <class T> void NfgContIter<T>::Freeze(const gBlock<int> &freeze)
{
  frozen = freeze;
  thawed = gBlock<int>(N->NumPlayers() - freeze.Length());
  for (int i = 1, j = 1; i <= N->NumPlayers(); i++)
    if (!frozen.Contains(i))   thawed[j++] = i;
  First();
}

template <class T> void NfgContIter<T>::Freeze(int pl)
{
  if (frozen.Contains(pl))   return;
  frozen.Append(pl);
  thawed.Remove(thawed.Find(pl));
  First();
}

template <class T> void NfgContIter<T>::Thaw(int pl)
{
  if (thawed.Contains(pl))   return;
  frozen.Remove(frozen.Find(pl));
  int i = 1;
  while (thawed[i] < pl)   i++;
  thawed.Insert(pl, i);
  First();
}

template <class T> int NfgContIter<T>::NextContingency(void)
{
  int j = thawed.Length();
  if (j == 0) return 0;    	

  Strategy *s;
  while (1)   {
    int pl = thawed[j];
    if (current_strat[pl] < stratset->sups[pl]->NumStrats()) {
      s = stratset->GetStrategy(pl, ++(current_strat[pl]));
      profile->Set(pl, s);
      return 1;
    }
    profile->Set(pl, stratset->GetStrategy(pl, 1));
    current_strat[pl] = 1;
    j--;
    if (j == 0)
      return 0;
  }
}

template <class T> long NfgContIter<T>::GetIndex(void) const
{
  return profile->GetIndex();
}

template <class T> gArray<int> NfgContIter<T>::Get(void) const
{
  gArray<int> current(N->NumPlayers());
  for (int i = 1; i <= current.Length(); i++)
    current[i] = (*profile)[i]->number;
  return current;
}

template <class T> void NfgContIter<T>::Get(gArray<int> &t) const
{
  for (int i = 1; i <= N->NumPlayers(); i++)
    t[i] = (*profile)[i]->number;
}

template <class T> const T &NfgContIter<T>::Payoff(int p) const
{
  return N->Payoff(p, profile);
}

template <class T> void NfgContIter<T>::SetPayoff(int p, const T &value)
{
  N->SetPayoff(p, profile, value);
}


template <class T> void NfgContIter<T>::Dump(void) const
{
  gout << "{ ";
  for (int i = 1; i <= N->NumPlayers(); i++)
    gout << (*profile)[i]->number << ' ';
  gout << '}';
}


