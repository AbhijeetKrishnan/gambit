//
// FILE: nfgciter.imp -- Implementation of contingency iterator
//
// $Id$
//

#include "nfgciter.h"
#include "nfg.h"
#include "nfstrat.h"
#include "nfplayer.h"

//-------------------------------------
// NfgContIter: Constructor, Destructor
//-------------------------------------

NfgContIter::NfgContIter(const NFSupport &s)
  : support(s), 
    current_strat(s.Game().NumPlayers()),
    N((Nfg *) &s.Game()), profile(*N), thawed(N->NumPlayers())
{
  for (int i = 1; i <= thawed.Length(); i++)
    thawed[i] = i;

  First();
}

NfgContIter::~NfgContIter()
{ }

//------------------------------
// NfgContIter: Member Functions
//------------------------------

void NfgContIter::First(void)
{
  for (int i = 1; i <= thawed.Length(); i++){
    profile.Set(thawed[i], support.Strategies(thawed[i])[1]);
    current_strat[thawed[i]] = 1;
  }	
}

void NfgContIter::Set(int pl, int num)
{
  if (!frozen.Contains(pl))   return;

  profile.Set(pl, support.Strategies(pl)[num]);
  current_strat[pl] = num;
}

void NfgContIter::Set(const Strategy *s)
{
  if (!frozen.Contains(s->Player()->GetNumber()))   return;

  profile.Set(s->Player()->GetNumber(), s);
  current_strat[s->Player()->GetNumber()] = s->Number();
}

void NfgContIter::Freeze(const gBlock<int> &freeze)
{
  frozen = freeze;
  thawed = gBlock<int>(N->NumPlayers() - freeze.Length());
  for (int i = 1, j = 1; i <= N->NumPlayers(); i++)
    if (!frozen.Contains(i))   thawed[j++] = i;
  First();
}

void NfgContIter::Freeze(int pl)
{
  if (frozen.Contains(pl))   return;
  frozen.Append(pl);
  thawed.Remove(thawed.Find(pl));
  First();
}

void NfgContIter::Thaw(int pl)
{
  if (thawed.Contains(pl))   return;
  frozen.Remove(frozen.Find(pl));
  int i = 1;
  while (thawed[i] < pl)   i++;
  thawed.Insert(pl, i);
  First();
}

int NfgContIter::NextContingency(void)
{
  int j = thawed.Length();
  if (j == 0) return 0;    	

  Strategy *s;
  while (1)   {
    int pl = thawed[j];
    if (current_strat[pl] < support.NumStrats(pl)) {
      s = support.Strategies(pl)[++(current_strat[pl])];
      profile.Set(pl, s);
      return 1;
    }
    profile.Set(pl, support.Strategies(pl)[1]);
    current_strat[pl] = 1;
    j--;
    if (j == 0)
      return 0;
  }
}

long NfgContIter::GetIndex(void) const
{
  return profile.GetIndex();
}

const StrategyProfile &NfgContIter::Profile(void) const
{
  return profile;
}

gArray<int> NfgContIter::Get(void) const
{
  gArray<int> current(N->NumPlayers());
  for (int i = 1; i <= current.Length(); i++)
    current[i] = profile[i]->Number();
  return current;
}

void NfgContIter::Get(gArray<int> &t) const
{
  for (int i = 1; i <= N->NumPlayers(); i++)
    t[i] = profile[i]->Number();
}

NFOutcome *NfgContIter::GetOutcome(void) const
{
  return N->GetOutcome(profile);
}

void NfgContIter::SetOutcome(NFOutcome *outcome)
{
  N->SetOutcome(profile, outcome);
}

void NfgContIter::Dump(gOutput &f) const
{
  f << "{ ";
  for (int i = 1; i <= N->NumPlayers(); i++)
    f << profile[i]->Number() << ' ';
  f << '}';
}


