//#
//# FILE: contiter.imp -- Implementation of contingency iterator
//#
//# $Id$
//#

#include "contiter.h"
#include "normal.h"
#include "strategy.h"

template <class T> ContIter<T>::ContIter(NormalForm<T> &nf, int undom)
  : N(&nf), profile(new StrategyProfile(N->NumPlayers())),
    thawed(N->NumPlayers()), undom_only(undom)
{
  for (int i = 1; i <= thawed.Length(); i++)
    thawed[i] = i;
  First();
}

template <class T> ContIter<T>::ContIter(NormalForm<T> *nf, int undom)
  : N(nf), profile(new StrategyProfile(N->NumPlayers())),
    thawed(N->NumPlayers()), undom_only(undom)
{
  for (int i = 1; i <= thawed.Length(); i++)
    thawed[i] = i;
  First();
}

template <class T> ContIter<T>::~ContIter()
{
  delete profile;
}

template <class T> void ContIter<T>::First(void)
{
  for (int i = 1; i <= thawed.Length(); i++)  {
    Strategy *s = (*N->strategies)(thawed[i], 1);
    while (undom_only && s->dominator)   s = s->next;
    profile->Set(thawed[i], s);
  }
}
  
template <class T> void ContIter<T>::Set(int pl, int num)
{
  if (!frozen.Contains(pl))   return;

  profile->Set(pl, N->GetStrategy(pl, num));
}

template <class T> void ContIter<T>::Freeze(const gBlock<int> &freeze)
{
  frozen = freeze;
  thawed = gBlock<int>(N->NumPlayers() - freeze.Length());
  for (int i = 1, j = 1; i <= N->NumPlayers(); i++)
    if (!frozen.Contains(i))   thawed[j++] = i;
  First();
}

template <class T> void ContIter<T>::Freeze(int pl)
{
  if (frozen.Contains(pl))   return;
  frozen.Append(pl);
  thawed.Remove(thawed.Find(pl));
  First();
}

template <class T> void ContIter<T>::Thaw(int pl)
{
  if (thawed.Contains(pl))   return;
  frozen.Remove(frozen.Find(pl));
  int i = 1;
  while (thawed[i] < pl)   i++;
  thawed.Insert(pl, i);
  First();
}

template <class T> int ContIter<T>::NextContingency(void)
{
  int j = thawed.Length();
  
  while (1)   {
    int pl = thawed[j];
    Strategy *s = (undom_only) ? (*profile)[pl]->next_undom
                               : (*profile)[pl]->next;
    if (s)  {
      profile->Set(pl, s);
      return 1;
    }

    s = (*N->strategies)(pl, 1);
    while (undom_only && s->dominator)   s = s->next;
    profile->Set(pl, s);
    j--;
    if (j == 0)
      return 0;
  }
}

template <class T> long ContIter<T>::GetIndex(void) const
{
  return profile->GetIndex();
}

template <class T> const T &ContIter<T>::Payoff(int pl) const
{
  return N->Payoff(pl, *profile);
}

template <class T> T &ContIter<T>::Payoff(int pl)
{
  return N->Payoff(pl, *profile);
}

template <class T> void ContIter<T>::Dump(gOutput &f) const
{
  f << "{ ";
  for (int i = 1; i <= N->NumPlayers(); i++)
    f << (*profile)[i]->number << ' ';
  f << '}';
}

      
