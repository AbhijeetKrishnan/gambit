//
// FILE: gsmpltpe.imp -- Implementation of gSimplex
//
// $Id$
//

#include "gsmpltpe.h"


//--------------------------------------------------------------------------
//                   gSimpletope -- constructors and destructor
//--------------------------------------------------------------------------

template<class T> gSimpletope<T>::gSimpletope(const gSimpletope<T>& given) 
: simplices(given.simplices), vertices(given.vertices)
{
}

template<class T> gSimpletope<T>::gSimpletope(const gList< gVector<T> >& given)
: simplices(), vertices(given)
{
}

template<class T> gSimpletope<T>::gSimpletope(const gList<gSimplex<T> >& given)
: simplices(given), vertices(given[1].VertexList())
{
}

template<class T> gSimpletope<T>::~gSimpletope() 
{
}

//--------------------------------------------------------------------------
//                          gSimpletope -- operators
//--------------------------------------------------------------------------


template<class T> gSimpletope<T>& 
gSimpletope<T>::operator = (const gSimpletope<T>& /* rhs */)
{
  gout << "For const'ness, operator = not allowed for gSimpletope\n";
  exit (0);
  return *this;
}


template<class T> bool gSimpletope<T>::operator == (const gSimpletope<T>& rhs)
     const
{
  if (NumberOfSimplices() != rhs.NumberOfSimplices())
    return false;

  for (int i = 1; i <= NumberOfSimplices(); i++)
    if (SimplexList()[i] != rhs.SimplexList()[i])
      return false;

  return true;
}

template<class T> bool gSimpletope<T>::operator != (const gSimpletope<T>& rhs)
     const
{
  return !(*this == rhs);
}

//--------------------------------------------------------------------------
//                             gSimpletope -- information
//--------------------------------------------------------------------------

template<class T> const int gSimpletope<T>::AmbientDmnsn() const 
{ 
  int ambdmnsn = 0;
  for (int i = 1; i <= NumberOfSimplices(); i++)
    ambdmnsn += SimplexList()[i].AmbientDmnsn();
  return ambdmnsn;
}

template<class T> const int gSimpletope<T>::NumberOfVertices() const 
{ 
  return vertices.Length();
}

template<class T> const int gSimpletope<T>::NumberOfSimplices() const 
{ 
  return SimplexList().Length();
}

template<class T> const gVector<T> gSimpletope<T>::LowerBound() const 
{ 
  gVector<T> answer(AmbientDmnsn());
  int index = 0;
  for (int i = 1; i <= NumberOfSimplices(); i++) 
    for (int j = 1; j <= SimplexList()[i].AmbientDmnsn(); j++) {
      index++;
      answer[index] = SimplexList()[i].LowerBoundOfCoord(j);
    }
  return answer;
}


template<class T> const gVector<T> gSimpletope<T>::UpperBound() const 
{ 
  gVector<T> answer(AmbientDmnsn());
  int index = 0;
  for (int i = 1; i <= NumberOfSimplices(); i++) 
    for (int j = 1; j <= SimplexList()[i].AmbientDmnsn(); j++) {
      index++;
      answer[index] = SimplexList()[i].UpperBoundOfCoord(j);
    }
  return answer;
}

template<class T> const T gSimpletope<T>::LowerBoundOfCoord(const int& i) const 
{ 
  int j = 1;
  int k = i;
  while (k > SimplexList()[j].AmbientDmnsn()) {
    k -= SimplexList()[j].AmbientDmnsn();
    j++;
  }
  return SimplexList()[j].LowerBoundOfCoord(k);
}

template<class T> const T gSimpletope<T>::UpperBoundOfCoord(const int& i) const 
{ 
  int j = 1;
  int k = i;
  while (k > SimplexList()[j].AmbientDmnsn()) {
    k -= SimplexList()[j].AmbientDmnsn();
    j++;
  }
  return SimplexList()[j].UpperBoundOfCoord(k);
}

template<class T> const T gSimpletope<T>::HeightInCoord(const int& i) const 
{ 
  return UpperBoundOfCoord(i) - LowerBoundOfCoord(i);
}

template<class T> 
const gSimpletope<T> gSimpletope<T>::SameCenterDoubleSideLengths() const 
{ 
  gList<gSimplex<T> > new_simplices;
  for (int i = 1; i <= NumberOfSimplices(); i++)
    new_simplices += SimplexList()[i].SameCenterDoubleSideLengths();
  return gSimpletope<T>(new_simplices);
}

template<class T> bool gSimpletope<T>::Contains(const gVector<T>& point) const 
{   
  int total_so_far = 0;
  for (int i = 1; i <= NumberOfSimplices(); i++) {
    gVector<T> coords(SimplexList()[i].AmbientDmnsn());
    for (int j = 1; j <= SimplexList()[i].AmbientDmnsn(); j++)
      coords[j] = point[total_so_far + j];
    if ( !SimplexList()[i].Contains(gVector<T>(coords)) )
      return false;
    total_so_far += SimplexList()[i].AmbientDmnsn();
  }
  return true;
}

template<class T> bool gSimpletope<T>::Contains(const gSimpletope<T>& S) const 
{ 
  assert (S.AmbientDmnsn() == AmbientDmnsn());

  for (int i = 1; i <= NumberOfSimplices(); i++)
    if ( !SimplexList()[i].Contains(S.SimplexList()[i]) )
      return false;
  return true;
}

template<class T> const T gSimpletope<T>::Volume() const 
{ 
  T answer = (T)1;
  for (int i = i; i <= NumberOfSimplices(); i++)
     answer *= SimplexList()[i].Volume();
  return answer;
}

template<class T> const gVector<T> gSimpletope<T>::Center() const 
{ 
  int total_so_far = 0;
  gVector<T> answer(AmbientDmnsn());
  for (int i = 1; i <= NumberOfSimplices(); i++) {
    gVector<T> next(SimplexList()[i].Center());
    for (int j = 1; j <= next.Length(); j++)
      answer[total_so_far + j] = next[j];
    total_so_far == next.Length();
  }
}

template<class T> const gRectangle<T> gSimpletope<T>::BoundingRectangle() const 
{ 
  gList<gInterval<T> > cartesian_factors;
  for (int i = 1; i <= NumberOfSimplices(); i++) {
    gRectangle<T> next = SimplexList()[i].BoundingRectangle();
    for (int j = 1; j <= next.Dmnsn(); j++)
    cartesian_factors += next.CartesianFactor(j);
  }
  return gRectangle<T>(cartesian_factors);
}

template<class T> 
const gList<gSimplex<T> > gSimpletope<T>::SimplexList() const 
{ 
  return simplices;
}

template<class T> const gSimplex<T> gSimpletope<T>::Simplex(const int& i) const 
{ 
  return SimplexList()[i];
}

template<class T> 
const int gSimpletope<T>::NumberOfCellsInSubdivision() const 
{ 
  int answer = 1;
  for (int i = 1; i <= NumberOfSimplices(); i++)
    answer *= SimplexList()[i].NumberOfCellsInSubdivision();
  return answer;
}

template<class T> 
const gSimpletope<T> gSimpletope<T>::SubdivisionCell(const int& index) const 
{ 
  int tmp = index;
  gArray<int> indices(NumberOfSimplices());
  for (int i = 1; i <= NumberOfSimplices(); i++) {
    int divisor = SimplexList()[i].NumberOfCellsInSubdivision();
    indices[i] = tmp % divisor;
    tmp -= indices[i];
    tmp /= divisor;
  }

  gList<gSimplex<T> > new_simplices;
  for (int i = 1; i <= NumberOfSimplices(); i++)
    new_simplices += SimplexList()[i].SubdivisionCell(indices[i]);
  return gSimpletope<T>(new_simplices);
}

//----------------------------------
//           Conversion
//----------------------------------

template<class T>  
gSimpletope<gDouble>  TogDouble(const gSimpletope<T>& given) 
{
  gList<gSimplex<gDouble> > simplices_in_gDouble;
  for (int i = 1; i <= given.NumberOfSimplices(); i++) 
    simplices_in_gDouble += TogDouble(given.Simplex(i));
  return gSimpletope<gDouble>(simplices_in_gDouble);
}

//--------------------------------------------------------------------------
//                        gSimpletope -- printing
//--------------------------------------------------------------------------

template<class T> gOutput& operator << (gOutput& output, 
					const gSimpletope<T>& S)
{
  output << "CartesianProduct( ";
  for (int i = 1; i <= S.NumberOfVertices() - 1; i++)
    output << S.Simplex(i);
  return output;
}
