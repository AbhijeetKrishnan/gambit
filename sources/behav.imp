//
// FILE: behav.imp -- Implementation of behavior profiles
//
// $Id$
//

#include "efg.h"
#include "efplayer.h"
#include "infoset.h"
#include "node.h"
#include "outcome.h"
#include "efgutils.h"

#include "gvector.h"
#include "behavsol.h"

#include "nfg.h"
#include "mixed.h"
#include "lexicon.h"

//-------------------------------------------------------------------------
//                    PureBehavProfile<T> member functions
//-------------------------------------------------------------------------

template <class T> PureBehavProfile<T>::PureBehavProfile(const Efg &efg)
  : E(&efg), profile(efg.NumPlayers())
{
  E->InitPayoffs();  // only needed for T=double, remove if class is detemplated
  for (int pl = 1; pl <= efg.NumPlayers(); pl++)  {
    EFPlayer *player = efg.Players()[pl];
    profile[pl] = new gArray<const Action *>(player->NumInfosets());
    for (int iset = 1; iset <= player->NumInfosets(); iset++)
      (*profile[pl])[iset] = player->Infosets()[iset]->Actions()[1];
  }
}

template <class T>
PureBehavProfile<T>::PureBehavProfile(const PureBehavProfile<T> &p)
  : E(p.E), profile(p.profile.Length())
{
  E->InitPayoffs();  // only needed for T=double, remove if class is detemplated
  for (int pl = 1; pl <= profile.Length(); pl++)   {
    profile[pl] = new gArray<const Action *>(p.profile[pl]->Length());
    for (int iset = 1; iset <= profile[pl]->Length(); iset++)
      (*profile[pl])[iset] = (*p.profile[pl])[iset];
  }
}

template <class T> PureBehavProfile<T>::~PureBehavProfile()
{
  for (int pl = 1; pl <= profile.Length(); delete profile[pl++]);
}

template <class T> 
PureBehavProfile<T> &PureBehavProfile<T>::operator=(const PureBehavProfile<T> &p) 
{
  if (this != &p && E == p.E)   {
    for(int pl = 1; pl <= profile.Length(); pl++)
    for(int iset = 1; iset <= profile[pl]->Length(); iset++)
    (*profile[pl])[iset] = (*p.profile[pl])[iset];
  }
  return *this;
}

template <class T> T PureBehavProfile<T>::operator()(Action *action) const
{
  if ((*profile[action->BelongsTo()->GetPlayer()->GetNumber()])
      [action->BelongsTo()->GetNumber()] == action)
    return (T) 1;
  else
    return (T) 0;
}

template <class T> void PureBehavProfile<T>::Set(const Action *action)
{
  (*profile[action->BelongsTo()->GetPlayer()->GetNumber()])
    [action->BelongsTo()->GetNumber()] = action;
}

template <class T>
void PureBehavProfile<T>::Set(const EFPlayer *player,
                              const gArray<const Action *> &actions)
{
  *profile[player->GetNumber()] = actions;
}

template <class T>
const Action *PureBehavProfile<T>::GetAction(const Infoset *infoset) const
{
  return (*profile[infoset->GetPlayer()->GetNumber()])[infoset->GetNumber()];
}

/* - The following is an attempt to eliminate all the extra work of
computing a vector of payoffs when only one agent's payoff is of
interest.  It runs into a problem that I don't know how to solve,
namely that compilation leads to a request for a cast from gNumber to
gRational. amm-8.98

template <class T>
void PureBehavProfile<T>::IndPayoff(const Node *n, 
				 const int &pl, 
				 const T prob, 
				       T &payoff) const
{
  if (n->IsTerminal())
    payoff += prob * (*payoffs)(n->GetOutcome()->GetNumber(), pl);
  
  if (n->IsNonterminal() && n->GetPlayer()->IsChance())
    for (int i = 1; i <= n->NumChildren(); i++) {
      IndPayoff(n->GetChild(i), pl,
	     prob * (T) E->GetChanceProb(n->GetInfoset(), i), payoff);
    }
  else if (n->IsNonterminal())
    IndPayoff(n->GetChild((*profile[n->GetPlayer()->GetNumber()])[n->GetInfoset()->GetNumber()]->GetNumber()), pl,
	   prob, payoff);
}
*/

// The following could be shortened by using the player-specific one above.
// Whether this would be more efficient in fact is unknown. - AMM 7.6.98

template <class T>
const T PureBehavProfile<T>::Payoff(const Node *n, const int &pl) const
{
  gArray<T> payoff(E->NumPlayers());
  for (int i = 1; i <= E->NumPlayers(); i++)
    payoff[i] = (T)0;
  Payoff(n, (T)1, payoff);
  return payoff[pl];
}

template <class T>
void PureBehavProfile<T>::Payoff(const Node *n, 
				 const T prob, 
				       gArray<T> &payoff) const
{
  if (n->IsTerminal())
    for (int pl = 1; pl <= E->NumPlayers(); pl++) 
      payoff[pl] += prob * Payoff(n->GetOutcome(),pl);
  
  else
    if (n->GetPlayer()->IsChance())	
      for (int i = 1; i <= E->NumChildren(n); i++)
	Payoff(n->GetChild(i),
	       prob * (T) E->GetChanceProb(n->GetInfoset(), i), payoff);
    else
      Payoff(n->GetChild(GetAction(n->GetInfoset())), prob, payoff);
}

template <class T>
void PureBehavProfile<T>::InfosetProbs(Node *n, T prob, gPVector<T> &probs) const
{
  if (n->GetInfoset() && n->GetPlayer()->IsChance())
    for (int i = 1; i <= E->NumChildren(n); i++)
      InfosetProbs(n->GetChild(i),
		   prob * (T) E->GetChanceProb(n->GetInfoset(), i), probs);
  else if (n->GetInfoset())  {
    probs(n->GetPlayer()->GetNumber(), n->GetInfoset()->GetNumber()) += prob;
    InfosetProbs(n->GetChild((*profile[n->GetPlayer()->GetNumber()])[n->GetInfoset()->GetNumber()]->GetNumber()),
		 prob, probs);
  }
}

template <class T>
void PureBehavProfile<T>::Payoff(gArray<T> &payoff) const
{
  for (int pl = 1; pl <= payoff.Length(); payoff[pl++] = (T) 0);
  Payoff(E->RootNode(), (T) 1, payoff);
}

template <class T>
void PureBehavProfile<T>::InfosetProbs(gPVector<T> &probs) const
{
  ((gVector<T> &) probs).operator=((T) 0);
  InfosetProbs(E->RootNode(), (T) 1, probs);
}

template <class T>
const T PureBehavProfile<T>::Payoff(const EFOutcome *o, const int &pl) const
{
  if (o)
    return o->payoffs[pl];
  else
    return (T) 0;
}

//------------------------------------------------------------------------
//      Implementation of BehavNode
//------------------------------------------------------------------------

template <class T> BehavProfile<T>::BehavNode::BehavNode(Efg *e, Node *n, int pl)
  : node(n), nval((T) 0), bval((T) 0), children(e->NumChildren(n)), 
    realizProb((T)0), belief((T)0), nodeValue(pl)
{
  for (int child = 1; child <= children.Length(); child++) 
    children[child] = new BehavNode(e,n->GetChild(child), pl);
}    

template <class T> BehavProfile<T>::BehavNode::~BehavNode()
{
  for (int child = 1; child <= children.Length();
       delete children[child++]);
}

//------------------------------------------------------------------------
//      Implementation of BehavInfoset<T>
//------------------------------------------------------------------------

template <class T> BehavProfile<T>::BehavInfoset::BehavInfoset(const EFSupport &s, Infoset *i, int pl)
  : iset(i), actions(s.NumActions(i)), value((T)0), prob((T)0)
{ 
for(int act = 1;act<=s.NumActions(i);act++)
     actions[act] = new BehavAction(s.Actions(i)[act],pl);
}    

template <class T> BehavProfile<T>::BehavInfoset::~BehavInfoset()
{ 
for(int act = 1;act<=actions.Length();act++)
  delete actions[act];
}

//------------------------------------------------------------------------
//      Implementation of BehavAction<T>
//------------------------------------------------------------------------

template <class T> BehavProfile<T>::BehavAction::BehavAction(Action *act, int pl)
  : action(act), probability(0), condPayoff((T)0), gripe((T)0)
{  }    

template <class T> BehavProfile<T>::BehavAction::~BehavAction()
{
  if(action->BelongsTo()->IsChanceInfoset())
  delete probability;
}

//-------------------------------------------------------------------------
//   BehavProfile<T>: Constructors, Destructor
//-------------------------------------------------------------------------

template <class T>
BehavProfile<T>::BehavProfile(const BehavProfile<T> &p_profile)
  : gDPVector<T>(p_profile), m_efg(p_profile.m_efg),
    m_root(new BehavNode((Efg *)p_profile.m_efg, p_profile.m_efg->RootNode(),
			 p_profile.m_efg->NumPlayers())),
    m_support(p_profile.m_support), m_isets(p_profile.m_isets.Length()), 
    m_cached_data(false)
{
  InitProfile();
}

template <class T> 
BehavProfile<T>::BehavProfile(const BehavSolution &p_solution)
  : gDPVector<T>(p_solution.Game().NumActions()), m_efg(&p_solution.Game()),
    m_root(new BehavNode((Efg*)m_efg, p_solution.Game().RootNode(),
			 p_solution.Game().NumPlayers())),
    m_support(EFSupport(p_solution.Game())), m_isets(p_solution.Game().TotalNumInfosets()), 
    m_cached_data(false)

{
  for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) {
    EFPlayer *player = m_efg->Players()[pl];
    for (int iset = 1; iset <= player->NumInfosets(); iset++) {
      Infoset *infoset = player->Infosets()[iset];
      for (int act = 1; act <= infoset->NumActions(); act++)
	(*this)(pl, iset, act) = p_solution(infoset->Actions()[act]);
    }
  } 
  InitProfile();
}

template <class T> BehavProfile<T>::BehavProfile(const EFSupport &p_support) 
  : gDPVector<T>(p_support.NumActions()), 
    m_efg(&p_support.Game()),
    m_root(new BehavNode((Efg *)m_efg, m_efg->RootNode(), m_efg->NumPlayers())),
    m_support(p_support), m_isets(m_efg->TotalNumInfosets()), 
    m_cached_data(false)

{
  InitProfile();
  Centroid();
}

template <class T>
BehavProfile<T>::BehavProfile(const MixedProfile<T> &p_profile)
  : gDPVector<T>(p_profile.Game().AssociatedEfg()->NumActions()), 
    m_efg(p_profile.Game().AssociatedEfg()),
    m_root(new BehavNode((Efg *)m_efg, m_efg->RootNode(), m_efg->NumPlayers())),
    m_support(*m_efg),  
    m_isets(p_profile.Game().AssociatedEfg()->TotalNumInfosets()), 
    m_cached_data(false)

{
  //  gout << "\nin BehavProfile(const MixedProfile<T> &p_profile)";

  InitProfile();

  if (m_efg->AssociatedAfg() == &p_profile.Game())   {
    ((gVector<T> &) *this).operator=((gVector<T> &) p_profile);
    return;
  }

  ((gVector<T> &) *this).operator=((T)0); 

  BehavNode *n = m_root;
  const NFSupport &support = p_profile.Support();
  const Nfg &nfg = p_profile.Game();

  for (int pl = 1; pl <= nfg.NumPlayers(); pl++)   {
    n->ClearNodeProbs();

    for (int st = 1; st <= support.NumStrats(pl); st++)  {
      int snum = support.Strategies(pl)[st]->Number();
      if (p_profile(pl, st) > (T) 0)  {
	const gArray<int> *const actions = m_efg->GetLexicon()->strategies[pl][snum];

	n->bval = p_profile(pl, st);

	RealizationProbs(p_profile, *m_efg, pl, actions, m_root);
      }
    }
    
    m_root->nval = (T) 1;
    BehaviorStrat(*m_efg, pl, n);
  }
}

template <class T> BehavProfile<T>::~BehavProfile()
{
  delete m_root;
  for(int i=1;i<=m_isets.Length();i++)
    delete m_isets[i];
}

//-------------------------------------------------------------------------
//   BehavProfile<T>: Operator overloading
//-------------------------------------------------------------------------

template <class T>
BehavProfile<T> &BehavProfile<T>::operator=(const BehavProfile<T> &p_profile)
{
  if (this != &p_profile && m_efg == p_profile.m_efg)   {
    Invalidate();
    // note that a dimensionality change will trigger an exception
    // in the gDPVector assignment operator
    gDPVector<T>::operator=(p_profile);
    m_support = p_profile.m_support;
  }
  return *this;
}

template <class T>
bool BehavProfile<T>::operator==(const BehavProfile<T> &p_profile) const
{
  return (m_efg == p_profile.m_efg &&
	  (gDPVector<T> &) *this == (gDPVector<T> &) p_profile);
}

//-------------------------------------------------------------------------
//   BehavProfile<T>: Installation, Initialization, Validation
//-------------------------------------------------------------------------

template <class T>
void BehavProfile<T>::InstallMe(BehavNode *b_node) const
{
  b_node->node->solution = b_node;
  for (int child = 1; child <= b_node->children.Length(); child++) 
    InstallMe(b_node->children[child]);
}

template <class T>
void BehavProfile<T>::InstallMe(void) const
{
  // The following may be needed depending on how subgame solver is implemented
  // if(m_root->node->GetParent())UnmarkParents(m_root->node->GetParent());
  InstallMe(m_root);
  for(int i=1;i<=m_isets.Length();i++) {
    m_isets[i]->iset->solution = m_isets[i];
    for(int j=1;j<=(m_isets[i]->actions).Length();j++) {
      (m_isets[i]->actions)[j]->action->solution = (m_isets[i]->actions)[j];
    }
  }
}

/*
template <class T>
void BehavProfile<T>::UnmarkParents(Node * n) const
{
  n->solution = 0;
  if(n->GetParent()) UnmarkParents(n->GetParent());
}
*/

template <class T>
void BehavProfile<T>::InitPayoffs(void) const
{
  InstallMe();
  m_efg->InitPayoffs();

  const gArray<Infoset *> &isets = ((FullEfg *)m_efg)->GetChance()->Infosets();
  for(int iset=1;iset<=isets.Length();iset++) {
    const gArray<Action *> &acts = m_support.Actions(isets[iset]);
    for(int act=1;act<=acts.Length();act++) 
      *(((BehavAction *)(acts[act]->solution))->probability) 
	= ((FullEfg *)m_efg)->GetChanceProb(acts[act]);
    // this should work, but doesn't:
    //      ActionProb(acts[act]) = ((FullEfg *)m_efg)->GetChanceProb(acts[act]);
  }
}

template <class T>
void BehavProfile<T>::InitProfile(void)
{
  const gBlock<Infoset *> &efg_isets = ((FullEfg *)m_efg)->Infosets();
  for(int i=1;i<=efg_isets.Length();i++) {
    int pl = efg_isets[i]->GetPlayer()->GetNumber();
    m_isets[i] = new BehavInfoset(m_support,efg_isets[i],m_efg->NumPlayers());
    int iset = m_isets[i]->iset->GetNumber();
    for(int j=1;j<=m_isets[i]->actions.Length();j++) 
      m_isets[i]->actions[j]->probability = &((*this)(pl,iset,j));
  }

  int n1 = efg_isets.Length();

  const gArray<Infoset *> &chance_isets = ((FullEfg *)m_efg)->GetChance()->Infosets();
  assert(efg_isets.Length()+chance_isets.Length()==m_isets.Length());
  for(int i=1;i<=chance_isets.Length();i++) {
    m_isets[n1+i] = new BehavInfoset(m_support,chance_isets[i],m_efg->NumPlayers());
    for(int j=1;j<=m_isets[n1+i]->actions.Length();j++) 
      m_isets[n1+i]->actions[j]->probability = new T(0); 
  }
  InitPayoffs();
}

template <class T>
bool BehavProfile<T>::IsInstalled(void) const
{
  return (m_root->node->solution == m_root);
}

template <class T> void BehavProfile<T>::Centroid(void) const
{
  T center;

  for (int pl = 1; pl <= dvlen.Length(); pl++)
    for (int iset = 1; iset <= dvlen[pl]; iset++)
      if (m_support.NumActions(pl,iset) > 0) {
	center = ((T) 1 / (T) m_support.NumActions(pl, iset));
	int act;
	for (act = 1; act <= svlen[dvidx[pl] + iset - 1]; act++)
	  dvptr[pl][iset][act] = center;
      }
}

//-------------------------------------------------------------------------
//   BehavProfile<T>: General data access -- private functions
//-------------------------------------------------------------------------

template <class T>
const T &BehavProfile<T>::RealizProb(const Node *node) const
{
  return ((BehavNode *)node->solution)->realizProb;
}

template <class T>
T &BehavProfile<T>::RealizProb(const Node *node)
{
  return ((BehavNode *)node->solution)->realizProb;
}

template <class T>
const T &BehavProfile<T>::BeliefProb(const Node *node) const
{
  return ((BehavNode *)node->solution)->belief;
}

template <class T>
T &BehavProfile<T>::BeliefProb(const Node *node)
{
  return ((BehavNode *)node->solution)->belief;
}


template <class T>
const T &BehavProfile<T>::IsetProb(const Infoset *iset) const
{
  return ((BehavInfoset *)iset->solution)->prob;
}

template <class T>
T &BehavProfile<T>::IsetProb(const Infoset *iset)
{
  return ((BehavInfoset *)iset->solution)->prob;
}


template <class T>
const T &BehavProfile<T>::IsetValue(const Infoset *iset) const
{
  return ((BehavInfoset *)iset->solution)->value;
}

template <class T>
T &BehavProfile<T>::IsetValue(const Infoset *iset)
{
  return ((BehavInfoset *)iset->solution)->value;
}


template <class T> const T &BehavProfile<T>::Regret(const Action * act) const
{
  return ((BehavAction *)(act->solution))->gripe;
}	

template <class T> T &BehavProfile<T>::Regret(const Action * act)
{
  return ((BehavAction *)(act->solution))->gripe;
}

//-------------------------------------------------------------------------
//   BehavProfile<T>: General data access -- public functions
//-------------------------------------------------------------------------

template <class T>
const T &BehavProfile<T>::GetRealizProb(const Node *node)
{ 
  ComputeSolutionData();
  return RealizProb(node);
}



template <class T>
const T &BehavProfile<T>::GetBeliefProb(const Node *node)
{ 
  ComputeSolutionData();
  return BeliefProb(node);
}

template <class T>
const gVector<T> &BehavProfile<T>::GetNodeValue(const Node *node)
{ 
  ComputeSolutionData();
  return NodeValue(node);
}

template <class T>
const T &BehavProfile<T>::GetIsetProb(const Infoset *iset)
{ 
  ComputeSolutionData();
  return IsetProb(iset);
}

template <class T>
const T &BehavProfile<T>::GetIsetValue(const Infoset *iset)
{ 
  ComputeSolutionData();
  return IsetValue(iset);
}

template <class T>
const T &BehavProfile<T>::GetActionProb(const Action *act) const
{ 
  if(!IsInstalled()) InstallMe();
  return ActionProb((Action *)act);
}


template <class T>
const T &BehavProfile<T>::GetActionValue(const Action * act)
{ 
  ComputeSolutionData();
  return ActionValue(act);
}

template <class T>
const T &BehavProfile<T>::GetRegret(const Action * act)
{ 
  ComputeSolutionData();
  return Regret(act);
}

//-------------------------------------------------------------------------
//   BehavProfile<T>: Computation of interesting quantities
//-------------------------------------------------------------------------

//--------------
// Payoff
//--------------


template <class T>
void BehavProfile<T>::Payoff(Node *node, T prob, int player, T &value) const
{
  Infoset * iset = node->infoset;

  if (node->outcome) 
    value += prob * Payoff(node->outcome, player);

  if (node->children.Length())  {
    const gArray<Action *> &acts = m_support.Actions(iset);
    for (int act = 1; act <= acts.Length(); act++) 
      Payoff(node->GetChild(acts[act]), prob * ActionProb(acts[act]), player, value);
  }
}

template <class T> T BehavProfile<T>::Payoff(int player) const
{
  if(!IsInstalled()) InstallMe();
  T value = (T) 0;
  Payoff(m_efg->RootNode(), (T) 1, player, value);
  return value;
}

// 
// Computation of Cached solution data
// 

template <class T>
void BehavProfile<T>::ComputeSolutionDataPass2(const Node *node)
{
  gVector<T> &nv = NodeValue(node);

  if (node->outcome) 
    for(int i=1;i<=nv.Length();i++) 
      nv[i] += Payoff(node->outcome,i);

  Infoset * iset = node->infoset;

  if(iset) {
    if (IsetProb(iset) != IsetProb(iset) * (T) 0)
      BeliefProb(node) = RealizProb(node) / IsetProb(iset);
    
    const gArray<Node *> &children = m_efg->Children(node); 
	
    // push down payoffs from outcomes attached to non-terminal nodes 
    for (int child = 1; child <= children.Length(); child++) 
      NodeValue(children[child]) = nv;
    
    nv = (T) 0;
    
    for (int child = 1; child <= children.Length(); child++)  {
      ComputeSolutionDataPass2(children[child]);

      gVector<T> &s = NodeValue(children[child]);

      const Action * act = children[child]->GetAction();

      for(int i=1;i<=s.Length();i++)
	nv[i] += s[i] * ActionProb(act);
      //      nv += s * ActionProb(act);

      if(!iset->IsChanceInfoset()) {
	T &cpay = ActionValue(act);
	if (IsetProb(iset) != IsetProb(iset) * (T) 0) 
	  cpay += BeliefProb(node) * s[iset->GetPlayer()->GetNumber()];
	else
	  cpay = (T)0;
      }
    }
  }
}

// compute realization probabilities for nodes and isets.  
template <class T>
void BehavProfile<T>::ComputeSolutionDataPass1(const Node *node)
{
  T &r = RealizProb(node);
  if(node->GetParent()) {
    r = RealizProb(node->GetParent()) * ActionProb(node->GetAction());
  }
  NodeValue(node) = (T)0;
  
  Infoset *iset = node->infoset;
  
  if(iset) {
    IsetProb(node->infoset) += r;
    
    const gArray<Node *> &children(m_efg->Children(node));
    for(int i=1;i<=children.Length();i++)
      ComputeSolutionDataPass1(children[i]);
  }
}

template <class T>
void BehavProfile<T>::ComputeSolutionData(void)
{
  if(!IsInstalled()) InstallMe();
  if(!m_cached_data) {
    for(int i = 1;i<=m_isets.Length();i++) {
      m_isets[i]->prob = (T)0;
      for(int j = 1;j<=m_isets[i]->actions.Length();j++)
	m_isets[i]->actions[j]->condPayoff = (T)0;
    }
    m_root->realizProb = (T)1;
    ComputeSolutionDataPass1(m_root->node);
    ComputeSolutionDataPass2(m_root->node);

    for(int i = 1;i<=m_isets.Length();i++) {
      Infoset * iset = m_isets[i]->iset;
      IsetValue(iset) = (T)0;
      for(int j = 1;j<=m_isets[i]->actions.Length();j++) {
	Action * act = m_isets[i]->actions[j]->action;
	IsetValue(iset) += ActionProb(act) * ActionValue(act);
      }
      for(int j = 1;j<=m_isets[i]->actions.Length();j++) {
	Action * act = m_isets[i]->actions[j]->action;
	Regret(act) = (ActionValue(act) - IsetValue(iset) ) * IsetProb(iset);
      }
    }
    m_cached_data = true;
  }
}

template <class T>
void BehavProfile<T>::BehaviorStrat(const Efg &E, int pl,
				    BehavNode *n)
{
  for (int i = 1; i <= n->children.Length(); i++)   {
    BehavProfile<T>::BehavNode *child = n->children[i];
    if (n->node->GetPlayer() && n->node->GetPlayer()->GetNumber() == pl)
      if (n->nval > (T) 0 && child->nval > (T) 0)  {
	(*this)(n->node->GetPlayer()->GetNumber(),
		n->node->GetInfoset()->GetNumber(), 
		Support().Find(n->node->GetInfoset()->Actions()[i])) =
	  child->nval / n->nval;
      }
    BehaviorStrat(E, pl, child);
  }
}

template <class T>
void BehavProfile<T>::RealizationProbs(const MixedProfile<T> &mp,
				       const Efg &E, int pl,
				       const gArray<int> *const actions,
				       BehavNode *n)
{
  static const T tremble = (T) 0;
  T prob;

  Node *node = n->node;

  for (int i = 1; i <= n->children.Length(); i++)   {
    if (node->GetPlayer() && !node->GetPlayer()->IsChance())   {
      if (node->GetPlayer()->GetNumber() == pl)  {
	if ((*actions)[node->GetInfoset()->GetNumber()] == i)
	  prob = (T) 1 - tremble + tremble / (T) E.NumChildren(node);
	else
	  prob = tremble / (T) E.NumChildren(node);
      }
      else if (Support().Find(node->GetInfoset()->Actions()[i]))
	prob = (T) 1 / (T) Support().NumActions(node->GetPlayer()->GetNumber(),
						node->GetInfoset()->GetNumber());
      else
	prob = (T) 0;
    }
    else  {   // n.GetPlayer() == 0
      prob = E.GetChanceProb(node->GetInfoset(), i).operator gRational();
    }

    BehavNode *child = n->children[i];
    child->bval = prob * n->bval;
    child->nval += child->bval;    

    RealizationProbs(mp, E, pl, actions, child);
  }    
	
}

//----------------
// ComputeActionValues
//----------------

template <class T>
void BehavProfile<T>::ComputeActionValues(Node *node, T prob)
{
  gVector<T> &nv = NodeValue(node);

  if (node->outcome) 
    for(int i=1;i<=nv.Length();i++) 
      nv[i] += Payoff(node->outcome,i);

  Infoset * iset = node->infoset;

  if(iset) {
    const gArray<Node *> &children = m_efg->Children(node); 
	
    // push down payoffs from outcomes attached to non-terminal nodes 
    for (int child = 1; child <= children.Length(); child++) 
      NodeValue(children[child]) = nv;
    
    nv = (T) 0;
    
    const gArray<Action *> &acts = m_support.Actions(iset);
    for (int act = 1; act <= acts.Length(); act++)  {
      Node * child = node->GetChild(acts[act]);
      
      const T newprob = ActionProb(acts[act]);
      ComputeActionValues(child, prob * newprob);
      
      gVector<T> &s = NodeValue(child);
      
      for (int i = 1; i <= s.Length(); i++)
	nv[i] += s[i] * newprob;

      // for some mysterious reason, the following leads to 
      // differnces in insignificant digits that can eventually lead to different 
      // convergence properties (i. e., in LiapSolve[LoadEfg["e06.efg"]])

      // nv += s * newprob;  
      
      if(!iset->IsChanceInfoset())
	ActionValue(acts[act]) += prob * s[iset->GetPlayer()->GetNumber()];
    }
    if(!iset->IsChanceInfoset())
      IsetProb(iset) += prob;
  }
}

template <class T> void BehavProfile<T>::ComputeActionValues(void)
{
  if(!IsInstalled())InstallMe();

  for(int i = 1;i<=m_isets.Length();i++) {
    m_isets[i]->prob = (T)0;
    for(int j = 1;j<=m_isets[i]->actions.Length();j++)
      m_isets[i]->actions[j]->condPayoff = (T)0;
  }

  m_root->nodeValue = (T) 0;
  ComputeActionValues(m_root->node, (T) 1);

  for(int i = 1;i<=m_isets.Length();i++) {
    BehavInfoset * biset = m_isets[i];
    if(!biset->iset->IsChanceInfoset()) 
      for(int j = 1;j<=biset->actions.Length();j++) 
	// This will protect against divides by zero.
	// It will leave unreached infoset values at zero.
	if (biset->prob != biset->prob * (T) 0)
	  biset->actions[j]->condPayoff /= biset->prob;
  }
}

template <class T> gDPVector<T> BehavProfile<T>::Beliefs(void)
{
  ComputeSolutionData();
  gDPVector<T> bprobs(m_efg->NumMembers());
  bprobs = (T) 0;

  for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) {
    EFPlayer *player = m_efg->Players()[pl];
    for (int iset = 1; iset <= player->NumInfosets(); iset++) {
      Infoset *infoset = player->Infosets()[iset];
      for (int i = 1; i <= infoset->Members().Length(); i++) 
	bprobs(player->GetNumber(),infoset->GetNumber(),i) = BeliefProb(infoset->Members()[i]);
    }
  }

  return bprobs;
}

template <class T> T BehavProfile<T>::LiapValue(void)
{
  static const T BIG1 = (T) 10000;
  static const T BIG2 = (T) 100;

  T x, result = ((T) 0), avg, sum;

  ComputeActionValues();

  const gArray<EFPlayer *> &players = m_efg->Players();
  for (int i = 1; i <= players.Length(); i++) {
    const gArray<Infoset *> &infosets = players[i]->Infosets();
    for (int iset = 1; iset <= infosets.Length(); iset++) {
      const gArray<Action *> &acts = m_support.Actions(infosets[iset]);
      avg = sum = (T)0;

      for (int act = 1; act <= acts.Length(); act++) {
	x = ActionProb(acts[act]);
	avg += x * ActionValue(acts[act]);
	sum += x;
	if (x > (T)0)  x = (T)0;
	result += BIG1 * x * x;         // add penalty for neg probabilities
      }

      for (int act = 1; act <= acts.Length(); act++) {
	x = ActionValue(acts[act]) - avg;
	if (x < (T)0) x = (T)0;
	result += x * x;          // add penalty if not best response
      }
      x = sum - (T)1;
      result += BIG2 * x * x;       // add penalty for sum not equal to 1
    }
  }
  return result;
}

template <class T> T BehavProfile<T>::QreValue(const gVector<T> &lambda, bool &_domain_err)
{
  static const T PENALTY = (T)10000;
  T BigNum = (T)500;
  
  //  gDPVector<T> _cpay(m_support.NumActions());

  T val = (T)0, prob, psum, z,factor;
 
  ComputeActionValues();

  const gArray<EFPlayer *> players = m_efg->Players();
  for (int pl = 1; pl <= players.Length(); pl++)  {
    const gArray<Infoset *> infosets = players[pl]->Infosets();    
    for (int iset = 1; iset <= infosets.Length(); iset++)  {
      const gArray<Action *> &acts = Support().Actions(infosets[iset]);
      prob = (T)0;
      psum = (T)0;

      for (int act = 1; act <= acts.Length(); act++)  {
	z = lambda[pl] * ActionValue(acts[act]);
	factor=(T)1;
	if(z>BigNum) {factor+=z-BigNum;z=BigNum;_domain_err=true;}
	if(z<-BigNum) {factor+=z+BigNum;z=-BigNum;_domain_err=true;}
	z = ((T)exp(z))*factor;
	psum += z;
	//	_cpay(pl,iset,act) = z;
	ActionValue(acts[act]) = z;
      }
      
      for (int act = 1; act <= acts.Length(); act++)  {
	z = ActionProb(acts[act]);
	prob += z;
	if (z < (T)0)
	  val += PENALTY * z * z;
	z -= ActionValue(acts[act]) / psum;
	//	z -= _cpay(pl,iset,act) / psum;
	val += z * z;
      }
      z = (T)1 - prob;
      val += (T)100 * z * z;
    }
  }

  return val;
}

template <class T>
T BehavProfile<T>::MaxRegret(void)
{ 
  ComputeSolutionData();
  T ret = (T)0;
  for(int i=1;i<=m_isets.Length();i++)
    for(int j=1;j<=m_isets[i]->actions.Length();j++)
      if(m_isets[i]->actions[j]->gripe>ret)
	ret = m_isets[i]->actions[j]->gripe;
  return ret;
}


template <class T> void BehavProfile<T>::Dump(gOutput &p_file) const
{
  gDPVector<T>::Dump(p_file);
}


//------------------------------------------------------------------------
//   BehavProfile<T>: Used in test of extendability to ANF Nash
//------------------------------------------------------------------------

template <class T> gPolyList<gDouble> 
BehavProfile<T>::ActionProbsSumToOneIneqs(const gSpace &BehavStratSpace, 
	        		          const term_order &Lex,
					  const EFSupport &big_supp,
				          const gList<gList<int> > &var_index) 
  const
{
  gPolyList<gDouble> answer(&BehavStratSpace, &Lex);

  int pl;
  for (pl = 1; pl <= Game().NumPlayers(); pl++) 
    for (int i = 1; i <= Game().Players()[pl]->NumInfosets(); i++) {
      Infoset *current_infoset = Game().Players()[pl]->Infosets()[i];
      if ( !big_supp.HasActiveActionAt(current_infoset) ) {
	int index_base = var_index[pl][i];
	gPoly<gDouble> factor(&BehavStratSpace, (gDouble)1.0, &Lex);
	for (int k = 1; k < current_infoset->NumActions(); k++)
	  factor -= gPoly<gDouble>(&BehavStratSpace, index_base + k, 1, &Lex);
	answer += factor;
      }
    }
  return answer;
}

template <class T>
bool BehavProfile<T>::ANFNodeProbabilityPoly(      gPoly<gDouble> & node_prob,
		          	          const gSpace &BehavStratSpace, 
				          const term_order &Lex,
					  const EFSupport &big_supp,
				          const gList<gList<int> > &var_index,
				          const Node *tempnode,
				          const int &pl,
				          const int &i,
				          const int &j) const
{
  while (tempnode != Game().RootNode()) {

    const Action *last_action = tempnode->GetAction();
    Infoset *last_infoset = last_action->BelongsTo();
    
    if (last_infoset->IsChanceInfoset()) 
      node_prob *= (gDouble)Game().GetChanceProb(last_action);
    else 
      if (big_supp.HasActiveActionAt(last_infoset)) {
	if (last_infoset == Game().Players()[pl]->Infosets()[i]) {
	  if (j != last_action->GetNumber()) 
	    return false;
	}
	else
	  if (big_supp.ActionIsActive((Action *)last_action))
	    node_prob *= (gDouble)ActionProb(last_action);
	  else 
	    return false;
      }
      else {
	int initial_var_no = 
 var_index[last_infoset->GetPlayer()->GetNumber()][last_infoset->GetNumber()];
	if (last_action->GetNumber() < last_infoset->NumActions()){
	  int varno = initial_var_no + last_action->GetNumber();
	  node_prob *= gPoly<gDouble>(&BehavStratSpace, varno, 1, &Lex);
	}
	else {
	  gPoly<gDouble> factor(&BehavStratSpace, (gDouble)1.0, &Lex);
	  int k;
	  for (k = 1; k < last_infoset->NumActions(); k++)
	    factor -= gPoly<gDouble>(&BehavStratSpace,
				     initial_var_no + k, 1, &Lex);
	  node_prob *= factor;
	}
      } 
    tempnode = tempnode->GetParent();
  }
  return true;
}

template <class T> gPolyList<gDouble> 
BehavProfile<T>::ANFExpectedPayoffDiffPolys(const gSpace &BehavStratSpace, 
					    const term_order &Lex,
					    const EFSupport &little_supp,
					    const EFSupport &big_supp,
					  const gList<gList<int> > &var_index) 
  const
{
  gPolyList<gDouble> answer(&BehavStratSpace, &Lex);

  gList<const Node *> terminal_nodes = Game().TerminalNodes();

  for (int pl = 1; pl <= Game().NumPlayers(); pl++)
    for (int i = 1; i <= Game().Players()[pl]->NumInfosets(); i++) {
      Infoset *infoset = Game().Players()[pl]->Infosets()[i];
      if (little_supp.MayReach(infoset)) 
	for (int j = 1; j <= infoset->NumActions(); j++)
	  if (!little_supp.ActionIsActive(pl,i,j)) {
	
	    // This will be the utility difference between the
	    // payoff resulting from the profile and deviation to 
	    // action j
	    gPoly<gDouble> next_poly(&BehavStratSpace, &Lex);

	    for (int n = 1; n <= terminal_nodes.Length(); n++) {
	      gPoly<gDouble> node_prob(&BehavStratSpace, (gDouble)1.0, &Lex);
	      if (ANFNodeProbabilityPoly(node_prob,
					 BehavStratSpace,
					 Lex,
					 big_supp,
					 var_index,
					 terminal_nodes[n],
					 pl,i,j)) {
		node_prob *= 
		  (gDouble)Game().Payoff(terminal_nodes[n],
					 Game().Players()[pl]);
		next_poly += node_prob;
	      }
	    }
	    answer += -next_poly + (gDouble)Payoff(pl);
	  }
    }
  return answer;
}

template <class T>  gPolyList<gDouble> 
BehavProfile<T>::ExtendsToANFNashIneqs(const gSpace &BehavStratSpace, 
				       const term_order &Lex,
				       const EFSupport &little_supp,
				       const EFSupport &big_supp,
				       const gList<gList<int> > &var_index) 
  const
{
  gPolyList<gDouble> answer(&BehavStratSpace, &Lex);
  answer += ActionProbsSumToOneIneqs(BehavStratSpace, 
				     Lex, 
				     big_supp, 
				     var_index);
  answer += ANFExpectedPayoffDiffPolys(BehavStratSpace, 
				       Lex, 
				       little_supp,
				       big_supp,
				       var_index);
  return answer;
}

//------------------------------------------------------------------------
//         BehavProfile<T>: Test whether extends to ANF Nash eq
//------------------------------------------------------------------------

template <class T> bool 
BehavProfile<T>::ExtendsToANFNash(const EFSupport &little_supp,
				  const EFSupport &big_supp,
				        gStatus &m_status) const
{
  // This asks whether there is a Nash extension of the BehavSolution to 
  // all information sets at which the behavioral probabilities are not
  // specified.  The assumption is that the support has active actions
  // at infosets at which the behavioral probabilities are defined, and
  // no others.
  
  // First we compute the number of variables, and indexing information
  int num_vars(0);
  gList<gList<int> > var_index;
  int pl;
  for (pl = 1; pl <= Game().NumPlayers(); pl++) {

    gList<int> list_for_pl;

    for (int i = 1; i <= Game().Players()[pl]->NumInfosets(); i++) {
      list_for_pl += num_vars;
      if ( !big_supp.HasActiveActionAt(Game().Players()[pl]->Infosets()[i]) ) {
	num_vars += Game().Players()[pl]->Infosets()[i]->NumActions() - 1;
      }
    }
    var_index += list_for_pl;
  }

  // We establish the space
  gSpace BehavStratSpace(num_vars);
  ORD_PTR ptr = &lex;
  term_order Lex(&BehavStratSpace, ptr);

  num_vars = BehavStratSpace.Dmnsn();
  gPolyList<gDouble> inequalities = ExtendsToANFNashIneqs(BehavStratSpace,
							  Lex,
							  little_supp,
							  big_supp,
							  var_index);

  // set up the rectangle of search
  gVector<gDouble> bottoms(num_vars), tops(num_vars);
  bottoms = (gDouble)0;
  tops = (gDouble)1;
  gRectangle<gDouble> Cube(bottoms, tops); 

  // Set up the test and do it
  IneqSolv<gDouble> extension_tester(inequalities,m_status);
  gVector<gDouble> sample(num_vars);
  return extension_tester.ASolutionExists(Cube,sample); 
}


//------------------------------------------------------------------------
//         BehavProfile<T>: Used in test of extendability to Nash
//------------------------------------------------------------------------

template <class T>  void
BehavProfile<T>::DeviationInfosetsRECURSION(    gList<const Infoset *> &answer,
					    const EFSupport & big_supp,
					    const EFPlayer *pl,
					    const Node* node,
					    const Action *act) const 
{
  Node *child  = node->GetChild(act);
  if ( child->IsNonterminal() ) {
    const Infoset *iset = child->GetInfoset();
    if ( iset->GetPlayer() == pl ) {
      int insert = 0;
      bool done = false;
      while (!done) {
	insert ++;
	if (insert > answer.Length() ||
	    iset->Precedes(answer[insert]->GetMember(1)))
	  done = true;
      }
      answer.Insert(iset,insert);
    }
    gList<Action *> action_list = iset->ListOfActions();
    for (int j = 1; j <= action_list.Length(); j++)
      DeviationInfosetsRECURSION(answer,big_supp,pl,child,action_list[j]);
  }
  return;
}

template <class T>  const gList<const Infoset *> 
BehavProfile<T>::DeviationInfosets(const EFSupport & big_supp,
				   const EFPlayer *pl,
				   const Infoset *iset,
				   const Action *act) const 
{
  gList<const Infoset *> answer;
  
  gList<const Node *> node_list = iset->ListOfMembers();
  for (int i = 1; i <= node_list.Length(); i++) {
    DeviationInfosetsRECURSION(answer,big_supp,pl,node_list[i],act);
  }

  return answer;
}

template <class T>  const gList<const EFSupport> 
BehavProfile<T>::DeviationSupports(const EFSupport & big_supp,
				   const gList<const Infoset *> & isetlist,
				   const EFPlayer */*pl*/,
				   const Infoset */*iset*/,
				   const Action */*act*/) const 
{
  gList<const EFSupport> answer;

  gArray<int> active_act_no(isetlist.Length());

  for (int k = 1; k <= active_act_no.Length(); k++)
    active_act_no[k] = 0;
 
  EFSupport new_supp(big_supp);

  for (int i = 1; i <= isetlist.Length(); i++) {
    for (int j = 1; j < isetlist[i]->NumActions(); j++)
      new_supp.RemoveAction(isetlist[i]->GetAction(j));
    new_supp.AddAction(isetlist[i]->GetAction(1));

    active_act_no[i] = 1;
    for (int k = 1; k < i; k++)
      if (isetlist[k]->Precedes(isetlist[i]->GetMember(1)))
	if (isetlist[k]->GetAction(1)->Precedes(isetlist[i]->GetMember(1))) {
	  new_supp.RemoveAction(isetlist[i]->GetAction(1));
	  active_act_no[i] = 0;
	}
  }
  answer += new_supp;

  int iset_cursor = isetlist.Length();
  while (iset_cursor > 0) {
    if ( active_act_no[iset_cursor] == 0 || 
	 active_act_no[iset_cursor] == isetlist[iset_cursor]->NumActions() )
      iset_cursor--;
    else {
      new_supp.RemoveAction(isetlist[iset_cursor]->
			    GetAction(active_act_no[iset_cursor]));
      active_act_no[iset_cursor]++;
      new_supp.AddAction(isetlist[iset_cursor]->
			 GetAction(active_act_no[iset_cursor]));
      for (int k = iset_cursor + 1; k <= isetlist.Length(); k++) {
	if (active_act_no[k] > 0)
	  new_supp.RemoveAction(isetlist[k]->GetAction(1));
	int h = 1;
	bool active = true;
	while (active && h < k) {
	  if (isetlist[h]->Precedes(isetlist[k]->GetMember(1)))
	    if (active_act_no[h] == 0 || 
		!isetlist[h]->GetAction(active_act_no[h])->
	              Precedes(isetlist[k]->GetMember(1))) {
	      active = false;
	      if (active_act_no[k] > 0) {
		new_supp.RemoveAction(isetlist[k]->
				      GetAction(active_act_no[k]));
		active_act_no[k] = 0;
	      }
	    }
	  h++;
	}
	if (active){
	  new_supp.AddAction(isetlist[k]->GetAction(1));
	  active_act_no[k] = 1;
	}
      }
      answer += new_supp;
    }
  }
  return answer;
}

template <class T> bool 
BehavProfile<T>::NashNodeProbabilityPoly(      gPoly<gDouble> & node_prob,
		          	         const gSpace &BehavStratSpace, 
				         const term_order &Lex,
				         const EFSupport &dsupp,
				         const gList<gList<int> > &var_index,
				         const Node *tempnode,
					 const EFPlayer */*pl*/,
				         const Infoset *iset,
				         const Action *act) const 
{
  while (tempnode != Game().RootNode()) {

    const Action *last_action = tempnode->GetAction();
    Infoset *last_infoset = last_action->BelongsTo();
    
    if (last_infoset->IsChanceInfoset()) 
      node_prob *= (gDouble)Game().GetChanceProb(last_action);
    else 
      if (dsupp.HasActiveActionAt(last_infoset)) {
	if (last_infoset == iset) {
	  if (act != last_action) {
	    return false;
	  }
	}
	else
	  if (dsupp.ActionIsActive((Action *)last_action)) {
	    if ( last_action->BelongsTo()->GetPlayer() !=
		         act->BelongsTo()->GetPlayer()     ||
		 !act->Precedes(tempnode) )
	    node_prob *= (gDouble)ActionProb(last_action);
	  }
	  else {
	    return false;
	  }
      }
      else {
	int initial_var_no = 
 var_index[last_infoset->GetPlayer()->GetNumber()][last_infoset->GetNumber()];
	if (last_action->GetNumber() < last_infoset->NumActions()){
	  int varno = initial_var_no + last_action->GetNumber();
	  node_prob *= gPoly<gDouble>(&BehavStratSpace, varno, 1, &Lex);
	}
	else {
	  gPoly<gDouble> factor(&BehavStratSpace, (gDouble)1.0, &Lex);
	  int k;
	  for (k = 1; k < last_infoset->NumActions(); k++)
	    factor -= gPoly<gDouble>(&BehavStratSpace,
				     initial_var_no + k, 1, &Lex);
	  node_prob *= factor;
	}
      } 
    tempnode = tempnode->GetParent();
  }
  return true;
}


template <class T> gPolyList<gDouble> 
BehavProfile<T>::NashExpectedPayoffDiffPolys(const gSpace &BehavStratSpace, 
				          const term_order &Lex,
					  const EFSupport &little_supp,
					  const EFSupport &big_supp,
				          const gList<gList<int> > &var_index) 
  const
{
  gPolyList<gDouble> answer(&BehavStratSpace, &Lex);

  gList<const Node *> terminal_nodes = Game().TerminalNodes();

  const gArray<EFPlayer *> players = Game().Players();
  for (int pl = 1; pl <= players.Length(); pl++) {
    const gArray<Infoset *> isets_for_pl = players[pl]->Infosets();
    for (int i = 1; i <= isets_for_pl.Length(); i++) {
      if (little_supp.MayReach(isets_for_pl[i])) {
	const gArray<Action *> acts_for_iset = isets_for_pl[i]->Actions();
	for (int j = 1; j <= acts_for_iset.Length(); j++)
	  if ( !little_supp.ActionIsActive(acts_for_iset[j]) ) {
	    gList<const Infoset *> isetlist = DeviationInfosets(big_supp, 
							     players[pl],
				         		     isets_for_pl[i],
							     acts_for_iset[j]);
	    gList<const EFSupport> dsupps = DeviationSupports(big_supp, 
							     isetlist, 
							     players[pl],
				         		     isets_for_pl[i],
							     acts_for_iset[j]);
	    for (int k = 1; k <= dsupps.Length(); k++) {

	    // This will be the utility difference between the
	    // payoff resulting from the profile and deviation to 
	    // the strategy for pl specified by dsupp[k]

	      gPoly<gDouble> next_poly(&BehavStratSpace, &Lex);

	      for (int n = 1; n <= terminal_nodes.Length(); n++) {
		gPoly<gDouble> node_prob(&BehavStratSpace, (gDouble)1.0, &Lex);
		if (NashNodeProbabilityPoly(node_prob,
					    BehavStratSpace,
					    Lex,
					    dsupps[k],
					    var_index,
					    terminal_nodes[n],
					    players[pl],
					    isets_for_pl[i],
					    acts_for_iset[j])) {
		  node_prob *= 
		    (gDouble)Game().Payoff(terminal_nodes[n],
					   Game().Players()[pl]);
		  next_poly += node_prob;
		}
	      }
	      answer += -next_poly + (gDouble)Payoff(pl);
	    }
	  }
      }
    }
  }
  return answer;
}

template <class T>  gPolyList<gDouble> 
BehavProfile<T>::ExtendsToNashIneqs(const gSpace &BehavStratSpace, 
				    const term_order &Lex,
				    const EFSupport &little_supp,
				    const EFSupport &big_supp,
				    const gList<gList<int> > &var_index) const
{
  gPolyList<gDouble> answer(&BehavStratSpace, &Lex);
  answer += ActionProbsSumToOneIneqs(BehavStratSpace, 
				     Lex, 
				     big_supp, 
				     var_index);

  answer += NashExpectedPayoffDiffPolys(BehavStratSpace, 
				    Lex, 
				    little_supp,
				    big_supp,
				    var_index);
  return answer;
}

//------------------------------------------------------------------------
//         BehavProfile<T>: Test whether extends to a Nash eq
//------------------------------------------------------------------------

template <class T> bool 
BehavProfile<T>::ExtendsToNash(const EFSupport &little_supp,
			       const EFSupport &big_supp,
			             gStatus &m_status) const
{
  // This asks whether there is a Nash extension of the BehavSolution to 
  // all information sets at which the behavioral probabilities are not
  // specified.  The assumption is that the support has active actions
  // at infosets at which the behavioral probabilities are defined, and
  // no others.
  
  // First we compute the number of variables, and indexing information
  int num_vars(0);
  gList<gList<int> > var_index;
  int pl;
  for (pl = 1; pl <= Game().NumPlayers(); pl++) {

    gList<int> list_for_pl;

    for (int i = 1; i <= Game().Players()[pl]->NumInfosets(); i++) {
      list_for_pl += num_vars;
      if ( !big_supp.HasActiveActionAt(Game().Players()[pl]->Infosets()[i]) ) {
	num_vars += Game().Players()[pl]->Infosets()[i]->NumActions() - 1;
      }
    }
    var_index += list_for_pl;
  }

  // We establish the space
  gSpace BehavStratSpace(num_vars);
  ORD_PTR ptr = &lex;
  term_order Lex(&BehavStratSpace, ptr);

  num_vars = BehavStratSpace.Dmnsn();

  gPolyList<gDouble> inequalities = ExtendsToNashIneqs(BehavStratSpace,
						       Lex,
						       little_supp,
						       big_supp,
						       var_index);
  // set up the rectangle of search
  gVector<gDouble> bottoms(num_vars), tops(num_vars);
  bottoms = (gDouble)0;
  tops = (gDouble)1;
  gRectangle<gDouble> Cube(bottoms, tops); 

  // Set up the test and do it
  IneqSolv<gDouble> extension_tester(inequalities,m_status);
  gVector<gDouble> sample(num_vars);
  return extension_tester.ASolutionExists(Cube,sample); 
}

template <class T> BehavProfile<T>::BadStuff::~BadStuff()
{ }

template <class T> gText BehavProfile<T>::BadStuff::Description(void) const
{
  return "Solution not installed in BehavProfile";
}

template <class T> void BehavProfile<T>::BehavNode::ClearNodeProbs(void)
{
  nval = (T) 0;
  for (int i = 1; i <= children.Length(); i++)
    children[i]->ClearNodeProbs();
}

//-----------------
//   Output
//-----------------

template <class T> gOutput &operator<<(gOutput &p_file,
				       const BehavProfile<T> &p_profile)
{
  p_profile.Dump(p_file);
  return p_file;
}

//------------------------------------------------------------------------
//  BehavAssessment<T>: Constructors, Destructor, Constructive Operators
//------------------------------------------------------------------------

template <class T>
BehavAssessment<T>::BehavAssessment(const EFSupport &p_support)
  : BehavProfile<T>(p_support), m_beliefs(p_support.Game().NumMembers())
{
  m_beliefs = BehavProfile<T>::Beliefs();
}

template <class T>
BehavAssessment<T>::BehavAssessment(const BehavProfile<T> &p_profile)
  : BehavProfile<T>(p_profile), m_beliefs(p_profile.Game().NumMembers())
{ 
  m_beliefs = BehavProfile<T>::Beliefs();
}

template <class T>
BehavAssessment<T>::BehavAssessment(const BehavAssessment<T> &p_assess)
  : BehavProfile<T>(p_assess), m_beliefs(p_assess.m_beliefs)
{ }

template <class T> BehavAssessment<T>::~BehavAssessment()
{ }

template <class T> BehavAssessment<T> &
BehavAssessment<T>::operator=(const BehavAssessment<T> &p_assess)
{
  if (this != &p_assess && &Game() == &p_assess.Game()) {
    BehavProfile<T>::operator=(p_assess);
    m_beliefs = p_assess.m_beliefs;
  }
  return *this;
}

//------------------------------------------------------------------------
//        BehavAssessment<T>: Access and manipulation of beliefs
//------------------------------------------------------------------------

template <class T> gDPVector<T> BehavAssessment<T>::Beliefs(void) const
{ return m_beliefs; }

template <class T> gDPVector<T> &BehavAssessment<T>::Beliefs(void)
{ return m_beliefs; }

//----------------
// CondPayoff
//----------------

template <class T>
void BehavAssessment<T>::CondPayoff(BehavNode *p_node, T p_prob,
				    gPVector<T> &p_probs,
				    gDPVector<T> &p_payoff) const
{
  int npl =
    (p_node->node->GetInfoset()) ? p_node->node->GetPlayer()->GetNumber() : -1;
  int iset = 
    (p_node->node->GetInfoset()) ? p_node->node->GetInfoset()->GetNumber() : 0;
  
  if (p_node->node->GetOutcome()) 
    for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) 
      p_node->nodeValue[pl] += Payoff(p_node->node->GetOutcome(), pl);

  int nc = p_node->children.Length();
  for (int child = 1; child <= nc; child++)
    p_node->children[child]->nodeValue = p_node->nodeValue;
  
  gVector<T> tmp(m_efg->NumPlayers());
  tmp = (T) 0;
  
  if (nc == 0)   return;

  if (npl == 0)   {
    for (int child = 1; child <= nc; child++)  {
      CondPayoff(p_node->children[child],
		 p_prob *
		 ActionProb(m_efg->Children(p_node->node)[child]->GetAction()),
		 //		 ChanceProb(p_node->node->GetInfoset(),child),
		 p_probs, p_payoff);
      
      for (int pl = 1; pl <= p_node->nodeValue.Length(); pl++)
	tmp[pl] += 
	  ActionProb(m_efg->Children(p_node->node)[child]->GetAction()) *
	  //	  ChanceProb(p_node->node->GetInfoset(), child) *
	  p_node->children[child]->nodeValue[pl];
    }
    p_node->nodeValue = tmp;
  }
  else  {    // player decision node
    // This implementation differs from the one in BehavProfile<T>
    // since we have well-defined belief probabilities off the equilibrium
    // path.  So, we must traverse the whole tree, and cannot ignore
    // the (zero-probability) actions which do not appear in the support
    for (int child = 1; child <= m_efg->NumChildren(p_node->node); child++) {
      int act = m_support.Find(p_node->node->GetInfoset()->Actions()[child]);
      T newprob;
      if (act)
	newprob = (*this)(npl, iset, act);
      else
	newprob = (T) 0;
      CondPayoff(p_node->children[child], p_prob * newprob,
		 p_probs, p_payoff);
      for (int pl = 1; pl <= p_node->nodeValue.Length(); pl++)
	tmp[pl] += newprob * p_node->children[child]->nodeValue[pl];
      
      int mnum;
      for (mnum = 1;
	   p_node->node->GetInfoset()->Members()[mnum] != p_node->node;
	   mnum++);
      p_payoff(npl, iset, child) += 
	m_beliefs(npl, iset, mnum)  * p_node->children[child]->nodeValue[npl];
      p_node->nodeValue = tmp;
    }
  }    
  
  if (npl > 0)
    p_probs(npl, p_node->node->GetInfoset()->GetNumber()) += p_prob;
}


template <class T>
void BehavAssessment<T>::CondPayoff(gDPVector<T> &p_payoff,
				    gPVector<T> &p_probs) const
{
  ((gVector<T> &) p_payoff).operator=((T) 0);
  ((gVector<T> &) p_probs).operator=((T) 0);

  m_root->nodeValue = (T) 0;
  CondPayoff(m_root, (T) 1, p_probs, p_payoff);

  // We can dispense with the normalization step found in the analogous
  // place in BehavProfile<T> since the beliefs are assumed to be 
  // normalized to sum to 1.  (If they don't, things are weird anyway.)
}

//------------------------------------------------------------------------
//                     BehavAssessment<T>: Output
//------------------------------------------------------------------------

template <class T> void BehavAssessment<T>::Dump(gOutput &p_file) const
{
  BehavProfile<T>::Dump(p_file);
  p_file << ' ';
  p_file << m_beliefs;
}

template <class T> gOutput &operator<<(gOutput &p_file,
				       const BehavAssessment<T> &p_assess)
{
  p_assess.Dump(p_file);
  return p_file;
}


