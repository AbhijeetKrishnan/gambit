//
// FILE: behav.imp -- Implementation of behavior profiles
//
// $Id$
//

#include "efg.h"
#include "efplayer.h"
#include "infoset.h"
#include "node.h"
#include "efgutils.h"
#include "fullefgoutcome.h"

#include "math/gvector.h"
#include "behavsol.h"

#include "nfg.h"
#include "mixed.h"
#include "lexicon.h"

//-------------------------------------------------------------------------
//                    PureBehavProfile<T> member functions
//-------------------------------------------------------------------------

template <class T> PureBehavProfile<T>::PureBehavProfile(const Efg::Game &efg)
  : E(&efg), profile(efg.NumPlayers())
{
  E->InitPayoffs();  // only needed for T=double, remove if class is detemplated
  for (int pl = 1; pl <= efg.NumPlayers(); pl++)  {
    EFPlayer *player = efg.Players()[pl];
    profile[pl] = new gArray<const Action *>(player->NumInfosets());
    for (int iset = 1; iset <= player->NumInfosets(); iset++)
      (*profile[pl])[iset] = player->Infosets()[iset]->Actions()[1];
  }
}

template <class T>
PureBehavProfile<T>::PureBehavProfile(const PureBehavProfile<T> &p)
  : E(p.E), profile(p.profile.Length())
{
  E->InitPayoffs();  // only needed for T=double, remove if class is detemplated
  for (int pl = 1; pl <= profile.Length(); pl++)   {
    profile[pl] = new gArray<const Action *>(p.profile[pl]->Length());
    for (int iset = 1; iset <= profile[pl]->Length(); iset++)
      (*profile[pl])[iset] = (*p.profile[pl])[iset];
  }
}

template <class T> PureBehavProfile<T>::~PureBehavProfile()
{
  for (int pl = 1; pl <= profile.Length(); delete profile[pl++]);
}

template <class T> 
PureBehavProfile<T> &PureBehavProfile<T>::operator=(const PureBehavProfile<T> &p) 
{
  if (this != &p && E == p.E)   {
    for(int pl = 1; pl <= profile.Length(); pl++)
    for(int iset = 1; iset <= profile[pl]->Length(); iset++)
    (*profile[pl])[iset] = (*p.profile[pl])[iset];
  }
  return *this;
}

template <class T> T PureBehavProfile<T>::operator()(Action *action) const
{
  if ((*profile[action->BelongsTo()->GetPlayer()->GetNumber()])
      [action->BelongsTo()->GetNumber()] == action)
    return (T) 1;
  else
    return (T) 0;
}

template <class T> void PureBehavProfile<T>::Set(const Action *action)
{
  (*profile[action->BelongsTo()->GetPlayer()->GetNumber()])
    [action->BelongsTo()->GetNumber()] = action;
}

template <class T>
void PureBehavProfile<T>::Set(const EFPlayer *player,
                              const gArray<const Action *> &actions)
{
  *profile[player->GetNumber()] = actions;
}

template <class T>
const Action *PureBehavProfile<T>::GetAction(const Infoset *infoset) const
{
  return (*profile[infoset->GetPlayer()->GetNumber()])[infoset->GetNumber()];
}

/* - The following is an attempt to eliminate all the extra work of
computing a vector of payoffs when only one agent's payoff is of
interest.  It runs into a problem that I don't know how to solve,
namely that compilation leads to a request for a cast from gNumber to
gRational. amm-8.98

template <class T>
void PureBehavProfile<T>::IndPayoff(const Node *n, 
				 const int &pl, 
				 const T prob, 
				       T &payoff) const
{
  if (n->IsTerminal())
    payoff += prob * (*payoffs)(n->GetOutcome()->GetNumber(), pl);
  
  if (n->IsNonterminal() && n->GetPlayer()->IsChance())
    for (int i = 1; i <= n->NumChildren(); i++) {
      IndPayoff(n->GetChild(i), pl,
	     prob * (T) E->GetChanceProb(n->GetInfoset(), i), payoff);
    }
  else if (n->IsNonterminal())
    IndPayoff(n->GetChild((*profile[n->GetPlayer()->GetNumber()])[n->GetInfoset()->GetNumber()]->GetNumber()), pl,
	   prob, payoff);
}
*/

// The following could be shortened by using the player-specific one above.
// Whether this would be more efficient in fact is unknown. - AMM 7.6.98

template <class T>
const T PureBehavProfile<T>::Payoff(const Node *n, const int &pl) const
{
  gArray<T> payoff(E->NumPlayers());
  for (int i = 1; i <= E->NumPlayers(); i++)
    payoff[i] = (T)0;
  Payoff(n, (T)1, payoff);
  return payoff[pl];
}

template <class T>
void PureBehavProfile<T>::Payoff(const Node *n, const T prob, 
				 gArray<T> &payoff) const
{
  if (n->IsTerminal()) {
    for (int pl = 1; pl <= E->NumPlayers(); pl++) {
      payoff[pl] += prob * Payoff(E->GetOutcome(n), pl);
    }
  }
  
  else
    if (n->GetPlayer()->IsChance())	
      for (int i = 1; i <= E->NumChildren(n); i++)
	Payoff(n->GetChild(i),
	       prob * (T) E->GetChanceProb(n->GetInfoset(), i), payoff);
    else
      Payoff(n->GetChild(GetAction(n->GetInfoset())), prob, payoff);
}

template <class T>
void PureBehavProfile<T>::InfosetProbs(Node *n, T prob, gPVector<T> &probs) const
{
  if (n->GetInfoset() && n->GetPlayer()->IsChance())
    for (int i = 1; i <= E->NumChildren(n); i++)
      InfosetProbs(n->GetChild(i),
		   prob * (T) E->GetChanceProb(n->GetInfoset(), i), probs);
  else if (n->GetInfoset())  {
    probs(n->GetPlayer()->GetNumber(), n->GetInfoset()->GetNumber()) += prob;
    InfosetProbs(n->GetChild((*profile[n->GetPlayer()->GetNumber()])[n->GetInfoset()->GetNumber()]->GetNumber()),
		 prob, probs);
  }
}

template <class T>
void PureBehavProfile<T>::Payoff(gArray<T> &payoff) const
{
  for (int pl = 1; pl <= payoff.Length(); payoff[pl++] = (T) 0);
  Payoff(E->RootNode(), (T) 1, payoff);
}

template <class T>
void PureBehavProfile<T>::InfosetProbs(gPVector<T> &probs) const
{
  ((gVector<T> &) probs).operator=((T) 0);
  InfosetProbs(E->RootNode(), (T) 1, probs);
}

template <class T>
const T PureBehavProfile<T>::Payoff(const Efg::Outcome &p_outcome,
				    const int &pl) const
{
  if (!p_outcome.IsNull()) {
    return E->Payoff(p_outcome)[pl];
  }
  else {
    return (T) 0;
  }
}

//------------------------------------------------------------------------
//      Implementation of BehavNode
//------------------------------------------------------------------------

template <class T> BehavProfile<T>::BehavNode::BehavNode(Efg::Game *e, Node *n, int pl)
  : node(n), nval((T) 0), bval((T) 0), children(e->NumChildren(n)), 
    realizProb((T)0), belief((T)0), nodeValue(pl)
{
  for (int child = 1; child <= children.Length(); child++) 
    children[child] = new BehavNode(e,n->GetChild(child), pl);
}    

template <class T> BehavProfile<T>::BehavNode::~BehavNode()
{
  for (int child = 1; child <= children.Length();
       delete children[child++]);
}

//------------------------------------------------------------------------
//      Implementation of BehavInfoset<T>
//------------------------------------------------------------------------

template <class T> BehavProfile<T>::BehavInfoset::BehavInfoset(const EFSupport &s, Infoset *i, int pl)
  : iset(i), actions(s.NumActions(i)), value((T)0), prob((T)0)
{ 
for(int act = 1;act<=s.NumActions(i);act++)
     actions[act] = new BehavAction(s.Actions(i)[act],pl);
}    

template <class T> BehavProfile<T>::BehavInfoset::~BehavInfoset()
{ 
for(int act = 1;act<=actions.Length();act++)
  delete actions[act];
}

//------------------------------------------------------------------------
//      Implementation of BehavAction<T>
//------------------------------------------------------------------------

template <class T> BehavProfile<T>::BehavAction::BehavAction(Action *act, int pl)
  : action(act), probability(0), condPayoff((T)0), gripe((T)0)
{  }    

template <class T> BehavProfile<T>::BehavAction::~BehavAction()
{
  if(action->BelongsTo()->IsChanceInfoset())
  delete probability;
}

//-------------------------------------------------------------------------
//   BehavProfile<T>: Constructors, Destructor
//-------------------------------------------------------------------------

template <class T>
BehavProfile<T>::BehavProfile(const BehavProfile<T> &p_profile)
  : gDPVector<T>(p_profile), m_efg(p_profile.m_efg),
    m_root(new BehavNode((Efg::Game *)p_profile.m_efg, p_profile.m_efg->RootNode(),
			 p_profile.m_efg->NumPlayers())),
    m_support(p_profile.m_support),
    m_isets(p_profile.m_isets.Length()), 
    m_cached_data(false)
{
  InitProfile();
}

template <class T> 
BehavProfile<T>::BehavProfile(const BehavSolution &p_solution)
  : gDPVector<T>(p_solution.GetGame().NumActions()), m_efg(&p_solution.GetGame()),
    m_root(new BehavNode((Efg::Game *)m_efg, p_solution.GetGame().RootNode(),
			 p_solution.GetGame().NumPlayers())),
    m_support(p_solution.GetGame()),
    m_isets(p_solution.GetGame().TotalNumInfosets()), 
    m_cached_data(false)

{
  for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) {
    EFPlayer *player = m_efg->Players()[pl];
    for (int iset = 1; iset <= player->NumInfosets(); iset++) {
      Infoset *infoset = player->Infosets()[iset];
      for (int act = 1; act <= infoset->NumActions(); act++)
	(*this)(pl, iset, act) = p_solution(infoset->Actions()[act]);
    }
  } 
  InitProfile();
}

template <class T> BehavProfile<T>::BehavProfile(const EFSupport &p_support) 
  : gDPVector<T>(p_support.NumActions()), 
    m_efg(&p_support.GetGame()),
    m_root(new BehavNode((Efg::Game *)m_efg, m_efg->RootNode(), m_efg->NumPlayers())),
    m_support(p_support), m_isets(m_efg->TotalNumInfosets()), 
    m_cached_data(false)

{
  InitProfile();
  Centroid();
}

template <class T>
BehavProfile<T>::BehavProfile(const MixedProfile<T> &p_profile)
  : gDPVector<T>(p_profile.GetGame().AssociatedEfg()->NumActions()), 
    m_efg(p_profile.GetGame().AssociatedEfg()),
    m_root(new BehavNode((Efg::Game *)m_efg, m_efg->RootNode(), m_efg->NumPlayers())),
    m_support(*m_efg),  
    m_isets(p_profile.GetGame().AssociatedEfg()->TotalNumInfosets()), 
    m_cached_data(false)

{
  //  gout << "\nin BehavProfile(const MixedProfile<T> &p_profile)";

  InitProfile();

  if (m_efg->AssociatedAfg() == &p_profile.GetGame())   {
    ((gVector<T> &) *this).operator=((gVector<T> &) p_profile);
    return;
  }

  ((gVector<T> &) *this).operator=((T)0); 

  BehavNode *n = m_root;
  const NFSupport &support = p_profile.Support();
  const Nfg &nfg = p_profile.GetGame();

  for (int pl = 1; pl <= nfg.NumPlayers(); pl++)   {
    n->ClearNodeProbs();

    for (int st = 1; st <= support.NumStrats(pl); st++)  {
      int snum = support.Strategies(pl)[st]->Number();
      if (p_profile(pl, st) > (T) 0)  {
	const gArray<int> *const actions = m_efg->GetLexicon()->strategies[pl][snum];

	n->bval = p_profile(pl, st);

	RealizationProbs(p_profile, *m_efg, pl, actions, m_root);
      }
    }
    
    m_root->nval = (T) 1;
    BehaviorStrat(*m_efg, pl, n);
  }
}

template <class T> BehavProfile<T>::~BehavProfile()
{
  delete m_root;
  for (int i = 1; i <= m_isets.Length(); i++)  {
    delete m_isets[i];
  }
}

//-------------------------------------------------------------------------
//   BehavProfile<T>: Operator overloading
//-------------------------------------------------------------------------

template <class T>
BehavProfile<T> &BehavProfile<T>::operator=(const BehavProfile<T> &p_profile)
{
  if (this != &p_profile && m_efg == p_profile.m_efg)   {
    Invalidate();
    // note that a dimensionality change will trigger an exception
    // in the gDPVector assignment operator
    gDPVector<T>::operator=(p_profile);
    m_support = p_profile.m_support;
  }
  return *this;
}

template <class T>
bool BehavProfile<T>::operator==(const BehavProfile<T> &p_profile) const
{
  return (m_efg == p_profile.m_efg &&
	  (gDPVector<T> &) *this == (gDPVector<T> &) p_profile);
}

//-------------------------------------------------------------------------
//   BehavProfile<T>: Installation, Initialization, Validation
//-------------------------------------------------------------------------

template <class T>
void BehavProfile<T>::InstallMe(BehavNode *b_node) const
{
  b_node->node->solution = b_node;
  for (int child = 1; child <= b_node->children.Length(); child++) 
    InstallMe(b_node->children[child]);
}

template <class T>
void BehavProfile<T>::InstallMe(void) const
{
  // The following may be needed depending on how subgame solver is implemented
  // if(m_root->node->GetParent())UnmarkParents(m_root->node->GetParent());
  InstallMe(m_root);
  for(int i=1;i<=m_isets.Length();i++) {
    m_isets[i]->iset->solution = m_isets[i];
    for(int j=1;j<=(m_isets[i]->actions).Length();j++) {
      (m_isets[i]->actions)[j]->action->solution = (m_isets[i]->actions)[j];
    }
  }
}

/*
template <class T>
void BehavProfile<T>::UnmarkParents(Node * n) const
{
  n->solution = 0;
  if(n->GetParent()) UnmarkParents(n->GetParent());
}
*/

template <class T>
void BehavProfile<T>::InitPayoffs(void) const
{
  InstallMe();
  m_efg->InitPayoffs();

  const gArray<Infoset *> &isets = ((FullEfg *)m_efg)->GetChance()->Infosets();
  for(int iset=1;iset<=isets.Length();iset++) {
    const gArray<Action *> &acts = m_support.Actions(isets[iset]);
    for(int act=1;act<=acts.Length();act++) 
      *(((BehavAction *)(acts[act]->solution))->probability) 
	= ((FullEfg *)m_efg)->GetChanceProb(acts[act]);
    // this should work, but doesn't:
    //      ActionProb(acts[act]) = ((FullEfg *)m_efg)->GetChanceProb(acts[act]);
  }
}

template <class T>
void BehavProfile<T>::InitProfile(void)
{
  const gBlock<Infoset *> &efg_isets = ((FullEfg *)m_efg)->Infosets();
  for(int i=1;i<=efg_isets.Length();i++) {
    int pl = efg_isets[i]->GetPlayer()->GetNumber();
    m_isets[i] = new BehavInfoset(m_support,efg_isets[i],m_efg->NumPlayers());
    int iset = m_isets[i]->iset->GetNumber();
    for(int j=1;j<=m_isets[i]->actions.Length();j++) 
      m_isets[i]->actions[j]->probability = &((*this)(pl,iset,j));
  }

  int n1 = efg_isets.Length();

  const gArray<Infoset *> &chance_isets = ((FullEfg *)m_efg)->GetChance()->Infosets();
  assert(efg_isets.Length()+chance_isets.Length()==m_isets.Length());
  for(int i=1;i<=chance_isets.Length();i++) {
    m_isets[n1+i] = new BehavInfoset(m_support,chance_isets[i],m_efg->NumPlayers());
    for(int j=1;j<=m_isets[n1+i]->actions.Length();j++) 
      m_isets[n1+i]->actions[j]->probability = new T(0); 
  }
  InitPayoffs();
}

template <class T>
bool BehavProfile<T>::IsInstalled(void) const
{
  return (m_root->node->solution == m_root);
}

template <class T> void BehavProfile<T>::Centroid(void) const
{
  T center;

  for (int pl = 1; pl <= dvlen.Length(); pl++)
    for (int iset = 1; iset <= dvlen[pl]; iset++)
      if (m_support.NumActions(pl,iset) > 0) {
	center = ((T) 1 / (T) m_support.NumActions(pl, iset));
	int act;
	for (act = 1; act <= svlen[dvidx[pl] + iset - 1]; act++)
	  dvptr[pl][iset][act] = center;
      }
}

//-------------------------------------------------------------------------
//   BehavProfile<T>: General data access -- private functions
//-------------------------------------------------------------------------

template <class T>
const T &BehavProfile<T>::RealizProb(const Node *node) const
{
  return ((BehavNode *)node->solution)->realizProb;
}

template <class T>
T &BehavProfile<T>::RealizProb(const Node *node)
{
  return ((BehavNode *)node->solution)->realizProb;
}

template <class T>
const T &BehavProfile<T>::BeliefProb(const Node *node) const
{
  return ((BehavNode *)node->solution)->belief;
}

template <class T>
T &BehavProfile<T>::BeliefProb(const Node *node)
{
  return ((BehavNode *)node->solution)->belief;
}


template <class T>
const T &BehavProfile<T>::IsetProb(const Infoset *iset) const
{
  return ((BehavInfoset *)iset->solution)->prob;
}

template <class T>
T &BehavProfile<T>::IsetProb(const Infoset *iset)
{
  return ((BehavInfoset *)iset->solution)->prob;
}


template <class T>
const T &BehavProfile<T>::IsetValue(const Infoset *iset) const
{
  return ((BehavInfoset *)iset->solution)->value;
}

template <class T>
T &BehavProfile<T>::IsetValue(const Infoset *iset)
{
  return ((BehavInfoset *)iset->solution)->value;
}


template <class T> const T &BehavProfile<T>::Regret(const Action * act) const
{
  return ((BehavAction *)(act->solution))->gripe;
}	

template <class T> T &BehavProfile<T>::Regret(const Action * act)
{
  return ((BehavAction *)(act->solution))->gripe;
}

//-------------------------------------------------------------------------
//   BehavProfile<T>: General data access -- public functions
//-------------------------------------------------------------------------

template <class T>
const T &BehavProfile<T>::GetRealizProb(const Node *node)
{ 
  ComputeSolutionData();
  return RealizProb(node);
}



template <class T>
const T &BehavProfile<T>::GetBeliefProb(const Node *node)
{ 
  ComputeSolutionData();
  return BeliefProb(node);
}

template <class T>
const gVector<T> &BehavProfile<T>::GetNodeValue(const Node *node)
{ 
  ComputeSolutionData();
  return NodeValue(node);
}

template <class T>
const T &BehavProfile<T>::GetIsetProb(const Infoset *iset)
{ 
  ComputeSolutionData();
  return IsetProb(iset);
}

template <class T>
const T &BehavProfile<T>::GetIsetValue(const Infoset *iset)
{ 
  ComputeSolutionData();
  return IsetValue(iset);
}

template <class T>
const T &BehavProfile<T>::GetActionProb(const Action *act) const
{ 
  if(!IsInstalled()) InstallMe();
  return ActionProb((Action *)act);
}


template <class T>
const T &BehavProfile<T>::GetActionValue(const Action * act)
{ 
  ComputeSolutionData();
  return ActionValue(act);
}

template <class T>
const T &BehavProfile<T>::GetRegret(const Action * act)
{ 
  ComputeSolutionData();
  return Regret(act);
}

//-------------------------------------------------------------------------
//   BehavProfile<T>: Computation of interesting quantities
//-------------------------------------------------------------------------

//--------------
// Payoff
//--------------


template <class T>
void BehavProfile<T>::Payoff(Node *node, T prob, int player, T &value) const
{
  Infoset * iset = node->infoset;

  if (node->outcome) {
    value += prob * Payoff(node->outcome, player);
  }

  if (node->children.Length())  {
    const gArray<Action *> &acts = m_support.Actions(iset);
    for (int act = 1; act <= acts.Length(); act++) 
      Payoff(node->GetChild(acts[act]), prob * ActionProb(acts[act]), player, value);
  }
}

template <class T> T BehavProfile<T>::Payoff(int player) const
{
  if(!IsInstalled()) InstallMe();
  T value = (T) 0;
  Payoff(m_efg->RootNode(), (T) 1, player, value);
  return value;
}

// 
// Computation of Cached solution data
// 

template <class T>
void BehavProfile<T>::ComputeSolutionDataPass2(const Node *node)
{
  gVector<T> &nv = NodeValue(node);

  if (node->outcome) {
    for (int i=1;i<=nv.Length();i++) { 
      nv[i] += Payoff(node->outcome, i);
    }
  }

  Infoset * iset = node->infoset;

  if(iset) {
    if (IsetProb(iset) != IsetProb(iset) * (T) 0)
      BeliefProb(node) = RealizProb(node) / IsetProb(iset);
    
    const gArray<Node *> &children = m_efg->Children(node); 
	
    // push down payoffs from outcomes attached to non-terminal nodes 
    for (int child = 1; child <= children.Length(); child++) 
      NodeValue(children[child]) = nv;
    
    nv = (T) 0;
    
    for (int child = 1; child <= children.Length(); child++)  {
      ComputeSolutionDataPass2(children[child]);

      gVector<T> &s = NodeValue(children[child]);

      const Action * act = children[child]->GetAction();

      for(int i=1;i<=s.Length();i++)
	nv[i] += s[i] * ActionProb(act);
      //      nv += s * ActionProb(act);

      if(!iset->IsChanceInfoset()) {
	T &cpay = ActionValue(act);
	if (IsetProb(iset) != IsetProb(iset) * (T) 0) 
	  cpay += BeliefProb(node) * s[iset->GetPlayer()->GetNumber()];
	else
	  cpay = (T)0;
      }
    }
  }
}

// compute realization probabilities for nodes and isets.  
template <class T>
void BehavProfile<T>::ComputeSolutionDataPass1(const Node *node)
{
  T &r = RealizProb(node);
  if(node->GetParent()) {
    r = RealizProb(node->GetParent()) * ActionProb(node->GetAction());
  }
  NodeValue(node) = (T)0;
  
  Infoset *iset = node->infoset;
  
  if(iset) {
    IsetProb(node->infoset) += r;
    
    const gArray<Node *> &children(m_efg->Children(node));
    for(int i=1;i<=children.Length();i++)
      ComputeSolutionDataPass1(children[i]);
  }
}

template <class T>
void BehavProfile<T>::ComputeSolutionData(void)
{
  if(!IsInstalled()) InstallMe();
  if(!m_cached_data) {
    for(int i = 1;i<=m_isets.Length();i++) {
      m_isets[i]->prob = (T)0;
      for(int j = 1;j<=m_isets[i]->actions.Length();j++)
	m_isets[i]->actions[j]->condPayoff = (T)0;
    }
    m_root->realizProb = (T)1;
    ComputeSolutionDataPass1(m_root->node);
    ComputeSolutionDataPass2(m_root->node);

    for(int i = 1;i<=m_isets.Length();i++) {
      Infoset * iset = m_isets[i]->iset;
      IsetValue(iset) = (T)0;
      for(int j = 1;j<=m_isets[i]->actions.Length();j++) {
	Action * act = m_isets[i]->actions[j]->action;
	IsetValue(iset) += ActionProb(act) * ActionValue(act);
      }
      for(int j = 1;j<=m_isets[i]->actions.Length();j++) {
	Action * act = m_isets[i]->actions[j]->action;
	Regret(act) = (ActionValue(act) - IsetValue(iset) ) * IsetProb(iset);
      }
    }
    m_cached_data = true;
  }
}

template <class T>
void BehavProfile<T>::BehaviorStrat(const Efg::Game &E, int pl,
				    BehavNode *n)
{
  for (int i = 1; i <= n->children.Length(); i++)   {
    BehavProfile<T>::BehavNode *child = n->children[i];
    if (n->node->GetPlayer() && n->node->GetPlayer()->GetNumber() == pl)
      if (n->nval > (T) 0 && child->nval > (T) 0)  {
	(*this)(n->node->GetPlayer()->GetNumber(),
		n->node->GetInfoset()->GetNumber(), 
		Support().Find(n->node->GetInfoset()->Actions()[i])) =
	  child->nval / n->nval;
      }
    BehaviorStrat(E, pl, child);
  }
}

template <class T>
void BehavProfile<T>::RealizationProbs(const MixedProfile<T> &mp,
				       const Efg::Game &E, int pl,
				       const gArray<int> *const actions,
				       BehavNode *n)
{
  static const T tremble = (T) 0;
  T prob;

  Node *node = n->node;

  for (int i = 1; i <= n->children.Length(); i++)   {
    if (node->GetPlayer() && !node->GetPlayer()->IsChance())   {
      if (node->GetPlayer()->GetNumber() == pl)  {
	if ((*actions)[node->GetInfoset()->GetNumber()] == i)
	  prob = (T) 1 - tremble + tremble / (T) E.NumChildren(node);
	else
	  prob = tremble / (T) E.NumChildren(node);
      }
      else if (Support().Find(node->GetInfoset()->Actions()[i]))
	prob = (T) 1 / (T) Support().NumActions(node->GetPlayer()->GetNumber(),
						node->GetInfoset()->GetNumber());
      else
	prob = (T) 0;
    }
    else  {   // n.GetPlayer() == 0
      prob = E.GetChanceProb(node->GetInfoset(), i).operator gRational();
    }

    BehavNode *child = n->children[i];
    child->bval = prob * n->bval;
    child->nval += child->bval;    

    RealizationProbs(mp, E, pl, actions, child);
  }    
	
}

//----------------
// ComputeActionValues
//----------------

template <class T>
void BehavProfile<T>::ComputeActionValues(Node *node, T prob)
{
  gVector<T> &nv = NodeValue(node);

  if (node->outcome) {
    for (int i=1;i<=nv.Length();i++) {
      nv[i] += Payoff(node->outcome,i);
    }
  }

  Infoset * iset = node->infoset;

  if(iset) {
    const gArray<Node *> &children = m_efg->Children(node); 
	
    // push down payoffs from outcomes attached to non-terminal nodes 
    for (int child = 1; child <= children.Length(); child++) 
      NodeValue(children[child]) = nv;
    
    nv = (T) 0;
    
    const gArray<Action *> &acts = m_support.Actions(iset);
    for (int act = 1; act <= acts.Length(); act++)  {
      Node * child = node->GetChild(acts[act]);
      
      const T newprob = ActionProb(acts[act]);
      ComputeActionValues(child, prob * newprob);
      
      gVector<T> &s = NodeValue(child);
      
      for (int i = 1; i <= s.Length(); i++)
	nv[i] += s[i] * newprob;

      // for some mysterious reason, the following leads to 
      // differnces in insignificant digits that can eventually lead to different 
      // convergence properties (i. e., in LiapSolve[LoadEfg["e06.efg"]])

      // nv += s * newprob;  
      
      if(!iset->IsChanceInfoset())
	ActionValue(acts[act]) += prob * s[iset->GetPlayer()->GetNumber()];
    }
    if(!iset->IsChanceInfoset())
      IsetProb(iset) += prob;
  }
}

template <class T> void BehavProfile<T>::ComputeActionValues(void)
{
  if(!IsInstalled())InstallMe();

  for(int i = 1;i<=m_isets.Length();i++) {
    m_isets[i]->prob = (T)0;
    for(int j = 1;j<=m_isets[i]->actions.Length();j++)
      m_isets[i]->actions[j]->condPayoff = (T)0;
  }

  m_root->nodeValue = (T) 0;
  ComputeActionValues(m_root->node, (T) 1);

  for(int i = 1;i<=m_isets.Length();i++) {
    BehavInfoset * biset = m_isets[i];
    if(!biset->iset->IsChanceInfoset()) 
      for(int j = 1;j<=biset->actions.Length();j++) 
	// This will protect against divides by zero.
	// It will leave unreached infoset values at zero.
	if (biset->prob != biset->prob * (T) 0)
	  biset->actions[j]->condPayoff /= biset->prob;
  }
}

template <class T> gDPVector<T> BehavProfile<T>::Beliefs(void)
{
  ComputeSolutionData();
  gDPVector<T> bprobs(m_efg->NumMembers());
  bprobs = (T) 0;

  for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) {
    EFPlayer *player = m_efg->Players()[pl];
    for (int iset = 1; iset <= player->NumInfosets(); iset++) {
      Infoset *infoset = player->Infosets()[iset];
      for (int i = 1; i <= infoset->Members().Length(); i++) 
	bprobs(player->GetNumber(),infoset->GetNumber(),i) = BeliefProb(infoset->Members()[i]);
    }
  }

  return bprobs;
}

template <class T> T BehavProfile<T>::LiapValue(void)
{
  static const T BIG1 = (T) 10000;
  static const T BIG2 = (T) 100;

  T x, result = ((T) 0), avg, sum;

  ComputeActionValues();

  const gArray<EFPlayer *> &players = m_efg->Players();
  for (int i = 1; i <= players.Length(); i++) {
    const gArray<Infoset *> &infosets = players[i]->Infosets();
    for (int iset = 1; iset <= infosets.Length(); iset++) {
      const gArray<Action *> &acts = m_support.Actions(infosets[iset]);
      avg = sum = (T)0;

      for (int act = 1; act <= acts.Length(); act++) {
	x = ActionProb(acts[act]);
	avg += x * ActionValue(acts[act]);
	sum += x;
	if (x > (T)0)  x = (T)0;
	result += BIG1 * x * x;         // add penalty for neg probabilities
      }

      for (int act = 1; act <= acts.Length(); act++) {
	x = ActionValue(acts[act]) - avg;
	if (x < (T)0) x = (T)0;
	result += x * x;          // add penalty if not best response
      }
      x = sum - (T)1;
      result += BIG2 * x * x;       // add penalty for sum not equal to 1
    }
  }
  return result;
}

template <class T> T BehavProfile<T>::QreValue(const gVector<T> &lambda, bool &_domain_err)
{
  static const T PENALTY = (T)10000;
  T BigNum = (T)500;
  
  //  gDPVector<T> _cpay(m_support.NumActions());

  T val = (T)0, prob, psum, z,factor;
 
  ComputeActionValues();

  const gArray<EFPlayer *> players = m_efg->Players();
  for (int pl = 1; pl <= players.Length(); pl++)  {
    const gArray<Infoset *> infosets = players[pl]->Infosets();    
    for (int iset = 1; iset <= infosets.Length(); iset++)  {
      const gArray<Action *> &acts = Support().Actions(infosets[iset]);
      prob = (T)0;
      psum = (T)0;

      for (int act = 1; act <= acts.Length(); act++)  {
	z = lambda[pl] * ActionValue(acts[act]);
	factor=(T)1;
	if(z>BigNum) {factor+=z-BigNum;z=BigNum;_domain_err=true;}
	if(z<-BigNum) {factor+=z+BigNum;z=-BigNum;_domain_err=true;}
	z = ((T)exp(z))*factor;
	psum += z;
	//	_cpay(pl,iset,act) = z;
	ActionValue(acts[act]) = z;
      }
      
      for (int act = 1; act <= acts.Length(); act++)  {
	z = ActionProb(acts[act]);
	prob += z;
	if (z < (T)0)
	  val += PENALTY * z * z;
	z -= ActionValue(acts[act]) / psum;
	//	z -= _cpay(pl,iset,act) / psum;
	val += z * z;
      }
      z = (T)1 - prob;
      val += (T)100 * z * z;
    }
  }

  return val;
}

template <class T>
T BehavProfile<T>::MaxRegret(void)
{ 
  ComputeSolutionData();
  T ret = (T)0;
  for(int i=1;i<=m_isets.Length();i++)
    for(int j=1;j<=m_isets[i]->actions.Length();j++)
      if(m_isets[i]->actions[j]->gripe>ret)
	ret = m_isets[i]->actions[j]->gripe;
  return ret;
}


template <class T> void BehavProfile<T>::Dump(gOutput &p_file) const
{
  gDPVector<T>::Dump(p_file);
}



template <class T> BehavProfile<T>::BadStuff::~BadStuff()
{ }

template <class T> gText BehavProfile<T>::BadStuff::Description(void) const
{
  return "Solution not installed in BehavProfile";
}

template <class T> void BehavProfile<T>::BehavNode::ClearNodeProbs(void)
{
  nval = (T) 0;
  for (int i = 1; i <= children.Length(); i++)
    children[i]->ClearNodeProbs();
}

//-----------------
//   Output
//-----------------

template <class T> gOutput &operator<<(gOutput &p_file,
				       const BehavProfile<T> &p_profile)
{
  p_profile.Dump(p_file);
  return p_file;
}

//------------------------------------------------------------------------
//  BehavAssessment<T>: Constructors, Destructor, Constructive Operators
//------------------------------------------------------------------------

template <class T>
BehavAssessment<T>::BehavAssessment(const EFSupport &p_support)
  : BehavProfile<T>(p_support), m_beliefs(p_support.GetGame().NumMembers())
{
  m_beliefs = BehavProfile<T>::Beliefs();
}

template <class T>
BehavAssessment<T>::BehavAssessment(const BehavProfile<T> &p_profile)
  : BehavProfile<T>(p_profile), m_beliefs(p_profile.GetGame().NumMembers())
{ 
  m_beliefs = BehavProfile<T>::Beliefs();
}

template <class T>
BehavAssessment<T>::BehavAssessment(const BehavAssessment<T> &p_assess)
  : BehavProfile<T>(p_assess), m_beliefs(p_assess.m_beliefs)
{ }

template <class T> BehavAssessment<T>::~BehavAssessment()
{ }

template <class T> BehavAssessment<T> &
BehavAssessment<T>::operator=(const BehavAssessment<T> &p_assess)
{
  if (this != &p_assess && &GetGame() == &p_assess.GetGame()) {
    BehavProfile<T>::operator=(p_assess);
    m_beliefs = p_assess.m_beliefs;
  }
  return *this;
}

//------------------------------------------------------------------------
//        BehavAssessment<T>: Access and manipulation of beliefs
//------------------------------------------------------------------------

template <class T> gDPVector<T> BehavAssessment<T>::Beliefs(void) const
{ return m_beliefs; }

template <class T> gDPVector<T> &BehavAssessment<T>::Beliefs(void)
{ return m_beliefs; }

//----------------
// CondPayoff
//----------------

template <class T>
void BehavAssessment<T>::CondPayoff(BehavProfile<T>::BehavNode *p_node,
				    T p_prob,
				    gPVector<T> &p_probs,
				    gDPVector<T> &p_payoff) const
{
  int npl =
    (p_node->node->GetInfoset()) ? p_node->node->GetPlayer()->GetNumber() : -1;
  int iset = 
    (p_node->node->GetInfoset()) ? p_node->node->GetInfoset()->GetNumber() : 0;
  
  if (p_node->node->outcome) {
    for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) { 
      p_node->nodeValue[pl] += Payoff(p_node->node->outcome, pl);
    }
  }

  int nc = p_node->children.Length();
  for (int child = 1; child <= nc; child++)
    p_node->children[child]->nodeValue = p_node->nodeValue;
  
  gVector<T> tmp(m_efg->NumPlayers());
  tmp = (T) 0;
  
  if (nc == 0)   return;

  if (npl == 0)   {
    for (int child = 1; child <= nc; child++)  {
      CondPayoff(p_node->children[child],
		 p_prob *
		 ActionProb(m_efg->Children(p_node->node)[child]->GetAction()),
		 //		 ChanceProb(p_node->node->GetInfoset(),child),
		 p_probs, p_payoff);
      
      for (int pl = 1; pl <= p_node->nodeValue.Length(); pl++)
	tmp[pl] += 
	  ActionProb(m_efg->Children(p_node->node)[child]->GetAction()) *
	  //	  ChanceProb(p_node->node->GetInfoset(), child) *
	  p_node->children[child]->nodeValue[pl];
    }
    p_node->nodeValue = tmp;
  }
  else  {    // player decision node
    // This implementation differs from the one in BehavProfile<T>
    // since we have well-defined belief probabilities off the equilibrium
    // path.  So, we must traverse the whole tree, and cannot ignore
    // the (zero-probability) actions which do not appear in the support
    for (int child = 1; child <= m_efg->NumChildren(p_node->node); child++) {
      int act = m_support.Find(p_node->node->GetInfoset()->Actions()[child]);
      T newprob;
      if (act)
	newprob = (*this)(npl, iset, act);
      else
	newprob = (T) 0;
      CondPayoff(p_node->children[child], p_prob * newprob,
		 p_probs, p_payoff);
      for (int pl = 1; pl <= p_node->nodeValue.Length(); pl++)
	tmp[pl] += newprob * p_node->children[child]->nodeValue[pl];
      
      int mnum;
      for (mnum = 1;
	   p_node->node->GetInfoset()->Members()[mnum] != p_node->node;
	   mnum++);
      p_payoff(npl, iset, child) += 
	m_beliefs(npl, iset, mnum)  * p_node->children[child]->nodeValue[npl];
      p_node->nodeValue = tmp;
    }
  }    
  
  if (npl > 0)
    p_probs(npl, p_node->node->GetInfoset()->GetNumber()) += p_prob;
}


template <class T>
void BehavAssessment<T>::CondPayoff(gDPVector<T> &p_payoff,
				    gPVector<T> &p_probs) const
{
  ((gVector<T> &) p_payoff).operator=((T) 0);
  ((gVector<T> &) p_probs).operator=((T) 0);

  m_root->nodeValue = (T) 0;
  CondPayoff(m_root, (T) 1, p_probs, p_payoff);

  // We can dispense with the normalization step found in the analogous
  // place in BehavProfile<T> since the beliefs are assumed to be 
  // normalized to sum to 1.  (If they don't, things are weird anyway.)
}

//------------------------------------------------------------------------
//                     BehavAssessment<T>: Output
//------------------------------------------------------------------------

template <class T> void BehavAssessment<T>::Dump(gOutput &p_file) const
{
  BehavProfile<T>::Dump(p_file);
  p_file << ' ';
  p_file << m_beliefs;
}

template <class T> gOutput &operator<<(gOutput &p_file,
				       const BehavAssessment<T> &p_assess)
{
  p_assess.Dump(p_file);
  return p_file;
}


