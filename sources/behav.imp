//#
//# FILE: efg.imp -- Implementation of templated extensive form members
//#
//# $Id$
//#

#include "efg.h"
#include "efplayer.h"
#include "infoset.h"
#include "node.h"
#include "outcome.h"
#include "efgutils.h"

template <class T> void OutcomeVector<T>::Resize(int pl)
{
  T *newdata = new T[pl] - 1;
  int i;
  for (i = 1; i <= pl; newdata[i++] = (T) 0.0);
  for (i = 1; i <= gmin(pl, maxdex); i++)
    newdata[i] = data[i];
  delete [] (data + 1);
  data = newdata;
  maxdex = pl;
}
  
//------------------------------------------------------------------------
//                   TypedNode<T>: Class definition
//------------------------------------------------------------------------

#include "tnode.h"

template <class T> TypedNode<T>::TypedNode(BaseEfg *E, Node *p, int pl) 
  : Node(E, p), scratch(new gVector<T>(pl))   { }

template <class T> TypedNode<T>::~TypedNode()   { delete scratch; }

template <class T> void TypedNode<T>::Resize(int pl)
{ 
  delete scratch;
  scratch = new gVector<T>(pl); 
  for (int i = children.Length(); i; i--)
    ((TypedNode<T> *) children[i])->Resize(pl);
}


//------------------------------------------------------------------------
//      Efg<T>: Constructor, destructors, constructive operators
//------------------------------------------------------------------------

template <class T> Efg<T>::Efg(void)
{ (root = new TypedNode<T>(this, 0, 0))->name = "ROOT"; }

template <class T> void Efg<T>::CopySubtree(Node *n, Node *m)
{
  n->name = m->name;
  if (m->outcome)
    n->outcome = outcomes[m->outcome->number];

  if (m->infoset)   {
    EFPlayer *p;
    if (m->infoset->player->number)
      p = players[m->infoset->player->number];
    else 
      p = chance;

    Infoset *s = p->infosets[m->infoset->number];
    AppendNode(n, s);
    for (int i = 1; i <= n->children.Length(); i++)
      CopySubtree(n->children[i], m->children[i]);
  }
}

template <class T> Efg<T>::Efg(const Efg<T> &E)
  : BaseEfg(E)
{
  int i;

  for (i = 1; i <= E.outcomes.Length(); i++)
    outcomes.Append(new OutcomeVector<T>(this, 
					 (OutcomeVector<T> &) *E.outcomes[i]));
  
  for (i = 1; i <= E.chance->infosets.Length(); i++)   {
    ChanceInfoset<T> *t = (ChanceInfoset<T> *) E.chance->infosets[i];
    ChanceInfoset<T> *s = new ChanceInfoset<T>(this, i, chance,
					       t->actions.Length());
    s->name = t->name;
    for (int j = 1; j <= s->probs.Length(); j++)  {
      s->probs[j] = t->probs[j];
      s->actions[j]->name = t->actions[j]->name;
    }
    chance->infosets.Append(s);
  }

  root = new TypedNode<T>(this, 0, E.NumPlayers());
  CopySubtree(root, E.root);
}

template <class T> Efg<T>::~Efg()
{ }

//------------------------------------------------------------------------
//            Efg<T>: Private and protected member functions
//------------------------------------------------------------------------

template <class T> Infoset *Efg<T>::CreateInfoset(int n, EFPlayer *p, int br)
{
  Infoset *s = (p->IsChance()) ? new ChanceInfoset<T>(this, n, p, br) :
               new Infoset(this, n, p, br);
  p->infosets.Append(s);
  return s;
}

template <class T> Node *Efg<T>::CreateNode(Node *parent)
{ return new TypedNode<T>(this, parent, players.Length()); }

template <class T> Infoset *Efg<T>::CreateInfoset(EFPlayer *p, int br)
{
  assert(p && p->BelongsTo() == this);
  return CreateInfoset(p->infosets.Length() + 1, p, br);
}

template <class T> Outcome *Efg<T>::CreateOutcomeByIndex(int index)
{
  OutcomeVector<T> *ret = NewOutcome();
  ret->number = index;
  return ret;
}

//------------------------------------------------------------------------
//                 Efg<T>: Operations on outcomes
//------------------------------------------------------------------------

template <class T> OutcomeVector<T> *Efg<T>::NewOutcome(void)
{
  OutcomeVector<T> *ret = new OutcomeVector<T>(this, outcomes.Length() + 1,
					       players.Length());
  for (int i = 1; i <= players.Length(); (*ret)[i++] = (T) 0);
  outcomes.Append(ret);
  return ret;
}

//------------------------------------------------------------------------
//                   Efg<T>: Payoff computation
//------------------------------------------------------------------------

#include "gdpvect.h"

template <class T>
void Efg<T>::Payoff(Node *n, T prob, const gPVector<int> &profile,
			gVector<T> &payoff) const
{
  if (n->outcome)
    for (int i = 1; i <= players.Length(); i++)
      payoff[i] += prob * ((OutcomeVector<T> &) *n->outcome)[i];
  
  if (n->infoset && n->infoset->player->IsChance())
    for (int i = 1; i <= n->children.Length(); i++)
      Payoff(n->children[i],
	     prob * ((ChanceInfoset<T> &) *n->infoset).probs[i],
	     profile, payoff);
  else if (n->infoset)
    Payoff(n->children[profile(n->infoset->player->number,n->infoset->number)],
	   prob, profile, payoff);
}

template <class T>
void Efg<T>::Payoff(const gPVector<int> &profile, gVector<T> &payoff) const
{
  ((gVector<T> &) payoff).operator=((T) 0);
  Payoff(root, (T) 1.0, profile, payoff);
}

template <class T>
void Efg<T>::Payoff(Node *n, T prob, const gArray<gArray<int> *> &profile,
		    gVector<T> &payoff) const
{
  if (n->outcome)
    for (int i = 1; i <= players.Length(); i++)
      payoff[i] += prob * ((OutcomeVector<T> &) *n->outcome)[i];
  
  if (n->infoset && n->infoset->player->IsChance())
    for (int i = 1; i <= n->children.Length(); i++)
      Payoff(n->children[i],
	     prob * ((ChanceInfoset<T> &) *n->infoset).probs[i],
	     profile, payoff);
  else if (n->infoset)
    Payoff(n->children[(*profile[n->infoset->player->number])[n->infoset->number]],
	   prob, profile, payoff);
}

template <class T>
void Efg<T>::Payoff(const gArray<gArray<int> *> &profile,
		    gVector<T> &payoff) const
{
  ((gVector<T> &) payoff).operator=((T) 0);
  Payoff(root, (T) 1.0, profile, payoff);
}

template <class T>
void Efg<T>::Payoff(Node *n, T prob, int pl, T &value,
			const BehavProfile<T> &profile) const
{
  if (n->outcome)
    value += prob * ((OutcomeVector<T> &) *n->outcome)[pl];
  if (n->children.Length())
    if (profile.IsTruncated())   {
      T p = (T) 0.0;
      for (int i = 1, npl = n->infoset->player->number,
	   iset = n->infoset->number; i < n->children.Length(); i++)  {
	p += ((npl) ? profile(npl, iset, i) :
	      ((ChanceInfoset<T> *) n->infoset)->probs[i]);
	Payoff(n->children[i],
	       prob * ((npl) ? profile(npl, iset, i) :
		       ((ChanceInfoset<T> *) n->infoset)->probs[i]),
	       pl, value, profile);
      }
      Payoff(n->children[i], prob * ((T)1 - p), pl, value, profile);
    }
    else  {
      for (int i = 1, npl = n->infoset->player->number,
	   iset = n->infoset->number; i <= n->children.Length(); i++)
	Payoff(n->children[i],
	       prob * ((npl) ? profile(npl, iset, i) :
		       ((ChanceInfoset<T> *) n->infoset)->probs[i]),
	       pl, value, profile);
    }
}

template <class T>
T Efg<T>::Payoff(int pl, const BehavProfile<T> &profile) const
{
  T value = (T) 0.0;
  Payoff(root, (T) 1.0, pl, value, profile);
  return value;
}

template <class T>
void Efg<T>::NodeValues(Node *n, T prob, int pl, T &value, gArray<T> &valarray,
			const BehavProfile<T> &profile, int &index) const
{

  int tindex = index;

  if (n->outcome)
    value += prob * ((OutcomeVector<T> &) *n->outcome)[pl];
  if (n->children.Length())
    if (profile.IsTruncated())   {
      T p = (T) 0.0;
      for (int i = 1, npl = n->infoset->player->number,
	   iset = n->infoset->number; i < n->children.Length(); i++)  {
	p += ((npl) ? profile(npl, iset, i) :
	      ((ChanceInfoset<T> *) n->infoset)->probs[i]);
	NodeValues(n->children[i],
		   prob * ((npl) ? profile(npl, iset, i) :
			   ((ChanceInfoset<T> *) n->infoset)->probs[i]),
		   pl, value, valarray, profile, ++index);
      }
      NodeValues(n->children[i], prob * ((T)1 - p), pl, value, valarray,
		 profile, ++index);
      valarray[tindex] = value;
    }
    else  {
      for (int i = 1, npl = n->infoset->player->number,
	   iset = n->infoset->number; i <= n->children.Length(); i++)
	NodeValues(n->children[i],
		   prob * ((npl) ? profile(npl, iset, i) :
			   ((ChanceInfoset<T> *) n->infoset)->probs[i]),
		   pl, value, valarray, profile, ++index);
      valarray[tindex] = value;
    }
  
}

template <class T>
gArray<T> Efg<T>::NodeValues(int pl, const BehavProfile<T> &profile) const
{
  T value = (T) 0.0;
  int index = 1;
  gArray<T> valarray(NumNodes(*profile.BelongsTo())); 
  NodeValues(root, (T) 1.0, pl, value, valarray, profile, index);
  return valarray;
}

template <class T>
void Efg<T>::CondPayoff(Node *n, T prob,
			    const BehavProfile<T> &profile,
			    gPVector<T> &probs,
			    gDPVector<T> &payoff) const
{
  int pl = (n->infoset) ? n->infoset->player->number : -1;
  int iset = (n->infoset) ? n->infoset->number : 0;

  if (n->outcome)
    *((TypedNode<T> *) n)->scratch += (OutcomeVector<T> &) *n->outcome;
  for (int i = 1, nc = n->children.Length(); i <= nc; i++)
    *((TypedNode<T> *) n->children[i])->scratch = *((TypedNode<T> *) n)->scratch;
  
  T cumprob((T) 0), newprob((T) 0);


  for (i = 1; i < nc; i++)   {
    newprob = ((pl) ? profile(pl, n->infoset->number, i) :
	       ((ChanceInfoset<T> *) n->infoset)->probs[i]);
    cumprob += newprob;
    CondPayoff(n->children[i], prob * newprob, profile, probs, payoff);

    for (int j = 1; j <= ((TypedNode<T> *) n)->scratch->Length(); j++)
      (*((TypedNode<T> *) n)->scratch)[j] += newprob * (*((TypedNode<T> *) n->children[i])->scratch)[j];
    if (pl > 0)
      payoff(pl, iset, i) += prob * (*((TypedNode<T> *) n->children[i])->scratch)[pl];
  }
  
  if (nc > 0)  {
    if (profile.IsTruncated())
      newprob = (T) 1.0 - cumprob;
    else
      newprob = ((pl) ? profile(pl, n->infoset->number, i) : 
		 ((ChanceInfoset<T> *) n->infoset)->probs[i]);

    CondPayoff(n->children[nc], prob * newprob, profile, probs, payoff);

    for (int j = 1; j <= ((TypedNode<T> *) n)->scratch->Length(); j++)
      (*((TypedNode<T> *) n)->scratch)[j] += newprob * (*((TypedNode<T> *) n->children[i])->scratch)[j];
    if (pl > 0)
      payoff(pl, iset, i) += prob * (*((TypedNode<T> *) n->children[i])->scratch)[pl];
  }

  if (pl > 0)
    probs(pl, n->infoset->number) += prob;
}


template <class T> void Efg<T>::CondPayoff(const BehavProfile<T> &profile,
					       gDPVector<T> &payoff,
					       gPVector<T> &probs) const
{
  ((gVector<T> &) payoff).operator=((T) 0);
  ((gVector<T> &) probs).operator=((T) 0);

  *((TypedNode<T> *) root)->scratch = (T) 0;
  CondPayoff(root, (T) 1.0, profile, probs, payoff);

  for (int i = 1; i <= players.Length(); i++)
    for (int j = 1; j <= players[i]->infosets.Length(); j++)
      for (int k = 1; k <= players[i]->infosets[j]->actions.Length(); k++)
	// Note that bad things happen if probs(i, j, k) == 0
	payoff(i, j, k) /= probs(i, j);
}

template <class T> 
gArray<T> Efg<T>::NodeRealizProbs(const BehavProfile<T> &bp)
{
  gArray<T> NRProbs(NumNodes(*bp.BelongsTo()));
  int index = 1;
  NodeRealizProbs( root, (T) 1.0, bp, index, NRProbs);
  return NRProbs;
}

template <class T>
void Efg<T>::NodeRealizProbs(Node *n, T prob, const BehavProfile<T> &profile,
			     int &index, gArray<T> &NRProbs)
{

  NRProbs[index] = prob;

  int pl = (n->infoset) ? n->infoset->player->number : -1;

  T cumprob((T) 0), newprob((T) 0);
  int i, nc = n->children.Length();

  for (i = 1; i < nc; i++) {
    newprob = ((pl) ? profile(pl, n->infoset->number, i) :
	       ((ChanceInfoset<T> *) n->infoset)->probs[i]);
    cumprob += newprob;
    NodeRealizProbs(n->children[i], prob * newprob, profile, ++index,
		     NRProbs);
  }
  
  if (nc > 0) {
    if (profile.IsTruncated())
      newprob = (T) 1.0 - cumprob;
    else newprob = ((pl) ? profile(pl, n->infoset->number, i) :
		    ((ChanceInfoset<T> *) n->infoset)->probs[i]);
    
    NodeRealizProbs(n->children[nc], prob * newprob, profile, ++index,
		     NRProbs);
  }
}

template <class T> gArray<T> Efg<T>::Beliefs( const BehavProfile<T> &bp )
{
  gArray<T> BProbs(NumNodes(*bp.BelongsTo()));
  gDPVector<T> payoff(Dimensionality());
  gPVector<T> probs(Dimensionality().Lengths());
  CondPayoff( bp, payoff, probs);
  probs.Dump(gout);  gout << '\n';
  int index = 1;
  Beliefs ( root, (T) 1.0, bp, index, BProbs, probs);
  BProbs.Dump(gout);  gout << '\n';
  return BProbs;
}

template <class T>
void Efg<T>::Beliefs(Node *n, T prob, const BehavProfile<T> &profile,
		     int &index, gArray<T> &BProbs, gPVector<T> &gpv)
{
  int pl = (n->infoset) ? n->infoset->player->number : -1;
  int iset = (n->infoset) ? n->infoset->number : 0;
  T cumprob((T) 0), newprob((T) 0);
  int i, nc = n->children.Length();

  gout << prob << '\n';

  if (pl == 0 || pl == -1)
    BProbs[index] = (T) 1.0;
  else
    BProbs[index] = prob / gpv(pl, iset);
  
  for (i = 1; i < nc; i++) {
    newprob = ((pl) ? profile(pl, n->infoset->number, i) :
	       ((ChanceInfoset<T> *) n->infoset)->probs[i]);
    cumprob += newprob;
    Beliefs(n->children[i], prob * newprob, profile, ++index,
	    BProbs, gpv);
  }
  
  if (nc > 0) {
    if (profile.IsTruncated())
      newprob = (T) 1.0 - cumprob;
    else newprob = ((pl) ? profile(pl, n->infoset->number, i) :
		    ((ChanceInfoset<T> *) n->infoset)->probs[i]);
    
    Beliefs(n->children[nc], prob * newprob, profile, ++index,
	    BProbs, gpv);
  }
}

template <class T> int Efg<T>::ProfileLength(bool trunc) const
{
  int sum = 0;

  for (int i = 1; i <= players.Length(); i++)
    for (int j = 1; j <= players[i]->infosets.Length(); j++)
      sum += players[i]->infosets[j]->actions.Length() - ((trunc) ? 1 : 0);

  return sum;
}

template <class T> gPVector<int> Efg<T>::Dimensionality(bool trunc) const
{
  gArray<int> foo(players.Length());
  for (int i = 1; i <= players.Length(); i++)
    foo[i] = players[i]->infosets.Length();

  gPVector<int> bar(foo);
  for (i = 1; i <= players.Length(); i++)
    for (int j = 1; j <= players[i]->infosets.Length(); j++)
      bar(i, j) = players[i]->infosets[j]->actions.Length() -((trunc) ? 1 : 0);

  return bar;
}  

template <class T> void Efg<T>::Centroid(BehavProfile<T> &profile) const
{
  T center;

  for (int i = 1; i <= players.Length(); i++)
    for (int j = 1; j <= players[i]->infosets.Length(); j++)  {
      center = ((T) 1 / (T) players[i]->infosets[j]->actions.Length());
      for (int k = 1; k < players[i]->infosets[j]->actions.Length(); k++)
	profile(i, j, k) = center;
      if (!profile.IsTruncated())   profile(i, j, k) = center;
    }
}

//---------------------------------------------------------------------------
//                    BehavProfile<T> member functions
//---------------------------------------------------------------------------

template <class T> BehavProfile<T>::BehavProfile(const Efg<T> &EF,
						 bool trunc)
  : BaseBehavProfile(EF, trunc), gDPVector<T>(EF.Dimensionality(trunc))
{
  EF.Centroid(*this);
}

template <class T> BehavProfile<T>::BehavProfile(const Efg<T> &EF,
						 const gDPVector<T> &profile)
  : BaseBehavProfile(EF, false), gDPVector<T>(profile)
{ }

template <class T> BehavProfile<T>::BehavProfile(const BehavProfile<T> &p)
  : BaseBehavProfile(p), gDPVector<T>(p)
{ }

template <class T> BehavProfile<T>::~BehavProfile()   { }

template <class T>
BehavProfile<T> &BehavProfile<T>::operator=(const BehavProfile<T> &p)
{
  BaseBehavProfile::operator=(p);
  gDPVector<T>::operator=(p);
  return *this;
}

template <class T> T BehavProfile<T>::Payoff(int pl) const
{ return ((Efg<T> *) E)->Payoff(pl, *this); }

#include <assert.h>

template <class T> bool BehavProfile<T>::IsPure(void) const
{
  // currently not implemented
  assert(0);
  return false;
}

template <class T> bool BehavProfile<T>::IsPure(int pl) const
{
  // currently not implemented
  assert(0);
  return false;
}

template <class T>
const T &BehavProfile<T>::GetValue(Infoset *s, int act) const
{
  return (*this)(s->GetPlayer()->GetNumber(), s->GetNumber(), act);
}

template <class T> gOutput &operator<<(gOutput &f, const BehavProfile<T> &p)
{ p.Dump(f);   return f;  }

