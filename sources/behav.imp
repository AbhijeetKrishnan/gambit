//
// FILE: efg.imp -- Implementation of templated extensive form members
//
// $Id$
//

#include "efg.h"
#include "efplayer.h"
#include "infoset.h"
#include "node.h"
#include "outcome.h"
#include "efgutils.h"


#include "gvector.h"


//-------------------------------------------------------------------------
//                    BehavProfile<T> member functions
//-------------------------------------------------------------------------

template <class T> class BehavNode  {
public:
  Node *node;
  T nval, bval;
  gVector<T> scratch;
  gArray<BehavNode<T> *> children;

  BehavNode(Node *n, int pl);
  ~BehavNode();
};

template <class T> BehavNode<T>::BehavNode(Node *n, int pl)
  : node(n), scratch(pl), children(n->NumChildren())
{
  for (int child = 1; child <= children.Length(); child++) 
    children[child] = new BehavNode<T>(n->GetChild(child), pl);
}    

template <class T> BehavNode<T>::~BehavNode()
{
  for (int child = 1; child <= children.Length();
       delete children[child++]);
}

template <class T> BehavProfile<T>::BehavProfile(const Efg &EF)
  : gDPVector<T>(EF.NumActions()), E(&EF),
    root(new BehavNode<T>(EF.RootNode(), EF.NumPlayers())), support(EF),
    payoffs(new gRectArray<T>(EF.NumOutcomes(), EF.NumPlayers()))
{
  Centroid();
  gArray<int> dim(EF.GetChance()->NumInfosets());
  for (int iset = 1; iset <= dim.Length(); iset++)
    dim[iset] = EF.GetChance()->Infosets()[iset]->NumActions();
  chanceprobs = new gPVector<T>(dim);
  for (int iset = 1; iset <= dim.Length(); iset++)
    for (int act = 1; act <= EF.GetChance()->Infosets()[iset]->NumActions(); act++)
       (*chanceprobs)(iset, act) = EF.GetChanceProb(EF.GetChance()->Infosets()[iset], act);

  for (int outc = 1; outc <= E->NumOutcomes(); outc++)
    for (int pl = 1; pl <= E->NumPlayers(); pl++)
      (*payoffs)(outc, pl) = (T) E->Payoff(E->Outcomes()[outc], pl);
}

template <class T> BehavProfile<T>::BehavProfile(const Efg &EF,
						 const gDPVector<T> &profile)
  : gDPVector<T>(profile), E(&EF),
    root(new BehavNode<T>(EF.RootNode(), EF.NumPlayers())), support(EF),
    payoffs(new gRectArray<T>(EF.NumOutcomes(), EF.NumPlayers()))
{
  gArray<int> dim(EF.GetChance()->NumInfosets());
  for (int iset = 1; iset <= dim.Length(); iset++)
    dim[iset] = EF.GetChance()->Infosets()[iset]->NumActions();
  chanceprobs = new gPVector<T>(dim);
  for (int iset = 1; iset <= dim.Length(); iset++)
    for (int act = 1; act <= EF.GetChance()->Infosets()[iset]->NumActions(); act++)
       (*chanceprobs)(iset, act) = EF.GetChanceProb(EF.GetChance()->Infosets()[iset], act);

  for (int outc = 1; outc <= E->NumOutcomes(); outc++)
    for (int pl = 1; pl <= E->NumPlayers(); pl++)
      (*payoffs)(outc, pl) = (T) E->Payoff(E->Outcomes()[outc], pl);
}

template <class T> BehavProfile<T>::BehavProfile(const BehavProfile<T> &p)
  : gDPVector<T>(p), E(p.E),
    root(new BehavNode<T>(p.E->RootNode(), p.E->NumPlayers())),
    support(p.support),
    payoffs(new gRectArray<T>(*p.payoffs))
{
  gArray<int> dim(E->GetChance()->NumInfosets());
  for (int iset = 1; iset <= dim.Length(); iset++)
    dim[iset] = E->GetChance()->Infosets()[iset]->NumActions();
  chanceprobs = new gPVector<T>(dim);
  for (int iset = 1; iset <= dim.Length(); iset++)
    for (int act = 1; act <= E->GetChance()->Infosets()[iset]->NumActions(); act++)
       (*chanceprobs)(iset, act) = E->GetChanceProb(E->GetChance()->Infosets()[iset], act);
}

template <class T> BehavProfile<T>::BehavProfile(const Efg &EF,
						 const EFSupport &s)
  : gDPVector<T>(s.NumActions()), E(&EF),
    root(new BehavNode<T>(EF.RootNode(), EF.NumPlayers())), support(s),
    payoffs(new gRectArray<T>(EF.NumOutcomes(), EF.NumPlayers()))
{
  gArray<int> dim(E->GetChance()->NumInfosets());
  Centroid();
  for (int iset = 1; iset <= dim.Length(); iset++)
    dim[iset] = E->GetChance()->Infosets()[iset]->NumActions();
  chanceprobs = new gPVector<T>(dim);
  for (int iset = 1; iset <= dim.Length(); iset++)
    for (int act = 1; act <= E->GetChance()->Infosets()[iset]->NumActions(); act++)
       (*chanceprobs)(iset, act) = E->GetChanceProb(E->GetChance()->Infosets()[iset], act);

  for (int outc = 1; outc <= E->NumOutcomes(); outc++)
    for (int pl = 1; pl <= E->NumPlayers(); pl++)
      (*payoffs)(outc, pl) = (T) E->Payoff(E->Outcomes()[outc], pl);

}

template <class T> BehavProfile<T>::~BehavProfile()
{
  delete root;
  delete chanceprobs;
  delete payoffs;
}

template <class T>
BehavProfile<T> &BehavProfile<T>::operator=(const BehavProfile<T> &p)
{
  if (this != &p && E == p.E)   {
    // note that a dimensionality change will trigger a failed assertion
    // in the gDPVector assignment operator
    support = p.support;
    gDPVector<T>::operator=(p);
  }
  return *this;
}

#include <assert.h>

template <class T> void BehavProfile<T>::Centroid(void) const
{
  T center;

  for (int pl = 1; pl <= dvlen.Length(); pl++)
    for (int iset = 1; iset <= dvlen[pl]; iset++)  {
      center = ((T) 1 / (T) support.NumActions(pl, iset));
      int act;
      for (act = 1; act <= svlen[dvidx[pl] + iset - 1]; act++)
	dvptr[pl][iset][act] = center;
    }
}

template <class T> T BehavProfile<T>::LiapValue(void) const
{
  static const T BIG1 = (T) 10000;
  static const T BIG2 = (T) 100;

  BehavProfile<T> p(*this);
  ((gVector<T> &) p).operator=(*this);
  BehavProfile<T> tmp(p);
  T x, result = ((T) 0), avg, sum;

  gDPVector<T> cpay(E->NumActions());  
  gPVector<T> probs(E->NumInfosets());
  tmp.CondPayoff(cpay, probs);

  for (int i = 1; i <= E->NumPlayers(); i++) {
    EFPlayer *player = E->Players()[i];
    for (int j = 1; j <= player->NumInfosets(); j++) {
      avg = sum = (T)0;
      Infoset *s = player->Infosets()[j];
      int k;
      for (k = 1; k <= s->NumActions(); k++) {
	x = p(i, j, k); 
	avg += x * cpay(i, j, k);
	sum += x;
	if (x > (T)0)  x = (T)0;
	result += BIG1 * x * x;         // add penalty for neg probabilities
      }
      for (k = 1; k <= s->NumActions(); k++) {
	x = cpay(i, j, k) - avg;
	if (x < (T)0) x = (T)0;
	result += x * x;          // add penalty if not best response
      }
      x = sum - (T)1;
      result += BIG2 * x * x;       // add penalty for sum not equal to 1
    }
  }
  return result;
}

    
template <class T> void BehavProfile<T>::Gripe(gDPVector<T> &value) const
{
  // Currently this is very inefficient.  But we need some functions 
  // to evaluate the effect on payoff from a change in a profile 
  // to make this better (rdm) 
  int i, j, k;
  T pay;
  BehavProfile<T> scratch(*this);
  
  for (i = 1; i <= E->NumPlayers(); i++) {
    pay = Payoff(i);
    EFPlayer *player = E->Players()[i];
    for (j = 1; j <= player->NumInfosets(); j++) {
      Infoset *s = player->Infosets()[j];
      for (k = 1; k <= s->NumActions(); k++) 
	scratch(i, j, k) = (T)0;
      for (k = 1; k <= s->NumActions(); k++) {
	scratch(i, j, k) = (T)1;
	value(i, j, k) = scratch.Payoff(i) - pay;
	if(value(i,j,k) < (T)0) 
	  value(i,j,k) = (T)0;
	scratch(i, j, k) = (T)0;
      }
      for (k = 1; k <= s->NumActions(); k++) 
	scratch(i, j, k) = (*this)(i, j, k);
    }
  }
}

template <class T> T BehavProfile<T>::MaxGripe(void) const
{
  int i;
  T maxgripe = (T)0;;

  gDPVector<T> v(*this);
  Gripe(v);
  for(i=v.First(); i<=v.Last(); i++)
    if(v[i] > maxgripe) maxgripe = v[i];
  return maxgripe;
}

template <class T>
const T &BehavProfile<T>::GetValue(Infoset *s, int act) const
{
  return (*this)(s->GetPlayer()->GetNumber(), s->GetNumber(), act);
}

template <class T>
bool BehavProfile<T>::operator==(const BehavProfile<T> &bp) const
{
  return (E == bp.E && (gDPVector<T> &) *this == (gDPVector<T> &) bp);
}

template <class T> gOutput &operator<<(gOutput &f, const BehavProfile<T> &p)
{ p.Dump(f);   return f;  }


//------------------------------------------------------------------------
//         BehavProfile<T>: Computation of interesting quantities
//------------------------------------------------------------------------

#include "gdpvect.h"

//--------------
// Payoff
//--------------

template <class T>
void BehavProfile<T>::Payoff(Node *n, T prob, int pl, T &value) const
{
  if (n->outcome)
    value += prob * (*payoffs)(n->outcome->GetNumber(), pl);
  if (n->children.Length())  {
    if (n->infoset->player->number == 0)  {
      for (int i = 1; i <= n->children.Length(); i++)
	Payoff(n->children[i],
	       prob * (*chanceprobs)(n->infoset->number, i),
	       pl, value);
    }
    else  {
      int npl = n->infoset->player->number;
      int iset = n->infoset->number;
      const gArray<Action *> &actions = support.Actions(npl, iset);

      for (int act = 1; act <= actions.Length(); act++)
	Payoff(n->children[actions[act]->GetNumber()],
	       prob * (*this)(npl, iset, act), pl, value);
    }
  }
}

template <class T> T BehavProfile<T>::Payoff(int pl) const
{
  T value = (T) 0.0;
  Payoff(E->RootNode(), (T) 1.0, pl, value);
  return value;
}

//----------------
// CondPayoff
//----------------

template <class T>
void BehavProfile<T>::CondPayoff(BehavNode<T> *n, T prob, gPVector<T> &probs,
				 gDPVector<T> &payoff) const
{
  int pl = (n->node->infoset) ? n->node->infoset->player->number : -1;
  int iset = (n->node->infoset) ? n->node->infoset->number : 0;
  
  if (n->node->outcome)  {
    for (int i = 1; i <= E->NumPlayers(); i++)
      n->scratch[i] += (*payoffs)(n->node->outcome->GetNumber(), i);
  }

  int i, nc;
  for (i = 1, nc = n->children.Length(); i <= nc; i++)
    n->children[i]->scratch = n->scratch;
  
  T newprob((T) 0);
  gVector<T> tmp(E->NumPlayers());
  tmp = (T) 0;
  
  if (nc == 0)   return;

  if (n->node->infoset->player->number == 0)   {
    for (i = 1; i <= nc; i++)  {
      CondPayoff(n->children[i],
		 prob * (*chanceprobs)(n->node->infoset->number, i),
		 probs, payoff);
      
      for (int j = 1; j <= n->scratch.Length(); j++)
	tmp[j] += 
	(*chanceprobs)(n->node->infoset->number, i) *
	n->children[i]->scratch[j];
    }
    n->scratch = tmp;
  }
  else  {    // player decision node
    int act;
    
    const gArray<Action *> &actions =
      support.Actions(n->node->infoset->player->number, 
		      n->node->infoset->number);
    
    for (act = 1; act <= actions.Length(); act++)  {
      int childno = actions[act]->GetNumber();
      newprob = (*this)(pl, n->node->infoset->number, act);
      CondPayoff(n->children[childno], prob * newprob, probs, payoff);
      
      for (int j = 1; j <= n->scratch.Length(); j++)
	tmp[j] +=
	newprob * n->children[childno]->scratch[j];

      payoff(pl, iset, childno) += 
	prob * n->children[childno]->scratch[pl];
      n->scratch = tmp;
    }
  }
  
  if (pl > 0)
    probs(pl, n->node->infoset->number) += prob;
}


template <class T> 
void BehavProfile<T>::CondPayoff(gDPVector<T> &payoff, 
				 gPVector<T> &probs) const
{
  ((gVector<T> &) payoff).operator=((T) 0);
  ((gVector<T> &) probs).operator=((T) 0);

  root->scratch = (T) 0;
  CondPayoff(root, (T) 1.0, probs, payoff);

  for (int i = 1; i <= E->NumPlayers(); i++)
    for (int j = 1; j <= (E->Players())[i]->infosets.Length(); j++)
      for (int k = 1; k <= (E->Players())[i]->infosets[j]->actions.Length();
	   k++)
	// This will protect against	 divides by zero.
	// It will leave unreached infoset values at zero, which
	// is probably not in general what we want.
	// CondPayoff() was designed for use with Gobit in which case
	// this doesn't happen. (?)   -- Ted
	if (probs(i,j) != (T) 0.0)
	  payoff(i, j, k) /= probs(i, j);
}

//--------------------
// NodeRealizProbs
//--------------------

template <class T>
void BehavProfile<T>::NodeRealizProbs(BehavNode<T> *n, T prob, int &index, 
				      gArray<T> &NRProbs) const
{
  NRProbs[index] = prob;
  int anum = 0;
  int pl = (n->node->infoset) ? n->node->infoset->player->number : -1;

  T newprob((T) 0);
  int i, nc = n->children.Length();

  if (nc == 0)   return;
  
  for (i = 1; i < nc; i++) {
    if ( pl == 0 || pl == -1 ||
	support.Find(n->node->infoset->actions[i])) {  
      if (pl != 0 && pl != -1)
	anum = support.Find(n->node->infoset->actions[i]);
      
      newprob = ((pl) ? (*this)(pl, n->node->infoset->number, anum) :
		 (*chanceprobs)(n->node->infoset->number, i));
      NodeRealizProbs(n->children[i], prob * newprob, ++index,
		      NRProbs);
    }
    else index += CountNodes(n->node->children[i]); 
  }

  if (nc > 0) 
    if  ( pl == 0 || pl == -1 ||  
	 support.Find(n->node->infoset->actions[i])) {
      if (pl !=0 && pl != -1)
	anum = support.Find(n->node->infoset->actions[i]);
      
      newprob = ((pl) ? (*this)(pl, n->node->infoset->number, anum) :
		 (*chanceprobs)(n->node->infoset->number, i));
      
      NodeRealizProbs(n->children[nc], prob * newprob, ++index,
		      NRProbs);
    }
    else index += CountNodes(n->node->children[i]);     
}

template <class T> 
gArray<T> BehavProfile<T>::NodeRealizProbs(void) const
{
  int index = 1, maxindex = NumNodes(*E);

  gArray<T> NRProbs(maxindex);
  for (int ii = 1; ii <= maxindex; ii++) NRProbs[ii] = (T)0;
  NodeRealizProbs(root, (T) 1.0, index, NRProbs);
  return NRProbs;
}

//------------
// Beliefs
//------------

template <class T>
void BehavProfile<T>::Beliefs(Node *n, T prob,
			      gDPVector<T> &BProbs, gPVector<T> &gpv) const
{
  int pl = (n->infoset) ? n->infoset->player->number : -1;
  int iset = (n->infoset) ? n->infoset->number : 0;
  T newprob((T) 0);
  int i, nc = n->children.Length();
  int mnum=1;

  if (n->infoset == 0)   return;

  while(mnum <= n->infoset->NumMembers() &&
	n->infoset->Members()[mnum]!=n) 
    mnum++;
  assert(mnum<=n->infoset->NumMembers());
  
  if (pl > 0 && gpv(pl, iset) != (T)0)
    BProbs(pl,iset,mnum) = prob / gpv(pl, iset);

  if (pl == 0)  {
    for (i = 1; i <= nc; i++)  {
      newprob = (*chanceprobs)(n->infoset->number, i);
      Beliefs(n->children[i], prob * newprob, BProbs, gpv);
    }

    return;
  }

  const gArray<Action *> &actions = support.Actions(pl, iset);

  for (i = 1; i <= support.NumActions(pl, iset); i++) {
    newprob = (*this)(pl, n->infoset->number, actions[i]->GetNumber());
    Beliefs(n->children[actions[i]->GetNumber()],
	    prob * newprob, BProbs, gpv);
  }
}

template <class T> gDPVector<T> BehavProfile<T>::Beliefs(void) const
{
  gDPVector<T> BProbs(E->NumMembers());
  BProbs = (T)0;
  gDPVector<T> payoff(E->NumActions());
  gPVector<T> probs(E->NumActions().Lengths());
  CondPayoff( payoff, probs);
  Beliefs ( E->RootNode(), (T)1, BProbs, probs);
//  gout << "\nBProbs: " << BProbs; 
  return BProbs;
}

//-----------------
// NodeValues
//-----------------

template <class T>
void BehavProfile<T>::NodeValues(BehavNode<T> *n, int pl, 
				 gArray<T> &valarray, int &index) const
{
  int child, tindex = index;

  if (n->node->outcome)
    n->nval += (*payoffs)(n->node->outcome->GetNumber(), pl);

  for (child = 1; child <= n->children.Length(); child++)
    n->children[child]->nval = n->nval;
 
  T value = (T) 0.0;
  
  if (n->node->infoset == 0)   {
    valarray[tindex] = n->nval;
    return;
  }
  
  if (n->node->infoset->player->number == 0)  {
    for (int i = 1; i <= n->children.Length(); i++)   {
      NodeValues(n->children[i], pl, valarray, ++index);
      value += (*chanceprobs)(n->node->infoset->number, i) *
	         n->children[i]->nval;
    }

    n->nval = value;
    return;
  }

  for (int i = 1, npl = n->node->infoset->player->number,
       iset = n->node->infoset->number; i <= n->children.Length(); i++)  {
    if (support.Find(n->node->infoset->actions[i])) {
      int anum = support.Find(n->node->infoset->actions[i]);
      NodeValues(n->children[i], pl, valarray, ++index);
      value += ((npl) ? (*this)(npl, iset, anum) :
		(*chanceprobs)(n->node->infoset->number, i)) *
		  n->children[i]->nval;
    }
    else
      NodeValues(n->children[i], pl, valarray, ++index);
  }
  
  n->nval = value;

  valarray[tindex] = n->nval;
}

template <class T>
gArray<T> BehavProfile<T>::NodeValues(int pl) const
{
  int index = 1, maxindex = NumNodes(*E);

  gArray<T> valarray(maxindex); 
  for (int i = 1; i <= maxindex; i++)  valarray[i] = (T) 0;
  root->nval = (T) 0.0;

  NodeValues(root, pl, valarray, index);
  return valarray;
}


