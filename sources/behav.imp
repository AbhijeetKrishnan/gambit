//
// FILE: efg.imp -- Implementation of templated extensive form members
//
// $Id$
//

#include "efg.h"
#include "efplayer.h"
#include "infoset.h"
#include "node.h"
#include "outcome.h"
#include "efgutils.h"

template <class T> void OutcomeVector<T>::Resize(int pl)
{
  T *newdata = new T[pl] - 1;
  int i;
  for (i = 1; i <= pl; newdata[i++] = (T) 0.0);
  for (i = 1; i <= gmin(pl, maxdex); i++)
    newdata[i] = data[i];
  delete [] (data + 1);
  data = newdata;
  maxdex = pl;
}
  
//------------------------------------------------------------------------
//                   TypedNode<T>: Class definition
//------------------------------------------------------------------------

#include "tnode.h"

template <class T> TypedNode<T>::TypedNode(BaseEfg *E, Node *p, int pl) 
  : Node(E, p), scratch(new gVector<T>(pl))   { }

template <class T> TypedNode<T>::~TypedNode()   { delete scratch; }

template <class T> void TypedNode<T>::Resize(int pl)
{ 
  delete scratch;
  scratch = new gVector<T>(pl); 
  for (int i = children.Length(); i; i--)
    ((TypedNode<T> *) children[i])->Resize(pl);
}


//------------------------------------------------------------------------
//           ChanceInfoset<T>: Member function definitions
//------------------------------------------------------------------------

template <class T>
ChanceInfoset<T>::ChanceInfoset(BaseEfg *E, int n, EFPlayer *p, int br)
  : Infoset(E, n, p, br), probs(br)
{
  for (int i = 1; i <= br; probs[i++] = (T) 1 / (T) br);
}

template <class T> void ChanceInfoset<T>::InsertAction(int where)
{ 
  actions.Insert(new Action(where, "", this), where);
  for (; where <= actions.Length(); where++)
    actions[where]->number = where;
  probs.Insert((T) 0, where);
}

template <class T> void ChanceInfoset<T>::RemoveAction(int which)
{
  delete actions.Remove(which);
  for (; which <= actions.Length(); which++)
    actions[which]->number = which;
  probs.Remove(which);
}

template <class T> void ChanceInfoset<T>::PrintActions(gOutput &f) const
{ 
  f << "{ ";
  for (int i = 1; i <= actions.Length(); i++)
    f << '"' << actions[i]->GetName() << "\" " << probs[i] << ' ';
  f << "}";
}

//------------------------------------------------------------------------
//      Efg<T>: Constructor, destructors, constructive operators
//------------------------------------------------------------------------

template <class T> Efg<T>::Efg(void)
{ (root = new TypedNode<T>(this, 0, 0))->name = "ROOT"; }

template <class T> void Efg<T>::CopySubtree(Node *n, Node *m)
{
  n->name = m->name;

  if (m->gameroot == m)
    n->gameroot = n;

  if (m->outcome)
    n->outcome = outcomes[m->outcome->number];

  if (m->infoset)   {
    EFPlayer *p;
    if (m->infoset->player->number)
      p = players[m->infoset->player->number];
    else 
      p = chance;

    Infoset *s = p->infosets[m->infoset->number];
    AppendNode(n, s);
    
    for (int i = 1; i <= n->children.Length(); i++)
      CopySubtree(n->children[i], m->children[i]);
  }
}

template <class T> Efg<T>::Efg(const BaseEfg &E)
  : BaseEfg(E)
{
  int i;
  
  for (i = 1; i <= E.NumOutcomes(); i++)  {
    OutcomeVector<T> *c = new OutcomeVector<T>(this, i, E.NumPlayers());
    c->name = E.OutcomeList()[i]->GetName();
    outcomes.Append(c);
  }

  
  for (i = 1; i <= E.GetChance()->NumInfosets(); i++)   {
    ChanceInfoset<T> *t = (ChanceInfoset<T> *) E.GetChance()->InfosetList()[i];
    ChanceInfoset<T> *s = new ChanceInfoset<T>(this, i, chance,
					       t->NumActions());
    s->name = t->GetName();
    for (int act = 1; act <= s->probs.Length(); act++)
      s->actions[act]->name = t->actions[act]->name;
    chance->infosets.Append(s);
  }

  root = new TypedNode<T>(this, 0, E.NumPlayers());
  CopySubtree(root, E.RootNode());

  sortisets = true;
  SortInfosets();
}

template <class T> Efg<T>::Efg(const Efg<T> &E)
  : BaseEfg(E)
{
  int i;

  for (i = 1; i <= E.outcomes.Length(); i++)
    outcomes.Append(new OutcomeVector<T>(this, 
					 (OutcomeVector<T> &) *E.outcomes[i]));
  
  for (i = 1; i <= E.chance->infosets.Length(); i++)   {
    ChanceInfoset<T> *t = (ChanceInfoset<T> *) E.chance->infosets[i];
    ChanceInfoset<T> *s = new ChanceInfoset<T>(this, i, chance,
					       t->actions.Length());
    s->name = t->name;
    for (int j = 1; j <= s->probs.Length(); j++)  {
      s->probs[j] = t->probs[j];
      s->actions[j]->name = t->actions[j]->name;
    }
    chance->infosets.Append(s);
  }

  root = new TypedNode<T>(this, 0, E.NumPlayers());
  CopySubtree(root, E.root);

  sortisets = true;
  SortInfosets();
}

//
// This function creates a new Efg out of an Efg, treating it as if
// it were rooted at node 'n'.
// This is designed to be used as a way of extracting subgames, but
// there is no restriction that 'n' be a subgame root.
//
// Use with care, if at all!
//
template <class T> Efg<T>::Efg(const Efg<T> &E, Node *n)
  : BaseEfg(E)
{
  int i;

  assert(n->BelongsTo() == (BaseEfg *) &E);

  for (i = 1; i <= E.outcomes.Length(); i++)
    outcomes.Append(new OutcomeVector<T>(this, 
					 (OutcomeVector<T> &) *E.outcomes[i]));
  
  for (i = 1; i <= E.chance->infosets.Length(); i++)   {
    ChanceInfoset<T> *t = (ChanceInfoset<T> *) E.chance->infosets[i];
    ChanceInfoset<T> *s = new ChanceInfoset<T>(this, i, chance,
					       t->actions.Length());
    s->name = t->name;
    for (int j = 1; j <= s->probs.Length(); j++)  {
      s->probs[j] = t->probs[j];
      s->actions[j]->name = t->actions[j]->name;
    }
    chance->infosets.Append(s);
  }

  root = new TypedNode<T>(this, 0, E.NumPlayers());
  CopySubtree(root, n);

  for (int pl = 1; pl <= players.Length(); pl++)   {
    for (i = 1; i <= players[pl]->infosets.Length(); i++)  {
      if (players[pl]->infosets[i]->members.Length() == 0)
	delete players[pl]->infosets.Remove(i--);
    }
  }     

  sortisets = true;
  SortInfosets();
}

template <class T> Efg<T>::~Efg()
{ }

//------------------------------------------------------------------------
//            Efg<T>: Private and protected member functions
//------------------------------------------------------------------------

template <class T> Infoset *Efg<T>::CreateInfoset(int n, EFPlayer *p, int br)
{
  Infoset *s = (p->IsChance()) ? new ChanceInfoset<T>(this, n, p, br) :
               new Infoset(this, n, p, br);
  p->infosets.Append(s);
  return s;
}

template <class T> Node *Efg<T>::CreateNode(Node *parent)
{ return new TypedNode<T>(this, parent, players.Length()); }

template <class T> Infoset *Efg<T>::CreateInfoset(EFPlayer *p, int br)
{
  assert(p && p->BelongsTo() == this);
  return CreateInfoset(p->infosets.Length() + 1, p, br);
}

template <class T> Outcome *Efg<T>::CreateOutcomeByIndex(int index)
{
  OutcomeVector<T> *ret = NewOutcome();
  ret->number = index;
  return ret;
}

//------------------------------------------------------------------------
//                 Efg<T>: Operations on outcomes
//------------------------------------------------------------------------

template <class T> OutcomeVector<T> *Efg<T>::NewOutcome(void)
{
  OutcomeVector<T> *ret = new OutcomeVector<T>(this, outcomes.Length() + 1,
					       players.Length());
  for (int i = 1; i <= players.Length(); (*ret)[i++] = (T) 0);
  outcomes.Append(ret);
  return ret;
}

template <class T> bool Efg<T>::IsConstSum(void) const
{
  int pl, index;
  T cvalue = (T) 0;

  if (outcomes.Length() == 0)  return true;

  for (pl = 1; pl <= players.Length(); pl++)
    cvalue += ((OutcomeVector<T> &) *outcomes[1])[pl];
  
  for (index = 2; index <= outcomes.Length(); index++)  {
    T thisvalue = (T) 0;
    
    for (pl = 1; pl <= players.Length(); pl++)
      thisvalue += ((OutcomeVector<T> &) *outcomes[index])[pl];

    if (cvalue != thisvalue)
      return false;
  }

  return true;
}

template <class T> T Efg<T>::MinPayoff(int pl) const
{
  int index, p, p1, p2;
  T minpay;
  
  if(pl) { p1=p2=pl;}
  else {p1=1;p2=players.Length();}

  minpay = ((OutcomeVector<T> &) *outcomes[1])[p1];
  
  for (index = 1; index <= outcomes.Length(); index++)  {
    for (p = p1; p <= p2; p++)
      if (((OutcomeVector<T> &) *outcomes[index])[p] < minpay)
	minpay = ((OutcomeVector<T> &) *outcomes[index])[p];
  }
  return minpay;
}

template <class T> T Efg<T>::MaxPayoff(int pl) const
{
  int index, p, p1, p2;
  T maxpay;
  
  if(pl) { p1=p2=pl;}
  else {p1=1;p2=players.Length();}

  maxpay = ((OutcomeVector<T> &) *outcomes[1])[p1];

  for (index = 1; index <= outcomes.Length(); index++)  {
    for (p = p1; p <= p2; p++)
      if (((OutcomeVector<T> &) *outcomes[index])[p] > maxpay)
	maxpay = ((OutcomeVector<T> &) *outcomes[index])[p];
  }
  return maxpay;
}



//------------------------------------------------------------------------
//                   Efg<T>: Payoff computation
//------------------------------------------------------------------------

template <class T>
void Efg<T>::Payoff(Node *n, T prob, const gPVector<int> &profile,
			gVector<T> &payoff) const
{
  if (n->outcome)
    for (int i = 1; i <= players.Length(); i++)
      payoff[i] += prob * ((OutcomeVector<T> &) *n->outcome)[i];
  
  if (n->infoset && n->infoset->player->IsChance())
    for (int i = 1; i <= n->children.Length(); i++)
      Payoff(n->children[i],
	     prob * ((ChanceInfoset<T> &) *n->infoset).probs[i],
	     profile, payoff);
  else if (n->infoset)
    Payoff(n->children[profile(n->infoset->player->number,n->infoset->number)],
	   prob, profile, payoff);
}

template <class T>
void Efg<T>::Payoff(const gPVector<int> &profile, gVector<T> &payoff) const
{
  ((gVector<T> &) payoff).operator=((T) 0);
  Payoff(root, (T) 1.0, profile, payoff);
}

template <class T>
void Efg<T>::Payoff(Node *n, T prob, const gArray<gArray<int> *> &profile,
		    gVector<T> &payoff) const
{
  if (n->outcome)
    for (int i = 1; i <= players.Length(); i++)
      payoff[i] += prob * ((OutcomeVector<T> &) *n->outcome)[i];
  
  if (n->infoset && n->infoset->player->IsChance())
    for (int i = 1; i <= n->children.Length(); i++)
      Payoff(n->children[i],
	     prob * ((ChanceInfoset<T> &) *n->infoset).probs[i],
	     profile, payoff);
  else if (n->infoset)
    Payoff(n->children[(*profile[n->infoset->player->number])[n->infoset->number]],
	   prob, profile, payoff);
}

template <class T>
void Efg<T>::Payoff(const gArray<gArray<int> *> &profile,
		    gVector<T> &payoff) const
{
  ((gVector<T> &) payoff).operator=((T) 0);
  Payoff(root, (T) 1.0, profile, payoff);
}




//-------------------------------------------------------------------------
//                    BehavProfile<T> member functions
//-------------------------------------------------------------------------

template <class T> BehavProfile<T>::BehavProfile(const Efg<T> &EF,
						 bool trunc)
: BaseBehavProfile(EF, trunc), gDPVector<T>(EF.Dimensionality(trunc))
{
  Centroid();
}

template <class T> BehavProfile<T>::BehavProfile(const Efg<T> &EF,
						 const gDPVector<T> &profile)
: BaseBehavProfile(EF, false), gDPVector<T>(profile)
{ }

template <class T> BehavProfile<T>::BehavProfile(const BehavProfile<T> &p)
: BaseBehavProfile(p), gDPVector<T>(p)
{ }

template <class T> BehavProfile<T>::BehavProfile(const EFSupport &s)
: BaseBehavProfile(s.BelongsTo(),false, s), 
  gDPVector<T>(s.Dimensionality(false))
{ 
  Centroid();
}

template <class T> BehavProfile<T>::~BehavProfile()   { }

template <class T>
BehavProfile<T> &BehavProfile<T>::operator=(const BehavProfile<T> &p)
{
  BaseBehavProfile::operator=(p);
  gDPVector<T>::operator=(p);
  return *this;
}

#include <assert.h>

template <class T> void BehavProfile<T>::Centroid(void) const
{
  T center;

  for (int pl = 1; pl <= dvlen.Length(); pl++)
    for (int iset = 1; iset <= dvlen[pl]; iset++)  {
      center = ((T) 1 / (T) support.NumActions(pl, iset));
      int act;
      for (act = 1; act < svlen[dvidx[pl] + iset - 1]; act++)
	dvptr[pl][iset][act] = center;
      if (!truncated)  dvptr[pl][iset][act] = center;
    }
}

template <class T> bool BehavProfile<T>::IsPure(void) const
{
  // currently not implemented
  assert(0);
  return false;
}

template <class T> bool BehavProfile<T>::IsPure(int) const
{
  // currently not implemented
  assert(0);
  return false;
}

template <class T> T BehavProfile<T>::LiapValue(void) const
{
  static const T BIG1 = (T) 10000;
  static const T BIG2 = (T) 100;

  BehavProfile<T> p(*this);
  ((gVector<T> &) p).operator=(*this);
  BehavProfile<T> tmp(p);
  T x, result = ((T) 0), avg, sum;

      // Ted -- only reason for this is because you 
      // got rid of CondPayoff ( . , . )
  gDPVector<T> cpay(((Efg<T> *)E)->Dimensionality());  
  gPVector<T> probs(((Efg<T> *)E)->Dimensionality().Lengths());  
  tmp.CondPayoff(cpay, probs);

  for (int i = 1; i <= E->NumPlayers(); i++) {
    EFPlayer *player = E->PlayerList()[i];
    for (int j = 1; j <= player->NumInfosets(); j++) {
      avg = sum = (T)0;
      Infoset *s = player->InfosetList()[j];
      int k;
      for (k = 1; k <= s->NumActions(); k++) {
	x = p(i, j, k); 
	avg += x * cpay(i, j, k);
	sum += x;
	if (x > (T)0)  x = (T)0;
	result += BIG1 * x * x;         // add penalty for neg probabilities
      }
      for (k = 1; k <= s->NumActions(); k++) {
	x = cpay(i, j, k) - avg;
	if (x < (T)0) x = (T)0;
	result += x * x;          // add penalty if not best response
      }
      x = sum - (T)1;
      result += BIG2 * x * x;       // add penalty for sum not equal to 1
    }
  }
  return result;
}

    
template <class T> void BehavProfile<T>::Gripe(gDPVector<T> &value) const
{
  int i, j, k;
  T pay;
  BehavProfile<T> scratch(*this);
  
  for (i = 1; i <= E->NumPlayers(); i++) {
    pay = Payoff(i);
    EFPlayer *player = E->PlayerList()[i];
    for (j = 1; j <= player->NumInfosets(); j++) {
      Infoset *s = player->InfosetList()[j];
      for (k = 1; k <= s->NumActions(); k++) 
	scratch(i, j, k) = (T)0;
      for (k = 1; k <= s->NumActions(); k++) {
	scratch(i, j, k) = (T)1;
	value(i, j, k) = scratch.Payoff(i) - pay;
	if(value(i,j,k) < (T)0) 
	  value(i,j,k) = (T)0;
	scratch(i, j, k) = (T)0;
      }
      for (k = 1; k <= s->NumActions(); k++) 
	scratch(i, j, k) = (*this)(i, j, k);
    }
  }
}

template <class T> T BehavProfile<T>::MaxGripe() const
{
  int i;
  T maxgripe = (T)0;;

  gDPVector<T> v(*this);
  Gripe(v);
  for(i=v.First(); i<=v.Last(); i++)
    if(v[i] > maxgripe) maxgripe = v[i];
  return maxgripe;
}

template <class T> bool BehavProfile<T>::IsNash(void) const
{
  if(MaxGripe()==(T)0) return 1;
  return 0;
}

template <class T>
const T &BehavProfile<T>::GetValue(Infoset *s, int act) const
{
  return (*this)(s->GetPlayer()->GetNumber(), s->GetNumber(), act);
}

template <class T>
bool BehavProfile<T>::operator==(const BehavProfile<T> &bp) const
{
  return (E == bp.E && (gDPVector<T> &) *this == (gDPVector<T> &) bp);
}

template <class T> gOutput &operator<<(gOutput &f, const BehavProfile<T> &p)
{ p.Dump(f);   return f;  }


//------------------------------------------------------------------------
//         BehavProfile<T>: Computation of interesting quantities
//------------------------------------------------------------------------

#include "gdpvect.h"

//--------------
// Payoff
//--------------

template <class T>
void BehavProfile<T>::Payoff(Node *n, T prob, int pl, T &value) const
{
  if (n->outcome)
    value += prob * ((OutcomeVector<T> &) *n->outcome)[pl];
  if (n->children.Length())
    if (IsTruncated())   {
      T p = (T) 0.0;
      
      if (n->infoset->player->number == 0)  {
	for (int i = 1; i <= n->children.Length(); i++)
	  Payoff(n->children[i],
		 prob * ((ChanceInfoset<T> *) n->infoset)->probs[i],
		 pl, value);
      }
      else  {
	int npl = n->infoset->player->number;
	int iset = n->infoset->number;
	const gArray<Action *> &actions = support.ActionList(npl, iset);

	int act;
	for (act = 1; act < actions.Length(); act++)  {
	  Payoff(n->children[actions[act]->GetNumber()],
		 prob * (*this)(npl, iset, act), pl, value);

	  p += (*this)(npl, iset, act);
	}

	Payoff(n->children[actions[act]->GetNumber()],
	       prob * ((T) 1 - p), pl, value);
      }
    }
    else  {
      if (n->infoset->player->number == 0)  {
	for (int i = 1; i <= n->children.Length(); i++)
	  Payoff(n->children[i],
		 prob * ((ChanceInfoset<T> *) n->infoset)->probs[i],
		 pl, value);
      }
      else  {
	int npl = n->infoset->player->number;
	int iset = n->infoset->number;
	const gArray<Action *> &actions = support.ActionList(npl, iset);
	
	for (int act = 1; act <= actions.Length(); act++)
	  Payoff(n->children[actions[act]->GetNumber()],
		 prob * (*this)(npl, iset, act), pl, value);
      }
    }
}

template <class T> T BehavProfile<T>::Payoff(int pl) const
{
  T value = (T) 0.0;
  Payoff(E->RootNode(), (T) 1.0, pl, value);
  return value;
}

//----------------
// CondPayoff
//----------------

template <class T>
void BehavProfile<T>::CondPayoff(Node *n, T prob, gPVector<T> &probs,
				 gDPVector<T> &payoff) const
{
  int pl = (n->infoset) ? n->infoset->player->number : -1;
  int iset = (n->infoset) ? n->infoset->number : 0;

  if (n->outcome)
    *((TypedNode<T> *) n)->scratch += (OutcomeVector<T> &) *n->outcome;
  int i, nc;
  for (i = 1, nc = n->children.Length(); i <= nc; i++)
    *((TypedNode<T> *) n->children[i])->scratch = *((TypedNode<T> *) n)->scratch;
  
  T cumprob((T) 0), newprob((T) 0);
  
  if (nc == 0)   return;

  if (n->infoset->player->number == 0)   {
    for (i = 1; i <= nc; i++)  {
      CondPayoff(n->children[i],
		 prob * ((ChanceInfoset<T> *) n->infoset)->probs[i],
		 probs, payoff);
      
      for (int j = 1; j <= ((TypedNode<T> *) n)->scratch->Length(); j++)
	(*((TypedNode<T> *) n)->scratch)[j] += 
	newprob * (*((TypedNode<T> *) n->children[i])->scratch)[j];
    }
  }
  else  {    // player decision node
    int act;
    
    const gArray<Action *> &actions =
      support.ActionList(n->infoset->player->number, n->infoset->number);
    
    for (act = 1; act < actions.Length(); act++)  {
      int childno = actions[act]->GetNumber();
      newprob = (*this)(pl, n->infoset->number, act);
      cumprob += newprob;
      CondPayoff(n->children[childno], prob * newprob, probs, payoff);
      
      for (int j = 1; j <= ((TypedNode<T> *) n)->scratch->Length(); j++)
	(*((TypedNode<T> *) n)->scratch)[j] += 
	newprob * (*((TypedNode<T> *) n->children[childno])->scratch)[j];

      payoff(pl, iset, childno) += 
	prob * (*((TypedNode<T> *) n->children[childno])->scratch)[pl];
    }

    int childno = actions[act]->GetNumber();
    newprob = (truncated) ? ((T) 1.0 - cumprob) : (*this)(pl, n->infoset->number, act);
    CondPayoff(n->children[childno], prob * newprob, probs, payoff);

    for (int j = 1; j <= ((TypedNode<T> *) n)->scratch->Length(); j++)
      (*((TypedNode<T> *) n)->scratch)[j] += 
      newprob * (*((TypedNode<T> *) n->children[childno])->scratch)[j];
    payoff(pl, iset, childno) += 
      prob * (*((TypedNode<T> *) n->children[childno])->scratch)[pl];
  }
  
  if (pl > 0)
    probs(pl, n->infoset->number) += prob;
}


template <class T> 
void BehavProfile<T>::CondPayoff( gDPVector<T> &payoff, 
				 gPVector<T> &probs) const
{
  ((gVector<T> &) payoff).operator=((T) 0);
  ((gVector<T> &) probs).operator=((T) 0);

  *((TypedNode<T> *) E->RootNode())->scratch = (T) 0;
  CondPayoff(E->RootNode(), (T) 1.0, probs, payoff);

  for (int i = 1; i <= E->NumPlayers(); i++)
    for (int j = 1; j <= (E->PlayerList())[i]->infosets.Length(); j++)
      for (int k = 1; k <= (E->PlayerList())[i]->infosets[j]->actions.Length();
	   k++)
	// This will protect against	 divides by zero.
	// It will leave unreached infoset values at zero, which
	// is probably not in general what we want.
	// CondPayoff() was designed for use with Gobit in which case
	// this doesn't happen. (?)   -- Ted
	if (probs(i,j) != (T) 0.0)
	  payoff(i, j, k) /= probs(i, j);
}

//--------------------
// NodeRealizProbs
//--------------------

template <class T>
void BehavProfile<T>::NodeRealizProbs(Node *n, T prob, int &index, 
				      gArray<T> &NRProbs)
{

  NRProbs[index] = prob;
  int anum;
  int pl = (n->infoset) ? n->infoset->player->number : -1;

  T cumprob((T) 0), newprob((T) 0);
  int i, nc = n->children.Length();

  if (nc == 0)   return;
  
  for (i = 1; i < nc; i++) {
    if ( pl == 0 || pl == -1 ||
	support.Contains(n->infoset->actions[i])) {  
      if (pl != 0 && pl != -1)
	anum = support.GetNumber(n->infoset->actions[i]);
      
      newprob = ((pl) ? (*this)(pl, n->infoset->number, anum) :
		 ((ChanceInfoset<T> *) n->infoset)->probs[i]);
      cumprob += newprob;
      NodeRealizProbs(n->children[i], prob * newprob, ++index,
		      NRProbs);
    }
    else index += CountNodes(n->children[i]); 
  }

  if (nc > 0) 
    if  ( pl == 0 || pl == -1 ||  
	 support.Contains(n->infoset->actions[i])) {
      if (pl !=0 && pl != -1)
	anum = support.GetNumber(n->infoset->actions[i]);
      
      if (truncated)
	newprob = (T) 1.0 - cumprob;
      else newprob = ((pl) ? (*this)(pl, n->infoset->number, anum) :
		      ((ChanceInfoset<T> *) n->infoset)->probs[i]);
      
      NodeRealizProbs(n->children[nc], prob * newprob, ++index,
		      NRProbs);
    }
    else index += CountNodes(n->children[i]);     
}

template <class T> 
gArray<T> BehavProfile<T>::NodeRealizProbs( void )
{
  int index = 1, maxindex = (NumNodes(*BelongsTo()));

  gArray<T> NRProbs(maxindex);
  for (int ii = 1; ii <= maxindex; ii++) NRProbs[ii] = (T)0;
  NodeRealizProbs( E->RootNode(), (T) 1.0, index, NRProbs);
  return NRProbs;
}

//------------
// Beliefs
//------------

template <class T>
void BehavProfile<T>::Beliefs(Node *n, T prob,
			      gDPVector<T> &BProbs, gPVector<T> &gpv)
{
  int pl = (n->infoset) ? n->infoset->player->number : -1;
  int iset = (n->infoset) ? n->infoset->number : 0;
  T cumprob((T) 0), newprob((T) 0);
  int i, nc = n->children.Length();
  int mnum=1;

  if (n->infoset == 0)   return;

  while(mnum <= n->infoset->NumMembers() &&
	n->infoset->GetMemberList()[mnum]!=n) 
    mnum++;
  assert(mnum<=n->infoset->NumMembers());
  
  if (gpv(pl, iset) != (T)0)
    BProbs(pl,iset,mnum) = prob / gpv(pl, iset);

  if (pl == 0)  {
    for (i = 1; i <= nc; i++)  {
      newprob = ((ChanceInfoset<T> *) n->infoset)->probs[i];
      Beliefs(n->children[i], prob * newprob, BProbs, gpv);
    }

    return;
  }

  const gArray<Action *> &actions = support.ActionList(pl, iset);

  for (i = 1; i < support.NumActions(pl, iset); i++) {
    newprob = (*this)(pl, n->infoset->number, actions[i]->GetNumber());
    Beliefs(n->children[actions[i]->GetNumber()],
	    prob * newprob, BProbs, gpv);
  }
  
  if (truncated)
    newprob = (T) 1.0 - cumprob;
  else
    newprob = (*this)(pl, n->infoset->number, actions[nc]->GetNumber());
  Beliefs(n->children[actions[nc]->GetNumber()],
	  prob * newprob, BProbs, gpv);
}

template <class T> gDPVector<T> BehavProfile<T>::Beliefs(void)
{
  gDPVector<T> BProbs(((Efg<T> *)E)->BeliefDimensionality());
  BProbs = (T)0;
  gDPVector<T> payoff(((Efg<T> *)E)->Dimensionality());
  gPVector<T> probs(((Efg<T> *)E)->Dimensionality().Lengths());
  CondPayoff( payoff, probs);
  Beliefs ( E->RootNode(), (T)1, BProbs, probs);
//  gout << "\nBProbs: " << BProbs; 
  return BProbs;
}

//-----------------
// NodeValues
//-----------------

template <class T>
void BehavProfile<T>::NodeValues(Node *n, int pl, 
				 gArray<T> &valarray, int &index) const
{
  int child, tindex = index;

  if (n->outcome)
    ((TypedNode<T> *) n)->nval += ((OutcomeVector<T> &) *n->outcome)[pl];

  for (child = 1; child <= n->children.Length(); child++)
    ((TypedNode<T> *) n->children[child])->nval = ((TypedNode<T> *) n)->nval;
 
  T value = (T) 0.0;
  
  if (n->infoset == 0)   {
    valarray[tindex] = ((TypedNode<T> *) n)->nval;
    return;
  }
  
  if (n->infoset->player->number == 0)  {
    for (int i = 1; i <= n->children.Length(); i++)   {
      NodeValues(n->children[i], pl, valarray, ++index);
      value += ((ChanceInfoset<T> *) n->infoset)->probs[i] *
	         ((TypedNode<T> *) n->children[i])->nval;
    }

    ((TypedNode<T> *) n)->nval = value;
    return;
  }

  if (truncated)   {
    T p = (T) 0.0;

    int i, npl, iset;
    for (i = 1, npl = n->infoset->player->number,
	 iset = n->infoset->number; i < n->children.Length(); i++)  {
      if (support.Contains(n->infoset->actions[i]))  {
	int anum = support.GetNumber(n->infoset->actions[i]);
	p += ((npl) ? (*this)(npl, iset, anum) :
	      ((ChanceInfoset<T> *) n->infoset)->probs[i]);
	NodeValues(n->children[i], pl, valarray, ++index);
	value += ((npl) ? (*this)(npl, iset, anum) :
		  ((ChanceInfoset<T> *) n->infoset)->probs[i]) *
		    ((TypedNode<T> *) n->children[i])->nval;
      }
      else
	NodeValues(n->children[i], pl, valarray, ++index);
    }
      
    NodeValues(n->children[i], pl, valarray, ++index);
    value += ((T) 1 - p) * ((TypedNode<T> *) n->children[i])->nval;
  }
  else  {
    for (int i = 1, npl = n->infoset->player->number,
	 iset = n->infoset->number; i <= n->children.Length(); i++)  {
      if (support.Contains(n->infoset->actions[i])) {
	int anum = support.GetNumber(n->infoset->actions[i]);
	NodeValues(n->children[i], pl, valarray, ++index);
	value += ((npl) ? (*this)(npl, iset, anum) :
		  ((ChanceInfoset<T> *) n->infoset)->probs[i]) *
		    ((TypedNode<T> *) n->children[i])->nval;
      }
      else
	NodeValues(n->children[i], pl, valarray, ++index);
    }

    ((TypedNode<T> *) n)->nval = value;
  }

  valarray[tindex] = ((TypedNode<T> *) n)->nval;
}

template <class T>
gArray<T> BehavProfile<T>::NodeValues(int pl) const
{
  int index = 1, maxindex = NumNodes(*BelongsTo());

  gArray<T> valarray(maxindex); 
  for (int i = 1; i <= maxindex; i++)  valarray[i] = (T) 0;
  ((TypedNode<T> *) E->RootNode())->nval = (T) 0.0;

  NodeValues(E->RootNode(), pl, valarray, index);
  return valarray;
}









