//
// FILE: behav.imp -- Implementation of behavior profiles
//
// $Id$
//

#include "efg.h"
#include "efplayer.h"
#include "infoset.h"
#include "node.h"
#include "outcome.h"
#include "efgutils.h"

#include "gvector.h"
#include "behavsol.h"

#include "nfg.h"
#include "mixed.h"
#include "lexicon.h"

//-------------------------------------------------------------------------
//                    PureBehavProfile<T> member functions
//-------------------------------------------------------------------------

template <class T> PureBehavProfile<T>::PureBehavProfile(const Efg &efg)
  : E(&efg), profile(efg.NumPlayers())
{
  E->InitPayoffs();  // only needed for T=double, remove if class is detemplated
  for (int pl = 1; pl <= efg.NumPlayers(); pl++)  {
    EFPlayer *player = efg.Players()[pl];
    profile[pl] = new gArray<const Action *>(player->NumInfosets());
    for (int iset = 1; iset <= player->NumInfosets(); iset++)
      (*profile[pl])[iset] = player->Infosets()[iset]->Actions()[1];
  }
}

template <class T>
PureBehavProfile<T>::PureBehavProfile(const PureBehavProfile<T> &p)
  : E(p.E), profile(p.profile.Length())
{
  E->InitPayoffs();  // only needed for T=double, remove if class is detemplated
  for (int pl = 1; pl <= profile.Length(); pl++)   {
    profile[pl] = new gArray<const Action *>(p.profile[pl]->Length());
    for (int iset = 1; iset <= profile[pl]->Length(); iset++)
      (*profile[pl])[iset] = (*p.profile[pl])[iset];
  }
}

template <class T> PureBehavProfile<T>::~PureBehavProfile()
{
  for (int pl = 1; pl <= profile.Length(); delete profile[pl++]);
}

template <class T> 
PureBehavProfile<T> &PureBehavProfile<T>::operator=(const PureBehavProfile<T> &p) 
{
  if (this != &p && E == p.E)   {
    for(int pl = 1; pl <= profile.Length(); pl++)
    for(int iset = 1; iset <= profile[pl]->Length(); iset++)
    (*profile[pl])[iset] = (*p.profile[pl])[iset];
  }
  return *this;
}

template <class T> T PureBehavProfile<T>::operator()(Action *action) const
{
  if ((*profile[action->BelongsTo()->GetPlayer()->GetNumber()])
      [action->BelongsTo()->GetNumber()] == action)
    return (T) 1;
  else
    return (T) 0;
}

template <class T> void PureBehavProfile<T>::Set(const Action *action)
{
  (*profile[action->BelongsTo()->GetPlayer()->GetNumber()])
    [action->BelongsTo()->GetNumber()] = action;
}

template <class T>
void PureBehavProfile<T>::Set(const EFPlayer *player,
                              const gArray<const Action *> &actions)
{
  *profile[player->GetNumber()] = actions;
}

template <class T>
const Action *PureBehavProfile<T>::GetAction(const Infoset *infoset) const
{
  return (*profile[infoset->GetPlayer()->GetNumber()])[infoset->GetNumber()];
}

/* - The following is an attempt to eliminate all the extra work of
computing a vector of payoffs when only one agent's payoff is of
interest.  It runs into a problem that I don't know how to solve,
namely that compilation leads to a request for a cast from gNumber to
gRational. amm-8.98

template <class T>
void PureBehavProfile<T>::IndPayoff(const Node *n, 
				 const int &pl, 
				 const T prob, 
				       T &payoff) const
{
  if (n->IsTerminal())
    payoff += prob * (*payoffs)(n->GetOutcome()->GetNumber(), pl);
  
  if (n->IsNonterminal() && n->GetPlayer()->IsChance())
    for (int i = 1; i <= n->NumChildren(); i++) {
      IndPayoff(n->GetChild(i), pl,
	     prob * (T) E->GetChanceProb(n->GetInfoset(), i), payoff);
    }
  else if (n->IsNonterminal())
    IndPayoff(n->GetChild((*profile[n->GetPlayer()->GetNumber()])[n->GetInfoset()->GetNumber()]->GetNumber()), pl,
	   prob, payoff);
}
*/

// The following could be shortened by using the player-specific one above.
// Whether this would be more efficient in fact is unknown. - AMM 7.6.98

template <class T>
const T PureBehavProfile<T>::Payoff(const Node *n, const int &pl) const
{
  gArray<T> payoff(E->NumPlayers());
  for (int i = 1; i <= E->NumPlayers(); i++)
    payoff[i] = (T)0;
  Payoff(n, (T)1, payoff);
  return payoff[pl];
}

template <class T>
void PureBehavProfile<T>::Payoff(const Node *n, 
				 const T prob, 
				       gArray<T> &payoff) const
{
  if (n->IsTerminal())
    for (int pl = 1; pl <= E->NumPlayers(); pl++) 
      payoff[pl] += prob * Payoff(n->GetOutcome(),pl);
  
  else
    if (n->GetPlayer()->IsChance())	
      for (int i = 1; i <= E->NumChildren(n); i++)
	Payoff(n->GetChild(i),
	       prob * (T) E->GetChanceProb(n->GetInfoset(), i), payoff);
    else
      Payoff(n->GetChild(GetAction(n->GetInfoset())), prob, payoff);
}

template <class T>
void PureBehavProfile<T>::InfosetProbs(Node *n, T prob, gPVector<T> &probs) const
{
  if (n->GetInfoset() && n->GetPlayer()->IsChance())
    for (int i = 1; i <= E->NumChildren(n); i++)
      InfosetProbs(n->GetChild(i),
		   prob * (T) E->GetChanceProb(n->GetInfoset(), i), probs);
  else if (n->GetInfoset())  {
    probs(n->GetPlayer()->GetNumber(), n->GetInfoset()->GetNumber()) += prob;
    InfosetProbs(n->GetChild((*profile[n->GetPlayer()->GetNumber()])[n->GetInfoset()->GetNumber()]->GetNumber()),
		 prob, probs);
  }
}

template <class T>
void PureBehavProfile<T>::Payoff(gArray<T> &payoff) const
{
  for (int pl = 1; pl <= payoff.Length(); payoff[pl++] = (T) 0);
  Payoff(E->RootNode(), (T) 1, payoff);
}

template <class T>
void PureBehavProfile<T>::InfosetProbs(gPVector<T> &probs) const
{
  ((gVector<T> &) probs).operator=((T) 0);
  InfosetProbs(E->RootNode(), (T) 1, probs);
}


//------------------------------------------------------------------------
//      Implementation of BehavNode
//------------------------------------------------------------------------

template <class T> BehavProfile<T>::BehavNode::BehavNode(Efg *e, Node *n, int pl)
  : node(n), nval((T) 0), bval((T) 0), scratch(pl), children(e->NumChildren(n)), 
    realizProb((T)0), belief((T)0), nodeValue(pl), condPayoff(pl)
{
  for (int child = 1; child <= children.Length(); child++) 
    children[child] = new BehavNode(e,n->GetChild(child), pl);
}    

template <class T> BehavProfile<T>::BehavNode::~BehavNode()
{
  for (int child = 1; child <= children.Length();
       delete children[child++]);
}

//------------------------------------------------------------------------
//      Implementation of BehavInfoset<T>
//------------------------------------------------------------------------

template <class T> BehavProfile<T>::BehavInfoset::BehavInfoset(const EFSupport &s, Infoset *i, int pl)
  : iset(i), actions(s.NumActions(i))
{ 
for(int act = 1;act<=s.NumActions(i);act++)
     actions[act] = new BehavAction(s.Actions(i)[act],pl);
}    

template <class T> BehavProfile<T>::BehavInfoset::~BehavInfoset()
{ 
for(int act = 1;act<=actions.Length();act++)
  delete actions[act];
}

//------------------------------------------------------------------------
//      Implementation of BehavAction<T>
//------------------------------------------------------------------------

template <class T> BehavProfile<T>::BehavAction::BehavAction(Action *act, int pl)
  : action(act), probability(0), condPayoff((T)0)
{  }    

template <class T> BehavProfile<T>::BehavAction::~BehavAction()
{ }

//-------------------------------------------------------------------------
//   BehavProfile<T>: Constructors, Destructor, Constructive Operators
//-------------------------------------------------------------------------

template <class T>
BehavProfile<T>::BehavProfile(const BehavProfile<T> &p_profile)
  : gDPVector<T>(p_profile), m_efg(p_profile.m_efg),
    m_root(new BehavNode((Efg *)p_profile.m_efg, p_profile.m_efg->RootNode(),
			 p_profile.m_efg->NumPlayers())),
    m_support(p_profile.m_support), m_isets(p_profile.m_isets.Length())
{
  InitProfile();
  InstallMe();
  InitPayoffs();
}

template <class T> 
BehavProfile<T>::BehavProfile(const BehavSolution &p_solution)
  : gDPVector<T>(p_solution.Game().NumActions()), m_efg(&p_solution.Game()),
    m_root(new BehavNode((Efg*)m_efg, p_solution.Game().RootNode(),
			 p_solution.Game().NumPlayers())),
    m_support(EFSupport(p_solution.Game())), m_isets(p_solution.Game().TotalNumInfosets())
{
  for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) {
    EFPlayer *player = m_efg->Players()[pl];
    for (int iset = 1; iset <= player->NumInfosets(); iset++) {
      Infoset *infoset = player->Infosets()[iset];
      for (int act = 1; act <= infoset->NumActions(); act++)
	(*this)(pl, iset, act) = p_solution(infoset->Actions()[act]);
    }
  } 
  InitProfile();
  InstallMe();
  InitPayoffs();

}

template <class T> BehavProfile<T>::BehavProfile(const EFSupport &p_support) 
  : gDPVector<T>(p_support.NumActions()), 
    m_efg(&p_support.Game()),
    m_root(new BehavNode((Efg *)m_efg, m_efg->RootNode(), m_efg->NumPlayers())),
    m_support(p_support), m_isets(m_efg->TotalNumInfosets())
{
  InitProfile();
  InstallMe();
  InitPayoffs();
  Centroid();
}

template <class T> BehavProfile<T>::~BehavProfile()
{
  delete m_root;
  for(int i=1;i<=m_isets.Length();i++)
    delete m_isets[i];
}

template <class T>
BehavProfile<T> &BehavProfile<T>::operator=(const BehavProfile<T> &p_profile)
{
  if (this != &p_profile && m_efg == p_profile.m_efg)   {
    // note that a dimensionality change will trigger an exception
    // in the gDPVector assignment operator
    gDPVector<T>::operator=(p_profile);
    m_support = p_profile.m_support;
  }
  return *this;
}

//-------------------------------------------------------------------------
//                 BehavProfile<T>: General data access
//-------------------------------------------------------------------------

template <class T>
const T &BehavProfile<T>::GetValue(const Action *p_action) const
{
  return (*this)(p_action->BelongsTo()->GetPlayer()->GetNumber(), 
		 p_action->BelongsTo()->GetNumber(),
		 m_support.Find(p_action));
}

template <class T> T BehavProfile<T>::LiapValue(void) const
{
  static const T BIG1 = (T) 10000;
  static const T BIG2 = (T) 100;

  BehavProfile<T> p(*this);
  ((gVector<T> &) p).operator=(*this);
  BehavProfile<T> tmp(p);
  T x, result = ((T) 0), avg, sum;

  gDPVector<T> cpay(m_efg->NumActions());  
  gPVector<T> probs(m_efg->NumInfosets());
  tmp.CondPayoff(cpay, probs);

  for (int i = 1; i <= m_efg->NumPlayers(); i++) {
    EFPlayer *player = m_efg->Players()[i];
    for (int j = 1; j <= player->NumInfosets(); j++) {
      avg = sum = (T)0;
      Infoset *s = player->Infosets()[j];
      int k;
      for (k = 1; k <= s->NumActions(); k++) {
	x = p(i, j, k); 
	avg += x * cpay(i, j, k);
	sum += x;
	if (x > (T)0)  x = (T)0;
	result += BIG1 * x * x;         // add penalty for neg probabilities
      }
      for (k = 1; k <= s->NumActions(); k++) {
	x = cpay(i, j, k) - avg;
	if (x < (T)0) x = (T)0;
	result += x * x;          // add penalty if not best response
      }
      x = sum - (T)1;
      result += BIG2 * x * x;       // add penalty for sum not equal to 1
    }
  }
  return result;
}

    
template <class T> void BehavProfile<T>::Gripe(gDPVector<T> &value) const
{
  // Currently this is very inefficient.  But we need some functions 
  // to evaluate the effect on payoff from a change in a profile 
  // to make this better (rdm) 
  BehavProfile<T> scratch(*this);
  
  for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) {
    T pay = Payoff(pl);
    T zero = pay - pay;
    EFPlayer *player = m_efg->Players()[pl];
    for (int iset = 1; iset <= player->NumInfosets(); iset++) {
      Infoset *infoset = player->Infosets()[iset];
      for (int act = 1; act <= infoset->NumActions(); act++) 
	scratch(pl, iset, act) = zero;
      for (int act = 1; act <= infoset->NumActions(); act++) {
	scratch(pl, iset, act) = (T) 1;
	value(pl, iset, act) = scratch.Payoff(pl) - pay;
	if (value(pl, iset, act) < (T) 0) 
	  value(pl, iset, act) = zero;
	scratch(pl, iset, act) = zero;
      }
      for (int act = 1; act <= infoset->NumActions(); act++) 
	scratch(pl, iset, act) = (*this)(pl, iset, act);
    }
  }
}

template <class T> T BehavProfile<T>::MaxGripe(void) const
{
  T maxgripe = (T) 0;
  gDPVector<T> v(*this);
  Gripe(v);

  for (int i = v.First(); i <= v.Last(); i++)
    if (v[i] > maxgripe) maxgripe = v[i];
  return maxgripe;
}

//-------------------------------------------------------------------------
//                 BehavProfile<T>: Operator overloading
//-------------------------------------------------------------------------

template <class T>
bool BehavProfile<T>::operator==(const BehavProfile<T> &p_profile) const
{
  return (m_efg == p_profile.m_efg &&
	  (gDPVector<T> &) *this == (gDPVector<T> &) p_profile);
}

template <class T> void BehavProfile<T>::Dump(gOutput &p_file) const
{
  gDPVector<T>::Dump(p_file);
}


//------------------------------------------------------------------------
//         BehavProfile<T>: Used in test of extendability to ANF Nash
//------------------------------------------------------------------------

template <class T> gPolyList<gDouble> 
BehavProfile<T>::ActionProbsSumToOneIneqs(const gSpace &BehavStratSpace, 
	        		          const term_order &Lex,
					  const EFSupport &big_supp,
				          const gList<gList<int> > &var_index) 
  const
{
  gPolyList<gDouble> answer(&BehavStratSpace, &Lex);

  int pl;
  for (pl = 1; pl <= Game().NumPlayers(); pl++) 
    for (int i = 1; i <= Game().Players()[pl]->NumInfosets(); i++) {
      Infoset *current_infoset = Game().Players()[pl]->Infosets()[i];
      if ( !big_supp.HasActiveActionAt(current_infoset) ) {
	int index_base = var_index[pl][i];
	gPoly<gDouble> factor(&BehavStratSpace, (gDouble)1.0, &Lex);
	for (int k = 1; k < current_infoset->NumActions(); k++)
	  factor -= gPoly<gDouble>(&BehavStratSpace, index_base + k, 1, &Lex);
	answer += factor;
      }
    }
  return answer;
}

template <class T>
bool BehavProfile<T>::ANFNodeProbabilityPoly(      gPoly<gDouble> & node_prob,
		          	          const gSpace &BehavStratSpace, 
				          const term_order &Lex,
					  const EFSupport &big_supp,
				          const gList<gList<int> > &var_index,
				          const Node *tempnode,
				          const int &pl,
				          const int &i,
				          const int &j) const
{
  while (tempnode != Game().RootNode()) {

    const Action *last_action = tempnode->GetAction();
    Infoset *last_infoset = last_action->BelongsTo();
    
    if (last_infoset->IsChanceInfoset()) 
      node_prob *= (gDouble)Game().GetChanceProb(last_action);
    else 
      if (big_supp.HasActiveActionAt(last_infoset)) {
	if (last_infoset == Game().Players()[pl]->Infosets()[i]) {
	  if (j != last_action->GetNumber()) 
	    return false;
	}
	else
	  if (big_supp.ActionIsActive((Action *)last_action))
	    node_prob *= (gDouble)GetValue(last_action);
	  else 
	    return false;
      }
      else {
	int initial_var_no = 
 var_index[last_infoset->GetPlayer()->GetNumber()][last_infoset->GetNumber()];
	if (last_action->GetNumber() < last_infoset->NumActions()){
	  int varno = initial_var_no + last_action->GetNumber();
	  node_prob *= gPoly<gDouble>(&BehavStratSpace, varno, 1, &Lex);
	}
	else {
	  gPoly<gDouble> factor(&BehavStratSpace, (gDouble)1.0, &Lex);
	  int k;
	  for (k = 1; k < last_infoset->NumActions(); k++)
	    factor -= gPoly<gDouble>(&BehavStratSpace,
				     initial_var_no + k, 1, &Lex);
	  node_prob *= factor;
	}
      } 
    tempnode = tempnode->GetParent();
  }
  return true;
}

template <class T> gPolyList<gDouble> 
BehavProfile<T>::ANFExpectedPayoffDiffPolys(const gSpace &BehavStratSpace, 
					    const term_order &Lex,
					    const EFSupport &little_supp,
					    const EFSupport &big_supp,
					  const gList<gList<int> > &var_index) 
  const
{
  gPolyList<gDouble> answer(&BehavStratSpace, &Lex);

  gList<const Node *> terminal_nodes = Game().TerminalNodes();

  for (int pl = 1; pl <= Game().NumPlayers(); pl++)
    for (int i = 1; i <= Game().Players()[pl]->NumInfosets(); i++) {
      Infoset *infoset = Game().Players()[pl]->Infosets()[i];
      if (little_supp.MayReach(infoset)) 
	for (int j = 1; j <= infoset->NumActions(); j++)
	  if (!little_supp.ActionIsActive(pl,i,j)) {
	
	    // This will be the utility difference between the
	    // payoff resulting from the profile and deviation to 
	    // action j
	    gPoly<gDouble> next_poly(&BehavStratSpace, &Lex);

	    for (int n = 1; n <= terminal_nodes.Length(); n++) {
	      gPoly<gDouble> node_prob(&BehavStratSpace, (gDouble)1.0, &Lex);
	      if (ANFNodeProbabilityPoly(node_prob,
					 BehavStratSpace,
					 Lex,
					 big_supp,
					 var_index,
					 terminal_nodes[n],
					 pl,i,j)) {
		node_prob *= 
		  (gDouble)Game().Payoff(terminal_nodes[n],
					 Game().Players()[pl]);
		next_poly += node_prob;
	      }
	    }
	    answer += -next_poly + (gDouble)Payoff(pl);
	  }
    }
  return answer;
}

template <class T>  gPolyList<gDouble> 
BehavProfile<T>::ExtendsToANFNashIneqs(const gSpace &BehavStratSpace, 
				       const term_order &Lex,
				       const EFSupport &little_supp,
				       const EFSupport &big_supp,
				       const gList<gList<int> > &var_index) 
  const
{
  gPolyList<gDouble> answer(&BehavStratSpace, &Lex);
  answer += ActionProbsSumToOneIneqs(BehavStratSpace, 
				     Lex, 
				     big_supp, 
				     var_index);
  answer += ANFExpectedPayoffDiffPolys(BehavStratSpace, 
				       Lex, 
				       little_supp,
				       big_supp,
				       var_index);
  return answer;
}

//------------------------------------------------------------------------
//         BehavProfile<T>: Test whether extends to ANF Nash eq
//------------------------------------------------------------------------

template <class T> bool 
BehavProfile<T>::ExtendsToANFNash(const EFSupport &little_supp,
				  const EFSupport &big_supp,
				        gStatus &m_status) const
{
  // This asks whether there is a Nash extension of the BehavSolution to 
  // all information sets at which the behavioral probabilities are not
  // specified.  The assumption is that the support has active actions
  // at infosets at which the behavioral probabilities are defined, and
  // no others.
  
  // First we compute the number of variables, and indexing information
  int num_vars(0);
  gList<gList<int> > var_index;
  int pl;
  for (pl = 1; pl <= Game().NumPlayers(); pl++) {

    gList<int> list_for_pl;

    for (int i = 1; i <= Game().Players()[pl]->NumInfosets(); i++) {
      list_for_pl += num_vars;
      if ( !big_supp.HasActiveActionAt(Game().Players()[pl]->Infosets()[i]) ) {
	num_vars += Game().Players()[pl]->Infosets()[i]->NumActions() - 1;
      }
    }
    var_index += list_for_pl;
  }

  // We establish the space
  gSpace BehavStratSpace(num_vars);
  ORD_PTR ptr = &lex;
  term_order Lex(&BehavStratSpace, ptr);

  num_vars = BehavStratSpace.Dmnsn();
  gPolyList<gDouble> inequalities = ExtendsToANFNashIneqs(BehavStratSpace,
							  Lex,
							  little_supp,
							  big_supp,
							  var_index);

  // set up the rectangle of search
  gVector<gDouble> bottoms(num_vars), tops(num_vars);
  bottoms = (gDouble)0;
  tops = (gDouble)1;
  gRectangle<gDouble> Cube(bottoms, tops); 

  // Set up the test and do it
  IneqSolv<gDouble> extension_tester(inequalities,m_status);
  gVector<gDouble> sample(num_vars);
  return extension_tester.ASolutionExists(Cube,sample); 
}


//------------------------------------------------------------------------
//         BehavProfile<T>: Used in test of extendability to Nash
//------------------------------------------------------------------------

template <class T>  void
BehavProfile<T>::DeviationInfosetsRECURSION(    gList<const Infoset *> &answer,
					    const EFSupport & big_supp,
					    const EFPlayer *pl,
					    const Node* node,
					    const Action *act) const 
{
  Node *child  = node->GetChild(act);
  if ( child->IsNonterminal() ) {
    const Infoset *iset = child->GetInfoset();
    if ( iset->GetPlayer() == pl ) {
      int insert = 0;
      bool done = false;
      while (!done) {
	insert ++;
	if (insert > answer.Length() ||
	    iset->Precedes(answer[insert]->GetMember(1)))
	  done = true;
      }
      answer.Insert(iset,insert);
    }
    gList<Action *> action_list = iset->ListOfActions();
    for (int j = 1; j <= action_list.Length(); j++)
      DeviationInfosetsRECURSION(answer,big_supp,pl,child,action_list[j]);
  }
  return;
}

template <class T>  const gList<const Infoset *> 
BehavProfile<T>::DeviationInfosets(const EFSupport & big_supp,
				   const EFPlayer *pl,
				   const Infoset *iset,
				   const Action *act) const 
{
  gList<const Infoset *> answer;
  
  gList<const Node *> node_list = iset->ListOfMembers();
  for (int i = 1; i <= node_list.Length(); i++) {
    DeviationInfosetsRECURSION(answer,big_supp,pl,node_list[i],act);
  }

  return answer;
}

template <class T>  const gList<const EFSupport> 
BehavProfile<T>::DeviationSupports(const EFSupport & big_supp,
				   const gList<const Infoset *> & isetlist,
				   const EFPlayer */*pl*/,
				   const Infoset */*iset*/,
				   const Action */*act*/) const 
{
  gList<const EFSupport> answer;

  gArray<int> active_act_no(isetlist.Length());

  for (int k = 1; k <= active_act_no.Length(); k++)
    active_act_no[k] = 0;
 
  EFSupport new_supp(big_supp);

  for (int i = 1; i <= isetlist.Length(); i++) {
    for (int j = 1; j < isetlist[i]->NumActions(); j++)
      new_supp.RemoveAction(isetlist[i]->GetAction(j));
    new_supp.AddAction(isetlist[i]->GetAction(1));

    active_act_no[i] = 1;
    for (int k = 1; k < i; k++)
      if (isetlist[k]->Precedes(isetlist[i]->GetMember(1)))
	if (isetlist[k]->GetAction(1)->Precedes(isetlist[i]->GetMember(1))) {
	  new_supp.RemoveAction(isetlist[i]->GetAction(1));
	  active_act_no[i] = 0;
	}
  }
  answer += new_supp;

  int iset_cursor = isetlist.Length();
  while (iset_cursor > 0) {
    if ( active_act_no[iset_cursor] == 0 || 
	 active_act_no[iset_cursor] == isetlist[iset_cursor]->NumActions() )
      iset_cursor--;
    else {
      new_supp.RemoveAction(isetlist[iset_cursor]->
			    GetAction(active_act_no[iset_cursor]));
      active_act_no[iset_cursor]++;
      new_supp.AddAction(isetlist[iset_cursor]->
			 GetAction(active_act_no[iset_cursor]));
      for (int k = iset_cursor + 1; k <= isetlist.Length(); k++) {
	if (active_act_no[k] > 0)
	  new_supp.RemoveAction(isetlist[k]->GetAction(1));
	int h = 1;
	bool active = true;
	while (active && h < k) {
	  if (isetlist[h]->Precedes(isetlist[k]->GetMember(1)))
	    if (active_act_no[h] == 0 || 
		!isetlist[h]->GetAction(active_act_no[h])->
	              Precedes(isetlist[k]->GetMember(1))) {
	      active = false;
	      if (active_act_no[k] > 0) {
		new_supp.RemoveAction(isetlist[k]->
				      GetAction(active_act_no[k]));
		active_act_no[k] = 0;
	      }
	    }
	  h++;
	}
	if (active){
	  new_supp.AddAction(isetlist[k]->GetAction(1));
	  active_act_no[k] = 1;
	}
      }
      answer += new_supp;
    }
  }
  return answer;
}

template <class T> bool 
BehavProfile<T>::NashNodeProbabilityPoly(      gPoly<gDouble> & node_prob,
		          	         const gSpace &BehavStratSpace, 
				         const term_order &Lex,
				         const EFSupport &dsupp,
				         const gList<gList<int> > &var_index,
				         const Node *tempnode,
					 const EFPlayer */*pl*/,
				         const Infoset *iset,
				         const Action *act) const 
{
  while (tempnode != Game().RootNode()) {

    const Action *last_action = tempnode->GetAction();
    Infoset *last_infoset = last_action->BelongsTo();
    
    if (last_infoset->IsChanceInfoset()) 
      node_prob *= (gDouble)Game().GetChanceProb(last_action);
    else 
      if (dsupp.HasActiveActionAt(last_infoset)) {
	if (last_infoset == iset) {
	  if (act != last_action) {
	    return false;
	  }
	}
	else
	  if (dsupp.ActionIsActive((Action *)last_action)) {
	    if ( last_action->BelongsTo()->GetPlayer() !=
		         act->BelongsTo()->GetPlayer()     ||
		 !act->Precedes(tempnode) )
	    node_prob *= (gDouble)GetValue(last_action);
	  }
	  else {
	    return false;
	  }
      }
      else {
	int initial_var_no = 
 var_index[last_infoset->GetPlayer()->GetNumber()][last_infoset->GetNumber()];
	if (last_action->GetNumber() < last_infoset->NumActions()){
	  int varno = initial_var_no + last_action->GetNumber();
	  node_prob *= gPoly<gDouble>(&BehavStratSpace, varno, 1, &Lex);
	}
	else {
	  gPoly<gDouble> factor(&BehavStratSpace, (gDouble)1.0, &Lex);
	  int k;
	  for (k = 1; k < last_infoset->NumActions(); k++)
	    factor -= gPoly<gDouble>(&BehavStratSpace,
				     initial_var_no + k, 1, &Lex);
	  node_prob *= factor;
	}
      } 
    tempnode = tempnode->GetParent();
  }
  return true;
}


template <class T> gPolyList<gDouble> 
BehavProfile<T>::NashExpectedPayoffDiffPolys(const gSpace &BehavStratSpace, 
				          const term_order &Lex,
					  const EFSupport &little_supp,
					  const EFSupport &big_supp,
				          const gList<gList<int> > &var_index) 
  const
{
  gPolyList<gDouble> answer(&BehavStratSpace, &Lex);

  gList<const Node *> terminal_nodes = Game().TerminalNodes();

  const gArray<EFPlayer *> players = Game().Players();
  for (int pl = 1; pl <= players.Length(); pl++) {
    const gArray<Infoset *> isets_for_pl = players[pl]->Infosets();
    for (int i = 1; i <= isets_for_pl.Length(); i++) {
      if (little_supp.MayReach(isets_for_pl[i])) {
	const gArray<Action *> acts_for_iset = isets_for_pl[i]->Actions();
	for (int j = 1; j <= acts_for_iset.Length(); j++)
	  if ( !little_supp.ActionIsActive(acts_for_iset[j]) ) {
	    gList<const Infoset *> isetlist = DeviationInfosets(big_supp, 
							     players[pl],
				         		     isets_for_pl[i],
							     acts_for_iset[j]);
	    gList<const EFSupport> dsupps = DeviationSupports(big_supp, 
							     isetlist, 
							     players[pl],
				         		     isets_for_pl[i],
							     acts_for_iset[j]);
	    for (int k = 1; k <= dsupps.Length(); k++) {

	    // This will be the utility difference between the
	    // payoff resulting from the profile and deviation to 
	    // the strategy for pl specified by dsupp[k]

	      gPoly<gDouble> next_poly(&BehavStratSpace, &Lex);

	      for (int n = 1; n <= terminal_nodes.Length(); n++) {
		gPoly<gDouble> node_prob(&BehavStratSpace, (gDouble)1.0, &Lex);
		if (NashNodeProbabilityPoly(node_prob,
					    BehavStratSpace,
					    Lex,
					    dsupps[k],
					    var_index,
					    terminal_nodes[n],
					    players[pl],
					    isets_for_pl[i],
					    acts_for_iset[j])) {
		  node_prob *= 
		    (gDouble)Game().Payoff(terminal_nodes[n],
					   Game().Players()[pl]);
		  next_poly += node_prob;
		}
	      }
	      answer += -next_poly + (gDouble)Payoff(pl);
	    }
	  }
      }
    }
  }
  return answer;
}

template <class T>  gPolyList<gDouble> 
BehavProfile<T>::ExtendsToNashIneqs(const gSpace &BehavStratSpace, 
				    const term_order &Lex,
				    const EFSupport &little_supp,
				    const EFSupport &big_supp,
				    const gList<gList<int> > &var_index) const
{
  gPolyList<gDouble> answer(&BehavStratSpace, &Lex);
  answer += ActionProbsSumToOneIneqs(BehavStratSpace, 
				     Lex, 
				     big_supp, 
				     var_index);

  answer += NashExpectedPayoffDiffPolys(BehavStratSpace, 
				    Lex, 
				    little_supp,
				    big_supp,
				    var_index);
  return answer;
}

//------------------------------------------------------------------------
//         BehavProfile<T>: Test whether extends to a Nash eq
//------------------------------------------------------------------------

template <class T> bool 
BehavProfile<T>::ExtendsToNash(const EFSupport &little_supp,
			       const EFSupport &big_supp,
			             gStatus &m_status) const
{
  // This asks whether there is a Nash extension of the BehavSolution to 
  // all information sets at which the behavioral probabilities are not
  // specified.  The assumption is that the support has active actions
  // at infosets at which the behavioral probabilities are defined, and
  // no others.
  
  // First we compute the number of variables, and indexing information
  int num_vars(0);
  gList<gList<int> > var_index;
  int pl;
  for (pl = 1; pl <= Game().NumPlayers(); pl++) {

    gList<int> list_for_pl;

    for (int i = 1; i <= Game().Players()[pl]->NumInfosets(); i++) {
      list_for_pl += num_vars;
      if ( !big_supp.HasActiveActionAt(Game().Players()[pl]->Infosets()[i]) ) {
	num_vars += Game().Players()[pl]->Infosets()[i]->NumActions() - 1;
      }
    }
    var_index += list_for_pl;
  }

  // We establish the space
  gSpace BehavStratSpace(num_vars);
  ORD_PTR ptr = &lex;
  term_order Lex(&BehavStratSpace, ptr);

  num_vars = BehavStratSpace.Dmnsn();

  gPolyList<gDouble> inequalities = ExtendsToNashIneqs(BehavStratSpace,
						       Lex,
						       little_supp,
						       big_supp,
						       var_index);
  // set up the rectangle of search
  gVector<gDouble> bottoms(num_vars), tops(num_vars);
  bottoms = (gDouble)0;
  tops = (gDouble)1;
  gRectangle<gDouble> Cube(bottoms, tops); 

  // Set up the test and do it
  IneqSolv<gDouble> extension_tester(inequalities,m_status);
  gVector<gDouble> sample(num_vars);
  return extension_tester.ASolutionExists(Cube,sample); 
}

//------------------------------------------------------------------------
//         BehavProfile<T>: Initialization and installation
//------------------------------------------------------------------------

template <class T>
bool BehavProfile<T>::IsInstalled(void) const
{
  return (m_root->node->solution == m_root);
}

template <class T>
void BehavProfile<T>::InstallMe(BehavNode *b_node) const
{
  b_node->node->solution = b_node;
  for (int child = 1; child <= b_node->children.Length(); child++) 
    InstallMe(b_node->children[child]);
}

template <class T>
void BehavProfile<T>::InstallMe(void) const
{
  //  gout << "\nInstallMe()";
  //  if(!IsInstalled()) {
    InstallMe(m_root);
    for(int i=1;i<=m_isets.Length();i++) {
      m_isets[i]->iset->solution = m_isets[i];
      for(int j=1;j<=(m_isets[i]->actions).Length();j++) {
	//	gout << "\ninstalling pl, iset, act: " << m_isets[i]->iset->GetPlayer()->GetNumber() << " " << i << " " << j;
	(m_isets[i]->actions)[j]->action->solution = (m_isets[i]->actions)[j];
      }
    }
    //  }
}

template <class T>
void BehavProfile<T>::InitPayoffs(void) const
{
  m_efg->InitPayoffs();
}

template <class T>
void BehavProfile<T>::InitProfile(void)
{
   gBlock<Infoset *> efg_isets(((FullEfg *)m_efg)->Infosets());
   // gList<Infoset *> efg_isets(m_support.ReachableInfosets(m_root->node));
   assert(efg_isets.Length()==m_isets.Length());
  for(int i=1;i<=efg_isets.Length();i++) {
    int pl = efg_isets[i]->GetPlayer()->GetNumber();
    m_isets[i] = new BehavInfoset(m_support,efg_isets[i],m_efg->NumPlayers());
    int iset = m_isets[i]->iset->GetNumber();
    for(int j=1;j<=m_isets[i]->actions.Length();j++) {
      m_isets[i]->actions[j]->probability 
	= &((*this)(pl,iset,j));
    }
  }
}

//--------------------
// NodeRealizProbs
//--------------------

template <class T>
void BehavProfile<T>::NodeRealizProbs(BehavNode *p_node, T p_prob,
				      int &p_index, gArray<T> &p_probs) const
{
  p_probs[p_index] = p_prob;
  if (!p_node->node->infoset)  return;

  int npl = p_node->node->infoset->player->number;

  if (npl == 0) {  // chance node
    for (int child = 1; child <= m_efg->NumChildren(p_node->node); child++) {
      NodeRealizProbs(p_node->children[child],
		      p_prob * ChanceProb(p_node->node->infoset, child),
		      ++p_index, p_probs);
    }
  }
  else if (npl > 0) {
    for (int child = 1; child <= m_efg->NumChildren(p_node->node); child++) {
      int index = m_support.Find(p_node->node->infoset->actions[child]);
      if (index) {
	NodeRealizProbs(p_node->children[child],
			p_prob * (*this)(npl, p_node->node->infoset->number,
					 index),
			++p_index, p_probs);
      }
      else
	p_index += CountNodes(*(m_efg),p_node->node->children[child]); 

    }
  }
}

template <class T> gArray<T> BehavProfile<T>::NodeRealizProbs(void) const
{
  int index = 1, maxindex = NumNodes(*m_efg);

  gArray<T> probs(maxindex);
  for (int i = 1; i <= maxindex; probs[i++] = (T) 0);
  NodeRealizProbs(m_root, (T) 1, index, probs);
  return probs;
}

//------------
// Beliefs
//------------

template <class T>
void BehavProfile<T>::Beliefs(Node *p_node, T p_prob,
			      gDPVector<T> &p_probs, gPVector<T> &p_gpv) const
{
  int npl = (p_node->infoset) ? p_node->infoset->player->number : -1;
  int iset = (p_node->infoset) ? p_node->infoset->number : 0;
  int nc = p_node->children.Length();
  int mnum = 1;

  if (p_node->infoset == 0)   return;

  while (mnum <= p_node->infoset->NumMembers() &&
	 p_node->infoset->Members()[mnum] != p_node) 
    mnum++;
  
  if (npl > 0 && p_gpv(npl, iset) != (T) 0)
    p_probs(npl, iset, mnum) = p_prob / p_gpv(npl, iset);

  if (npl == 0)  {
    for (int child = 1; child <= nc; child++)  {
      Beliefs(p_node->children[child],
	      p_prob * ChanceProb(p_node->infoset, child),
	      p_probs, p_gpv);
    }
  }
  else {
    const gArray<Action *> &actions = m_support.Actions(npl, iset);

    for (int act = 1; act <= m_support.NumActions(npl, iset); act++) {
      Beliefs(p_node->children[actions[act]->GetNumber()],
	      p_prob * (*this)(npl,
			       p_node->infoset->number,
			       actions[act]->GetNumber()),
	      p_probs, p_gpv);
    }
  }
}

template <class T> gDPVector<T> BehavProfile<T>::Beliefs(void) const
{
  gDPVector<T> bprobs(m_efg->NumMembers());
  bprobs = (T) 0;
  gDPVector<T> payoff(m_efg->NumActions());
  gPVector<T> probs(m_efg->NumActions().Lengths());
  CondPayoff(payoff, probs);
  Beliefs(m_efg->RootNode(), (T) 1, bprobs, probs);
  return bprobs;
}

//-----------------
// NodeValues
//-----------------

template <class T>
void BehavProfile<T>::NodeValues(BehavNode *p_node, int p_player, 
				 gArray<T> &p_values, int &p_index) const
{
  int tindex = p_index;

 if (p_node->node->outcome) 
   p_node->nval += Payoff(p_node->node->outcome, p_player);
 

  for (int child = 1; child <= p_node->children.Length(); child++)
    p_node->children[child]->nval = p_node->nval;
 
  T value = (T) 0;
  
  if (p_node->node->infoset == 0)   {
    p_values[tindex] = p_node->nval;
    return;
  }
  
  if (p_node->node->infoset->player->number == 0)  {
    for (int child = 1; child <= p_node->children.Length(); child++)   {
      NodeValues(p_node->children[child], p_player, p_values, ++p_index);
      value += ChanceProb(p_node->node->infoset, child) *
	         p_node->children[child]->nval;
    }

    p_node->nval = value;
  }
  else {
    int npl = p_node->node->infoset->player->number;
    int iset = p_node->node->infoset->number;
    for (int act = 1; act <= p_node->children.Length(); act++)  {
      NodeValues(p_node->children[act], p_player, p_values, ++p_index);
      int index = m_support.Find(p_node->node->infoset->actions[act]);
      if (index)
	value += (*this)(npl, iset, index) * p_node->children[act]->nval;
    }
  
    p_node->nval = value;
    p_values[tindex] = p_node->nval;
  }
}

template <class T> T BehavProfile<T>::NodeValue(Node * node, int p_player) const
{
  NodeValues(p_player);
  return ((BehavNode *)(node->solution))->nval;
}

template <class T> gArray<T> BehavProfile<T>::NodeValues(int p_player) const
{
  int index = 1, maxindex = NumNodes(*m_efg);
  gArray<T> values(maxindex); 
  for (int i = 1; i <= maxindex; values[i++] = (T) 0);
  m_root->nval = (T) 0;
  NodeValues(m_root, p_player, values, index);
  return values;
}


template <class T> void BehavProfile<T>::Centroid(void) const
{
  T center;

  for (int pl = 1; pl <= dvlen.Length(); pl++)
    for (int iset = 1; iset <= dvlen[pl]; iset++)
      if (m_support.NumActions(pl,iset) > 0) {
	center = ((T) 1 / (T) m_support.NumActions(pl, iset));
	int act;
	for (act = 1; act <= svlen[dvidx[pl] + iset - 1]; act++)
	  dvptr[pl][iset][act] = center;
      }
}

template <class T> const T &BehavProfile<T>::ActionProb(Action * act) const
{
  if(!IsInstalled()) 
  //  throw BadStuff();
    InstallMe();

  return *(((BehavAction *)(act->solution))->probability);
}	

template <class T> T &BehavProfile<T>::ActionProb(Action * act)
{
  if(!IsInstalled()) 
    //throw BadStuff();
    InstallMe();
  return *(((BehavAction *)(act->solution))->probability);
}

template <class T> BehavProfile<T>::BadStuff::~BadStuff()
{ }

template <class T> gText BehavProfile<T>::BadStuff::Description(void) const
{
  return "Solution not installed in BehavProfile";
}

template <class T>
void RealizationProbs(const MixedProfile<T> &mp,
		      const Efg &E, BehavProfile<T> &bp,
		      int pl, const gArray<int> *const actions,
		      BehavProfile<T>::BehavNode *n)
{
  static const T tremble = (T) 0;
  T prob;

  Node *node = n->node;

  for (int i = 1; i <= n->children.Length(); i++)   {
    if (node->GetPlayer() && !node->GetPlayer()->IsChance())   {
      if (node->GetPlayer()->GetNumber() == pl)  {
	if ((*actions)[node->GetInfoset()->GetNumber()] == i)
	  prob = (T) 1 - tremble + tremble / (T) E.NumChildren(node);
	else
	  prob = tremble / (T) E.NumChildren(node);
      }
      else if (bp.Support().Find(node->GetInfoset()->Actions()[i]))
	prob = (T) 1 / (T) bp.Support().NumActions(node->GetPlayer()->GetNumber(),
							  node->GetInfoset()->GetNumber());
      else
	prob = (T) 0;
    }
    else  {   // n.GetPlayer() == 0
      prob = E.GetChanceProb(node->GetInfoset(), i).operator gRational();
    }

    BehavProfile<T>::BehavNode *child = n->children[i];
    child->bval = prob * n->bval;
    child->nval += child->bval;    

    RealizationProbs(mp, E, bp, pl, actions, child);
  }    
	
}

template <class T>
void BehaviorStrat(const Efg &E, BehavProfile<T> &bp, int pl,
		   BehavProfile<T>::BehavNode *n)
{
  for (int i = 1; i <= n->children.Length(); i++)   {
    BehavProfile<T>::BehavNode *child = n->children[i];
    if (n->node->GetPlayer() && n->node->GetPlayer()->GetNumber() == pl)
      if (n->nval > (T) 0 && child->nval > (T) 0)  {
	bp(n->node->GetPlayer()->GetNumber(),
	   n->node->GetInfoset()->GetNumber(), 
	   bp.Support().Find(n->node->GetInfoset()->Actions()[i])) =
	  child->nval / n->nval;
      }
    BehaviorStrat(E, bp, pl, child);
  }
}

template <class T> void BehavProfile<T>::BehavNode::ClearNodeProbs(void)
{
  nval = (T) 0;
  for (int i = 1; i <= children.Length(); i++)
    children[i]->ClearNodeProbs();
}

template <class T>
BehavProfile<T>::BehavProfile(const MixedProfile<T> &p_profile)
  : gDPVector<T>(p_profile.Game().AssociatedEfg()->NumActions()), 
    m_efg(p_profile.Game().AssociatedEfg()),
    m_root(new BehavNode((Efg *)m_efg, m_efg->RootNode(), m_efg->NumPlayers())),
    m_support(*m_efg),  
    m_isets(p_profile.Game().AssociatedEfg()->TotalNumInfosets())
{
  //  gout << "\nin BehavProfile(const MixedProfile<T> &p_profile)";

  InitProfile();
  InstallMe();
  InitPayoffs();

  if (m_efg->AssociatedAfg() == &p_profile.Game())   {
    ((gVector<T> &) *this).operator=((gVector<T> &) p_profile);
    return;
  }

  ((gVector<T> &) *this).operator=((T)0); 

  BehavNode *n = m_root;
  const NFSupport &support = p_profile.Support();
  const Nfg &nfg = p_profile.Game();

  for (int pl = 1; pl <= nfg.NumPlayers(); pl++)   {
    n->ClearNodeProbs();

    for (int st = 1; st <= support.NumStrats(pl); st++)  {
      int snum = support.Strategies(pl)[st]->Number();
      if (p_profile(pl, st) > (T) 0)  {
	const gArray<int> *const actions = m_efg->GetLexicon()->strategies[pl][snum];

	n->bval = p_profile(pl, st);

	RealizationProbs(p_profile, *m_efg, *this, pl, actions, m_root);
      }
    }
    
    m_root->nval = (T) 1;
    BehaviorStrat(*m_efg, *this, pl, n);
  }
}

//-----------------
//   Output
//-----------------

template <class T> gOutput &operator<<(gOutput &p_file,
				       const BehavProfile<T> &p_profile)
{
  p_profile.Dump(p_file);
  return p_file;
}



//------------------------------------------------------------------------
//  BehavAssessment<T>: Constructors, Destructor, Constructive Operators
//------------------------------------------------------------------------

template <class T>
BehavAssessment<T>::BehavAssessment(const EFSupport &p_support)
  : BehavProfile<T>(p_support), m_beliefs(p_support.Game().NumMembers())
{
  m_beliefs = BehavProfile<T>::Beliefs();
}

template <class T>
BehavAssessment<T>::BehavAssessment(const BehavProfile<T> &p_profile)
  : BehavProfile<T>(p_profile), m_beliefs(p_profile.Beliefs())
{ }

template <class T>
BehavAssessment<T>::BehavAssessment(const BehavAssessment<T> &p_assess)
  : BehavProfile<T>(p_assess), m_beliefs(p_assess.m_beliefs)
{ }

template <class T> BehavAssessment<T>::~BehavAssessment()
{ }

template <class T> BehavAssessment<T> &
BehavAssessment<T>::operator=(const BehavAssessment<T> &p_assess)
{
  if (this != &p_assess && &Game() == &p_assess.Game()) {
    BehavProfile<T>::operator=(p_assess);
    m_beliefs = p_assess.m_beliefs;
  }
  return *this;
}

//------------------------------------------------------------------------
//        BehavAssessment<T>: Access and manipulation of beliefs
//------------------------------------------------------------------------

template <class T> gDPVector<T> BehavAssessment<T>::Beliefs(void) const
{ return m_beliefs; }

template <class T> gDPVector<T> &BehavAssessment<T>::Beliefs(void)
{ return m_beliefs; }

//----------------
// CondPayoff
//----------------

template <class T>
void BehavAssessment<T>::CondPayoff(BehavNode *p_node, T p_prob,
				    gPVector<T> &p_probs,
				    gDPVector<T> &p_payoff) const
{
  int npl =
    (p_node->node->GetInfoset()) ? p_node->node->GetPlayer()->GetNumber() : -1;
  int iset = 
    (p_node->node->GetInfoset()) ? p_node->node->GetInfoset()->GetNumber() : 0;
  
  if (p_node->node->GetOutcome()) 
    for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) 
      p_node->scratch[pl] += Payoff(p_node->node->GetOutcome(), pl);

  int nc = p_node->children.Length();
  for (int child = 1; child <= nc; child++)
    p_node->children[child]->scratch = p_node->scratch;
  
  gVector<T> tmp(m_efg->NumPlayers());
  tmp = (T) 0;
  
  if (nc == 0)   return;

  if (npl == 0)   {
    for (int child = 1; child <= nc; child++)  {
      CondPayoff(p_node->children[child],
		 p_prob *
		 ChanceProb(p_node->node->GetInfoset(),child),
		 p_probs, p_payoff);
      
      for (int pl = 1; pl <= p_node->scratch.Length(); pl++)
	tmp[pl] += 
	  ChanceProb(p_node->node->GetInfoset(), child) *
	  p_node->children[child]->scratch[pl];
    }
    p_node->scratch = tmp;
  }
  else  {    // player decision node
    // This implementation differs from the one in BehavProfile<T>
    // since we have well-defined belief probabilities off the equilibrium
    // path.  So, we must traverse the whole tree, and cannot ignore
    // the (zero-probability) actions which do not appear in the support
    for (int child = 1; child <= m_efg->NumChildren(p_node->node); child++) {
      int act = m_support.Find(p_node->node->GetInfoset()->Actions()[child]);
      T newprob;
      if (act)
	newprob = (*this)(npl, iset, act);
      else
	newprob = (T) 0;
      CondPayoff(p_node->children[child], p_prob * newprob,
		 p_probs, p_payoff);
      for (int pl = 1; pl <= p_node->scratch.Length(); pl++)
	tmp[pl] += newprob * p_node->children[child]->scratch[pl];
      
      int mnum;
      for (mnum = 1;
	   p_node->node->GetInfoset()->Members()[mnum] != p_node->node;
	   mnum++);
      p_payoff(npl, iset, child) += 
	m_beliefs(npl, iset, mnum)  * p_node->children[child]->scratch[npl];
      p_node->scratch = tmp;
    }
  }    
  
  if (npl > 0)
    p_probs(npl, p_node->node->GetInfoset()->GetNumber()) += p_prob;
}


template <class T>
void BehavAssessment<T>::CondPayoff(gDPVector<T> &p_payoff,
				    gPVector<T> &p_probs) const
{
  ((gVector<T> &) p_payoff).operator=((T) 0);
  ((gVector<T> &) p_probs).operator=((T) 0);

  m_root->scratch = (T) 0;
  CondPayoff(m_root, (T) 1, p_probs, p_payoff);

  // We can dispense with the normalization step found in the analogous
  // place in BehavProfile<T> since the beliefs are assumed to be 
  // normalized to sum to 1.  (If they don't, things are weird anyway.)
}

//------------------------------------------------------------------------
//                     BehavAssessment<T>: Output
//------------------------------------------------------------------------

template <class T> void BehavAssessment<T>::Dump(gOutput &p_file) const
{
  BehavProfile<T>::Dump(p_file);
  p_file << ' ';
  p_file << m_beliefs;
}

template <class T> gOutput &operator<<(gOutput &p_file,
				       const BehavAssessment<T> &p_assess)
{
  p_assess.Dump(p_file);
  return p_file;
}


//-------- BehavProfile<T> functions using "installation" --------------

//--------------
// Payoff
//--------------


template <class T>
void BehavProfile<T>::Payoff(Node *node, T prob, int player, T &value) const
{
  if(!IsInstalled())
     throw BadStuff();
  ((BehavNode *) node->solution)->realizProb = prob;
  Infoset * iset = node->infoset;

  if (node->outcome) 
    value += prob * Payoff(node->outcome, player);

  if (node->children.Length())  {
    if (iset->IsChanceInfoset())  {
      for (int child = 1; child <= node->children.Length(); child++)
	Payoff(node->children[child], prob * ChanceProb(iset, child), player, value);
    }
    else  {
      const gArray<Action *> &acts = m_support.Actions(iset);
      for (int act = 1; act <= acts.Length(); act++) {
	if( ((BehavAction *)acts[act]->solution)->action != acts[act]) InstallMe();
	if( ((BehavAction *)acts[act]->solution)->action != acts[act]) throw BadStuff();
	Payoff(node->GetChild(acts[act]), prob * ActionProb(acts[act]), player, value);
      }
    }
  }
  ((BehavNode *) node->solution)->nodeValue[player] = value;
}

template <class T> T BehavProfile<T>::Payoff(int player) const
{
  if(!IsInstalled())
    InstallMe();
  T value = (T) 0;
  Payoff(m_efg->RootNode(), (T) 1, player, value);
  return value;
}

//----------------
// CondPayoff
//----------------

template <class T>
void BehavProfile<T>::CondPayoff(Node *node, T prob, gPVector<T> &probs,
				 gDPVector<T> &payoff) const
{
  if(!IsInstalled())throw BadStuff();
  BehavNode *b_node = (BehavNode *)node->solution;
  gVector<T> &scratch = b_node->scratch;
  int npl = m_efg->NumPlayers();

  if (node->outcome)  
      for (int i = 1; i <= npl; i++) 
	scratch[i] +=  Payoff(node->outcome, i);
  

  if(m_efg->NumChildren(node)>0) {

    Infoset * iset = node->infoset;
    int pl = iset->player->number;
	
    // push down payoffs from outcomes attached to non-terminal nodes 
    for (int child = 1; child <= b_node->children.Length(); child++)
      b_node->children[child]->scratch = scratch;
    
    scratch = (T) 0;
    
    if (iset->IsChanceInfoset())   {
      for (int child = 1; child <= m_efg->NumChildren(node); child++)  {
	CondPayoff(m_efg->Children(node)[child], prob*ChanceProb(iset, child),
		   probs, payoff);
	
	for (int i = 1; i <= npl; i++)
	  scratch[i] += ChanceProb(iset, child) * b_node->children[child]->scratch[i];
      }
    }
    else  {    // player decision node
      
      const gArray<Action *> &acts = m_support.Actions(iset);
      
      for (int act = 1; act <= acts.Length(); act++)  {
	BehavNode *b_child = (BehavNode *)node->GetChild(acts[act])->solution;
	
	T newprob = ActionProb(acts[act]);
	CondPayoff(node->GetChild(acts[act]), prob * newprob, probs, payoff);
	
	for (int i = 1; i <= npl; i++)
	  scratch[i] += newprob * b_child->scratch[i];
	
	payoff(pl, iset->number, acts[act]->GetNumber()) += prob * b_child->scratch[pl];

	//	BehavAction<T> *b_act = (BehavAction<T> *)acts[act]->solution;
	//	b_act->condPayoff += prob * b_child->scratch[pl];
      }
    }
    if(pl>0)
      probs(pl, iset->number) += prob;
  }
}

template <class T> void BehavProfile<T>::CondPayoff(gDPVector<T> &payoff,
						    gPVector<T> &probs) const
{
  if(!IsInstalled())InstallMe();
  ((gVector<T> &) payoff).operator=((T) 0);
  ((gVector<T> &) probs).operator=((T) 0);

  m_root->scratch = (T) 0;
  CondPayoff(m_root->node, (T) 1, probs, payoff);

  for (int pl = 1; pl <= m_efg->NumPlayers(); pl++) {
    EFPlayer *player = m_efg->Players()[pl];
    for (int iset = 1; iset <= player->NumInfosets(); iset++) {
      Infoset *infoset = player->Infosets()[iset];
      for (int act = 1; act <= infoset->NumActions(); act++) {
	// This will protect against divides by zero.
	// It will leave unreached infoset values at zero.
	if (probs(pl, iset) != probs(pl, iset) * (T) 0)
	  payoff(pl, iset, act) /= probs(pl, iset);
      }
    }
  }
}


//--------------------
// NodeRealizProbs
//--------------------

template <class T>
void BehavProfile<T>::NodeRealizProbs(Node *node, T prob) const
{
  ((BehavNode *) node->solution)->realizProb = prob;
  Infoset * iset = node->infoset;

  if (!iset)  return;

  if (iset->IsChanceInfoset())   // chance node
    for (int child = 1; child <= m_efg->NumChildren(node); child++) 
      NodeRealizProbs(node->children[child], prob * ChanceProb(iset, child));

  else {
    const gArray<Action *> &acts = m_support.Actions(iset);
    for (int act = 1; act <= acts.Length(); act++)
	NodeRealizProbs(node->GetChild(acts[act]), prob * ActionProb(acts[act]));
  }
}

template <class T> void BehavProfile<T>::NodeRealizProb(void) const
{
  if(!IsInstalled()) 
    InstallMe();
    NodeRealizProbs(m_root->node, (T) 1);
}

