//#
//# FILE: efg.imp -- Implementation of templated extensive form members
//#
//# $Id$
//#

#include "efg.h"
#include "efplayer.h"
#include "infoset.h"
#include "node.h"
#include "outcome.h"
#include "efgutils.h"

template <class T> void OutcomeVector<T>::Resize(int pl)
{
  T *newdata = new T[pl] - 1;
  int i;
  for (i = 1; i <= pl; newdata[i++] = (T) 0.0);
  for (i = 1; i <= gmin(pl, maxdex); i++)
    newdata[i] = data[i];
  delete [] (data + 1);
  data = newdata;
  maxdex = pl;
}
  
//------------------------------------------------------------------------
//                   TypedNode<T>: Class definition
//------------------------------------------------------------------------

#include "tnode.h"

template <class T> TypedNode<T>::TypedNode(BaseEfg *E, Node *p, int pl) 
  : Node(E, p), scratch(new gVector<T>(pl))   { }

template <class T> TypedNode<T>::~TypedNode()   { delete scratch; }

template <class T> void TypedNode<T>::Resize(int pl)
{ 
  delete scratch;
  scratch = new gVector<T>(pl); 
  for (int i = children.Length(); i; i--)
    ((TypedNode<T> *) children[i])->Resize(pl);
}


//------------------------------------------------------------------------
//      Efg<T>: Constructor, destructors, constructive operators
//------------------------------------------------------------------------

template <class T> Efg<T>::Efg(void)
{ (root = new TypedNode<T>(this, 0, 0))->name = "ROOT"; }

template <class T> void Efg<T>::CopySubtree(Node *n, Node *m)
{
  n->name = m->name;
  if (m->outcome)
    n->outcome = outcomes[m->outcome->number];

  if (m->infoset)   {
    EFPlayer *p;
    if (m->infoset->player->number)
      p = players[m->infoset->player->number];
    else 
      p = chance;

    Infoset *s = p->infosets[m->infoset->number];
    AppendNode(n, s);
    
    n->gameroot = (m->gameroot == m) ? n : n->parent->gameroot;

    for (int i = 1; i <= n->children.Length(); i++)
      CopySubtree(n->children[i], m->children[i]);
  }
}

template <class T> Efg<T>::Efg(const Efg<T> &E)
  : BaseEfg(E)
{
  int i;

  for (i = 1; i <= E.outcomes.Length(); i++)
    outcomes.Append(new OutcomeVector<T>(this, 
					 (OutcomeVector<T> &) *E.outcomes[i]));
  
  for (i = 1; i <= E.chance->infosets.Length(); i++)   {
    ChanceInfoset<T> *t = (ChanceInfoset<T> *) E.chance->infosets[i];
    ChanceInfoset<T> *s = new ChanceInfoset<T>(this, i, chance,
					       t->actions.Length());
    s->name = t->name;
    for (int j = 1; j <= s->probs.Length(); j++)  {
      s->probs[j] = t->probs[j];
      s->actions[j]->name = t->actions[j]->name;
    }
    chance->infosets.Append(s);
  }

  root = new TypedNode<T>(this, 0, E.NumPlayers());
  CopySubtree(root, E.root);

  sortisets = true;
  SortInfosets();
}

//
// This function creates a new Efg out of an Efg, treating it as if
// it were rooted at node 'n'.
// This is designed to be used as a way of extracting subgames, but
// there is no restriction that 'n' be a subgame root.
//
// Use with care, if at all!
//
template <class T> Efg<T>::Efg(const Efg<T> &E, Node *n)
  : BaseEfg(E)
{
  int i;

  assert(n->BelongsTo() == (BaseEfg *) &E);

  for (i = 1; i <= E.outcomes.Length(); i++)
    outcomes.Append(new OutcomeVector<T>(this, 
					 (OutcomeVector<T> &) *E.outcomes[i]));
  
  for (i = 1; i <= E.chance->infosets.Length(); i++)   {
    ChanceInfoset<T> *t = (ChanceInfoset<T> *) E.chance->infosets[i];
    ChanceInfoset<T> *s = new ChanceInfoset<T>(this, i, chance,
					       t->actions.Length());
    s->name = t->name;
    for (int j = 1; j <= s->probs.Length(); j++)  {
      s->probs[j] = t->probs[j];
      s->actions[j]->name = t->actions[j]->name;
    }
    chance->infosets.Append(s);
  }

  root = new TypedNode<T>(this, 0, E.NumPlayers());
  CopySubtree(root, n);
  
  for (int pl = 1; pl <= players.Length(); pl++)   {
    for (i = 1; i <= players[pl]->infosets.Length(); i++)  {
      if (players[pl]->infosets[i]->members.Length() == 0)
	delete players[pl]->infosets.Remove(i--);
    }
  }     

  sortisets = true;
  SortInfosets();
}

template <class T> Efg<T>::~Efg()
{ }

//------------------------------------------------------------------------
//            Efg<T>: Private and protected member functions
//------------------------------------------------------------------------

template <class T> Infoset *Efg<T>::CreateInfoset(int n, EFPlayer *p, int br)
{
  Infoset *s = (p->IsChance()) ? new ChanceInfoset<T>(this, n, p, br) :
               new Infoset(this, n, p, br);
  p->infosets.Append(s);
  return s;
}

template <class T> Node *Efg<T>::CreateNode(Node *parent)
{ return new TypedNode<T>(this, parent, players.Length()); }

template <class T> Infoset *Efg<T>::CreateInfoset(EFPlayer *p, int br)
{
  assert(p && p->BelongsTo() == this);
  return CreateInfoset(p->infosets.Length() + 1, p, br);
}

template <class T> Outcome *Efg<T>::CreateOutcomeByIndex(int index)
{
  OutcomeVector<T> *ret = NewOutcome();
  ret->number = index;
  return ret;
}

//------------------------------------------------------------------------
//                 Efg<T>: Operations on outcomes
//------------------------------------------------------------------------

template <class T> OutcomeVector<T> *Efg<T>::NewOutcome(void)
{
  OutcomeVector<T> *ret = new OutcomeVector<T>(this, outcomes.Length() + 1,
					       players.Length());
  for (int i = 1; i <= players.Length(); (*ret)[i++] = (T) 0);
  outcomes.Append(ret);
  return ret;
}

//------------------------------------------------------------------------
//                   Efg<T>: Payoff computation
//------------------------------------------------------------------------

template <class T>
void Efg<T>::Payoff(Node *n, T prob, const gPVector<int> &profile,
			gVector<T> &payoff) const
{
  if (n->outcome)
    for (int i = 1; i <= players.Length(); i++)
      payoff[i] += prob * ((OutcomeVector<T> &) *n->outcome)[i];
  
  if (n->infoset && n->infoset->player->IsChance())
    for (int i = 1; i <= n->children.Length(); i++)
      Payoff(n->children[i],
	     prob * ((ChanceInfoset<T> &) *n->infoset).probs[i],
	     profile, payoff);
  else if (n->infoset)
    Payoff(n->children[profile(n->infoset->player->number,n->infoset->number)],
	   prob, profile, payoff);
}

template <class T>
void Efg<T>::Payoff(const gPVector<int> &profile, gVector<T> &payoff) const
{
  ((gVector<T> &) payoff).operator=((T) 0);
  Payoff(root, (T) 1.0, profile, payoff);
}

template <class T>
void Efg<T>::Payoff(Node *n, T prob, const gArray<gArray<int> *> &profile,
		    gVector<T> &payoff) const
{
  if (n->outcome)
    for (int i = 1; i <= players.Length(); i++)
      payoff[i] += prob * ((OutcomeVector<T> &) *n->outcome)[i];
  
  if (n->infoset && n->infoset->player->IsChance())
    for (int i = 1; i <= n->children.Length(); i++)
      Payoff(n->children[i],
	     prob * ((ChanceInfoset<T> &) *n->infoset).probs[i],
	     profile, payoff);
  else if (n->infoset)
    Payoff(n->children[(*profile[n->infoset->player->number])[n->infoset->number]],
	   prob, profile, payoff);
}

template <class T>
void Efg<T>::Payoff(const gArray<gArray<int> *> &profile,
		    gVector<T> &payoff) const
{
  ((gVector<T> &) payoff).operator=((T) 0);
  Payoff(root, (T) 1.0, profile, payoff);
}


template <class T> int Efg<T>::ProfileLength(bool trunc) const
{
  int sum = 0;

  for (int i = 1; i <= players.Length(); i++)
    for (int j = 1; j <= players[i]->infosets.Length(); j++)
      sum += players[i]->infosets[j]->actions.Length() - ((trunc) ? 1 : 0);

  return sum;
}

template <class T> gPVector<int> Efg<T>::Dimensionality(bool trunc) const
{
  gArray<int> foo(players.Length());
  for (int i = 1; i <= players.Length(); i++)
    foo[i] = players[i]->infosets.Length();

  gPVector<int> bar(foo);
  for (i = 1; i <= players.Length(); i++)
    for (int j = 1; j <= players[i]->infosets.Length(); j++)
      bar(i, j) = players[i]->infosets[j]->actions.Length() -((trunc) ? 1 : 0);

  return bar;
}  


//-------------------------------------------------------------------------
//                    BehavProfile<T> member functions
//-------------------------------------------------------------------------

template <class T> BehavProfile<T>::BehavProfile(const Efg<T> &EF,
						 bool trunc)
: BaseBehavProfile(EF, trunc), gDPVector<T>(EF.Dimensionality(trunc))
{
  Centroid();
}

template <class T> BehavProfile<T>::BehavProfile(const Efg<T> &EF,
						 const gDPVector<T> &profile)
: BaseBehavProfile(EF, false), gDPVector<T>(profile)
{ }

template <class T> BehavProfile<T>::BehavProfile(const BehavProfile<T> &p)
: BaseBehavProfile(p), gDPVector<T>(p)
{ }

template <class T> BehavProfile<T>::BehavProfile(const EFSupport &s)
: BaseBehavProfile(s.BelongsTo(),false, s), 
  gDPVector<T>(s.Dimensionality(false))
{ 
  Centroid();
}

template <class T> BehavProfile<T>::~BehavProfile()   { }

template <class T>
BehavProfile<T> &BehavProfile<T>::operator=(const BehavProfile<T> &p)
{
  BaseBehavProfile::operator=(p);
  gDPVector<T>::operator=(p);
  return *this;
}

#include <assert.h>

template <class T> bool BehavProfile<T>::IsPure(void) const
{
  // currently not implemented
  assert(0);
  return false;
}

template <class T> bool BehavProfile<T>::IsPure(int pl) const
{
  // currently not implemented
  assert(0);
  return false;
}

template <class T>
const T &BehavProfile<T>::GetValue(Infoset *s, int act) const
{
  return (*this)(s->GetPlayer()->GetNumber(), s->GetNumber(), act);
}

template <class T> gOutput &operator<<(gOutput &f, const BehavProfile<T> &p)
{ p.Dump(f);   return f;  }


//------------------------------------------------------------------------
//                   BehavProfile<T>: Payoff computation
//------------------------------------------------------------------------

#include "gdpvect.h"

template <class T>
void BehavProfile<T>::Payoff(Node *n, T prob, int pl, T &value) const
{
  int anum;

  if (n->outcome)
    value += prob * ((OutcomeVector<T> &) *n->outcome)[pl];
  if (n->children.Length())
    if (IsTruncated())   {
      T p = (T) 0.0;
      for (int i = 1, npl = n->infoset->player->number,
	   iset = n->infoset->number; i < n->children.Length(); i++)  {
	if ( npl == 0 || 
			behavsupport.IsActionInSupport(npl,iset,n->infoset->actions[i]) ) {
	  if (npl != 0)
			anum = behavsupport.OriNumber(npl,iset,n->infoset->actions[i]);
	  p += ((npl) ? (*this)(npl, iset, anum) :
		((ChanceInfoset<T> *) n->infoset)->probs[i]);
	  Payoff(n->children[i],
		 prob * ((npl) ? (*this)(npl, iset, anum) :
			 ((ChanceInfoset<T> *) n->infoset)->probs[i]),
		 pl, value);
	}
      }
      Payoff(n->children[i], prob * ((T)1 - p), pl, value);
    }
    else  {
      for (int i = 1, npl = n->infoset->player->number,
	   iset = n->infoset->number; i <= n->children.Length(); i++){
	if ( npl == 0 || 
			behavsupport.IsActionInSupport(npl,iset,n->infoset->actions[i]) ){
	  if ( npl != 0 )
			anum = behavsupport.OriNumber(npl,iset,n->infoset->actions[i]);
	

	  Payoff(n->children[i],
		 prob * ((npl) ? (*this)(npl, iset, anum) :
			 ((ChanceInfoset<T> *) n->infoset)->probs[i]),
		 pl, value);
	}
      }
    }
}

template <class T>
T BehavProfile<T>::Payoff(int pl) const
{
	behavsupport.ValidSupport();

  T value = (T) 0.0;
  Payoff(E->RootNode(), (T) 1.0, pl, value);
  return value;
}

template <class T>
void BehavProfile<T>::CondPayoff(Node *n, T prob, gPVector<T> &probs,
				 gDPVector<T> &payoff) const
{
  int anum;
  int pl = (n->infoset) ? n->infoset->player->number : -1;
  int iset = (n->infoset) ? n->infoset->number : 0;

  if (n->outcome)
    *((TypedNode<T> *) n)->scratch += (OutcomeVector<T> &) *n->outcome;
  for (int i = 1, nc = n->children.Length(); i <= nc; i++)
    *((TypedNode<T> *) n->children[i])->scratch = *((TypedNode<T> *) n)->scratch;
  
  T cumprob((T) 0), newprob((T) 0);


  for (i = 1; i < nc; i++)   {
    if ( pl == 0 || pl == -1 || 
	behavsupport.IsActionInSupport(pl, iset, n->infoset->actions[i])) {
      if (pl != 0 && pl != -1)
	anum = behavsupport.OriNumber(pl, iset, n->infoset->actions[i]);
      newprob = ((pl) ? (*this)(pl, n->infoset->number, anum) :
		 ((ChanceInfoset<T> *) n->infoset)->probs[i]);
      cumprob += newprob;
      CondPayoff(n->children[i], prob * newprob, probs, payoff);
      
      for (int j = 1; j <= ((TypedNode<T> *) n)->scratch->Length(); j++)
	(*((TypedNode<T> *) n)->scratch)[j] += 
	  newprob * (*((TypedNode<T> *) n->children[i])->scratch)[j];
      if (pl > 0)
	payoff(pl, iset, i) += 
	  prob * (*((TypedNode<T> *) n->children[i])->scratch)[pl];
    }
  }
  if (nc > 0)
    if( pl == 0 || pl == -1 || 
			 behavsupport.IsActionInSupport(pl, iset, n->infoset->actions[i])) {
      if (pl != 0 && pl != -1)
	anum = behavsupport.OriNumber(pl, iset, n->infoset->actions[i]);
      if (IsTruncated())
	newprob = (T) 1.0 - cumprob;
      else
	newprob = ((pl) ? (*this)(pl, n->infoset->number, anum) : 
		   ((ChanceInfoset<T> *) n->infoset)->probs[i]);
      
      CondPayoff(n->children[nc], prob * newprob, probs, payoff);
      
      for (int j = 1; j <= ((TypedNode<T> *) n)->scratch->Length(); j++)
	(*((TypedNode<T> *) n)->scratch)[j] += 
	  newprob * (*((TypedNode<T> *) n->children[i])->scratch)[j];
      if (pl > 0)
	payoff(pl, iset, i) += 
	  prob * (*((TypedNode<T> *) n->children[i])->scratch)[pl];
    }	
  
  if (pl > 0)
    probs(pl, n->infoset->number) += prob;
}


template <class T> 
void BehavProfile<T>::CondPayoff( gDPVector<T> &payoff, 
				 gPVector<T> &probs) const
{
  ((gVector<T> &) payoff).operator=((T) 0);
  ((gVector<T> &) probs).operator=((T) 0);

	behavsupport.ValidSupport();
  *((TypedNode<T> *) E->RootNode())->scratch = (T) 0;
  CondPayoff(E->RootNode(), (T) 1.0, probs, payoff);

  for (int i = 1; i <= E->NumPlayers(); i++)
    for (int j = 1; j <= (E->PlayerList())[i]->infosets.Length(); j++)
      for (int k = 1; k <= (E->PlayerList())[i]->infosets[j]->actions.Length();
	   k++)
	// This will protect against	 divides by zero.
	// It will leave unreached infoset values at zero, which
	// is probably not in general what we want.
	// CondPayoff() was designed for use with Gobit in which case
	// this doesn't happen. (?)   -- Ted
	if (probs(i,j) != (T) 0.0)
	  payoff(i, j, k) /= probs(i, j);
}

template <class T> 
gArray<T> BehavProfile<T>::NodeRealizProbs( void )
{
  int index = 1, maxindex = (NumNodes(*BelongsTo()));

  behavsupport.ValidSupport();
  gArray<T> NRProbs(maxindex);
  for (int ii = 1; ii <= maxindex; ii++) NRProbs[ii] = (T)0;
  NodeRealizProbs( E->RootNode(), (T) 1.0, index, NRProbs);
  return NRProbs;
}

template <class T>
void BehavProfile<T>::NodeRealizProbs(Node *n, T prob, int &index, 
				      gArray<T> &NRProbs)
{

  NRProbs[index] = prob;
  int anum;
  int pl = (n->infoset) ? n->infoset->player->number : -1;

  T cumprob((T) 0), newprob((T) 0);
  int i, nc = n->children.Length();

  for (i = 1; i < nc; i++) {
    if ( pl == 0 || pl == -1 ||
	behavsupport.IsActionInSupport(pl, n->infoset->number , 
				       n->infoset->actions[i])) {  
      if (pl != 0 && pl != -1)
	anum = behavsupport.OriNumber(pl, n->infoset->number,
				      n->infoset->actions[i]);
      
      newprob = ((pl) ? (*this)(pl, n->infoset->number, anum) :
		 ((ChanceInfoset<T> *) n->infoset)->probs[i]);
      cumprob += newprob;
      NodeRealizProbs(n->children[i], prob * newprob, ++index,
		      NRProbs);
    }
    else index += CountNodes(n->children[i]); 
  }

  if (nc > 0) 
    if  ( pl == 0 || pl == -1 ||  
	 behavsupport.IsActionInSupport(pl, n->infoset->number, 
					n->infoset->actions[i])) {
      if (pl !=0 && pl != -1)
	anum = behavsupport.OriNumber(pl, n->infoset->number,
				      n->infoset->actions[i]);
      
      if (IsTruncated())
	newprob = (T) 1.0 - cumprob;
      else newprob = ((pl) ? (*this)(pl, n->infoset->number, anum) :
		      ((ChanceInfoset<T> *) n->infoset)->probs[i]);
      
      NodeRealizProbs(n->children[nc], prob * newprob, ++index,
		      NRProbs);
    }
    else index += CountNodes(n->children[i]);     
}

template <class T> gArray<T> BehavProfile<T>::Beliefs(void)
{
  int index = 1, maxindex = (NumNodes(*BelongsTo()));

  behavsupport.ValidSupport();  
  gArray<T> BProbs(maxindex);
  for (int ii = 1; ii <= maxindex; ii++) BProbs[ii] = 0;
  gDPVector<T> payoff(((Efg<T> *)E)->Dimensionality());
  gPVector<T> probs(((Efg<T> *)E)->Dimensionality().Lengths());
  CondPayoff( payoff, probs);
//  probs.Dump(gout);  gout << '\n';
  Beliefs ( E->RootNode(), (T) 1.0, index, BProbs, probs);
//  BProbs.Dump(gout);  gout << '\n';
  return BProbs;
}

template <class T>
void BehavProfile<T>::Beliefs(Node *n, T prob,
		     int &index, gArray<T> &BProbs, gPVector<T> &gpv)
{
  int anum;
  int pl = (n->infoset) ? n->infoset->player->number : -1;
  int iset = (n->infoset) ? n->infoset->number : 0;
  T cumprob((T) 0), newprob((T) 0);
  int i, nc = n->children.Length();

//  gout << prob << '\n';

  if (pl == 0 || pl == -1)
    BProbs[index] = (T) 1.0;
  else if (gpv(pl, iset) != (T) 0.0)
    BProbs[index] = prob / gpv(pl, iset);
  
  for (i = 1; i < nc; i++) {
    if ( pl == 0 || pl == -1 ||
	behavsupport.IsActionInSupport(pl, n->infoset->number
				       , n->infoset->actions[i])) {
      if (pl !=0 && pl != -1)
	anum = behavsupport.OriNumber(pl, n->infoset->number
				      , n->infoset->actions[i]);
      
      newprob = ((pl) ? (*this)(pl, n->infoset->number, anum) :
		 ((ChanceInfoset<T> *) n->infoset)->probs[i]);
      cumprob += newprob;
      Beliefs(n->children[i], prob * newprob, ++index,
	      BProbs, gpv);
    }
    else index += CountNodes(n->children[i]); 
  }
  if (nc > 0)
    if ( pl == 0 || pl == -1 ||  
	behavsupport.IsActionInSupport(pl, iset, n->infoset->actions[i])) {
    
      if ( pl != 0 && pl != -1 )
	anum = behavsupport.OriNumber(pl, iset, n->infoset->actions[i]);
      
      if (IsTruncated())
	newprob = (T) 1.0 - cumprob;
      else newprob = ((pl) ? (*this)(pl, n->infoset->number, anum) :
		      ((ChanceInfoset<T> *) n->infoset)->probs[i]);
      
      Beliefs(n->children[nc], prob * newprob, ++index,
	      BProbs, gpv);
    }
    else index += CountNodes(n->children[i]); 
}

template <class T>
void BehavProfile<T>::NodeValues(Node *n, T prob, int pl, 
			gArray<T> &valarray, int &index) const
{
  int anum;
	int tindex = index;
	if (n->parent)
		((TypedNode<T> *) n)->nval = ((TypedNode<T> *) n->parent)->nval;
	else
	 ((TypedNode<T> *) n)->nval =  (T)0.0;

  if (n->outcome)
    ((TypedNode<T> *) n)->nval += ((OutcomeVector<T> &) *n->outcome)[pl];

  T value = (T) 0.0;

  if (n->children.Length())
    if (IsTruncated())   {
      T p = (T) 0.0;
      
      for (int i = 1, npl = n->infoset->player->number,
	   iset = n->infoset->number; i < n->children.Length(); i++)  {
	if ( npl == 0 ||
			behavsupport.IsActionInSupport(npl, iset, n->infoset->actions[i])){
	  if ( npl != 0 )
			anum = behavsupport.OriNumber(npl, iset, n->infoset->actions[i]);
	  p += ((npl) ? (*this)(npl, iset, anum) :
		((ChanceInfoset<T> *) n->infoset)->probs[i]);
	  NodeValues(n->children[i],
		     prob * ((npl) ? (*this)(npl, iset, anum) :
			     ((ChanceInfoset<T> *) n->infoset)->probs[i]),
		     pl, valarray, ++index);
	  value += ((npl) ? (*this)(npl, iset, anum) :
		    ((ChanceInfoset<T> *) n->infoset)->probs[i]) *
		      ((TypedNode<T> *) n->children[i])->nval;
	}
	else index += CountNodes(n->children[i]); 
      }
      
      NodeValues(n->children[i], prob * ((T)1 - p), pl, valarray,
		 ++index);
      value += ((T) 1 - p) * ((TypedNode<T> *) n->children[i])->nval;
      
    }
    else  {
      for (int i = 1, npl = n->infoset->player->number,
	   iset = n->infoset->number; i <= n->children.Length(); i++)  {
	if ( npl == 0 || 
	    behavsupport.IsActionInSupport(npl, n->infoset->number,
						 n->infoset->actions[i])) {
	  if (npl != 0)
	    anum = behavsupport.OriNumber(npl, n->infoset->number,
						n->infoset->actions[i]);
	  NodeValues(n->children[i],
		     prob * ((npl) ? (*this)(npl, iset, anum) :
			     ((ChanceInfoset<T> *) n->infoset)->probs[i]),
		     pl, valarray, ++index);
	  value += ((npl) ? (*this)(npl, iset, anum) :
		    ((ChanceInfoset<T> *) n->infoset)->probs[i]) *
		      ((TypedNode<T> *) n->children[i])->nval;
	}
	else index += CountNodes(n->children[i]);
      }
    }
  ((TypedNode<T> *) n)->nval += value;
  valarray[tindex] = ((TypedNode<T> *) n)->nval;
}

template <class T>
gArray<T> BehavProfile<T>::NodeValues(int pl) const
{
  int index = 1, maxindex = NumNodes(*BelongsTo());

	behavsupport.ValidSupport();
  gArray<T> valarray(maxindex); 
  for (int ii=1; ii<=maxindex; ii++) valarray[ii] = (T) 0;
  NodeValues(E->RootNode(), (T) 1.0, pl, valarray, index);
  return valarray;
}

template <class T> void BehavProfile<T>::Centroid(void) const
{
  T center;

  for (int i = 1; i <= dvlen.Length(); i++)
    for (int j = 1; j <= dvlen[i]; j++)  {
      center = ((T) 1 / (T) behavsupport.NumActions(i,j));
      for (int k = 1; k < svlen[dvidx[i] + j - 1]; k++)
	if (behavsupport.IsActionInSupport(i,j,behavsupport.GetPlayer(i).infosets[j]->actions[k]))
	dvptr[i][j][k] = center;
	else dvptr[i][j][k] = 0;
      if (!IsTruncated())  dvptr[i][j][k] = center;
    }
}








