//#
//# FILE: extform.imp -- Implementation of templated extensive form members
//#
//# $Id$
//#

#include "extform.h"
#include "player.h"
#include "infoset.h"
#include "node.h"
#include "outcome.h"

//------------------------------------------------------------------------
//                   TypedNode<T>: Class definition
//------------------------------------------------------------------------

template <class T> class TypedNode : public Node    {
  public:
    gVector<T> *scratch;

    TypedNode(BaseExtForm *E, Node *parent, int pl);
    virtual ~TypedNode();

    void Resize(int pl);
};

template <class T> TypedNode<T>::TypedNode(BaseExtForm *E, Node *p, int pl) 
  : Node(E, p), scratch(new gVector<T>(pl))   { }

template <class T> TypedNode<T>::~TypedNode()   { delete scratch; }

template <class T> void TypedNode<T>::Resize(int pl)
{ 
  delete scratch;
  scratch = new gVector<T>(pl); 
  for (int i = children.Length(); i; i--)
    ((TypedNode<T> *) children[i])->Resize(pl);
}


//------------------------------------------------------------------------
//      ExtForm<T>: Constructor, destructors, constructive operators
//------------------------------------------------------------------------

template <class T> ExtForm<T>::ExtForm(void)
{ root = new TypedNode<T>(this, 0, 0); }

template <class T> ExtForm<T>::~ExtForm()
{ }

//------------------------------------------------------------------------
//            ExtForm<T>: Private and protected member functions
//------------------------------------------------------------------------

template <class T> Infoset *ExtForm<T>::CreateInfoset(int n, Player *p, int br)
{
  Infoset *s = (p->IsChance()) ? new ChanceInfoset<T>(this, n, p, br) :
               new Infoset(this, n, p, br);
  
  n = 1;
  do  {
    s->name = "(" + ToString(p->number) + "," + ToString(n++) + ")";
  }  while (p->IsInfosetDefined(s->name));
  return s;
}

template <class T> Node *ExtForm<T>::CreateNode(Node *parent)
{ return new TypedNode<T>(this, parent, players.Length()); }

//------------------------------------------------------------------------
//                 ExtForm<T>: Operations on outcomes
//------------------------------------------------------------------------

template <class T> OutcomeVector<T> *ExtForm<T>::NewOutcome(void)
{
  OutcomeVector<T> *ret = new OutcomeVector<T>(players.Length());
  outcomes.Append(ret);
  ret->name = "Outcome " + ToString(outcomes.Length());
  return ret;
}

template <class T>
OutcomeVector<T> *ExtForm<T>::GetOutcome(const gString &s) const
{
  if (s == "")   return 0;
  for (int i = 1; i <= outcomes.Length(); i++)
    if (outcomes[i]->GetName() == s)   return (OutcomeVector<T> *) outcomes[i];

  return 0;
}

//------------------------------------------------------------------------
//                   ExtForm<T>: Payoff computation
//------------------------------------------------------------------------

#include "gdpvect.h"

template <class T>
void ExtForm<T>::Payoff(Node *n, T prob, const gPVector<int> &profile,
			gVector<T> &payoff) const
{
  if (n->outcome)
    for (int i = 1; i <= players.Length(); i++)
      payoff[i] += prob * ((OutcomeVector<T> &) *n->outcome)[i];
  
  if (n->infoset && n->infoset->player->IsChance())
    for (int i = 1; i <= n->children.Length(); i++)
      Payoff(n->children[i],
	     prob * ((ChanceInfoset<T> &) *n->infoset).probs[i],
	     profile, payoff);
  else if (n->infoset)
    Payoff(n->children[profile(n->infoset->player->number,n->infoset->number)],
	   prob, profile, payoff);
}

template <class T>
void ExtForm<T>::Payoff(const gPVector<int> &profile, gVector<T> &payoff) const
{
  ((gVector<T> &) payoff).operator=((T) 0);
  Payoff(root, (T) 1.0, profile, payoff);
}

template <class T>
void ExtForm<T>::Payoff(Node *n, T prob, int pl, T &value,
			const BehavProfile<T> &profile) const
{
  if (n->outcome)
    value += prob * ((OutcomeVector<T> &) *n->outcome)[pl];
  if (n->children.Length())
    if (profile.IsTruncated())   {
      T p = (T) 0.0;
      for (int i = 1, npl = n->infoset->player->number,
	   iset = n->infoset->number; i < n->children.Length(); i++)  {
	p += ((npl) ? profile(npl, iset, i) :
	      ((ChanceInfoset<T> *) n->infoset)->probs[i]);
	Payoff(n->children[i],
	       prob * ((npl) ? profile(npl, iset, i) :
		       ((ChanceInfoset<T> *) n->infoset)->probs[i]),
	       pl, value, profile);
      }
      Payoff(n->children[i], prob * ((T)1 - p), pl, value, profile);
    }
    else  {
      for (int i = 1, npl = n->infoset->player->number,
	   iset = n->infoset->number; i <= n->children.Length(); i++)
	Payoff(n->children[i],
	       prob * ((npl) ? profile(npl, iset, i) :
		       ((ChanceInfoset<T> *) n->infoset)->probs[i]),
	       pl, value, profile);
    }
}

template <class T>
T ExtForm<T>::Payoff(int pl, const BehavProfile<T> &profile) const
{
  T value = (T) 0.0;
  Payoff(root, (T) 1.0, pl, value, profile);
  return value;
}

template <class T>
void ExtForm<T>::CondPayoff(Node *n, T prob,
			    const BehavProfile<T> &profile,
			    gPVector<T> &probs,
			    gDPVector<T> &payoff) const
{
  int pl = (n->infoset) ? n->infoset->player->number : -1;
  int iset = (n->infoset) ? n->infoset->number : 0;

  if (n->outcome)
    *((TypedNode<T> *) n)->scratch += (OutcomeVector<T> &) *n->outcome;
  for (int i = 1, nc = n->children.Length(); i <= nc; i++)
    *((TypedNode<T> *) n->children[i])->scratch = *((TypedNode<T> *) n)->scratch;
  
  T cumprob((T) 0), newprob((T) 0);


  for (i = 1; i < nc; i++)   {
    newprob = ((pl) ? profile(pl, n->infoset->number, i) :
	       ((ChanceInfoset<T> *) n->infoset)->probs[i]);
    cumprob += newprob;
    CondPayoff(n->children[i], prob * newprob, profile, probs, payoff);

    for (int j = 1; j <= ((TypedNode<T> *) n)->scratch->Length(); j++)
      (*((TypedNode<T> *) n)->scratch)[j] += newprob * (*((TypedNode<T> *) n->children[i])->scratch)[j];
    if (pl > 0)
      payoff(pl, iset, i) += prob * (*((TypedNode<T> *) n->children[i])->scratch)[pl];
  }
  
  if (nc > 0)  {
    if (profile.IsTruncated())
      newprob = (T) 1.0 - cumprob;
    else
      newprob = ((pl) ? profile(pl, n->infoset->number, i) : 
		 ((ChanceInfoset<T> *) n->infoset)->probs[i]);

    CondPayoff(n->children[nc], prob * newprob, profile, probs, payoff);

    for (int j = 1; j <= ((TypedNode<T> *) n)->scratch->Length(); j++)
      (*((TypedNode<T> *) n)->scratch)[j] += newprob * (*((TypedNode<T> *) n->children[i])->scratch)[j];
    if (pl > 0)
      payoff(pl, iset, i) += prob * (*((TypedNode<T> *) n->children[i])->scratch)[pl];
  }

  if (pl > 0)
    probs(pl, n->infoset->number) += prob;
}


template <class T> void ExtForm<T>::CondPayoff(const BehavProfile<T> &profile,
					       gDPVector<T> &payoff,
					       gPVector<T> &probs) const
{
  ((gVector<T> &) payoff).operator=((T) 0);
  ((gVector<T> &) probs).operator=((T) 0);

  *((TypedNode<T> *) root)->scratch = (T) 0;
  CondPayoff(root, (T) 1.0, profile, probs, payoff);

  for (int i = 1; i <= players.Length(); i++)
    for (int j = 1; j <= players[i]->infosets.Length(); j++)
      for (int k = 1; k <= players[i]->infosets[j]->actions.Length(); k++)
	// Note that bad things happen if probs(i, j, k) == 0
	payoff(i, j, k) /= probs(i, j);
}

template <class T> int ExtForm<T>::ProfileLength(bool trunc) const
{
  int sum = 0;

  for (int i = 1; i <= players.Length(); i++)
    for (int j = 1; j <= players[i]->infosets.Length(); j++)
      sum += players[i]->infosets[j]->actions.Length() - ((trunc) ? 1 : 0);

  return sum;
}

template <class T> gPVector<int> ExtForm<T>::Dimensionality(bool trunc) const
{
  gArray<int> foo(players.Length());
  for (int i = 1; i <= players.Length(); i++)
    foo[i] = players[i]->infosets.Length();

  gPVector<int> bar(foo);
  for (i = 1; i <= players.Length(); i++)
    for (int j = 1; j <= players[i]->infosets.Length(); j++)
      bar(i, j) = players[i]->infosets[j]->actions.Length() -((trunc) ? 1 : 0);

  return bar;
}  

template <class T> void ExtForm<T>::Centroid(BehavProfile<T> &profile) const
{
  T center;

  for (int i = 1; i <= players.Length(); i++)
    for (int j = 1; j <= players[i]->infosets.Length(); j++)  {
      center = ((T) 1 / (T) players[i]->infosets[j]->actions.Length());
      for (int k = 1; k < players[i]->infosets[j]->actions.Length(); k++)
	profile(i, j, k) = center;
      if (!profile.IsTruncated())   profile(i, j, k) = center;
    }
}

//---------------------------------------------------------------------------
//                    BehavProfile<T> member functions
//---------------------------------------------------------------------------

template <class T> BehavProfile<T>::BehavProfile(const ExtForm<T> &EF,
						 bool trunc)
  : BaseBehavProfile(EF, trunc), gDPVector<T>(EF.Dimensionality(trunc))
{
  EF.Centroid(*this);
}

template <class T> BehavProfile<T>::BehavProfile(const ExtForm<T> &EF,
						 const gDPVector<T> &profile)
  : BaseBehavProfile(EF, false), gDPVector<T>(profile)
{ }

template <class T> BehavProfile<T>::~BehavProfile()   { }

template <class T>
BehavProfile<T> &BehavProfile<T>::operator=(const BehavProfile<T> &p)
{
  BaseBehavProfile::operator=(p);
  gDPVector<T>::operator=(p);
  return *this;
}

#include <assert.h>

template <class T> bool BehavProfile<T>::IsPure(void) const
{
  // currently not implemented
  assert(0);
  return false;
}

template <class T> bool BehavProfile<T>::IsPure(int pl) const
{
  // currently not implemented
  assert(0);
  return false;
}

template <class T>
const T &BehavProfile<T>::GetValue(Infoset *s, int act) const
{
  return (*this)(s->GetPlayer()->GetNumber(), s->GetNumber(), act);
}

template <class T> gOutput &operator<<(gOutput &f, const BehavProfile<T> &p)
{ p.Dump(f);   return f;  }

