//
// FILE: polenum.imp -- Polynomial Nash Enum module
//
// $Id$ 
//

#include "gwatch.h"
#include "nfg.h"
#include "nfgiter.h"
#include "nfgciter.h"

#include "polenum.h"
#include "quiksolv.h"

template <class T> class PolEnumModule  {
private:
  T eps;
  const Nfg &NF;
  const NFSupport &support;
  PolEnumParams params;
  gSpace Space;
  term_order Lex;
  int num_vars;
  long count,nevals;
  double time;
  gArray<gNumber> values;
  gList<MixedSolution> solutions;

  bool EqZero(T x) const;
  
  // p_i_j as a gPoly, with last prob in terms of previous probs
  gPoly<T> Prob(int i,int j) const;

  // equation for when player i sets strat1 = strat2
  // with last probs for each player substituted out.  
  gPoly<T> Equation(int i, int strat2, int strat2) const;

  int SaveSolutions(const gList<gVector<gDouble> > &list);
public:
  PolEnumModule(const NFSupport &, const PolEnumParams &p,
	     const gArray<gNumber> &values);
  
  int PolEnum(void);
  
  long NumEvals(void) const;
  double Time(void) const;
  
  PolEnumParams &Parameters(void);

  const gList<MixedSolution> &GetSolutions(void) const;
};

//-------------------------------------------------------------------------
//                    PolEnumModule<T>: Member functions
//-------------------------------------------------------------------------

template <class T>
PolEnumModule<T>::PolEnumModule(const NFSupport &S, const PolEnumParams &p,
			  const gArray<gNumber> &v)
  : NF(S.Game()), support(S), params(p), 
    Space(support.TotalNumStrats()-NF.NumPlayers()), 
    Lex(&Space, &lex), num_vars(support.TotalNumStrats()-NF.NumPlayers()), 
    count(0), nevals(0), values(v)
{ 
//  gEpsilon(eps,12);
}


template <class T> int PolEnumModule<T>::PolEnum(void)
{
  int i,j;

  gWatch watch;
  gPolyList<T> equations(&Space,&Lex);

  // equations for equality of strat j to strat j+1
  for( i=1;i<=NF.NumPlayers();i++) 
    for(j=1;j<support.NumStrats(i);j++) 
      equations+=Equation(i,j,j+1);

  for( i=1;i<=NF.NumPlayers();i++)
    if(support.NumStrats(i)>2) 
      equations+=Prob(i,support.NumStrats(i));

  // set up the rectangle of search
  gVector<T> bottoms(num_vars), tops(num_vars);
  bottoms = (T)0;
  tops = (T)1;
 
  gRectangle<T> Cube(bottoms, tops); 

  // start QuikSolv
  gWatch timer;
  timer.Start();

  QuikSolv<T> quickie(equations);
  if(params.trace>0) {
    (*params.tracefile) << "\nThe equilibrium equations are \n" 
      << quickie.UnderlyingEquations() ;
  }  
  if(quickie.FindRoots(Cube,2000)) {
    if(params.trace>0) {
      (*params.tracefile) << "\nThe system has the following roots in [0,1]^"
	<< num_vars << " :\n" << quickie.RootList();
    }
  }
  else
    if(params.trace>0) {
      (*params.tracefile) << "The system\n" << quickie.UnderlyingEquations()
	<< " could not be resolved by FindRoots.\n";
    }
  timer.Stop();
  if(params.trace>0) {
    (*params.tracefile)  << "The QuikSolv computation of roots took " 
      << (int)timer.Elapsed() << " seconds.\n\n";
  }
  int index = SaveSolutions(quickie.RootList());
  time = watch.Elapsed();
  return index;	 

}

template <class T> int 
PolEnumModule<T>::SaveSolutions(const gList<gVector<gDouble> > &list)
{
  MixedProfile<double> profile(support, values);
  int i,j,k,kk,index;
  double sum;

  for(k=1;k<=list.Length();k++) {
    kk=0;
    for(i=1;i<=NF.NumPlayers();i++) {
      sum=0;
      for(j=1;j<support.NumStrats(i);j++) {
	profile(i,j) = (list[k][j+kk]).ToDouble();
	sum+=profile(i,j);
      }
      profile(i,j) = (double)1.0 - sum;
      kk+=(support.NumStrats(i)-1);
    }
    index = solutions.Append(MixedSolution(profile, NfgAlg_POLENUM));
    if(params.status.Get() != 1) {
      solutions[index].SetEpsilon(0);
      solutions[index].SetIsNash(T_YES);
    }
  }
  return index;
}

template <class T> bool PolEnumModule<T>::EqZero(T x) const
{
  if(x <= eps && x >= -eps) return 1;
  return 0;
}     

template <class T> long PolEnumModule<T>::NumEvals(void) const
{
  return nevals;
}

template <class T> double PolEnumModule<T>::Time(void) const
{
  return time;
}

template <class T> PolEnumParams &PolEnumModule<T>::Parameters(void)
{
  return params;
}

template <class T>
const gList<MixedSolution> &PolEnumModule<T>::GetSolutions(void) const
{
  return solutions;
}

template <class T> gPoly<T> PolEnumModule<T>::Prob(int p, int strat) const
{
  gPoly<T> equation(&Space,&Lex);
  gVector<int> exps(num_vars);
  int i,j,kk = 0;
  
  for(i=1;i<p;i++) 
    kk+=(support.NumStrats(i)-1);

  if(strat<support.NumStrats(p)) {
    exps=0;
    exps[strat+kk]=1;
    exp_vect const_exp(&Space,exps);
    gMono<T> const_term((T)1,const_exp);
    gPoly<T> new_term(&Space,const_term,&Lex);
    equation+=new_term;
  }
  else {
    for(j=1;j<support.NumStrats(p);j++) {
      exps=0;
      exps[j+kk]=1;
      exp_vect exponent(&Space,exps);
      gMono<T> term((T)(-1),exponent);
      gPoly<T> new_term(&Space,term,&Lex);
      equation+=new_term;
    }
    exps=0;
    exp_vect const_exp(&Space,exps);
    gMono<T> const_term((T)1,const_exp);
    gPoly<T> new_term(&Space,const_term,&Lex);
    equation+=new_term;
  }
  return equation;
}

template <class T> gPoly<T> 
PolEnumModule<T>::Equation(int i, int strat1, int strat2) const
{
  StrategyProfile profile(NF);

  NfgContIter A(support), B(support);
  A.Freeze(i);
  A.Set(i, strat1);
  B.Freeze(i);
  B.Set(i, strat2);
  gPoly<T> equation(&Space,&Lex);
  do {
    gPoly<T> term(&Space,(T)1,&Lex);
    profile = A.Profile();
    int k;
    for(k=1;k<=NF.NumPlayers();k++) 
      if(i!=k) 
	term*=Prob(k,support.Find(profile[k]));
    T coeff,ap,bp;
    ap = (T)NF.Payoff(A.GetOutcome(), i).Evaluate(values);
    bp = (T)NF.Payoff(B.GetOutcome(), i).Evaluate(values);
    coeff = ap - bp;
    term*=coeff;
    equation+=term;
    A.NextContingency();
  } while (B.NextContingency());
  return equation;
}


