//
// FILE: polenum.imp -- Polynomial Nash Enum module
//
// $Id$ 
//

#include "gwatch.h"
#include "nfg.h"
#include "nfgiter.h"
#include "nfgciter.h"

#include "polenum.h"
#include "quiksolv.h"

template <class T> class PolEnumModule  {
private:
  T eps;
  const Nfg &NF;
  const NFSupport &support;
  PolEnumParams params;
  int rows,cols,level;
  long count,nevals;
  double time;
  gArray<gNumber> values;
  gList<MixedSolution> solutions;

  bool EqZero(T x) const;
//  gPoly<T> PEquation(int pl, int const_pl, int const_st,
//	    int cur_pl, long index, T prob, T &value) const;
  
public:
  PolEnumModule(const NFSupport &, const PolEnumParams &p,
	     const gArray<gNumber> &values);
  
  int PolEnum(void);
  
  long NumEvals(void) const;
  double Time(void) const;
  
  PolEnumParams &Parameters(void);

//  gPoly<T> Equation(int pl, int player1, int strat1) const;

  const gList<MixedSolution> &GetSolutions(void) const;
};

//-------------------------------------------------------------------------
//                    PolEnumModule<T>: Member functions
//-------------------------------------------------------------------------

template <class T>
PolEnumModule<T>::PolEnumModule(const NFSupport &S, const PolEnumParams &p,
			  const gArray<gNumber> &v)
  : NF(S.Game()), support(S), params(p), rows(S.NumStrats(1)), cols(S.NumStrats(2)), 
    level(0), count(0), nevals(0), values(v)
{ 
  gEpsilon(eps,12);
}


template <class T> int PolEnumModule<T>::PolEnum(void)
{
  int i,j,num = 0;
  for( i=1;i<=NF.NumPlayers();i++)
    num+=(support.NumStrats(i)-1);
  gSpace Space(num);

  ORD_PTR ptr = &lex;
  term_order Lex(&Space, ptr);
  
  gPolyList<T> equations(&Space,&Lex);

  gArray<int> strats(NF.NumPlayers());
  gArray<gNumber> values(NF.Parameters()->Dmnsn());
  for (i = 1; i <= values.Length(); values[i++] = gNumber(0));
  NfgContIter A(support), B(support);

  for( i=1;i<=NF.NumPlayers();i++) {
    for(j=1;j<support.NumStrats(i);j++) {
      gPoly<T> equation(&Space,&Lex);
      gArray<int> exps(num);
      do {
	A.Freeze(i);
	A.Set(i, j);
	B.Freeze(i);
	B.Set(i, j+1);
	strats = A.Get();
	int k,kk = 0;
	for(k=1;k<=NF.NumPlayers();k++) 
	  if(i!=k) {
	    exps[k+kk]=1;
	    kk+=(NF.NumStrats(k)-1);
	  }
	exp_vect exponent(&Space,exps);
	T ap = NF.Payoff(A.GetOutcome(), i).Evaluate(values);
	T bp = NF.Payoff(B.GetOutcome(), i).Evaluate(values);
	T coeff = ap - bp;
	gMono<T> term(coeff,exponent);
	gPoly<T> new_term(&Space,term,&Lex);
	equation+=new_term;
	A.NextContingency();
      } while (B.NextContingency());
      equations+=equation;    
    }
  }

  // Set up the rectangle of search
  gVector<T> bottoms(num); 
  gVector<T> tops(num); 
  for (i = 1; i <= num; i++) {
    bottoms[i] = (T)0; tops[i] = (T)1;
  }

  gRectangle<T> Cube(bottoms, tops); 

  gWatch timer;

  timer.Start();

  QuikSolv<T> quickie(equations);
  gout << "\nThe first test system is\n" 
    << quickie.UnderlyingEquations() ;
    /*
  if (quickie.FindRoots(Cube,22,2000))
    gout << "\nThe first test system is\n" 
	 << quickie.UnderlyingEquations() 
	 << "It has the following roots in [0,1]^num:\n"
	 << quickie.RootList();
  else
    gout << "The system\n" << quickie.UnderlyingEquations()
	 << " could not be resolved by FindRoots.\n";
  */
  timer.Stop();
  gout << "The QuikSolv computation of roots took " 
    << (int)timer.Elapsed() << " seconds.\n\n";
/*
  gSpace Space(4);

  ORD_PTR ptr = &lex;
  term_order Lex(&Space, ptr);
  ptr = &reversedeglex;
  term_order ReverseDegLex(&Space, ptr);
  ptr = &reverselex;
  term_order ReverseLex(&Space, ptr);

  gPoly<gDouble> pw(&Space,&Lex);
  gPoly<gDouble> px(&Space,&Lex);
  gPoly<gDouble> py(&Space,&Lex);
  gPoly<gDouble> pz(&Space,&Lex);

  gString gw; gString gx; gString gy; gString gz;

  gw = "3 + 5n3 - 4n4 + 25n3 * n4";                         pw = gw;
  gx = "4 + 3n3 - 7n4 + 10n3 * n4";                         px = gx;
  gy = "7 - 2n1 + 4n2 + 37n4 + 3n1 * n4 - 5n2 * n4";        py = gy;
  gz = "25 + 4n1 - -2n2 - 3n3 + 6n1 * n3 -2n2 * n3";        pz = gz;

  // Set up the rectangle of search
  gVector<gDouble> bottoms(4); 
  gVector<gDouble> tops(4); 
  for (int i = 1; i <= 4; i++) {
    bottoms[i] = (gDouble)-4; tops[i] = (gDouble)4;
  }

  gRectangle<gDouble> Cube(bottoms, tops); 

  // First System
  gPolyList<gDouble> test_bss1(&Space,&ReverseDegLex);
  test_bss1 += pw;
  test_bss1 += px;
  test_bss1 += py;
  test_bss1 += pz;

  gWatch timer;

  timer.Start();

  QuikSolv<gDouble> quickie(test_bss1);
  if (quickie.FindRoots(Cube,22,2000))
    gout << "\nThe first test system is\n" 
	 << quickie.UnderlyingEquations() 
	 << "It has the following roots in [-4,4]^4:\n"
	 << quickie.RootList();
  else
    gout << "The system\n" << quickie.UnderlyingEquations()
	 << " could not be resolved by FindRoots.\n";

  timer.Stop();
  gout << "The QuikSolv computation of roots took " 
    << (int)timer.Elapsed() << " seconds.\n\n";
  */
  return 1;
}


template <class T> bool PolEnumModule<T>::EqZero(T x) const
{
  if(x <= eps && x >= -eps) return 1;
  return 0;
}     

template <class T> long PolEnumModule<T>::NumEvals(void) const
{
  return nevals;
}

template <class T> double PolEnumModule<T>::Time(void) const
{
  return time;
}

template <class T> PolEnumParams &PolEnumModule<T>::Parameters(void)
{
  return params;
}

template <class T>
const gList<MixedSolution> &PolEnumModule<T>::GetSolutions(void) const
{
  return solutions;
}

/*
template <class T>
gPoly<T> PolEnumModule<T>::Equation(int pl, int player1, int strat1) const
{
  T value = (T) 0;
  PEquation(pl, player1, strat1, 1,
	 support.Strategies(player1)[strat1]->index + 1, (T) 1, value);
  return value;
}

template <class T>
gPoly<T> PolEnumModule<T>::PEquation(int pl, int const_pl, int const_st,
				int cur_pl, long index, T prob, T &value) const
{
  Strategy *s;

  if (cur_pl == const_pl)
    PEquation(pl, const_pl, const_st, cur_pl + 1, index,
	    prob, value);
  else if (cur_pl > N->NumPlayers())  {
    if (N->GetOutcome(index))
      value += prob *
      (*payoffs)(N->GetOutcome(index)->GetNumber(), pl);
  }
  else   {
    for (int j = 1; j <= support.NumStrats(cur_pl); j++)  {
      s = support.Strategies(cur_pl)[j];
      if ((*this)(cur_pl, j) > (T) 0)
	PEquation(pl, const_pl, const_st, cur_pl + 1,
		index + s->index, prob * (*this)(cur_pl, j), value);
    }
  }
}

*/
