//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of multivariate gbtPolyUni type
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include "gpoly.h"
#include "math/gmath.h"

//---------------------------------------------------------------
//                      gbtPolyMulti
//---------------------------------------------------------------

//---------------------------
// Constructors / Destructor
//---------------------------


template <class T> gbtPolyMulti<T>::gbtPolyMulti(const gbtPolySpace* p, const gbtPolyTermOrder* o)
: Space(p), Order(o), Terms()
{
}

template <class T> gbtPolyMulti<T>::gbtPolyMulti(const gbtPolySpace*     p, 
				     const T&          constant,
				     const gbtPolyTermOrder* o)
: Space(p), Order(o), Terms()
{
  if (constant != (T)0)   Terms += gbtMonomial<T>(p,constant);
}

template <class T> gbtPolyMulti<T>::gbtPolyMulti(const gbtPolySpace *p, 
				       const std::string &s,
				       const gbtPolyTermOrder* o)
: Space(p), Order(o), Terms()
{
  *this=s;  // Operator = needs to be fixed
}

template <class T> gbtPolyMulti<T>::gbtPolyMulti(const gbtPolySpace *p, int var_no, int exp,
				       const gbtPolyTermOrder* o)
: Space(p), Order(o), Terms()
{
  Terms += gbtMonomial<T>((T)1,gbtPolyExponent(p,var_no,exp));
}

template <class T> gbtPolyMulti<T>::gbtPolyMulti(const gbtPolySpace* p, 
				       gbtPolyExponent exps, 
				       T coeff,
				       const gbtPolyTermOrder* o)
: Space(p), Order(o), Terms()
{
  Terms += gbtMonomial<T>(coeff,exps);
}

template <class T> gbtPolyMulti<T>::gbtPolyMulti(const gbtPolySpace* p, 
				   const gbtMonomial<T>& mono, 
				   const gbtPolyTermOrder* o)
: Space(p), Order(o), Terms()
{
  Terms += mono;
}

template <class T> gbtPolyMulti<T>::gbtPolyMulti(const gbtPolyMulti<T> &p)
: Space(p.Space), Order(p.Order), Terms(p.Terms)
{
  *this=p; 
}

template <class T> gbtPolyMulti<T>::~gbtPolyMulti()
{
}


//----------------------------------
//        Operators
//----------------------------------

template<class T> gbtPolyMulti<T> &gbtPolyMulti<T>::operator=(const gbtPolyMulti<T> &p)
{
  assert (Space == p.Space && Order == p.Order);

  Terms = p.Terms; return (*this);
}

template <class T> gbtPolyMulti<T>& gbtPolyMulti<T>::operator=(const std::string &Hold)
{
  gbtList<gbtMonomial<T> > nullTerms;
  Terms = nullTerms;           // get rid of old Terms

  charnum = 0;
  int contflag = 1;
  T nega = 1;
  gbtArray<int> PowArray(Space->Dmnsn());
  TheString = Hold + " +";

  charc = TheString[charnum];

  while (charnum <= TheString.length() && contflag){
    switch (charc) {
    case '+' :
    case ' ':
      charnum++;
      charc = TheString[charnum];
      break;
    case '-':
      charnum++;
      charc = TheString[charnum];
      nega = -nega;
      break;
    case 0:  //Null termination of string
      contflag = 0;
      break;
    default:
      String_Term(nega);
      nega = T (1);
      break;
    }
  }

  gbtList<gbtMonomial<T> > newTerms;
  for (int j = 1; j <= Terms.Length(); j++) {
    int low = 0; int high = newTerms.Length() + 1;
    while (low +1 < high) {
      int test = low + (high - low)/2;
      if (1 <= test && test <= newTerms.Length()) 
	assert (Terms[j].ExpV() != newTerms[test].ExpV());
      if ( Order->Less(Terms[j].ExpV(),newTerms[test].ExpV()) )
	high = test;
      else
	low = test;
    }
    newTerms.Insert(Terms[j],high);
  }
  Terms = newTerms;

  return (*this);
}


template<class T> gbtPolyMulti<T> gbtPolyMulti<T>::operator-() const
{
  gbtPolyMulti<T> neg(*this);
  for (int j = 1; j <= Terms.Length(); j++)  neg.Terms[j] = -Terms[j];
  return neg;
}

template<class T> gbtPolyMulti<T> gbtPolyMulti<T>::operator-(const gbtPolyMulti<T> &p) const
{
  gbtPolyMulti<T> dif(*this);
  dif -= p;
  return dif;
}

template<class T> void gbtPolyMulti<T>::operator-=(const gbtPolyMulti<T> &p)
{
  assert(Space == p.Space);

  gbtPolyMulti<T> neg = p;
  for (int i = 1; i <= neg.Terms.Length(); i++)
    neg.Terms[i] = - neg.Terms[i];
  Terms = Adder(Terms,neg.Terms);
}

template<class T> gbtPolyMulti<T> gbtPolyMulti<T>::operator+(const gbtPolyMulti<T> &p) const
{ 
  gbtPolyMulti<T> sum(*this);
  sum += p;
  return sum;
}

template<class T> void gbtPolyMulti<T>::operator+=(const gbtPolyMulti<T> &p)
{
  assert(Space == p.Space);

  Terms = Adder(Terms,p.Terms); 
}

template<class T> void gbtPolyMulti<T>::operator+=(const T& val)
{
  *this += gbtPolyMulti<T>(Space,val,Order);
}

template<class T> gbtPolyMulti<T> gbtPolyMulti<T>::operator*(const gbtPolyMulti<T> &p) const
{
  gbtPolyMulti<T> prod(*this);
  prod *= p;
  return prod;
}

template<class T> gbtPolyMulti<T> gbtPolyMulti<T>::operator/(const T val) const
{
  assert (val != (T)0);
  T one = (T)1;
  return (one/val) * (*this);
}

template<class T> 
gbtPolyMulti<T> gbtPolyMulti<T>::operator/(const gbtPolyMulti<T> & den) const
{
  return DivideByPolynomial(den);
}

template<class T> void gbtPolyMulti<T>::operator*=(const gbtPolyMulti<T> &p)
{ 
  assert(Space == p.Space);

  Terms = Mult(Terms,p.Terms);
}

template<class T> void gbtPolyMulti<T>::operator*=(const T& val)
{ 
  for (int j = 1; j <= Terms.Length(); j++)
    Terms[j] *= val;
}


template<class T> bool gbtPolyMulti<T>::operator==(const gbtPolyMulti<T> &p) const
{
  assert(Space == p.Space && Order == p.Order);

  if (Terms.Length() != p.Terms.Length())           return false;
  if (Terms.Length() == 0 && p.Terms.Length() == 0) return true;

  return (Terms == p.Terms);
}

template<class T> bool gbtPolyMulti<T>::operator!=(const gbtPolyMulti<T> &p) const
{
  return !(*this == p);
}


//----------------------------------
//        Member Functions
//----------------------------------

template <class T> void gbtPolyMulti<T>::String_Term(T nega)
{
  gbtArray<int> PowArray(Dmnsn());
  for (int a=1; a<= Dmnsn(); a++) PowArray[a] = 0;
  T val;
  val = String_Coeff(nega);
  
  while (charc != '+' && charc != '-') {
    if (charc == ' ') { charnum++; charc = TheString[charnum]; }
    else String_VarAndPow(PowArray);
  }

  Terms += gbtMonomial<T>(val, gbtPolyExponent(Space,PowArray));
}

template <class T> int gbtPolyMulti<T>::String_GetPow(void)
{

  std::string Pow = "";
  while (charc == ' '){
    charnum++;
    charc = TheString[charnum];
  }

  while (charc >= '0' && charc <= '9'){
    Pow += charc;
    charnum++;
    charc = TheString[charnum];
  }
  return (atoi(Pow.c_str()));
}

template <class T> void gbtPolyMulti<T>::String_VarAndPow(gbtArray<int> &PowArray)
{
  std::string VarName = "";
  int pow, varname;
  while (charc != '^' && charc != ' '){
    VarName += charc;
    charnum++;
    charc = TheString[charnum];
  }
  if (charc == '^') { 
    charnum++; 
    charc = TheString[charnum]; 
    pow = String_GetPow(); 
  }
  else pow = 1;
  for(varname = 1;varname <= Dmnsn() &&  
      VarName != (Space->VariableWithNumber(varname))->Name;
      varname ++);
  if (varname <= Dmnsn()) PowArray[varname] = pow;
}

// bool function to check the string in &Hold

template <class T> bool gbtPolyMulti<T>::Check_String(const std::string &Hold){
 unsigned int charnum=0;
 int boolflag=0;
// state variables
 int statenumber=0;
 int statevar=0;
 int statesign=1;
//values of the state variables 
 enum number {nonumberbef, numberbef};
 enum var {novarbef, varbef};
 enum sign {nosignbef, signbef}; 
 std::string TheString = Hold;
 char charc = TheString[charnum];
//movement along the string with a switch case
 while (charnum < TheString.length()){
  switch (charc){
   case '0':
   case '1':
   case '2':
   case '3':
   case '4':
   case '5':
   case '6':
   case '7':
   case '8':
   case '9':
    statenumber=numberbef;
    statesign=nosignbef;
    break;
   case 'n':
    if (statenumber==0 && statesign==0) boolflag++;
    if (charnum == (TheString.length()-1)) boolflag++;
    statenumber=number(0);
    statevar=varbef;
    statesign=nosignbef;
    break;
   case '^':
    if (statenumber==0) boolflag++;
    if (statevar==0) boolflag++;
    if (charnum == (TheString.length()-1)) boolflag++;
    statenumber=nonumberbef;
    statevar=novarbef;
    statesign=nosignbef;
    break;
   case '/':
   case '.':
    if (statenumber==0) boolflag++;
    if (charnum == (TheString.length()-1)) boolflag++;
    statenumber=nonumberbef;
    statesign=nosignbef;
    break;
   case '+':
   case '-':
    if (statenumber==0 && charnum!=0) boolflag++;
    if (charnum == (TheString.length()-1)) boolflag++;
    statenumber=nonumberbef;
    statevar=novarbef;
    statesign=signbef;
    break;
   case ' ':
    break;  
   default:
    boolflag++; 
    break;
   }    
 charnum++;
 charc = TheString[charnum];
 }
// return values
 if (boolflag==0) return true;
 else return false;
}
 
template <class T> void gbtPolyMulti<T>::GetChar(void)
{
  charc = TheString[charnum];
}

//----------------------------------
//           Information
//----------------------------------
  
template <class T> const gbtPolySpace* gbtPolyMulti<T>::GetSpace(void) const
{
  return (gbtPolySpace *) Space;  
}
  
template <class T> const gbtPolyTermOrder* gbtPolyMulti<T>::GetOrder(void) const
{
  return (gbtPolyTermOrder *) Order;  
}

template <class T> int gbtPolyMulti<T>::Dmnsn() const
{
  return Space->Dmnsn();
}

template <class T> int gbtPolyMulti<T>::DegreeOfVar(int var_no) const
{
  int max = 0;
  for (int j = 1; j <= Terms.Length(); j++) 
    if (max < Terms[j].ExpV()[var_no]) 
      max = Terms[j].ExpV()[var_no];
  return max;
}

template <class T> bool gbtPolyMulti<T>::IsZero() const
{
  if (Terms.Length() == 0) return true;
  else                     return false;
}

template <class T> int gbtPolyMulti<T>::Degree() const
{
  int max = 0;
  for (int j = 1; j <= Terms.Length(); j++)
    if (Terms[j].TotalDegree() > max)  
      max = Terms[j].TotalDegree();
  return max;
}

template <class T> T gbtPolyMulti<T>::GetCoef(const gbtArray<int> &Powers) const
{
  return GetCoef(gbtPolyExponent(Space,Powers));
}

template <class T> T gbtPolyMulti<T>::GetCoef(const gbtPolyExponent &Powers) const
{
  for (int j = 1; j <= Terms.Length(); j++)
    if (Terms[j].ExpV() == Powers)
      return Terms[j].Coef();
  return (T)0;
}

template <class T> T gbtPolyMulti<T>::NumLeadCoeff() const
{
  assert (Degree() == 0 && Terms.Length() <= 1);

  if (Terms.Length() == 1) return Terms[1].Coef();
  else                     return (T)0;
}

template <class T> bool gbtPolyMulti<T>::IsConstant() const
{
  for (int i = 1; i <= Terms.Length(); i++)
    if (!Terms[i].IsConstant())
      return false;
  return true;
}

template <class T> bool gbtPolyMulti<T>::IsMultiaffine() const
{
  for (int i = 1; i <= Terms.Length(); i++)
    if (!Terms[i].IsMultiaffine())
      return false;
  return true;
}

template <class T> T gbtPolyMulti<T>::Evaluate(const gbtArray<T> &values) const
{
  T answer=0;
  for (int j = 1; j <= Terms.Length(); j++)
    answer += Terms[j].Evaluate(values);
  return answer;
}


template <class T> gbtList<gbtPolyExponent> gbtPolyMulti<T>::ExponentVectors() const
{
  gbtList<gbtPolyExponent> result;
  for (int j = 1; j <= Terms.Length(); j++)
    result += gbtPolyExponent(Terms[j].ExpV());
  return result;
}

template <class T> gbtList<gbtMonomial<T> > gbtPolyMulti<T>::MonomialList() const
{
  return Terms;
}

template <class T> int gbtPolyMulti<T>::No_Monomials() const
{
  //  gout << "Eliminate old code in No_monomials, if successful.\n";

  return Terms.Length();
}

template <class T> int gbtPolyMulti<T>::UniqueActiveVariable() const
{
  gbtList<gbtPolyExponent> ExpVecs = ExponentVectors();
  int activar = 0;
  for (int i = 1; i <= ExpVecs.Length(); i++) {
    for (int j = 1; j <= Dmnsn(); j++) {
      if (ExpVecs[i][j] > 0)
	if (activar > 0 && activar != j) return -1;// multivariate!
	else activar = j;
    }
  }
  return activar;
}

template <class T> 
gbtPolyUni<T> gbtPolyMulti<T>::UnivariateEquivalent(int activar) const
{
  assert(UniqueActiveVariable() >= 0);

  gbtList<T> coefs;

  if (!IsZero()) {
    for (int h = 0; h <= DegreeOfVar(activar); h++) coefs += (T)0;

    for (int i = 1; i <= Terms.Length(); i++)
      coefs[Terms[i].ExpV()[activar] + 1] = Terms[i].Coef();
  }

  return  gbtPolyUni<T>(coefs);
} 

//-------------------------------------------------------------
//           Private Versions of Arithmetic Operators
//-------------------------------------------------------------

template <class T> 
gbtList< gbtMonomial<T> > gbtPolyMulti<T>::Adder(const gbtList<gbtMonomial<T> >& One, 
				   const gbtList<gbtMonomial<T> >& Two) const
{
  if (One.Length() == 0) return Two; if (Two.Length() == 0) return One;

  gbtList<gbtMonomial<T> > answer;

  int i = 1; int j = 1;
  while (i <= One.Length() || j <= Two.Length()) {
    if      (i > One.Length()) { answer += Two[j]; j++; }
    else if (j > Two.Length()) { answer += One[i]; i++; }
    else {
      if      ( Order->Less(   One[i].ExpV(),Two[j].ExpV()) ) 
	{ answer += One[i]; i++; }
      else if ( Order->Greater(One[i].ExpV(),Two[j].ExpV()) ) 
	{ answer += Two[j]; j++; }
      else {
	if (One[i].Coef() + Two[j].Coef() != (T)0) 
	  answer += One[i] + Two[j]; 
	i++; j++; 
      }
    }
  }

  return answer;
}

template <class T> 
gbtList< gbtMonomial<T> > gbtPolyMulti<T>::Mult(const gbtList<gbtMonomial<T> >& One, 
				  const gbtList<gbtMonomial<T> >& Two) const
{
  gbtList<gbtMonomial<T> > answer;

  if (One.Length() == 0 || Two.Length() == 0) return answer;

  int i;
  for (i = 1; i <= One.Length(); i++)
    for (int j = 1; j <= Two.Length(); j++) 
      {
	gbtMonomial<T> next = One[i] * Two[j];

	if (answer.Length() == 0) answer += next;

	else
	  {
	    int bot = 1; int top = answer.Length();
	    if      ( Order->Less   (answer[top].ExpV(),next.ExpV()) ) 
	      answer += next;
	    else if ( Order->Greater(answer[bot].ExpV(),next.ExpV()) )
	      answer.Insert(next,1);
	    else
	      {
		if      ( answer[bot].ExpV() == next.ExpV() ) top = bot;
		else if ( answer[top].ExpV() == next.ExpV() ) bot = top;
		
		while (bot < top - 1)
		  {
		    int test = bot + (top - bot)/2;
		    if ( answer[test].ExpV() == next.ExpV() ) bot = top = test;
		    else
		      if      (Order->Less   (answer[test].ExpV(),next.ExpV()))
			bot = test;
		      else // (Order->Greater(answer[test].ExpV(),next.ExpV()))
			top = test;
		  }

		if (bot == top) answer[bot] += next;
		else            answer.Insert(next,top);
	      }
	  }
      }
  return answer;
}

template<class T> 
gbtPolyMulti<T> gbtPolyMulti<T>::DivideByPolynomial(const gbtPolyMulti<T> &den) const
{
  gbtPolyMulti<T> zero(Space,(T)0,Order);

  assert(den != zero);
  assert(*this == zero || den.Degree() <= Degree());

  // assumes exact divisibility!

  gbtPolyMulti<T> result = zero;

  if (*this == zero) return result;
  else if (den.Degree() == 0)
    { result = *this/den.NumLeadCoeff(); return result; }
  else
    {
      int last = Dmnsn();
      while (den.DegreeOfVar(last) == 0) last--;

      gbtPolyMulti<T> remainder = *this;

      while (remainder != zero)
	{
	  gbtPolyMulti<T> quot = remainder.LeadingCoefficient(last) /
	                     den.LeadingCoefficient(last);
	  gbtPolyMulti<T> power_of_last(Space,last,remainder.DegreeOfVar(last) - 
			                        den.DegreeOfVar(last),Order);
	  result += quot * power_of_last;
	  remainder -= quot * power_of_last * den;
	}
    }
  return result;
} 

template <class T> 
gbtPolyMulti<T> gbtPolyMulti<T>::EvaluateOneVar( int varnumber, T val) const
{
  gbtPolyMulti<T> answer(Space,(T)0,Order);

  for (int i = 1; i <= Terms.Length(); i++) 
    answer += gbtPolyMulti<T>(Space,
	       Terms[i].ExpV().AfterZeroingOutExpOfVariable(varnumber),
	       ((T) Terms[i].Coef())* ((T) pow(val,(long int)Terms[i].ExpV()[varnumber])), 
		       Order);
  return answer;
}

template <class T>
gbtPolyExponent gbtPolyMulti<T>::OrderMaxMonomialDivisibleBy(const gbtPolyTermOrder& order,
					       const gbtPolyExponent& /*expv*/)
{
  //  gout << "You have just tested OrderMaxMonomialDivisibleBy.\n";

  gbtPolyExponent answer(Space); // constructs [0,..,0]
  for (int i = 1; i <= Terms.Length(); i++)
    if ( order.Less(answer,Terms[i].ExpV()) && answer < Terms[i].ExpV() )
      answer = Terms[i].ExpV();
  return answer;
}

template <class T> 
gbtPolyMulti<T> gbtPolyMulti<T>::PartialDerivative(int varnumber) const
{
  gbtPolyMulti<T> newPoly(*this); 

  for (int i = 1; i <= newPoly.Terms.Length(); i++)
    newPoly.Terms[i] = gbtMonomial<T>(newPoly.Terms[i].Coef()
                           * (T)newPoly.Terms[i].ExpV()[varnumber],
	  newPoly.Terms[i].ExpV().AfterDecrementingExpOfVariable(varnumber));

  int j = 1;
  while (j <= newPoly.Terms.Length()) {
    if (newPoly.Terms[j].Coef() == (T)0) newPoly.Terms.Remove(j);
    else j++;
  }

  return (newPoly);
} 

template <class T> 
gbtPolyMulti<T> gbtPolyMulti<T>::LeadingCoefficient(int varnumber) const
{
  gbtPolyMulti<T> newPoly(*this); 

  int degree = DegreeOfVar(varnumber);

  newPoly.Terms = gbtList<gbtMonomial<T> >();
  for (int j = 1; j <= Terms.Length(); j++) {
    if (Terms[j].ExpV()[varnumber] == degree)
      newPoly.Terms += gbtMonomial<T>(Terms[j].Coef(),
	      Terms[j].ExpV().AfterZeroingOutExpOfVariable(varnumber));
  }

  return (newPoly);
}

//--------------------
// Term Order Concepts
//--------------------

template <class T> 
gbtPolyExponent gbtPolyMulti<T>::LeadingPowerProduct(const gbtPolyTermOrder & order) const
{
  assert (Terms.Length() > 0);

  if (*Order == order) // worth a try ...
    return Terms[Terms.Length()].ExpV();
  else {
    int max = 1;
    for (int j = 2; j <= Terms.Length(); j++) {
      if ( order.Less(Terms[max].ExpV(),Terms[j].ExpV()) )
	max = j;
    }
    return Terms[max].ExpV();
  }
}

template <class T> 
T gbtPolyMulti<T>::LeadingCoefficient(const gbtPolyTermOrder & order) const
{
  if (*Order == order) // worth a try ...
    return Terms[Terms.Length()].Coef();
  else {
    int max = 1;
    for (int j = 2; j <= Terms.Length(); j++)
      if ( order.Less(Terms[max].ExpV(),Terms[j].ExpV()) )
	max = j;
    return Terms[max].Coef();
  }
}

template <class T>
gbtPolyMulti<T> gbtPolyMulti<T>::LeadingTerm(const gbtPolyTermOrder & order) const
{
  if (*Order == order) // worth a try ...
    return gbtPolyMulti<T>(Space,Terms[Terms.Length()],Order);
  else {
    int max = 1;
    for (int j = 2; j <= Terms.Length(); j++)
      if ( order.Less(Terms[max].ExpV(),Terms[j].ExpV()) )
	max = j;
    return gbtPolyMulti<T>(Space,Terms[max],Order);
  }
}

template <class T>
void gbtPolyMulti<T>::ToMonic(const gbtPolyTermOrder & order) 
{
  *this = *this/LeadingCoefficient(order);
}

template <class T>
void gbtPolyMulti<T>::ReduceByDivisionAtExpV(const gbtPolyTermOrder & order, 
				      const gbtPolyMulti<T> & divisor, 
				      const gbtPolyExponent & expv)
{
  assert(expv >= divisor.LeadingPowerProduct(order));
  assert(divisor.LeadingCoefficient(order) != (T)0);

  gbtPolyMulti<T> factor(Space, 
		    expv - divisor.LeadingPowerProduct(order), 
		    (T)1,
		    Order);

  *this -= (GetCoef(expv) / divisor.LeadingCoefficient(order)) * 
           factor * divisor;
}

template <class T>
void gbtPolyMulti<T>::ReduceByRepeatedDivision(const gbtPolyTermOrder & order, 
					const gbtPolyMulti<T> & divisor)
{
  gbtPolyExponent zero_exp_vec(Space);

  gbtPolyExponent exps = OrderMaxMonomialDivisibleBy(order,
			       divisor.LeadingPowerProduct(order));

  while (exps != zero_exp_vec) {
    ReduceByDivisionAtExpV(order, divisor, exps);
    exps = OrderMaxMonomialDivisibleBy(order,
      		       divisor.LeadingPowerProduct(order));
  }
}

template <class T>
gbtPolyMulti<T> gbtPolyMulti<T>::S_Polynomial(const gbtPolyTermOrder& order, 
                                const gbtPolyMulti<T>& arg2) const
{
  gbtPolyExponent exp_lcm = 
        (LeadingPowerProduct(order)).LCM(arg2.LeadingPowerProduct(order));
  gbtPolyMulti<T> lcm = gbtPolyMulti<T>(Space,exp_lcm,(T)1,Order);
  gbtPolyMulti<T> L1 = lcm/LeadingTerm(order);
  gbtPolyMulti<T> L2 = lcm/arg2.LeadingTerm(order);

  return L1*(*this) - L2*arg2;
}

template<class T> gbtPolyMulti<T> 
gbtPolyMulti<T>::TranslateOfMono(const gbtMonomial<T>& m, 
				      const gbtVector<T>& new_origin) const
{
  gbtPolyMulti<T> answer(GetSpace(), (T)1, GetOrder());

  for (int i = 1; i <= Dmnsn(); i++) {
    if (m.ExpV()[i] > 0) {
      gbtPolyMulti<T> lt(GetSpace(), i, 1, GetOrder());
      lt += gbtPolyMulti<T>(GetSpace(), new_origin[i], GetOrder());
      for (int j = 1; j <= m.ExpV()[i]; j++)
	answer *= lt;
    }
  }

  answer *= m.Coef();

  return answer;
}

template<class T> gbtPolyMulti<T> 
gbtPolyMulti<T>::TranslateOfPoly(const gbtVector<T>& new_origin) const
{
  gbtPolyMulti<T> answer(GetSpace(), GetOrder());
  for (int i = 1; i <= this->MonomialList().Length(); i++) 
    answer += TranslateOfMono(this->MonomialList()[i],new_origin);
  return answer;
}


template<class T> gbtPolyMulti<T>  
gbtPolyMulti<T>::MonoInNewCoordinates(const gbtMonomial<T>& m, 
					    const gbtSquareMatrix<T>& M) const
{
  assert(M.NumRows() == Dmnsn());

  gbtPolyMulti<T> answer(GetSpace(), (T)1, GetOrder());

  for (int i = 1; i <= Dmnsn(); i++) {
    if (m.ExpV()[i] > 0) {
      gbtPolyMulti<T> linearform(GetSpace(), (T)0, GetOrder());
      for (int j = 1; j <= Dmnsn(); j++) {
	gbtPolyExponent exps(GetSpace(), j, 1);
	linearform += gbtPolyMulti<T>(GetSpace(), exps, M(i,j), GetOrder());
      }
      for (int k = 1; k <= m.ExpV()[i]; k++) answer *= linearform;
    }
  }

  answer *= m.Coef();

  return answer;
}

template<class T> 
gbtPolyMulti<T> gbtPolyMulti<T>::PolyInNewCoordinates(const gbtSquareMatrix<T>& M) const
{
  gbtPolyMulti<T> answer(GetSpace(), GetOrder());
  for (int i = 1; i <= MonomialList().Length(); i++) 
    answer += MonoInNewCoordinates(MonomialList()[i],M);
  return answer;
}

template<class T>
T gbtPolyMulti<T>::MaximalValueOfNonlinearPart(const T& radius)  const
{
  T maxcon = (T)0;
  for (int i = 1; i <= MonomialList().Length(); i++) 
    if (MonomialList()[i].TotalDegree() > 1) 
      maxcon += MonomialList()[i].Coef() * 
	            pow(radius,(long)MonomialList()[i].TotalDegree());

  return maxcon;
}

//---------------------------
//    Global Operators
//---------------------------

template<class T> gbtPolyMulti<T> operator*(const T val, const gbtPolyMulti<T> &poly)
{
  gbtPolyMulti<T> prod(poly);
  prod *= val;
  return prod;
}

template<class T> gbtPolyMulti<T> operator*(const gbtPolyMulti<T> &poly, const T val)
{
  return val * poly;
}

template<class T> gbtPolyMulti<T> operator+(const T val, const gbtPolyMulti<T> &poly)
{
  gbtPolyMulti<T> prod(poly);
  prod += val;
  return prod;
}

template<class T> gbtPolyMulti<T> operator+(const gbtPolyMulti<T> &poly, const T val)
{
  return val + poly;
}

template <class T> void gbtPolyMulti<T>::Output(std::string &t) const
{
  std::string s;
  if (Terms.Length() == 0)  {
    s += "0";
  }
  else {
    for (int j = 1; j <= Terms.Length(); j++) {
      if (Terms[j].Coef() < (T)0) {
	s += "-";
	if (j > 1) s += " ";
      }
      else if (j > 1) s += "+ ";
	
      if ((Terms[j].Coef() != (T)1 && -Terms[j].Coef() != (T)1) ||
	   Terms[j].IsConstant() ) 
	if (Terms[j].Coef() < (T)0) { 
	  s += ToText(-Terms[j].Coef());
	}
	else {                        
	  s += ToText( Terms[j].Coef());
	}
	
	for (int k = 1; k <= Space->Dmnsn(); k++) {
	  int exp = Terms[j].ExpV() [k];
	  if (exp > 0) {
	    s += " ";
	    s += (*Space)[k]->Name;
	    if (exp != 1) {
	      s += '^';
	      s += ToText(exp);
	    }
	  }
	}
	
	if (j < Terms.Length()) s += " ";
      }
  }
  if (s == "") s = " 0";
  
  t += s;
}

template <class T> std::string &operator<<(std::string &p_text, const gbtPolyMulti<T> &p_poly)
{
  p_poly.Output(p_text);
  return p_text;
}

//----------------------------------
//           Conversion
//----------------------------------

template<class T>  
gbtPolyMulti<double> NormalizationOfPoly(const gbtPolyMulti<T>& given) 
{
  gbtList<gbtMonomial<T> > list = given.MonomialList();
  T maxcoeff = (T) 0;
  for (int i =1; i <= list.Length(); i++) {
    maxcoeff = gmax(maxcoeff,fabs((T)list[i].Coef()));
  }

  //  if (maxcoeff < (T) 0.000000001) return given;

  gbtPolyMulti<double>   answer(given.GetSpace(),given.GetOrder());
  for (int i =1; i <= list.Length(); i++) {
    double nextcoef = (double)list[i].Coef()/(double) maxcoeff;
    gbtPolyMulti<double> next(given.GetSpace(),
			list[i].ExpV(),
			nextcoef,
			given.GetOrder());
    answer += next;
  }
  
  return answer;
}

template <class T> std::ostream &operator<<(std::ostream &f, const gbtPolyMulti<T> &p)
{
  std::string s;
  s << p;
  f << s;
  return f;
}
