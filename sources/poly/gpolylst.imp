//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of gbtPolyUni list type
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include "gpolylst.h"

//---------------------------------------------------------------
//                      gbtPolyMultiList
//---------------------------------------------------------------

//---------------------------
// Constructors / Destructors
//---------------------------

template <class T> gbtPolyMultiList<T>::gbtPolyMultiList(const gbtPolySpace* sp, 
					   const gbtPolyTermOrder* to) 
: Space(sp), Order(to), List()
{
}

template<class T> gbtPolyMultiList<T>::gbtPolyMultiList(const gbtPolySpace * sp,
					  const gbtPolyTermOrder* to,
					  const gbtList< gbtPolyMulti<T> *> & plist)
: Space(sp), Order(to), List()
{
  int ii;
  for ( ii = 1; ii <= plist.Length(); ii++) 
    { gbtPolyMulti<T>* temp = new gbtPolyMulti<T>(*plist[ii]); List+=temp; }
}

template<class T> gbtPolyMultiList<T>::gbtPolyMultiList(const gbtPolySpace * sp,
					  const gbtPolyTermOrder* to,
					  const gbtList< gbtPolyMulti<T> > & list)
: Space(sp), Order(to), List()
{
  int ii;
  for ( ii = 1; ii <= list.Length(); ii++) 
    { gbtPolyMulti<T>* temp = new gbtPolyMulti<T>(list[ii]); List+=temp; }
}

template<class T> gbtPolyMultiList<T>::gbtPolyMultiList(const gbtPolyMultiList<T> & lst)
: Space(lst.Space), Order(lst.Order), List()
{
  int ii;
  for ( ii = 1; ii <= lst.List.Length(); ii++) 
    { gbtPolyMulti<T>* temp = new gbtPolyMulti<T>(*(lst.List[ii])); List+=temp; }
}

template<class T> gbtPolyMultiList<T>::~gbtPolyMultiList()
{
  int ii;
  for (ii = 1; ii <= List.Length(); ii++) delete List[ii];
}

//----------------------------------
//        Operators
//----------------------------------

template<class T> 
gbtPolyMultiList<T>& gbtPolyMultiList<T>::operator=(const gbtPolyMultiList<T> & rhs)
{
  assert (Space == rhs.Space && Order == rhs.Order);

  if (*this != rhs) {
    int ii;
    for (ii = List.Length(); ii >= 1; ii--) 
      { delete List[ii]; List.Remove(ii); }

    for (ii = 1; ii <= rhs.List.Length(); ii++) 
      { gbtPolyMulti<T>* temp = new gbtPolyMulti<T>(*(rhs.List[ii])); List+=temp; }

  }
  return *this;
}

template<class T>  
bool gbtPolyMultiList<T>::operator==(const gbtPolyMultiList<T> & rhs) const
{
  if (Space != rhs.Space || Order != rhs.Order) return false;
  if (List.Length() != rhs.List.Length()) return false;
  for (int j = 1; j <= List.Length(); j++)
    if (*List[j] != *(rhs.List[j]))
      return false;
  return true;
}

template<class T>  
bool gbtPolyMultiList<T>::operator!=(const gbtPolyMultiList<T> & rhs) const
{
  return !(*this == rhs);
}

template<class T>  void gbtPolyMultiList<T>::operator+=(const gbtPolyMulti<T> & new_poly)
{
  gbtPolyMulti<T>* temp = new gbtPolyMulti<T>(new_poly);
  List+=temp;
}

template<class T>  void gbtPolyMultiList<T>::operator+=(const gbtPolyMultiList<T> & new_list)
{
  gbtList<gbtPolyMulti<T>*> temp;
  for (int i = 1; i <= new_list.Length(); i++)
    temp += new gbtPolyMulti<T>(new_list[i]);
  List+=temp;
}

// NB - does not copy pointee - see gpolylst.h
template<class T>  void gbtPolyMultiList<T>::operator+=(gbtPolyMulti<T> * new_poly_ptr)
{
  List+=new_poly_ptr;
}

template<class T>  gbtPolyMulti<T> gbtPolyMultiList<T>::operator[](const int index) const
{
  return *(List[index]);
}

//-------------------------------------------------
//        Term Order and Grobner Basis Operations
//-------------------------------------------------

template<class T> bool gbtPolyMultiList<T>::SelfReduction(const int& target,
					          const gbtPolyTermOrder& order)
{  
  assert (!List[target]->IsZero());

  gbtPolyMulti<T> tear_up(*List[target]);
  gbtPolyMulti<T> reduction(Space,(T)0,&order);
  bool     target_was_reduced = false;

  while (!tear_up.IsZero())
    {
      int index = 1;
      while (index <= List.Length() && !tear_up.IsZero()) {
        if (index == target || List[index]->IsZero()) index++;
	else if ( List[index]->LeadingPowerProduct(order) 
	            <= tear_up.LeadingPowerProduct(order) ) {
	  tear_up.ReduceByDivisionAtExpV(order,
					 *List[index],
					 tear_up.LeadingPowerProduct(order));
	  target_was_reduced = true;
	  index = 1;
	}
	if (!tear_up.IsZero()) {
	  reduction+=tear_up.LeadingTerm(order);
	  tear_up-=tear_up.LeadingTerm(order);
	}
      }
    }
  *List[target] = reduction;
  return target_was_reduced;
}

template<class T> gbtPolyMulti<T> gbtPolyMultiList<T>::ReductionOf(const gbtPolyMulti<T>& f,
					           const gbtPolyTermOrder& order) 
                                                                        const
{
  assert (Space == f.GetSpace());

  if (f.IsZero()) {
    gbtPolyMulti<T> zero(Space,(T)0,f.GetOrder());
    return zero;
  }

  gbtPolyMulti<T> tear_up(f);
  gbtPolyMulti<T> reduction(Space,(T)0,f.GetOrder());

  while (!tear_up.IsZero())
    {
      int index = 1;
      while (index <= List.Length() && !tear_up.IsZero()) {
	if (List[index]->IsZero()) index++;
	else if ( List[index]->LeadingPowerProduct(order) 
	            <= tear_up.LeadingPowerProduct(order) ) {

	  tear_up.ReduceByDivisionAtExpV(order,
					 *List[index],
					 tear_up.LeadingPowerProduct(order));
	  index = 1;
	}
	else index++;
      }
      if (!tear_up.IsZero()) {
	reduction+=tear_up.LeadingTerm(order);
	tear_up-=tear_up.LeadingTerm(order);
      }

    }
  return reduction;
}

template<class T> void gbtPolyMultiList<T>::Sort(const gbtPolyTermOrder& order) 
                                       // bubble sort, justified since
                                       // I expect List.Length() < 10
{
  if (List.Length() <= 1) return;
  int ii;
  for (ii = 1; ii < List.Length(); ii++)
    if (!List[ii]->IsZero()) {
      for (int j = ii + 1; j <= List.Length(); j++) {
	bool swap = false;
	if (List[j]->IsZero())
	  swap = true;
	else if ( order.Less(List[j]->LeadingPowerProduct(order),
			    List[ii]->LeadingPowerProduct(order)) ) 
	  swap = true;
	if (swap) {
	  gbtPolyMulti<T>* temp = List[ii];
	  List[ii] = List[j];
	  List[j] = temp;
	}
      }
    }
}

template <class T> 
void gbtPolyMultiList<T>::CriterionTwo(      gbtList<gbtIndexPair>& uncomputed, 
				const gbtList<gbtIndexPair>& computed, 
				const int&               no_polys,
				const gbtPolyTermOrder & order)           const
{
  for (int ell = 1; ell < no_polys; ell++) {
    int spot = uncomputed.Find(gbtIndexPair(ell,no_polys));
    if (spot != 0) {
      int ii;
      for (ii = 1; ii < no_polys; ii++) 
	if (ii != ell && spot != 0) 
	  if ( uncomputed.Contains(gbtIndexPair(ii,ell)) ||
	       computed.Contains(gbtIndexPair(ii,ell)) )
	    if (uncomputed.Contains(gbtIndexPair(ii,no_polys)))  {
	      gbtPolyExponent lpp_i        = List[ii]->  LeadingPowerProduct(order);
	      gbtPolyExponent lpp_ell      = List[ell]->LeadingPowerProduct(order);
	      gbtPolyExponent lpp_no_polys = List[no_polys]->
		LeadingPowerProduct(order);
	      if ( lpp_ell.Divides(lpp_i.LCM(lpp_no_polys)) ) {
		uncomputed.Remove(spot); 
		spot = 0;
	      }
	    }
    }
  }
  int ii;
  for (ii = 1; ii < no_polys; ii++) {
    if ( uncomputed.Contains(gbtIndexPair(ii,no_polys)) )
      for (int j = ii + 1; j < no_polys; j++) {
	int spot = uncomputed.Find(gbtIndexPair(ii,j));
	if ( uncomputed.Contains(gbtIndexPair(j,no_polys)) && (spot != 0) ) {
	      gbtPolyExponent lpp_i        = List[ii]->LeadingPowerProduct(order);
	      gbtPolyExponent lpp_j        = List[j]->LeadingPowerProduct(order);
	      gbtPolyExponent lpp_no_polys = List[no_polys]->
		                               LeadingPowerProduct(order);
	      if ( lpp_no_polys.Divides(lpp_i.LCM(lpp_j)) )
		uncomputed.Remove(spot);
	    }
      }
  }
}

template<class T> void gbtPolyMultiList<T>::Grobnerize(const gbtPolyTermOrder & order)
{
  int index = 1;                 // Remove all 0's from List
  while (index <= List.Length())
    if (List[index]->IsZero())
      { delete List[index]; List.Remove(index); }
    else index++;

  if (List.Length() <= 1) return;
  int ii;
  for (ii = 1; ii <= List.Length(); ii++) List[ii]->ToMonic(order);

  gbtList<gbtIndexPair> uncomputed;
  gbtList<gbtIndexPair>   computed;

  for (ii = 2; ii <= List.Length(); ii++) {
    for (int j = 1; j < ii; j++) 
      uncomputed += gbtIndexPair(j,ii);
    CriterionTwo(uncomputed, computed, ii, order);
  }

  while (uncomputed.Length() > 0) {
    int mindex = 1;
    for (ii = 2; ii <= uncomputed.Length(); ii++)
      if (order.Less(List[uncomputed[ii][1]]->LeadingPowerProduct(order).
	        LCM(List[uncomputed[ii][2]]->LeadingPowerProduct(order)),
	        List[uncomputed[mindex][1]]->LeadingPowerProduct(order).
	        LCM(List[uncomputed[mindex][2]]->LeadingPowerProduct(order))))
	mindex = ii;
    computed += uncomputed[mindex];
    int ii = uncomputed[mindex][1];
    int j = uncomputed[mindex][2];
    uncomputed.Remove(mindex);
    if ( !List[ii]->LeadingPowerProduct(order).
	UsesDifferentVariablesThan(List[j]->LeadingPowerProduct(order)) ) {

      gbtPolyMulti<T> h = ReductionOf(List[ii]->S_Polynomial(order,*(List[j])),order);
      if (!h.IsZero()) {
	h.ToMonic(order);
	gbtPolyMulti<T>* hptr = new gbtPolyMulti<T>(h);
	List += hptr;
	for (int k = 1; k < List.Length(); k++) 
	  uncomputed += gbtIndexPair(k,List.Length());
	CriterionTwo(uncomputed, computed, List.Length(), order);
      }
    }
  }
}

template<class T> 
void gbtPolyMultiList<T>::GrobnerToMinimalGrobner(const gbtPolyTermOrder & order)
{
  if (Length() <= 1) return;

  int i = 1; int j = 2;
  while (j <= Length()) {

    if ( List[i]->LeadingPowerProduct(order) <= 
	List[j]->LeadingPowerProduct(order) )    { 
      delete List[j]; List.Remove(j);
    }

    else if ( List[i]->LeadingPowerProduct(order) >= 
	     List[j]->LeadingPowerProduct(order) )    {
      delete List[i]; List.Remove(i);
      if (i < j-1) j--; else i = 1;
    }

    else  {
      if (i < j-1) i++; else { i = 1; j++; }
    }

  }
}


template<class T> 
void gbtPolyMultiList<T>::MinimalGrobnerToReducedGrobner(const gbtPolyTermOrder & order)
{
  if (Length() <= 1) return;

  int i = 1;
  while (i <= List.Length()) {

    gbtPolyMultiList<T> AllBut_ith(*this);
    delete AllBut_ith.List[i]; AllBut_ith.List.Remove(i);

    gbtPolyMulti<T> h = AllBut_ith.ReductionOf(*List[i],order);
    delete List[i]; List[i] = new gbtPolyMulti<T>(h);

    i++;
  }
}

template<class T> 
gbtPolyMultiList<T>& gbtPolyMultiList<T>::ToSortedReducedGrobner(const gbtPolyTermOrder & order)
{
  Grobnerize(order);
  GrobnerToMinimalGrobner(order);
  MinimalGrobnerToReducedGrobner(order);
  Sort(order);

  return *this;
}

//------------------------------------------
//           New Coordinate Systems
//------------------------------------------

template<class T> gbtPolyMultiList<T> 
gbtPolyMultiList<T>::TranslateOfSystem(const gbtVector<T>& new_origin) const
{
  gbtList<gbtPolyMulti<T> > new_polys;
  for (int i = 1; i <= Length(); i++) {
    new_polys += (*this)[i].TranslateOfPoly(new_origin);
    //    assert (TranslateOfPoly((*this)[i],new_origin) == 
    //	    (*this)[i].TranslateOfPoly(new_origin));
  }
  return gbtPolyMultiList<T>(AmbientSpace(),TermOrder(),new_polys);
}

template<class T> gbtPolyMultiList<T> 
gbtPolyMultiList<T>::SystemInNewCoordinates(const gbtSquareMatrix<T>& M) const
{
  gbtList<gbtPolyMulti<T> > new_polys;
  for (int i = 1; i <= Length(); i++) {
    //    assert ( (*this)[i].PolyInNewCoordinates(M) == 
    //     	     gbtPolyMulti<T>( PolyInNewCoordinates((*this)[i],M) ) );
    new_polys += (*this)[i].PolyInNewCoordinates(M);
  }
  return gbtPolyMultiList<T>(AmbientSpace(),TermOrder(),new_polys);
}

//-----------------------------------
//           Truncations
//-----------------------------------

template<class T> gbtPolyMultiList<T> 
gbtPolyMultiList<T>::InteriorSegment(int first, int last) const
{
  return gbtPolyMultiList<T>(AmbientSpace(), TermOrder(), 
		      List.InteriorSegment(first,last));
}


//----------------------------------
//           Information
//----------------------------------

template <class T> gbtList<gbtPolyMulti<T> > gbtPolyMultiList<T>::UnderlyingbtList(void) const
{
  gbtList<gbtPolyMulti<T> > NewList;
  int ii;
  for (ii = 1; ii <= List.Length(); ii++) 
    NewList += *List[ii];
  return NewList;
}

template <class T> const bool gbtPolyMultiList<T>::IsMultiaffine() const
{
  for (int i = 1; i <= List.Length(); i++)
    if (!(*List[i]).IsMultiaffine()) 
      return false;
  return true;
}
  
template<class T> 
const gbtVector<T> gbtPolyMultiList<T>::Evaluate(const gbtVector<T>& v) const
{
  gbtVector<T> answer(Length());
  int ii;
  for (ii = 1; ii <= List.Length(); ii++)
    answer[ii] = List[ii]->Evaluate(v);

  return answer;
}
  
template<class T> const bool gbtPolyMultiList<T>::IsRoot(const gbtVector<T>& v) const
{
  for (int ii = 1; ii <= List.Length(); ii++) 
    if (List[ii]->Evaluate(v) != (T)0) 
      return false;
  return true;
}
  
template<class T> 
const gbtRectArray<gbtPolyMulti<T>*> gbtPolyMultiList<T>::DerivativeMatrix() const
{
  gbtPolyMulti<T> zero(Space, Order);
  gbtRectArray<gbtPolyMulti<T>*> answer(Length(),Dmnsn());
  int ii;
  for (ii = 1; ii <= Length(); ii++)
    for (int j = 1; j <= Dmnsn(); j++)
      answer(ii,j) = new gbtPolyMulti<T>(UnderlyingbtList()[ii].PartialDerivative(j));
  
  return answer;
}
  
template<class T> 
const gbtPolyMulti<T> gbtPolyMultiList<T>::DetOfDerivativeMatrix() const
{
  assert(List.Length() == Space->Dmnsn());

  int n = List.Length();
  gbtRectArray<gbtPolyMulti<T>*> deriv_matrix = DerivativeMatrix();
  gbtPolyMulti<T> answer(Space, Order);

  gbtPermutationOdometer odo(n);

  while (odo.Turn()) {
    gbtPolyMulti<T> increment(Space, (T)1, Order);
    for (int i = 1; i <= n; i++) increment *= *(deriv_matrix(i, odo[i]));
    increment *= (T)odo.CurrentSign();
    answer += increment;
  }

  return answer;
}
  
template<class T> 
const gbtMatrix<T> gbtPolyMultiList<T>::DerivativeMatrix(const gbtVector<T>& p) const
{
  gbtMatrix<T> answer(Length(),Dmnsn());
  gbtList<gbtPolyMulti<T> > list = UnderlyingbtList();
  int ii;
  for (ii = 1; ii <= Length(); ii++)
    for (int j = 1; j <= Dmnsn(); j++)
      answer(ii,j) = list[ii].PartialDerivative(j).Evaluate(p);
  
  return answer;
}
  
template<class T> const gbtSquareMatrix<T> 
gbtPolyMultiList<T>::SquareDerivativeMatrix(const gbtVector<T>& p) const
{
  assert (Length() == Dmnsn());

  gbtSquareMatrix<T> answer(Length());
  gbtList<gbtPolyMulti<T> > list = UnderlyingbtList();
  int ii;
  for (ii = 1; ii <= Length(); ii++)
    for (int j = 1; j <= Dmnsn(); j++)
      answer(ii,j) = list[ii].PartialDerivative(j).Evaluate(p);
  
  return answer;
}

//----------------------------------
//          Conversion
//----------------------------------

template<class T> 
gbtList<gbtPolyMulti<T> > gbtPolyMultiList<T>::ToList(void) const
{
  gbtList<gbtPolyMulti<T> > newlist;
  int ii;
  for (ii = 1; ii <= List.Length(); ii++) {
    newlist += gbtPolyMulti<T>(*List[ii]);
  }
  return newlist;
}

template<class T> 
gbtList<gbtPolyMulti<double> > gbtPolyMultiList<T>::NormalizedList(void) const
{
  gbtList<gbtPolyMulti<double> > newlist;
  int ii;
  for (ii = 1; ii <= List.Length(); ii++) {
    newlist += gbtPolyMulti<double>(NormalizationOfPoly(*List[ii]));
  }
  return newlist;
}

template <class T> const gbtPolySpace* gbtPolyMultiList<T>::AmbientSpace() const { return Space; }
template <class T> const gbtPolyTermOrder* gbtPolyMultiList<T>::TermOrder()  const { return Order; }
template <class T> const int gbtPolyMultiList<T>::Length() const { return List.Length(); }
template <class T> const int gbtPolyMultiList<T>::Dmnsn() const { return Space->Dmnsn(); }


//----------------------------------
//           Printing
//----------------------------------

template <class T> std::ostream& operator << (std::ostream& output, 
					 const gbtPolyMultiList<T>& x)
{
  for(int t = 1; t <= x.Length(); t++)
    output << t << ":  " << x[t] <<"\n"; 
  return  output;
}
