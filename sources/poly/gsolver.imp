//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of class gbtPolyMultiSolver
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include "gsolver.h"

//---------------------------------------------------------------
//                      gbtPolyMultiSolver
//---------------------------------------------------------------

//---------------------------
// Constructor / Destructor
//---------------------------


template<class T>  gbtPolyMultiSolver<T>::gbtPolyMultiSolver(const gbtPolyTermOrder* Order,
				       const gbtPolyMultiList<T>& Inputs)
: InputList(Inputs), TheIdeal(Order, Inputs)
{
}


template<class T>  gbtPolyMultiSolver<T>::gbtPolyMultiSolver(const gbtPolyMultiSolver<T>& given)
: InputList(given.InputList), TheIdeal(given.TheIdeal)
{
}

template<class T>  gbtPolyMultiSolver<T>::~gbtPolyMultiSolver()
{
}

//---------------------------
//        Utilities
//---------------------------

template <class T> gbtList<gbtPolyMulti<gbtDouble> > gbtPolyMultiSolver<T>::BasisTogDouble() const
{
  gbtList<gbtPolyMulti<gbtDouble> > newlist;
  gbtPolyMultiList<T> oldlist = TheIdeal.CanonicalBasis();
  for (int i = 1; i <= oldlist.Length(); i++) {
    
    newlist += TogDouble(oldlist[i]); 
  }
  return newlist;
}

template <class T> gbtList<gbtVector<gbtDouble> >  
    gbtPolyMultiSolver<T>::ContinuationSolutions(const gbtList<gbtPolyMulti<gbtDouble> >& list,
				      const int dmnsn,
				      const int curvar,
				      const gbtVector<gbtDouble>& knownvals)
{
  gbtList<gbtVector<gbtDouble> > answer;

  if (!list[1].IsZero()) {
    gbtPolyUni<gbtDouble> rootpoly = list[1].UnivariateEquivalent(curvar);

    gInterval<gbtDouble> root_interval((gbtDouble)-10,(gbtDouble)10); //  Ouch!!
    gbtDouble error = (gbtDouble) 0.0001;                           // Ditto!!

//DEBUG
//gout << "About to enter PreciseRoots ... \n";

    gbtList<gbtDouble> rootlist = rootpoly.PreciseRoots(root_interval,error);

//DEBUG
//gout << "Just left PreciseRoots ... \n";


    for (int i = 1; i <= rootlist.Length(); i++) {
      gbtVector<gbtDouble> newvec(knownvals);
      newvec[curvar] = rootlist[i];
      if (curvar == dmnsn) answer +=  newvec;
      else {
	gbtList<gbtPolyMulti<gbtDouble> > newlist;
	for (int j = 2; j <= list.Length(); j++) 
	  newlist += list[j].EvaluateOneVar(curvar,rootlist[i]);
	answer += ContinuationSolutions(newlist,dmnsn,curvar+1,newvec);
      }
    }
  }
  
  else {   // (list[1].IsZero())
    gbtList<gbtPolyMulti<gbtDouble> > newlist;
    for (int j = 2; j <= list.Length(); j++) 
      newlist += list[j];
    answer += ContinuationSolutions(newlist,dmnsn,curvar,knownvals);
  }

  return answer;
}

//---------------------------
//        Information
//---------------------------

template<class T> bool gbtPolyMultiSolver<T>::IsZeroDimensional()
{
  return TheIdeal.ZeroDimensional();
}

/* - Old Implementation of Roots
template<class T> gbtList<gbtVector<gbtDouble> > gbtPolyMultiSolver<T>::Roots()
{
  gbtList<gbtPolyMulti<gbtDouble> >   dlist = BasisTogDouble();

  int dmnsn = InputList.AmbientSpace()->Dmnsn();

  gbtVector<gbtDouble> origin(dmnsn);
  for (int i = 1; i <= dmnsn; i++) origin[i] = (gbtDouble)0; // Needless!

  gbtList<gbtVector<gbtDouble> > rootlist = ContinuationSolutions(dlist,
							    dmnsn,
							    1,
							    origin);
  return rootlist;
}
*/

template<class T> gbtList<gbtVector<gbtDouble> > gbtPolyMultiSolver<T>::Roots()
{
  gbtList<gbtPolyExponent> mon_bss = TheIdeal.MonomialBasis();

  gbtList<gbtPolyUni<T> > UnivariateRootEquations;
  int i;
  for (i = 1; i <= TheIdeal.Dmnsn(); i++) {
    gbtMatrix<T> CoefficientMatrix(mon_bss.Length()+1, mon_bss.Length());
    int j = 0; 
    bool done = false;
    while (!done) {
      gbtPolyExponent x_i_to_j(InputList.AmbientSpace(),i,j);
      gbtPolyMulti<T> power(InputList.AmbientSpace(),x_i_to_j,(T)1,TheIdeal.Order());
      gbtPolyMulti<T> reduced_power = TheIdeal.CanonicalBasis().
	                                ReductionOf(power,*(TheIdeal.Order()));
      for (int k = 1; k <= mon_bss.Length(); k++)
	CoefficientMatrix(j+1,k) = reduced_power.GetCoef(mon_bss[k]);

//DEBUG
//gout << "After updating, j = " << j
//  << "and CoefficientMatrix is\n" << CoefficientMatrix << "\n";

      gbtMatrix<T> SubMatrix(j+1,mon_bss.Length());
      for (int m = 1; m <= j+1; m++)
	for (int n = 1; n <= mon_bss.Length(); n++)
	  SubMatrix(m,n) = CoefficientMatrix(m,n);

//DEBUG
//gout << "Before entering Linear Combination, SubMatrix is\n" 
//  << SubMatrix << "\n";

      gbtLinearCombination<T> Attempt(SubMatrix);
      if (Attempt.LastRowIsSpanned()) {
	gbtPolyUni<T> root_eqn_i(Attempt.LinearDependence());
	UnivariateRootEquations += root_eqn_i;
	done = true;
      }
      j++;
    }
  }

  gbtList<gbtPolyUni<gbtDouble> > ConvertedUnivariateRootEquations;
  for (i = 1; i <= UnivariateRootEquations.Length(); i++)
    ConvertedUnivariateRootEquations += UnivariateRootEquations[i].TogDouble();

  gbtList<gbtVector<gbtDouble> > original;
  gbtList<gbtVector<gbtDouble> > revised;
  gbtVector<gbtDouble> zero(TheIdeal.Dmnsn());
  original += zero;

    gInterval<gbtDouble> root_interval((gbtDouble)-10,(gbtDouble)10); //  Ouch!!
    gbtDouble error = (gbtDouble) 0.0001;                           // Ditto!!

  for (i = 1; i <= TheIdeal.Dmnsn(); i++) {
    gbtList<gbtDouble> roots_of_eqn_i =
      ConvertedUnivariateRootEquations[i].PreciseRoots(root_interval,error);
    for (int j = 1; j <= original.Length(); j++)
      for (int k = 1; k <= roots_of_eqn_i.Length(); k++) {
      gbtVector<gbtDouble> new_vec = original[j];
      new_vec[i] = roots_of_eqn_i[k];
      revised += new_vec;
    }
    original = revised;
    revised.Flush();
  }

  gbtList<gbtVector<gbtDouble> > finished;
  gbtList<gbtPolyMulti<gbtDouble> > gDoublePolys = InputList.ListTogDouble();
  gbtPolyMultiList<gbtDouble> InputListTogDouble(TheIdeal.TheSpace(),
					TheIdeal.Order(),
					gDoublePolys);
  for (i = 1; i <= original.Length(); i++)
    if (InputListTogDouble.IsRoot(original[i])) finished += original[i];
  return finished;
}
