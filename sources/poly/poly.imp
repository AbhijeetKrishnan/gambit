//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of gbtPolyUni class
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include "poly.h"

//--------------------------------------------------------------------------
//                      class: gbtPolyUni<T>
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
//                 constructors and a destructor
//--------------------------------------------------------------------------

template <class T> gbtPolyUni<T>::gbtPolyUni(const gbtPolyUni<T>& x) 
: coeflist(x.coeflist)
{ 
}

template <class T> gbtPolyUni<T>::gbtPolyUni(const T& coeff, const int& deg) 
{ 
  if (coeff != (T)0) {
    for (int i = 0; i < deg; i++)
      coeflist += (T)0;
    coeflist += coeff;
  }
}

template <class T> 
gbtPolyUni<T>::gbtPolyUni(const gbtList<T>& coefficientlist) 
: coeflist(coefficientlist)
{ 
}

template <class T> 
gbtPolyUni<T>::gbtPolyUni(const gbtVector<T>& coefficientvector) 
: coeflist()
{ 
  for (int i = 1; i <= coefficientvector.Length(); i++)
    coeflist += coefficientvector[i];
}

template <class T> gbtPolyUni<T>::gbtPolyUni(const int deg) 
: coeflist()
{ 
  if (deg >= 0) { 
    //gout << "Error is gbtPolyUni int constructor.\n"; 
    exit(1);
  }
}

template <class T> gbtPolyUni<T>::~gbtPolyUni()
{
}

//--------------------------------------------------------------------------
//                             operators
//--------------------------------------------------------------------------

template <class T> gbtPolyUni<T>& 
                   gbtPolyUni<T>::operator= (const gbtPolyUni<T>& y)
{
  if (this!=&y) coeflist = y.coeflist;

  return *this;
}

template <class T> 
bool gbtPolyUni<T>::operator== (const gbtPolyUni<T>& y) const
{
  if (Degree() != y.Degree()) return false;
  else
    for (int i = 0; i <= Degree(); i++)
      if (coeflist[i+1] != y.coeflist[i+1]) return false;
  return true;
}

template <class T> 
bool gbtPolyUni<T>::operator!= (const gbtPolyUni<T>& y) const
{
  return !(*this == y); 
}

template <class T> const T& gbtPolyUni<T>::operator[](const int index) const
{ 
  return coeflist[index+1];
}

template <class T> gbtPolyUni<T> 
                   gbtPolyUni<T>::operator+(const gbtPolyUni<T>& y) const
{
  if      (  Degree() < 0) return gbtPolyUni<T>(y); 
  else if (y.Degree() < 0) return gbtPolyUni<T>(*this);

  int max_degree;

  if (Degree() > y.Degree()) {max_degree =   Degree();}
  else                       {max_degree = y.Degree();}

  gbtPolyUni<T> sum;
  for (int i = 0; i <= max_degree; i++) {
    sum.coeflist += (T)0;
    if (i <=   Degree()) sum.coeflist[i+1] +=   coeflist[i+1];
    if (i <= y.Degree()) sum.coeflist[i+1] += y.coeflist[i+1];
  }

  while ( (sum.coeflist.Length() >= 1) && 
          (sum.coeflist[sum.coeflist.Length()] == (T)0) )
    sum.coeflist.Remove(sum.coeflist.Length());

  return sum;
}

template <class T> gbtPolyUni<T> 
                   gbtPolyUni<T>::operator-(const gbtPolyUni<T>& y) const
{
  return gbtPolyUni<T>(*this+(-y));
}

template <class T> gbtPolyUni<T> 
                   gbtPolyUni<T>::operator*(const gbtPolyUni<T> &y) const
{
  if      (Degree() == -1) return gbtPolyUni<T>(*this); 
  else if (y.Degree() == -1) return gbtPolyUni<T>(y);

  int tot_degree = Degree() + y.Degree();

  gbtPolyUni<T> product;
  for (int t = 0; t <= tot_degree; t++) 
    product.coeflist += (T)0;
  for (int i = 0; i <= Degree(); i++)
    for (int j = 0; j <= y.Degree(); j++) 
      product.coeflist[i+j+1] += (*this)[i] * y[j];

  return product;
}

template <class T> gbtPolyUni<T> 
                   gbtPolyUni<T>::operator/(const gbtPolyUni<T> &q) const
{
  assert(q.Degree() >= 0);

  gbtPolyUni<T> ans;
  gbtPolyUni<T> r = *this;
  while (r.Degree() >= q.Degree()) {
    gbtPolyUni<T> x(r.LeadingCoefficient()/q.LeadingCoefficient(),
		    r.Degree() - q.Degree());
    ans += x;
    r-=q*x;
  }
  return gbtPolyUni<T>(ans);
}

template <class T> gbtPolyUni<T>&
                   gbtPolyUni<T>::operator+=(const gbtPolyUni<T>& y) 
{
  return ((*this)=(*this)+y);
}

template <class T> gbtPolyUni<T>&
                   gbtPolyUni<T>::operator-=(const gbtPolyUni<T>& y)
{
  return ((*this)=(*this)-y);
}

template <class T> gbtPolyUni<T>&
                   gbtPolyUni<T>::operator*=(const gbtPolyUni<T>& y)
{
  return ((*this)=(*this)*y);
}

template <class T> gbtPolyUni<T>&
                   gbtPolyUni<T>::operator/=(const gbtPolyUni<T>& y)
{
  return ((*this)=(*this)/y);
}

template <class T> gbtPolyUni<T> 
                   gbtPolyUni<T>::operator%(const gbtPolyUni<T> &q) const
{
  assert (q.Degree() != -1);

  gbtPolyUni<T> ans;
  gbtPolyUni<T> r = *this;

  while (r.Degree() >= q.Degree())
    {
      gbtPolyUni<T> x(r.LeadingCoefficient()/q.LeadingCoefficient(),
		      r.Degree() - q.Degree());
      ans += x;
      r-=q*x;
    }
  return gbtPolyUni<T>(r);
}

template <class T> gbtPolyUni<T> gbtPolyUni<T>::operator- () const
{
  gbtPolyUni<T> negation;
  for (int i = 0; i <= Degree(); i++)
    negation.coeflist += -coeflist[i+1];

  return negation;
}

template <class T> gbtPolyUni<T> gbtPolyUni<T>::Derivative() const 
{
  if (Degree() <= 0) return gbtPolyUni<T>(-1);

  gbtPolyUni<T> derivative; 
  for (int i = 1; i <= Degree(); i++)
    derivative.coeflist += (T)i * coeflist[i+1];

  return derivative;
}

//--------------------------------------------------------------------------
//                             manipulation
//--------------------------------------------------------------------------

template <class T>  void gbtPolyUni<T>::ToMonic() 
{
  assert (!IsZero());

  T lc = LeadingCoefficient();
  for (int i = 1; i <= coeflist.Length(); i++)
    coeflist[i] /= lc;
}

template<class T>  
gbtPolyUni<gbtDouble>  gbtPolyUni<T>::TogDouble() const
{
  gbtList<gbtDouble> newcoefs;
  for (int i = 1; i <= coeflist.Length(); i++) {
    newcoefs += (gbtDouble)coeflist[i];
  }
  return gbtPolyUni<gbtDouble>(newcoefs);
}

//--------------------------------------------------------------------------
//                              information
//--------------------------------------------------------------------------

template <class T>  bool gbtPolyUni<T>::IsZero() const
{
  if (coeflist.Length() == 0) return true;
  else                        return false;
}

template <class T>  T gbtPolyUni<T>::EvaluationAt(const T& arg) const
{
  T answer;

  if (IsZero()) answer = (T)0;
  else {
    answer = coeflist[Degree() + 1];
    for (int i = Degree(); i >= 1; i--) {
      answer *= arg;
      answer += coeflist[i];
    }
  }

  return answer;
}

template <class T> int gbtPolyUni<T>::Degree() const
{
  return coeflist.Length() - 1;
}

template <class T> T gbtPolyUni<T>::LeadingCoefficient() const
{
  if (Degree() < 0) return (T)0;
  else              return coeflist[Degree() + 1];
}

template <class T> gbtList<T> gbtPolyUni<T>::CoefficientList() const
{
  return coeflist;
}

template <class T> 
gbtPolyUni<T> gbtPolyUni<T>::GcdWith(const gbtPolyUni<T>& that) const
{
  assert( !this->IsZero() && !that.IsZero() );

  gbtPolyUni<T> numerator(*this);
  numerator.ToMonic();
  gbtPolyUni<T> denominator(that);
  denominator.ToMonic();
  gbtPolyUni<T> remainder(numerator % denominator);

  while (!remainder.IsZero()) {
    remainder.ToMonic();
    numerator = denominator; 
    denominator = remainder; 
    remainder = numerator % denominator;
  }

  return denominator;
}

template <class T> 
bool gbtPolyUni<T>::IsQuadratfrei() const
{
  gbtPolyUni<T> Df(Derivative());
  if (Df.Degree() <= 0)             return true;
  if ( GcdWith(Df).Degree() <= 1 ) return true;
  else                              return false;
}

template <class T> 
bool gbtPolyUni<T>::CannotHaveRootsIn(const gInterval<T>& I) const
{
  // get rid of easy cases
  if      (Degree() == -1) return false;
  else if (Degree() ==  0) return true;
  else if (EvaluationAt(I.LowerBound()) == (T)0) return false;

  // generate list of derivatives
  gbtList< gbtPolyUni<T> > derivs;
  derivs += Derivative();
  int i;
  for (i = 2; i <= Degree(); i++) derivs += derivs[i-1].Derivative();

  T val = EvaluationAt(I.LowerBound());
  if (val < (T)0) val = -val;

  // find max |c_0/Degree()*c_i|^(1/i)
  int max_index = 0;
  T base_of_max_index = (T)0;
  T relevant_factorial = (T)1;
  for (i = 1; i <= Degree(); i++) {
    relevant_factorial *= (T)i;
    T ith_coeff = derivs[i].EvaluationAt(I.LowerBound()) / relevant_factorial;
    if (ith_coeff < (T)0) ith_coeff = -ith_coeff;

    if (ith_coeff != (T)0) {
      T base = val/((T)Degree()*ith_coeff);

      if (base_of_max_index == (T)0)
	{ max_index = i; base_of_max_index = base; }
      else if ( pow((T)base,(long)max_index) < pow((T)base_of_max_index,(long)i))
	{ max_index = i; base_of_max_index = base; }
    }

  }
                             assert(base_of_max_index != (T)0);

  if ( (T)pow((T)I.Length(),(long)max_index) < (T)base_of_max_index ) 
    return true;
  else 
    return false;
}


template <class T> gbtList< gInterval<T> >
gbtPolyUni<T>::RootSubintervals(const gInterval<T>& I) const
{ assert ( Degree() >= 0 && IsQuadratfrei() );

  gbtPolyUni<T> Df = Derivative();

  gbtList< gInterval<T> > answer;

  gbtList< gInterval<T> > to_be_processed; to_be_processed += I;
  while (to_be_processed.Length() > 0) {

    gInterval<T> in_process = to_be_processed.Remove(to_be_processed.Length());

    if      ( EvaluationAt(in_process.LowerBound()) == (T)0 ) {

      if (Df.CannotHaveRootsIn(in_process)) {
	answer += in_process;
      }
      else {	
	to_be_processed += in_process.RightHalf();
	to_be_processed += in_process.LeftHalf();
      }
    }

    else if ( EvaluationAt(in_process.UpperBound()) == (T)0 ) {
      if (Df.CannotHaveRootsIn(in_process))  {
	if (in_process.UpperBound() == I.UpperBound()) {
	  answer += in_process;
	}
      }
      else {
	to_be_processed += in_process.RightHalf();
	to_be_processed += in_process.LeftHalf();
      }
    }

    else if (!CannotHaveRootsIn(in_process)) {
      if (Df.CannotHaveRootsIn(in_process)) {
	if ( (EvaluationAt(in_process.LowerBound()) < (T)0 &&
	      EvaluationAt(in_process.UpperBound()) > (T)0) ||
	     (EvaluationAt(in_process.LowerBound()) > (T)0 &&
	      EvaluationAt(in_process.UpperBound()) < (T)0) ) {
	  answer += in_process;
	}
      }
      else {
	to_be_processed += in_process.RightHalf();
	to_be_processed += in_process.LeftHalf();
      }
    }

  }

  return answer;
}

template <class T> gInterval<T>
gbtPolyUni<T>::NeighborhoodOfRoot(const gInterval<T>& I, T& error) const
{
  gbtList< gInterval<T> > intrvls; intrvls += I;
  while (intrvls[intrvls.Length()].Length() >= error) {
    if      (EvaluationAt(intrvls[intrvls.Length()].LowerBound()) == (T)0) 
      intrvls += gInterval<T>(intrvls[intrvls.Length()].LowerBound(),
			      intrvls[intrvls.Length()].LowerBound());

    else if (EvaluationAt(intrvls[intrvls.Length()].UpperBound()) == (T)0) 
      intrvls += gInterval<T>(intrvls[intrvls.Length()].UpperBound(),
			      intrvls[intrvls.Length()].UpperBound());

    else if ( (EvaluationAt(intrvls[intrvls.Length()].LowerBound()) >= (T)0 &&
	       EvaluationAt(intrvls[intrvls.Length()].Midpoint  ()) <= (T)0)   ||
              (EvaluationAt(intrvls[intrvls.Length()].LowerBound()) <= (T)0 &&
	       EvaluationAt(intrvls[intrvls.Length()].Midpoint  ()) >= (T)0) )
         intrvls += intrvls[intrvls.Length()].LeftHalf(); 

    else intrvls += intrvls[intrvls.Length()].RightHalf(); 
  }

  return intrvls[intrvls.Length()];

  // It is, perhaps, possible to speed this up, at least for double's
  // by introducing Newton's method.
}

template <class T> gbtList< gInterval<T> >
gbtPolyUni<T>::PreciseRootIntervals(const gInterval<T>& I, T& error) const
{
  gbtList< gInterval<T> > coarse = RootSubintervals(I);
  gbtList< gInterval<T> > fine;

  for (int i = 1; i <= coarse.Length(); i++) 
    fine += NeighborhoodOfRoot(coarse[i],error);

  return fine;
}

template <class T> gbtList<T>
gbtPolyUni<T>::PreciseRoots(const gInterval<T>& I, T& error) const
{
  gbtList<T> roots;

  gbtPolyUni<T> p(*this), factor(*this);

  while ( p.Degree() > 0 ) {

    int depth = 1;
    gbtPolyUni<T> probe(p.Derivative());
    gbtPolyUni<T> current_gcd( p.GcdWith(probe) );
    while ( current_gcd.Degree() > 0 ) { 
      depth++; 
      factor = current_gcd; 
      probe = probe.Derivative(); 
      current_gcd = current_gcd.GcdWith(probe);
    }

    for (int i = 1; i <= depth; i++) p = p/factor;
    gbtList< gInterval<T> > fine = factor.PreciseRootIntervals(I,error);
    for (int j = 1; j <= fine.Length(); j++) {
      T approx = fine[j].LowerBound();
      for (int h = 1; h <= 2; h++) {
	approx -= factor.EvaluationAt(approx)
                          /
	  factor.Derivative().EvaluationAt(approx); // Newton's Method
      }
      roots += approx;
    }
    factor = p;
  }

  return roots;
}

//--------------------------------------------------------------------------
//                                printing
//--------------------------------------------------------------------------

template <class T> void gbtPolyUni<T>::Output(gbtOutput &output) const
{
  if (Degree() < 0) output << "0";
  else {
    for (int t = 0; t <= Degree(); t++)
      if (coeflist[t+1] != (T)0) { 
	output << coeflist[t+1]; 
	if (t >= 1) output << "x";
	if (t >= 2) output << "^" << t;
	if (t < Degree()) output << " + "; }
  }
}

template <class T> gbtOutput &operator<<(gbtOutput &p_file,
				       const gbtPolyUni<T> &p_poly)
{
  p_poly.Output(p_file);
  return p_file;
}

//--------------------------------------------------------------------------
//                      class: gbtPolyComplex
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
//                 constructors and a destructor
//--------------------------------------------------------------------------

gbtPolyComplex::gbtPolyComplex(const gbtPolyComplex& x) 
: coeflist(x.coeflist)
{ 
}

gbtPolyComplex::gbtPolyComplex(const gbtComplex& coeff, const int& deg) 
{ 
  if (coeff != (gbtComplex)0) {
    for (int i = 0; i < deg; i++)
      coeflist += (gbtComplex)0;
    coeflist += coeff;
  }
}

 
gbtPolyComplex::gbtPolyComplex(const gbtList<gbtComplex>& coefficientlist) 
: coeflist(coefficientlist)
{ 
}

gbtPolyComplex::gbtPolyComplex(const int deg) 
: coeflist()
{ 
  if (deg >= 0) { 
    //gout << "Error is gbtPolyComplex int constructor.\n"; 
    exit(1);
  }
}

gbtPolyComplex::~gbtPolyComplex()
{
}

//--------------------------------------------------------------------------
//                             operators
//--------------------------------------------------------------------------

gbtPolyComplex& gbtPolyComplex::operator= (const gbtPolyComplex& y)
{
  if (this!=&y) coeflist = y.coeflist;

  return *this;
}
 
bool gbtPolyComplex::operator== (const gbtPolyComplex& y) const
{
  if (Degree() != y.Degree()) return false;
  else
    for (int i = 0; i <= Degree(); i++)
      if (coeflist[i+1] != y.coeflist[i+1]) return false;
  return true;
}
 
bool gbtPolyComplex::operator!= (const gbtPolyComplex& y) const
{
  return !(*this == y); 
}

const gbtComplex& gbtPolyComplex::operator[](const int index) const
{ 
  return coeflist[index+1];
}

gbtPolyComplex gbtPolyComplex::operator+(const gbtPolyComplex& y) const
{
  if      (  Degree() < 0) return gbtPolyComplex(y); 
  else if (y.Degree() < 0) return gbtPolyComplex(*this);

  int max_degree;

  if (Degree() > y.Degree()) {max_degree =   Degree();}
  else                       {max_degree = y.Degree();}

  gbtPolyComplex sum;
  for (int i = 0; i <= max_degree; i++) {
    sum.coeflist += (gbtComplex)0;
    if (i <=   Degree()) sum.coeflist[i+1] +=   coeflist[i+1];
    if (i <= y.Degree()) sum.coeflist[i+1] += y.coeflist[i+1];
  }

  while ( (sum.coeflist.Length() >= 1) && 
          (sum.coeflist[sum.coeflist.Length()] == (gbtComplex)0) )
    sum.coeflist.Remove(sum.coeflist.Length());

  return sum;
}

gbtPolyComplex gbtPolyComplex::operator-(const gbtPolyComplex& y) const
{
  return gbtPolyComplex(*this+(-y));
}

gbtPolyComplex gbtPolyComplex::operator*(const gbtPolyComplex &y) const
{
  if      (Degree() == -1) return gbtPolyComplex(*this); 
  else if (y.Degree() == -1) return gbtPolyComplex(y);

  int tot_degree = Degree() + y.Degree();

  gbtPolyComplex product;
  for (int t = 0; t <= tot_degree; t++) 
    product.coeflist += (gbtComplex)0;
  for (int i = 0; i <= Degree(); i++)
    for (int j = 0; j <= y.Degree(); j++) 
      product.coeflist[i+j+1] += (*this)[i] * y[j];

  return product;
}

gbtPolyComplex gbtPolyComplex::operator/(const gbtPolyComplex &q) const
{
  assert(q.Degree() >= 0);

  gbtPolyComplex ans;
  gbtPolyComplex r = *this;
  while (r.Degree() >= q.Degree()) {
    gbtPolyComplex x(r.LeadingCoefficient()/q.LeadingCoefficient(),
		    r.Degree() - q.Degree());
    ans += x;
    r-=q*x;
  }
  return gbtPolyComplex(ans);
}

gbtPolyComplex& gbtPolyComplex::operator+=(const gbtPolyComplex& y) 
{
  return ((*this)=(*this)+y);
}

gbtPolyComplex& gbtPolyComplex::operator-=(const gbtPolyComplex& y)
{
  return ((*this)=(*this)-y);
}

gbtPolyComplex& gbtPolyComplex::operator*=(const gbtPolyComplex& y)
{
  return ((*this)=(*this)*y);
}

gbtPolyComplex& gbtPolyComplex::operator/=(const gbtPolyComplex& y)
{
  return ((*this)=(*this)/y);
}

gbtPolyComplex gbtPolyComplex::operator%(const gbtPolyComplex &q) const
{
  assert (q.Degree() != -1);

  gbtPolyComplex ans;
  gbtPolyComplex r = *this;

  while (r.Degree() >= q.Degree())
    {
      gbtPolyComplex x(r.LeadingCoefficient()/q.LeadingCoefficient(),
		      r.Degree() - q.Degree());
      ans += x;
      r-=q*x;
    }
  return gbtPolyComplex(r);
}

gbtPolyComplex gbtPolyComplex::operator- () const
{
  gbtPolyComplex negation;
  for (int i = 0; i <= Degree(); i++)
    negation.coeflist += -coeflist[i+1];

  return negation;
}

gbtPolyComplex gbtPolyComplex::Derivative() const 
{
  if (Degree() <= 0) return gbtPolyComplex(-1);

  gbtPolyComplex derivative; 
  for (int i = 1; i <= Degree(); i++)
    derivative.coeflist += (gbtComplex)i * coeflist[i+1];

  return derivative;
}

//--------------------------------------------------------------------------
//                             manipulation
//--------------------------------------------------------------------------

void gbtPolyComplex::ToMonic() 
{
  assert (!IsZero());

  gbtComplex lc = LeadingCoefficient();
  for (int i = 1; i <= coeflist.Length(); i++)
    coeflist[i] /= lc;
}


//--------------------------------------------------------------------------
//                              information
//--------------------------------------------------------------------------

bool gbtPolyComplex::IsZero() const
{
  if (coeflist.Length() == 0) return true;
  else                        return false;
}

gbtComplex gbtPolyComplex::EvaluationAt(const gbtComplex& arg) const
{
  gbtComplex answer;

  for (int i = 0; i <= Degree(); i++) {
    gbtComplex monom_val = (gbtComplex)1;
    for (int j = 1; j <= i; j++) monom_val *= arg;
    answer += coeflist[i+1] * monom_val;
  }

  return answer;
}

int gbtPolyComplex::Degree() const
{
  return coeflist.Length() - 1;
}

gbtComplex gbtPolyComplex::LeadingCoefficient() const
{
  if (Degree() < 0) return (gbtComplex)0;
  else              return coeflist[Degree() + 1];
}

 
gbtPolyComplex gbtPolyComplex::GcdWith(const gbtPolyComplex& that) const
{
  assert( !this->IsZero() && !that.IsZero() );

  gbtPolyComplex numerator(*this);
  numerator.ToMonic();
  gbtPolyComplex denominator(that);
  denominator.ToMonic();
  gbtPolyComplex remainder(numerator % denominator);

  while (!remainder.IsZero()) {
    remainder.ToMonic();
    numerator = denominator; 
    denominator = remainder; 
    remainder = numerator % denominator;
  }

  return denominator;
}

 
bool gbtPolyComplex::IsQuadratfrei() const
{
  gbtPolyComplex Df(Derivative());
  if (Df.Degree() <= 0)             return true;
  if ( GcdWith(Df).Degree() <= 1 ) return true;
  else                              return false;
}


gbtList<gbtComplex> gbtPolyComplex::Roots() const 
{
  assert (!IsZero());

  gbtList<gbtComplex> answer;

  if (Degree() == 0) 
    return answer;

  gbtPolyComplex deriv(Derivative());

  gbtComplex guess(1.3,0.314159);

  while (fabs(EvaluationAt(guess)) > 0.00001) {
    gbtComplex diff = EvaluationAt(guess)/deriv.EvaluationAt(guess);
    int count = 0;
    bool done = false;
    while (!done) {
	if ( count < 10 &&
	    fabs(EvaluationAt(guess - diff)) >= fabs(EvaluationAt(guess)) ) {
	  diff /= gbtComplex(4.0,0.0);
	  count++;
	}
	else done = true;
      }
    if (count == 10) { 
      //      gout << "Failure in gbtPolyComplex::Roots().\n";
      exit(1);
    }

    guess -= diff;
  }

  answer += guess;

  gbtList<gbtComplex> lin_form_coeffs;
  lin_form_coeffs += guess;
  lin_form_coeffs += gbtComplex(-1.0,0.0);
  gbtPolyComplex linear_form(lin_form_coeffs);
  gbtPolyComplex quotient = *this/linear_form;
  answer += quotient.Roots();

  for (int i = 1; i <= answer.Length(); i++) { // "Polish" each root twice
    answer[i] -= EvaluationAt(answer[i])/deriv.EvaluationAt(answer[i]);
    answer[i] -= EvaluationAt(answer[i])/deriv.EvaluationAt(answer[i]);
  }

  return answer;
}

//--------------------------------------------------------------------------
//                                printing
//--------------------------------------------------------------------------

gbtOutput& operator << (gbtOutput& output, const gbtPolyComplex& x)
{
  if (x.Degree() < 0) output << "0";
  else {
    for (int t = 0; t <= x.Degree(); t++)
      if (x.coeflist[t+1] != (gbtComplex)0) { 
	output << x.coeflist[t+1]; 
	if (t >= 1) output << "x";
	if (t >= 2) output << "^" << t;
	if (t < x.Degree()) output << " + "; }
  }
  return output;
}
