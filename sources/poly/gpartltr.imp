//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of gbtPolyPartialTree
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include "gpartltr.h"

//---------------------------------------------------------------
//                   class: gbtPolyPartialTree
//---------------------------------------------------------------

//---------------------------
// Constructors / Destructors
//---------------------------

template <class T> gbtPolyPartialTree<T>::gbtPolyPartialTree(const gbtPolyMulti<T>& given) 
: PartialTree(given)
{
  TreeOfPartialsRECURSIVE(PartialTree, PartialTree.RootNode());  
}

//-------------------------------------------------------------------------
// Recursive generation of all partial derivatives of the root gbtPolyUni
//-------------------------------------------------------------------------

template <class T>
void gbtPolyPartialTree<T>::TreeOfPartialsRECURSIVE(gbtTree<gbtPolyMulti<T> >& t,
					  gbtTreeNode<gbtPolyMulti<T> >* n) const
{
  if (n->GetData().Degree() >= 1) {
    for (int i = 1; i <= n->GetData().Dmnsn(); i++) {
      t.InsertAt(n->GetData().PartialDerivative(i),n);
      TreeOfPartialsRECURSIVE(t,n->GetYoungest());
    }
  }
}

template<class T> gbtPolyPartialTree<T>::gbtPolyPartialTree(const gbtPolyPartialTree& qs)
: PartialTree(qs.PartialTree)
{
}

template<class T> gbtPolyPartialTree<T>::~gbtPolyPartialTree()
{
}

template <class T> 
T gbtPolyPartialTree<T>::ValueOfPartialOfRootPoly(const int& coord, 
					      const gbtVector<T>& p) const
{
  if (RootPoly().Degree() <= 0) return (T)0;
  else {
    int i = 1; 
    gbtTreeNode<gbtPolyMulti<T> >* node = RootNode()->GetEldest();
    while (i < coord) {
      i++;
      node = node->GetNext();
    }
    T answer = node->GetData().Evaluate(p);
    return answer;
  }
}

template <class T>
gbtVector<T> gbtPolyPartialTree<T>::VectorOfPartials(const gbtVector<T>& point) const
{
  gbtVector<T> answer(Dmnsn());
  for (int i = 1; i <= Dmnsn(); i++)
    answer[i] = ValueOfPartialOfRootPoly(i,point);
  return answer;
}

template <class T> T
gbtPolyPartialTree<T>::MaximalNonconstantContributionRECURSIVE(
					     const gbtTreeNode<gbtPolyMulti<T> >* n,
					     const gbtVector<T>& p,
					     const gbtVector<T>& halvesoflengths,
					     gbtVector<int>& wrtos) const
{
  T answer = (T)0;

  if (n->GetEldest() != NULL) {
    gbtList<gbtTreeNode<gbtPolyMulti<T> >*> children = PartialTree.Children(n);
    for (int i = 1; i <= children.Length(); i++) {
      wrtos[i]++;

      T increment = children[i]->GetData().Evaluate(p);
      if (increment < (T)0) increment = -increment;
     	  
      for (int j = 1; j <= p.Length(); j++) 
	for (int k = 1; k <= wrtos[j]; k++) {
	  increment *= halvesoflengths[j];
	  increment /= (T)k;
	}

      answer += increment;

      answer += MaximalNonconstantContributionRECURSIVE(children[i],
							p,
							halvesoflengths,
							wrtos);
      
      wrtos[i]--;
    }
  }

  return answer;
}

template <class T> T
gbtPolyPartialTree<T>::MaximalNonconstantDifferenceRECURSIVE(
					     const gbtTreeNode<gbtPolyMulti<T> >* n1,
					     const gbtTreeNode<gbtPolyMulti<T> >* n2,
					     const gbtVector<T>& p,
					     const gbtVector<T>& halvesoflengths,
					     gbtVector<int>& wrtos) const
{
  T answer = (T)0;

  if (n1->GetEldest() != NULL && n2->GetEldest() != NULL) {
    gbtList<gbtTreeNode<gbtPolyMulti<T> >*> children1 = PartialTree.Children(n1);
    gbtList<gbtTreeNode<gbtPolyMulti<T> >*> children2 = PartialTree.Children(n2);
    for (int i = 1; i <= children1.Length(); i++) {
      wrtos[i]++;

      T increment = children1[i]->GetData().Evaluate(p) - 
	            children2[i]->GetData().Evaluate(p);
      if (increment < (T)0) increment = -increment;
     	  
      for (int j = 1; j <= p.Length(); j++) 
	for (int k = 1; k <= wrtos[j]; k++) {
	  increment *= halvesoflengths[j];
	  increment /= (T)k;
	}

      answer += increment;

      answer += MaximalNonconstantDifferenceRECURSIVE(children1[i],
						      children2[i],
						      p,
						      halvesoflengths,
						      wrtos);
      
      wrtos[i]--;
    }
  }

  else if (n1->GetEldest() != NULL && n2->GetEldest() == NULL) {
    gbtList<gbtTreeNode<gbtPolyMulti<T> >*> children1 = PartialTree.Children(n1);
    for (int i = 1; i <= children1.Length(); i++) {
      wrtos[i]++;

      T increment = children1[i]->GetData().Evaluate(p);
      if (increment < (T)0) increment = -increment;
     	  
      for (int j = 1; j <= p.Length(); j++) 
	for (int k = 1; k <= wrtos[j]; k++) {
	  increment *= halvesoflengths[j];
	  increment /= (T)k;
	}

      answer += increment;

      answer += MaximalNonconstantContributionRECURSIVE(children1[i],
							p,
							halvesoflengths,
							wrtos);
      
      wrtos[i]--;
    }
  }

  else if (n1->GetEldest() == NULL && n2->GetEldest() != NULL) {
    gbtList<gbtTreeNode<gbtPolyMulti<T> >*> children2 = PartialTree.Children(n2);
    for (int i = 1; i <= children2.Length(); i++) {
      wrtos[i]++;

      T increment = children2[i]->GetData().Evaluate(p);
      if (increment < (T)0) increment = -increment;
     	  
      for (int j = 1; j <= p.Length(); j++) 
	for (int k = 1; k <= wrtos[j]; k++) {
	  increment *= halvesoflengths[j];
	  increment /= (T)k;
	}

      answer += increment;

      answer += MaximalNonconstantContributionRECURSIVE(children2[i],
							p,
							halvesoflengths,
							wrtos);
      
      wrtos[i]--;
    }
  }

  return answer;
}


template <class T> T
gbtPolyPartialTree<T>::MaximalNonconstantContribution(const gbtVector<T>& p,
						  const gbtVector<T>& 
						     halvesoflengths) const
{
  gbtVector<int> WithRespectTos(p.Length());
  for (int i = 1; i <= p.Length(); i++) WithRespectTos[i] = 0;

  return MaximalNonconstantContributionRECURSIVE(RootNode(),
						 p,
						 halvesoflengths,
						 WithRespectTos); 
}

template <class T> T
gbtPolyPartialTree<T>::MaximalNonconstantDifference(const gbtPolyPartialTree<T>& other,
						const gbtVector<T>& p,
						const gbtVector<T>& 
						   halvesoflengths) const
{
  gbtVector<int> WithRespectTos(p.Length());
  for (int i = 1; i <= p.Length(); i++) WithRespectTos[i] = 0;

  return MaximalNonconstantDifferenceRECURSIVE(other.RootNode(),
					       RootNode(),
					       p,
					       halvesoflengths,
					       WithRespectTos); 
}


template <class T>
T gbtPolyPartialTree<T>::EvaluateRootPoly(const gbtVector<T>& point) const 
{
  return RootNode()->GetData().Evaluate(point); 
}

template <class T>
T gbtPolyPartialTree<T>::ValueOfRootPoly(const gbtVector<T>& point) const 
{ 
  return RootPoly().Evaluate(point); 
}


template <class T> gbtOutput& operator << (gbtOutput& output, 
					 const gbtPolyPartialTree<T>& /* x */)
{
  // Changed to just return silently.
  return output;
}

template <class T> bool
gbtPolyPartialTree<T>::PolyHasNoRootsIn(const gRectangle<T>& r) const
{
  if (this->RootNode()->GetData().IsMultiaffine())
    return MultiaffinePolyHasNoRootsIn(r);
  else {
    gbtVector<T> center = r.Center();
    
    T constant = this->RootNode()->GetData().Evaluate(center);
    if (constant < (T)0) constant = - constant;
    
    gbtVector<T> HalvesOfSideLengths = r.SideLengths();
    for (int k = 1; k <= Dmnsn(); k++) HalvesOfSideLengths[k] /= (T)2;
    
    T max = 
      this->MaximalNonconstantContribution(center, HalvesOfSideLengths);
  
    if (max >= constant) 
      return false;
    else 
      return true;
  }
}

template <class T> bool 
gbtPolyPartialTree<T>::MultiaffinePolyHasNoRootsIn(const gRectangle<T>& r) const
{
  int sign;
  if (this->RootNode()->GetData().Evaluate(r.Center()) > (T)0)
    sign = 1;
  else
    sign = -1;
  
  gbtArray<int> zeros(Dmnsn());
  gbtArray<int> ones(Dmnsn());
  for (int j = 1; j <= Dmnsn(); j++) {
    zeros[j] = 0; 
    if (this->RootNode()->GetData().DegreeOfVar(j) > 0) ones[j] = 1;
    //Equation_i_uses_var_j(index,j)) ones[j] = 1; 
    else                                ones[j] = 0;
  }
  gbtIndexOdometer topbottoms(zeros,ones);
  
  while (topbottoms.Turn()) {
    gbtVector<T> point(Dmnsn());
    for (int i = 1; i <= Dmnsn(); i++)
      if (topbottoms[i] == 0)
	point[i] = r.LowerBoundOfCoord(i);
      else
	point[i] = r.UpperBoundOfCoord(i);
    if ((T)sign * this->RootNode()->GetData().Evaluate(point) <=  (T)0)
      return false;
  }
  
  return true;
}



template<class T> bool
gbtPolyPartialTree<T>::MultiaffinePolyEverywhereNegativeIn(
					        const gRectangle<T>& r) const
{ 
  if (Dmnsn() == 0) {
    gbtVector<T> point(Dmnsn());
    if (this->RootNode()->GetData().Evaluate(point) >= (T)0)
      return false;
    else
      return true;
  }

  gbtArray<int> zeros(Dmnsn());
  gbtArray<int> ones(Dmnsn());
  for (int j = 1; j <= Dmnsn(); j++) {
    zeros[j] = 0; 
    if (this->RootNode()->GetData().DegreeOfVar(j) > 0) ones[j] = 1; 
    else                                                ones[j] = 0;
  }
  gbtIndexOdometer topbottoms(zeros,ones);
  
  while (topbottoms.Turn()) {
    gbtVector<T> point(Dmnsn());
    for (int i = 1; i <= Dmnsn(); i++)
      if (topbottoms[i] == 0)
	point[i] = r.LowerBoundOfCoord(i);
      else
	point[i] = r.UpperBoundOfCoord(i);
    if (this->RootNode()->GetData().Evaluate(point) >= (T)0)
      return false;
  }
  
  return true;
}

template<class T> bool
gbtPolyPartialTree <T>::PolyEverywhereNegativeIn(const gRectangle<T>& r) const
{
  if (this->RootNode()->GetData().IsMultiaffine())
    return MultiaffinePolyEverywhereNegativeIn(r);
  else {
    gbtVector<T> center = r.Center();

    T constant = 
      this->RootNode()->GetData().Evaluate(center);
    if (constant >= (T)0) return false;
    
    gbtVector<T> HalvesOfSideLengths = r.SideLengths();
    for (int k = 1; k <= Dmnsn(); k++) HalvesOfSideLengths[k] /= (T)2;
    
    T max = this->MaximalNonconstantContribution(center, HalvesOfSideLengths);

    if (max + constant >= (T)0) return false;
    else                     return true;
  }
}




//---------------------------------------------------------------
//                    class: gbtPolyPartialTreeList
//---------------------------------------------------------------

//---------------------------
// Constructors / Destructors
//---------------------------

template <class T> 
gbtPolyPartialTreeList<T>::gbtPolyPartialTreeList(const gbtList<gbtPolyMulti<T> >& given) 
: PartialTreeList()
{
  for (int i = 1; i <= given.Length(); i++) 
    PartialTreeList += gbtPolyPartialTree<T>(given[i]);
}

template <class T> 
gbtPolyPartialTreeList<T>::gbtPolyPartialTreeList(const gbtPolyMultiList<T>& given) 
: PartialTreeList()
{
  for (int i = 1; i <= given.Length(); i++) 
    PartialTreeList += gbtPolyPartialTree<T>(given[i]);
}

template<class T> 
gbtPolyPartialTreeList<T>::gbtPolyPartialTreeList(const gbtPolyPartialTreeList& qs)
: PartialTreeList(qs.PartialTreeList)
{
}

template<class T> gbtPolyPartialTreeList<T>::~gbtPolyPartialTreeList()
{
}

template <class T> bool 
gbtPolyPartialTreeList<T>::operator ==(const gbtPolyPartialTreeList<T>& rhs) const
{
  if (Length() != rhs.Length()) return false;
  for (int i = 1; i <= Length(); i++)
    if ((*this)[i] != rhs[i])
      return false;
  return true;
}

template <class T> bool 
gbtPolyPartialTreeList<T>::operator !=(const gbtPolyPartialTreeList<T>& rhs) const
{
  return !(*this == rhs);
}

template <class T> 
gbtMatrix<T> gbtPolyPartialTreeList<T>::DerivativeMatrix(const gbtVector<T>& p) const
{
  gbtMatrix<T> answer(Length(),Dmnsn());
  int i;
  for (i = 1; i <= Length(); i++)
    for (int j = 1; j <= Dmnsn(); j++)
      answer(i,j) = (*this)[i].ValueOfPartialOfRootPoly(j,p);
  
  return answer;
}

template <class T> gbtMatrix<T> 
gbtPolyPartialTreeList<T>::DerivativeMatrix(const gbtVector<T>& p,
					const int& NoEquations) const
{
  gbtMatrix<T> answer(NoEquations,Dmnsn());
  int i;
  for (i = 1; i <= NoEquations; i++)
    for (int j = 1; j <= Dmnsn(); j++)
      answer(i,j) = (*this)[i].ValueOfPartialOfRootPoly(j,p);
  
  return answer;
}

template <class T> gbtSquareMatrix<T> 
gbtPolyPartialTreeList<T>::SquareDerivativeMatrix(const gbtVector<T>& p) const
{
  assert (Length() >= Dmnsn());
  gbtSquareMatrix<T> answer(Dmnsn());
  int i;
  for (i = 1; i <= Dmnsn(); i++)
    for (int j = 1; j <= Dmnsn(); j++)
      answer(i,j) = (*this)[i].ValueOfPartialOfRootPoly(j,p);
 
  return answer;
}

template <class T> gbtVector<T> 
gbtPolyPartialTreeList<T>::ValuesOfRootPolys(const gbtVector<T>& point,
					 const int& NoEquations) const
{
  gbtVector<T> answer(NoEquations);
  for (int i = 1; i <= NoEquations; i++)
    answer[i] = PartialTreeList[i].EvaluateRootPoly(point);

  return answer;
}

template <class T> T  
gbtPolyPartialTreeList<T>::MaximalNonconstantDifference(const int& i,
						    const int& j,
						    const gbtVector<T>& point, 
				  const gbtVector<T>& halvesoflengths)    const
{
  return PartialTreeList[i].MaximalNonconstantDifference(PartialTreeList[j],
							 point,
							 halvesoflengths);
}

template <class T> gbtOutput& operator << (gbtOutput& output, 
					 const gbtPolyPartialTreeList<T>& /* x */)
{
  // Changed to just return silently.
  return output;
}
