//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Declaration of gbtPolyIdeal
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#ifndef IDEAL_H
#define IDEAL_H

#include "base/odometer.h"
#include "gpolylst.h"

/*
   By the Hilbert basis theorem, every ideal is generated by some finite
basis, and for computational purposes we essentially think of ideals
as bases.  There are some important operations, however, that differ
across the various bases generating a single ideal, and for this
reason we will have a separate basis class.  Operator == is defined
setwise -- computationally we sort the two bases and then compare
termwise.
   In class ideal operator == is defined in terms of the ideal generated.
Computationally two ideals agree if their ordered reduced Grobner bases are
the same.
 */

// ***********************
//      class gbtPolyIdeal
// ***********************

template <class T> class gbtPolyIdeal {
 private:
   const gbtPolySpace*      Space;
   const gbtPolyTermOrder*  order;
         gbtPolyMultiList<T> basis;
   
 public:
  gbtPolyIdeal(const gbtPolySpace *, const gbtPolyTermOrder *); // Null gbtPolyIdeal constructor
  gbtPolyIdeal(const gbtPolySpace *, const gbtPolyTermOrder *,
	      const gbtList< gbtPolyMulti<T> *> &);
  gbtPolyIdeal(const gbtPolyTermOrder *, const gbtPolyMultiList<T> &);
  gbtPolyIdeal(const gbtPolyIdeal<T> &);

  ~gbtPolyIdeal();

   // Operators
   gbtPolyIdeal<T>& operator=(const gbtPolyIdeal<T> &);

   bool      operator==(const gbtPolyIdeal<T> &) const;
   bool      operator!=(const gbtPolyIdeal<T> &) const;
   gbtPolyIdeal<T> operator+ (const gbtPolyIdeal<T> &) const;
   gbtPolyIdeal<T> operator* (const gbtPolyIdeal<T> &) const;

   // Information
   inline int               Dmnsn()            const { return Space->Dmnsn(); }
   inline const gbtPolySpace*     TheSpace()         const { return Space         ; }
   inline int               NoBasisElements()  const { return basis.Length(); }
   inline const gbtPolyTermOrder* Order()            const { return order; }
   inline gbtPolyMultiList<T>      CanonicalBasis()   const { return basis; }
          gbtPolyIdeal<T>         MonomialIdeal()    const;
          gbtList<gbtPolyExponent>   MonomialBasis()    const;
                // This returns a monomial basis of the ring of gbtPolyUni
                // functions on the variety V(I), where I is the given ideal.
                // It fails if the variety is not zero dimensional.
          bool              IsRoot(const gbtVector<T>&) const;

   bool ZeroDimensional()    const;
   bool IsEntireRing()       const;
   bool Contains(gbtPolyMulti<T> &) const;
};  

#endif //# IDEAL_H
