//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of monomial classes
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include "monomial.h"


//--------------------------------------------------------------------------
//                 gbtMonomial -- constructors and destructor
//--------------------------------------------------------------------------

template<class T> gbtMonomial<T>::gbtMonomial(const gbtPolySpace* p, const T& x) 
: coef(x), exps(p)
{ 
}

template<class T> gbtMonomial<T>::gbtMonomial(const T& x, const gbtPolyExponent& e) 
: coef(x), exps(e)
{ 
  if (x == (T)0) exps.ToZero();
}

template<class T> gbtMonomial<T>::gbtMonomial(const gbtMonomial<T>& y) 
: coef(y.coef), exps(y.exps)
{
}

template<class T> gbtMonomial<T>::~gbtMonomial() 
{
}

//--------------------------------------------------------------------------
//                             gbtMonomial -- operators
//--------------------------------------------------------------------------

template<class T> gbtMonomial<T>& gbtMonomial<T>::operator = (const gbtMonomial<T>& y)
{
  if (this != &y) { coef = y.coef; exps = y.exps; }
  return *this;
}

template<class T> bool gbtMonomial<T>::operator == (const gbtMonomial<T>& y) const
{
  return (coef == y.coef && exps == y.exps);
}

template<class T> bool gbtMonomial<T>::operator != (const gbtMonomial<T>& y) const
{
  return !(*this == y);
}

template<class T> gbtMonomial<T> gbtMonomial<T>::operator * (const gbtMonomial<T> & y) const
{
  return gbtMonomial<T>(coef * y.coef,exps + y.exps);
}

template<class T> gbtMonomial<T> gbtMonomial<T>::operator / (const gbtMonomial<T>& y) const
{
  //  assert ( y.coef != (T)0);
  return gbtMonomial<T>(coef / y.coef,exps - y.exps);
}

template<class T> gbtMonomial<T> gbtMonomial<T>::operator + (const gbtMonomial<T> & y) const
{
  // assert (exps == y.exps);
  return gbtMonomial<T>(coef + y.coef,exps);
}

template<class T> gbtMonomial<T>& gbtMonomial<T>::operator += (const gbtMonomial<T> & y) 
{
  // assert (exps == y.exps);
  coef += y.coef;
  return *this;
}

template<class T> gbtMonomial<T>& gbtMonomial<T>::operator *= (const T& val) 
{
  coef *= val;
  return *this;
}

template<class T> gbtMonomial<T> gbtMonomial<T>::operator - () const
{
  return gbtMonomial<T>(-coef,exps);
}

//--------------------------------------------------------------------------
//                             gbtMonomial -- information
//--------------------------------------------------------------------------

template<class T> const T &gbtMonomial<T>::Coef() const 
{ 
  return coef; 
}

template<class T> int gbtMonomial<T>::Dmnsn() const 
{ 
  return exps.Dmnsn(); 
}

template<class T> int gbtMonomial<T>::TotalDegree() const 
{ 
  return exps.TotalDegree(); 
}

template<class T> const gbtPolyExponent &gbtMonomial<T>::ExpV() const 
{ 
  return exps; 
}

template<class T> bool gbtMonomial<T>::IsConstant() const 
{ 
  return exps.IsConstant(); 
}

template<class T> bool gbtMonomial<T>::IsMultiaffine() const 
{ 
  return exps.IsMultiaffine(); 
}

template<class T> T gbtMonomial<T>::Evaluate(const gbtArray<T>& vals) const 
{ 
  T answer = Coef();

  for (int i = 1; i <= Dmnsn(); i++)
    for (int j = 1; j <= exps[i]; j++)
      answer *= vals[i];

  return answer;
}

template<class T> T gbtMonomial<T>::Evaluate(const gbtVector<T>& vals) const 
{ 
  T answer = Coef();

  for (int i = 1; i <= Dmnsn(); i++)
    for (int j = 1; j <= exps[i]; j++)
      answer *= vals[i];

  return answer;
}

//--------------------------------------------------------------------------
//                             gbtMonomial -- printing
//--------------------------------------------------------------------------

template<class T> std::ostream& operator << (std::ostream& output, const gbtMonomial<T>& x)
{
    output << x.Coef() << x.ExpV();    return output;
}
