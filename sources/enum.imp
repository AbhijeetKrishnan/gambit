//
// FILE: enum.imp -- Nash Enum module
//
// $Id$
//

#include "gwatch.h"
#include "nfg.h"
#include "nfgiter.h"

#include "enum.h"
#include "clique.h"


template <class T> class EnumModule  {
private:
  T eps;
  const Nfg &NF;
  const NFSupport &support;
  EnumParams params;
  int rows,cols,level,v1,v2;
  long count,npivots;
  double time;
  gList<MixedSolution> solutions;
  gList<int> node1, node2;   // IDs of each component of the extreme equilibria

  // note:  The keys give the mixed strategy associated with each node.  
  //        The keys should also keep track of the basis
  //        As things stand now, two different bases could lead to the same key
  //        BAD!

  gList<gVector<T> > key1, key2;  

  bool EqZero(T x) const;
  
public:
  EnumModule(const NFSupport &, const EnumParams &p);
  
  int Enum(void);
  int DoubleEnum(void);
  
  long NumPivots(void) const;
  double Time(void) const;
  
  EnumParams &Parameters(void);

  const gList<MixedSolution> &GetSolutions(void) const;
  void GetCliques() const;
};

//-------------------------------------------------------------------------
//                    EnumModule<T>: Member functions
//-------------------------------------------------------------------------

template <class T>
EnumModule<T>::EnumModule(const NFSupport &S, const EnumParams &p)
  : NF(S.Game()), support(S), params(p), rows(S.NumStrats(1)), 
    cols(S.NumStrats(2)), level(0), count(0), npivots(0)
{ 
  gEpsilon(eps,12);
}


template <class T> int EnumModule<T>::DoubleEnum(void)
{
  int index;
  T min;

  if (NF.NumPlayers() != 2)   return 0;  
  int n1, n2,i,j;

  gWatch watch;
  n1=support.NumStrats(1);
  n2=support.NumStrats(2);
  NfgIter iter(support); 

  gMatrix<T> A1(1,n1,1,n2);
  gMatrix<T> A2(1,n2,1,n1);
  gVector<T> b1(1,n1);
  gVector<T> b2(1,n2);

  min = MinPayoff(NF) - gNumber(1);

   // construct A1,A2,b1,b2  

  for (i=1; i<=n1; i++) {
    for (j=1; j<=n2; j++)  {
      A1(i, j) = NF.Payoff(iter.GetOutcome(), 1) - gNumber(min);
      A2(j, i) = NF.Payoff(iter.GetOutcome(), 2) - gNumber(min);
      iter.Next(2);
    }
    iter.Next(1);
  }

  b1 = -(T)1;
  b2 = -(T)1;

  // enumerate vertices of A1 x + b1 <= 0 and A2 x + b2 <= 0

  params.status.SetProgress((double)0);

  time = watch.Elapsed();
  double dt = (double)0;
  if(params.trace>=2) 
    (*params.tracefile) << "\nat start,    dt = " << dt << " time = " << time; 
  
  DoubleVertEnum<T> poly(A1,b1,A2,b2,params.status);

  gout << "\nDoubleVertEnum finished:\n";
  poly.Dump(gout);

  BFS<T> bfs1,bfs2;
  MixedProfile<T> profile(support);
  T sum;
  int k;
  
  const gList<BFS<T> > &verts1(poly.VertexList());
  const gList<BFS<T> > &verts2(poly.VertexList2());

  for( i=2; i<=verts1.Length() &&
       (params.stopAfter==0 || solutions.Length()<params.stopAfter);
       i++ ) {
    params.status.Get();
    bfs1 = verts2[i];
    bfs2 = verts1[i];
    
    sum = (T)0;
    for(k=1;k<=n1;k++) {
      profile(1,k) = (T)0;
      if(bfs1.IsDefined(k)) {
    profile(1,k) =-bfs1(k);
    sum+=profile(1,k);
      }
    } 
    for(k=1;k<=n1;k++) {
      if(bfs1.IsDefined(k)) 
    profile(1,k)/=sum;
    }
    sum = (T)0;
    for(k=1;k<=n2;k++) {
      profile(2,k) = (T)0;
      if(bfs2.IsDefined(k)) {
    profile(2,k) =-bfs2(k);
    sum+=profile(2,k);
      }
    } 
    for(k=1;k<=n2;k++) {
      if(bfs2.IsDefined(k)) 
    profile(2,k)/=sum;
    } 
  
    index = solutions.Append(MixedSolution(profile, algorithmNfg_ENUMMIXED));
    solutions[index].SetEpsilon(eps);
    solutions[index].SetIsNash(triTRUE);
  }
  npivots = poly.NumPivots();

  dt = watch.Elapsed()-time;
  time = watch.Elapsed();
  if(params.trace>=2) {
    (*params.tracefile) << "\nafter loop,  dt = " << dt << " time = " << time;
    (*params.tracefile) << "\n";
  }
  return 1;
}

template <class T> int EnumModule<T>::Enum(void)
{
  int index;
  T min;

  if (NF.NumPlayers() != 2)   return 0;  
  int n1, n2,i,j,k;

  gWatch watch;

  n1=support.NumStrats(1);
  n2=support.NumStrats(2);
  NfgIter iter(support); 

  gMatrix<T> A1(1,n1,1,n2);
  gMatrix<T> A2(1,n2,1,n1);
  gVector<T> b1(1,n1);
  gVector<T> b2(1,n2);

  min = MinPayoff(NF) - gNumber(1);

   // construct A1,A2,b1,b2  

  for (i=1; i<=n1; i++) {
    for (j=1; j<=n2; j++)  {
      A1(i, j) = NF.Payoff(iter.GetOutcome(), 1) - gNumber(min);
      A2(j, i) = NF.Payoff(iter.GetOutcome(), 2) - gNumber(min);
      iter.Next(2);
    }
    iter.Next(1);
  }

  b1 = -(T)1;
  b2 = -(T)1;

  // enumerate vertices of A1 x + b1 <= 0 and A2 x + b2 <= 0

  params.status.SetProgress((double)0);

  time = watch.Elapsed();
  double dt = (double)0;
  if(params.trace>=2) 
    (*params.tracefile) << "\nat start,    dt = " << dt << " time = " << time; 
  

  VertEnum<T> poly1(A1,b1,params.status);
  params.status.SetProgress(-(double)(1));

  dt = watch.Elapsed()-time;
  time = watch.Elapsed();
  if(params.trace>=2) 
    (*params.tracefile) << "\nafter poly1, dt = " << dt << " time = " << time; 
  

  VertEnum<T> poly2(A2,b2,params.status);
  params.status.SetProgress(-(double)1);

  
  dt = watch.Elapsed()-time;
  time = watch.Elapsed();
  if(params.trace>=2) 
    (*params.tracefile) << "\nafter poly2, dt = " << dt << " time = " << time; 
  

  const gList<BFS<T> > &verts1(poly1.VertexList());
  const gList<BFS<T> > &verts2(poly2.VertexList());
  v1=verts1.Length();
  v2=verts2.Length();

//  v1=poly1.VertexList().Length();
//  v2=poly2.VertexList().Length();
  if(params.trace>=2) 
    (*params.tracefile) << "\n v1 = " << v1 << ", v2 = " << v2;

  BFS<T> bfs1,bfs2;
  MixedProfile<T> profile(support);
  T sum;
  bool nash;

  gArray<int> vert1id(v1);
  gArray<int> vert2id(v2);
  for(i=1;i<=vert1id.Length();i++) vert1id[i]=0;
  for(i=1;i<=vert2id.Length();i++) vert2id[i]=0;

  i=0;

  int i1,i2,id1=0,id2=0;

  if(params.trace>=2) 
    (*params.tracefile) << "\n" << v2 << " " << v1 << "\n";

  for( i2=2; 
       i2<=v2 &&
       (params.stopAfter==0 || solutions.Length()<params.stopAfter);
       i2++ ) {
    params.status.Get();
    bfs1 = verts2[i2];
    params.status.SetProgress((double)(i-2)/(double)v2);
//    gout << "\nProgress = " << (double)(i-2)/(double)v2;
    i++;
    for( i1=2; 
     i1<=v1 && (params.stopAfter==0 || solutions.Length()<params.stopAfter);
     i1++ ) {
      bfs2 = verts1[i1];
      
      // check if solution is nash 
      // need only check complementarity, since it is feasible
      
      nash=1;
      for(k=1;k<=n1 && nash==1;k++)
    if(bfs1.IsDefined(k) && bfs2.IsDefined(-k))
      if(!EqZero(bfs1(k)*bfs2(-k)))
        nash=0;
      for(k=1;k<=n2 && nash==1;k++)
    if(bfs2.IsDefined(k) && bfs1.IsDefined(-k))
      if(!EqZero(bfs2(k)*bfs1(-k)))
        nash=0;

      if(nash) {
    sum = (T)0;
    for(k=1;k<=n1;k++) {
      profile(1,k) = (T)0;
      if(bfs1.IsDefined(k)) {
        profile(1,k) =-bfs1(k);
        sum+=profile(1,k);
      }
    } 
    for(k=1;k<=n1;k++) {
      if(bfs1.IsDefined(k)) 
        profile(1,k)/=sum;
    }
    sum = (T)0;
    for(k=1;k<=n2;k++) {
      profile(2,k) = (T)0;
      if(bfs2.IsDefined(k)) {
        profile(2,k) =-bfs2(k);
        sum+=profile(2,k);
      }
    } 
    for(k=1;k<=n2;k++) {
      if(bfs2.IsDefined(k)) 
        profile(2,k)/=sum;
    } 
      
    if(params.trace>=2) 
      (*params.tracefile) << "\n" << i2 << " " << i1;

    index = solutions.Append(MixedSolution(profile, algorithmNfg_ENUMMIXED));
    solutions[index].SetEpsilon(eps);
    solutions[index].SetIsNash(triTRUE);
    
    // note:  this is not really sufficient information -- we should also
    //        keep the basis
    if(vert1id[i1]==0){id1++;vert1id[i1]=id1;key2.Append(profile.GetRow(2));}
    if(vert2id[i2]==0){id2++;vert2id[i2]=id2;key1.Append(profile.GetRow(1));}
    node1.Append(vert2id[i2]);
    node2.Append(vert1id[i1]);
      }
    }

  }
  npivots = poly1.NumPivots()+poly2.NumPivots();

  dt = watch.Elapsed()-time;
  time = watch.Elapsed();
  if(params.trace>=2) {
    (*params.tracefile) << "\nafter loop,  dt = " << dt << " time = " << time;
    (*params.tracefile) << "\n";
  }
  return 1;
}

template <class T> bool EnumModule<T>::EqZero(T x) const
{
  if(x <= eps && x >= -eps) return 1;
  return 0;
}     

template <class T> long EnumModule<T>::NumPivots(void) const
{
  return npivots;
}

template <class T> double EnumModule<T>::Time(void) const
{
  return time;
}

template <class T> EnumParams &EnumModule<T>::Parameters(void)
{
  return params;
}

template <class T>
const gList<MixedSolution> &EnumModule<T>::GetSolutions(void) const
{
  return solutions;
}

template <class T> void EnumModule<T>::GetCliques() const
{
  int i,n = node1.Length();
  assert (node2.Length() == n);

  gArray<edge> edgelist(n);

  gout << "\nKey:\nPlayer 1:";
  for(i=1;i<=key1.Length();i++) {
    gout << "\n" << i << ": " << key1[i];
  }
  gout << "\nPlayer 2:";
  for(i=1;i<=key2.Length();i++)
    gout << "\n" << i << ": " << key2[i];
  gout << "\nExtreme equilibria:";
  for(int i=1;i<=n;i++) {
    edgelist[i].node1 = node1[i];
    edgelist[i].node2 = node2[i];
    gout << "\n" << node1[i] << " " << node2[i];
  }
  EnumCliques clique(edgelist,v2+1,v1+1);
}

