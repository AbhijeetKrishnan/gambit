//
// FILE: gnarray.imp -- Implementation of n-dimensional arrays
//
// $Id$
//

#include "gnarray.h"
#include <assert.h>

#ifdef USE_EXCEPTIONS
#include "gtext.h"

template <class T> gText gNArray<T>::BadDim::Description(void) const
{
  return "Bad dimension exception in gNArray";
}

template <class T> gText gNArray<T>::BadIndex::Description(void) const
{
  return "Bad index exception in gNArray";
}

#endif  // USE_EXCEPTIONS

template <class T> gNArray<T>::gNArray(const gArray<int> &d)
  : dim(d)
{
  if (dim.Length() <= 0)   {
    storage = 0;
    storage_size = 0;
  }
  else   {
#ifdef USE_EXCEPTIONS
    if (dim.First() != 1)   throw BadIndex();
#else
    assert(dim.First() == 1);
#endif   // USE_EXCEPTIONS
    storage_size = 1;
    
    for (int i = 1; i <= dim.Length(); i++)   {
#ifdef USE_EXCEPTIONS
      if (dim[i] < 1)   throw BadDim();
#else
      assert(dim[i] >= 1);
#endif   // USE_EXCEPTIONS
      storage_size *= dim[i];
    }
    
    storage = new T[storage_size];
    for (int i = 0; i < storage_size; storage[i++] = 0);
  }
}

template <class T> gNArray<T>::gNArray(const gNArray<T> &a)
  : storage_size(a.storage_size), dim(a.dim)
{
  storage = (storage_size > 0) ? new T[storage_size] : 0;
  for (int i = 0; i < storage_size; i++)
    storage[i] = a.storage[i];
}

template <class T> gNArray<T>::~gNArray()
{
  if (storage)    delete [] storage;
}

template <class T> gNArray<T> &gNArray<T>::operator=(const gNArray<T> &a)
{
  if (this != &a)   {
    T *new_storage = (a.storage_size > 0) ? new T[a.storage_size] : 0;
    if (storage)    delete [] storage;
    storage = new_storage;
    dim = a.dim;
    storage_size = a.storage_size;
    for (int i = 0; i < storage_size; i++)
      storage[i] = a.storage[i];
  }
  return *this;
}

template <class T> T gNArray<T>::operator[](const gArray<int> &v) const
{
#ifdef USE_EXCEPTIONS
  if (dim.Length() != v.Length())   throw BadDim();
#else
  assert(dim.Length() == v.Length());
#endif  // USE_EXCEPTIONS
 
  int i, location, offset;
  
  for (i = 1, location = 0, offset = 1; i <= dim.Length(); i++)   {
    assert(v[i] > 0 && v[i] <= dim[i]);
    location += (v[i] - 1) * offset;
    offset *= dim[i];
  }

  return storage[location];
}

template <class T> T &gNArray<T>::operator[](const gArray<int> &v)
{
#ifdef USE_EXCEPTIONS
  if (dim.Length() != v.Length())   throw BadDim();
#else
  assert(dim.Length() == v.Length());
#endif  // USE_EXCEPTIONS

  int i, location, offset;
  
  for (i = 1, location = 0, offset = 1; i <= dim.Length(); i++)   {
    assert(v[i] > 0 && v[i] <= dim[i]);
    location += (v[i] - 1) * offset;
    offset *= dim[i];
  }

  return storage[location];
}

template <class T> void gNArray<T>::Output(gOutput &f) const
{
  if (dim.Length() > 0)   {
    for (int i = dim.Length(); i > 0; f << i-- << ' ');
    f << '\n';
    
    gArray<int> v(1, dim.Length());
    DumpFrom(f, 1, v);
    f << '\n';
  }
}

template <class T> 
void gNArray<T>::DumpFrom(gOutput &f, int offset, gArray<int> &v) const
{
  for (int i = 1; i <= dim[offset]; i++)   {
    v[offset] = i;
    if (offset == dim.Length())
      f << (*this)[v] << ' ';
    else
      DumpFrom(f, offset + 1, v);
  }
}
/*
template <class T> const T &gNArray<T>::operator[](long l) const
{
  assert(l >= 0 && l < storage_size);
  return storage[l];
}

template <class T> T &gNArray<T>::operator[](long l) 
{
  assert(l >= 0 && l < storage_size);
  return storage[l];
}
*/

template <class T> const gArray<int> &gNArray<T>::Dimensions(void) const
{
  return dim;
}
