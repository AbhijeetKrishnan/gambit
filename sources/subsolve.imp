//
// FILE: subsolve.imp -- Implementation of solve-by-subgame algorithms
//
// $Id$ 
//

#include "subsolve.h"

//-------------------------------------------------------------------------
//                Implementation of base solver algorithm
//-------------------------------------------------------------------------

template <class T>
void SubgameSolver<T>::FindSubgames(Node *n, gList<BehavSolution> &solns,
						gList<EFOutcome *> &values)
{
  int i;
  int failed;
  bool marked = AllSubgamesMarked(efg);
  
  gList<BehavProfile<T> > thissolns;
  thissolns.Append(solution);
  ((gVector<T> &) thissolns[1]).operator=((T) 0);
  
  gList<Node *> subroots;
  ChildSubgames(n, subroots);
  
  gList<gArray<EFOutcome *> > subrootvalues;
  subrootvalues.Append(gArray<EFOutcome *>(subroots.Length()));
  
  for (i = 1; i <= subroots.Length(); i++)  {
    gList<BehavSolution> subsolns;
    gList<EFOutcome *> subvalues;
    
    FindSubgames(subroots[i], subsolns, subvalues);
    
    if (subsolns.Length() == 0)  {
      solns.Flush();
      return;
    }
    
    assert(subvalues.Length() == subsolns.Length());
    
    gList<BehavProfile<T> > newsolns;
    gList<gArray<EFOutcome *> > newsubrootvalues;
    
    for (int soln = 1; soln <= thissolns.Length() &&
	 (max_solns == 0 || newsolns.Length() <= max_solns);
	 soln++)
      for (int subsoln = 1; subsoln <= subsolns.Length() &&
	   (max_solns == 0 || newsolns.Length() <= max_solns); subsoln++)  {
	BehavProfile<T> bp(thissolns[soln]);
	for (int j = 1; j <= bp.Length(); j++)
	  bp[j] += subsolns[subsoln][j];
	newsolns.Append(bp);
	
	newsubrootvalues.Append(subrootvalues[soln]);
	newsubrootvalues[newsubrootvalues.Length()][i] = subvalues[subsoln];
      }
    
    thissolns = newsolns;
    subrootvalues = newsubrootvalues;
  }
  
  assert(n->GetSubgameRoot() == n);
  
  // This is here to allow called hook code to figure out which subgame
  // is currently being solved.  The number should correspond to the index
  // of the subgame in the list returned by SubgameRoots().
  
  subgame_number++;
  
  for (int soln = 1; soln <= thissolns.Length(); soln++)   {
    for (i = 1; i <= subroots.Length(); i++)
      subroots[i]->SetOutcome(subrootvalues[soln][i]);
    
    Efg foo(efg, n);
    // this prevents double-counting of outcomes at roots of subgames
    // by convention, we will just put the payoffs in the parent subgame
    foo.RootNode()->SetOutcome(0);
    
    ViewSubgame(subgame_number, foo);
    
    gList<Node *> nodes;
    Nodes(efg, n, nodes);
    
    gList<BehavSolution> sol;

    EFSupport subsupport(foo);
    // here, we build the support for the subgame
    for (int pl = 1; pl <= foo.NumPlayers(); pl++)  {
      EFPlayer *p = foo.Players()[pl];
      int index;

      for (index = 1; index <= nodes.Length() &&
	   nodes[index]->GetPlayer() != efg.Players()[pl]; index++);
	
      if (index > nodes.Length())  continue;

      int base;
	
      for (base = 1; base <= efg.Players()[pl]->NumInfosets(); base++)
	if (efg.Players()[pl]->Infosets()[base] ==
	    nodes[index]->GetInfoset())  break;
	
      assert(base <= efg.Players()[pl]->NumInfosets());
	
      for (int iset = 1; iset <= p->NumInfosets(); iset++)  {
	for (index = 1; index <= infosets[pl]->Length(); index++)
	  if ((*infosets[pl])[index] == efg.Players()[pl]->Infosets()[iset + base - 1])
	    break;
	  
	assert(index <= infosets[pl]->Length());
	  
	for (int act = 1; act <= p->Infosets()[iset]->NumActions();
	     act++)  {
	  if (!support.Find((*infosets[pl])[index]->Actions()[act])) 
	    subsupport.RemoveAction(p->Infosets()[iset]->Actions()[act]);
	}
      }
    }

    failed = SolveSubgame(foo, subsupport, sol);
    
    SelectSolutions(subgame_number, foo, sol);
    
    // put behav profile in "total" solution here...
    
    if (sol.Length() == 0)  {
      solns.Flush();
      return;
    }
    
    for (int solno = 1; solno <= sol.Length(); solno++)  {
      solns.Append(thissolns[soln]);
      
      for (int pl = 1; pl <= foo.NumPlayers(); pl++)  {
	EFPlayer *p = foo.Players()[pl];
	int index;

	for (index = 1; index <= nodes.Length() &&
	     nodes[index]->GetPlayer() != efg.Players()[pl]; index++);
	
	if (index > nodes.Length())  continue;

	int base;
	
	for (base = 1; base <= efg.Players()[pl]->NumInfosets(); base++)
	  if (efg.Players()[pl]->Infosets()[base] ==
	      nodes[index]->GetInfoset())  break;
	
	assert(base <= efg.Players()[pl]->NumInfosets());
	
	for (int iset = 1; iset <= p->NumInfosets(); iset++)  {
	  for (index = 1; index <= infosets[pl]->Length(); index++)
	    if ((*infosets[pl])[index] == efg.Players()[pl]->Infosets()[iset + base - 1])
	      break;
	  
	  assert(index <= infosets[pl]->Length());
	  
	  for (int act = 1; act <= subsupport.NumActions(pl, iset); act++)
	    solns[solns.Length()](pl, index, act) = sol[solno](pl, iset, act);
	}
	int j=solns.Length();
	solns[j].SetCreator( (EfgAlgType) AlgorithmID());
	if(failed == 0) {
	  solns[j].SetIsNash(T_YES);
	  if(marked)
	    solns[j].SetIsSubgamePerfect(T_YES); 
	  if(solns[j].Creator() == EfgAlg_ELIAPSUB) {
	    solns[j].SetLiap(solns[j].LiapValue());
	    solns[j].SetIsSequential(T_YES);      // even if marked = false
	    solns[j].SetIsSubgamePerfect(T_YES);  // even if marked = false
	  }

	}
      }
      
      gVector<T> subval(foo.NumPlayers());
      for (i = 1; i <= foo.NumPlayers(); i++)  {
	      subval[i] = sol[solno].Payoff(i);
	      if (n->GetOutcome())  {
          gArray<gNumber> values(efg.Parameters()->Dmnsn());
          for (int j = 1; j <= values.Length(); values[j++] = gNumber(0));
	        subval[i] += (T) efg.Payoff(n->GetOutcome(), i).Evaluate(values);
        }
      }

      EFOutcome *ov = efg.NewOutcome();
      for (i = 1; i <= efg.NumPlayers(); i++)
	      efg.SetPayoff(ov, i, gPoly<gNumber>(efg.Parameters(), gNumber(subval[i]),
                                            efg.ParamOrder()));
 
      values.Append(ov);
    }
  }

  efg.DeleteTree(n);
}

// These are dummies... for specific applications, these can be overriden
// in derived classes to allow interactive access to the solution process

// This is called immediately after the subgame is constructed in the
// solution process.  Mostly to allow viewing of the subgame, but probably
// isn't generally useful.

template <class T>
void SubgameSolver<T>::ViewSubgame(int, const Efg &)
{ }

// This is called in the normal-form solution modules after the normal
// form is constructed.  Note especially that the Nfg is passed
// non-const, so that strategies may be eliminated as seen fit.
// It is assumed that the NFSupport returned is "sensible"

template <class T>
void SubgameSolver<T>::ViewNormal(const Nfg &, NFSupport *&)
{ }
// This is called for each subgame after the solutions have been computed
// The idea is for the called code to possibly allow for viewing or
// selection of "interesting" equilibria for further computation during
// the process.  Again, there is no restriction that one can't
// muck about with the solution list in "bad" ways using this.
// Caveat utor!

template <class T>
void SubgameSolver<T>::SelectSolutions(int, const Efg &,
				       gList<BehavSolution> &)
{ }

template <class T> 
SubgameSolver<T>::SubgameSolver(const Efg &E, const EFSupport &S, int max)
  : max_solns(max), efg(E), support(efg), solution(E, S),
    infosets(E.NumPlayers())
{
  for (int i = 1; i <= efg.NumPlayers(); i++)
    infosets[i] = new gArray<Infoset *>(efg.Players()[i]->Infosets());
  
  for (int pl = 1; pl <= efg.NumPlayers(); pl++)  {
    EFPlayer *player = E.Players()[pl];
    for (int iset = 1; iset <= player->NumInfosets(); iset++)  {
      Infoset *infoset = player->Infosets()[iset];
      for (int act = 1; act <= infoset->NumActions(); act++) 
	if (!S.Find(infoset->Actions()[act]))
	  support.RemoveAction(efg.Players()[pl]->Infosets()[iset]->Actions()[act]);
    }
  }
}

template <class T> SubgameSolver<T>::~SubgameSolver()  
{
  for (int i = 1; i <= efg.NumPlayers(); i++)
    delete infosets[i];
}

template <class T> 
void SubgameSolver<T>::Solve(void)
{
  gWatch watch;

  solutions.Flush();
  subgame_number = 0;

  gList<EFOutcome *> values;

  ((gVector<T> &) solution).operator=((T) 0);

  FindSubgames(efg.RootNode(), solutions, values);

  time = watch.Elapsed();
}

