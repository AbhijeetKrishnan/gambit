//#
//# FILE: grarray.imp -- Implementation of base rectangular array class
//#
//# $Id$
//#

#include "grarray.h"

#include <assert.h>

//------------------------------------------------------------------------
//                   Private/protected member functions
//------------------------------------------------------------------------

template <class T> bool gRectArray<T>::Check(int row, int col) const
{
  return (row >= 1 && row <= nrows && col >= 1 && col <= ncols);
}

//------------------------------------------------------------------------
//            Constructors, destructor, constructive operators
//------------------------------------------------------------------------

template <class T> gRectArray<T>::gRectArray(int rows, int cols)
  : nrows(rows), ncols(cols)
{
  assert(rows > 0 && cols > 0);
  data = new T *[nrows] - 1;
  for (int i = 1; i <= nrows; data[i++] = new T[ncols] - 1);
}

template <class T> gRectArray<T>::gRectArray(const gRectArray<T> &a)
  : nrows(a.nrows), ncols(a.ncols)
{
  data = new T *[nrows] - 1;
  for (int i = 1; i <= nrows; i++)  {
    data[i] = new T[ncols] - 1;
    for (int j = 1; j <= ncols; j++)
      data[i][j] = a.data[i][j];
  }
}

template <class T> gRectArray<T>::~gRectArray()
{
  for (int i = 1; i <= nrows; delete [] (data[i++] + 1));
  delete [] (data + 1);
}

template <class T>
gRectArray<T> &gRectArray<T>::operator=(const gRectArray<T> &a)
{
  assert(nrows == a.nrows && ncols == a.ncols);

  for (int i = 1; i <= nrows; i++)
    for (int j = 1; j <= ncols; j++)
      data[i][j] = a.data[i][j];

  return *this;
}

//------------------------------------------------------------------------
//                          Data access members
//------------------------------------------------------------------------

template <class T> int gRectArray<T>::NumRows(void) const     { return nrows; }
template <class T> int gRectArray<T>::NumColumns(void) const  { return ncols; }

template <class T> T &gRectArray<T>::operator()(int r, int c)
{
  assert(Check(r, c));
  return data[r][c];
}

template <class T> const T &gRectArray<T>::operator()(int r, int c) const
{
  assert(Check(r, c));
  return data[r][c];
}

template <class T> void gRectArray<T>::Dump(gOutput &f) const
{
  f << "{ ";
  for (int i = 1; i <= nrows; i++)  {
    if (i > 1)  f << "\n  ";
    f << "{ ";
    for (int j = 1; j <= ncols; j++)
      f << data[i][j] << ' ';
    f << "}";
  }
  f << " }\n";
}

template <class T> gOutput &operator<<(gOutput &f, const gRectArray<T> &a)
{
  a.Dump(f);   return f;
}

//------------------------------------------------------------------------
//                       Row rotation and swapping
//------------------------------------------------------------------------

template <class T> void gRectArray<T>::RotateUp(int lo, int hi)
{
  assert(lo >= 1 && hi >= lo && nrows >= hi);
  T *temp = data[lo];
  for (int k = lo; k < hi; k++)
    data[k] = data[k + 1];
  data[hi] = temp;
}

template <class T> void gRectArray<T>::RotateDown(int lo, int hi)
{
  assert(lo >= 1 && hi >= lo && nrows >= hi);
  T *temp = data[hi];
  for (int k = hi; k > lo; k--)
    data[k] = data[k - 1];
  data[lo] = temp;
}

template <class T> void gRectArray<T>::SwitchRows(int i, int j)
{
  assert(i >= 1 && i <= nrows && j >= 1 && j <= nrows);
  T *temp = data[j];
  data[j] = data[i];
  data[i] = temp;
}

