//
// FILE: lemke.imp -- Lemke-Howson module
//
// $Id$
//

#include "gwatch.h"
#include "gpvector.h"

#include "nfg.h"

#include "lemke.h"
#include "lhtab.h"

template <class T> gMatrix<T> Make_A1(const Nfg &, const NFSupport &, 
				      const T &);
template <class T> gVector<T> Make_b1(const Nfg &, const NFSupport &, 
				      const T &);
template <class T> gMatrix<T> Make_A2(const Nfg &, const NFSupport &,
				      const T &);
template <class T> gVector<T> Make_b2(const Nfg &, const NFSupport &,
				      const T &);


template <class T> class LemkeModule  {
private:
  const Nfg &NF;
  const NFSupport &support;
  const LemkeParams &params;
  long npivots;
  double time;
  T epsilon;
  int num_strats;
  gList<BFS<T> > List;
  gList<MixedSolution> solutions;

public:
  LemkeModule(const NFSupport &, const LemkeParams &);
  virtual ~LemkeModule();
  
  int Lemke(int dup = 0);
  int All_Lemke(int dup, LHTableau<T> &B, long &np, int depth);
  
  int Add_BFS(LHTableau<T> &B);
  long NumPivots(void) const;
  double Time(void) const;
  
  void AddSolutions(void);
  const gList<MixedSolution> &GetSolutions(void) const;
};


//---------------------------------------------------------------------------
//                        LemkeModule: member functions
//---------------------------------------------------------------------------

//
// Lemke is the most important routine.
// It implements the Lemke-Howson algorithm, as refined by Eaves.
// It is assumed that the starting point is a complementary basic
// feasible solution.  If not it returns 0 without doing anything.
//


template <class T> int LemkeModule<T>::Lemke(int dup)
{
  BFS<T> cbfs((T) 0);
  int i;

  if (NF.NumPlayers() != 2)   return 0;

  gWatch watch;

  List.Flush();

  try {
    gMatrix<T> A1 = Make_A1(NF, support, (T) 0);
    gVector<T> b1 = Make_b1(NF, support, (T) 0);
    gMatrix<T> A2 = Make_A2(NF, support, (T) 0);
    gVector<T> b2 = Make_b2(NF, support, (T) 0);
    LHTableau<T> B(A1,A2,b1,b2);
    epsilon = B.Epsilon();
    if ( params.stopAfter!=1 || dup==0)
      All_Lemke(0,B,npivots, params.maxdepth);
    else  {
      B.LemkePath(dup);
      Add_BFS(B);
    }
    if (params.trace >= 2)  {
      for (i = 1; i <= List.Length(); i++)   {
	List[i].Dump(*params.tracefile);
	(*params.tracefile) << "\n";
      }
    }

    AddSolutions();
    time = watch.Elapsed();
    return List.Length();
  }
  catch (gSignalBreak &E) {
    // for now, we won't give *any* solutions -- but we should list
    // any solutions found!
    throw;
  }
  // any other exceptions will propagate out.
}

template <class T> int LemkeModule<T>::Add_BFS(LHTableau<T> &B)
{
  BFS<T> cbfs((T) 0);
  cbfs = B.GetBFS();
  if ( (params.stopAfter>0 && List.Length()>params.stopAfter) 
       || List.Contains(cbfs))  
    return 0;
  if(params.trace >=2) {
    (*params.tracefile) << "\nFound CBFS";
    (*params.tracefile)  << "\nB = ";
    B.Dump(*params.tracefile);
    (*params.tracefile)  << "\ncbfs = ";
    cbfs.Dump(*params.tracefile );
  }
  List.Append(cbfs);
  return 1;
}

//
// All_Lemke finds all accessible Nash equilibria by recursively 
// calling itself.  List maintains the list of basic variables 
// for the equilibria that have already been found.  
// From each new accessible equilibrium, it follows
// all possible paths, adding any new equilibria to the List.  
//
template <class T> int LemkeModule<T>::All_Lemke(int j, LHTableau<T> &B,long &np, int depth)
{
  if(params.maxdepth!=0 && depth>params.maxdepth) return 1;
//  BFS<T> cbfs((T) 0);
  int i;
  int len;
  T p1,p2,aa;

  np+=B.NumPivots();
  if(!Add_BFS(B)) return 1;
  
  for (i = B.MinCol(); 
       i <= B.MaxCol() &&
       (params.stopAfter==0 || (List.Length()-1) < params.stopAfter);
       i++) {
    params.status.Get();
    if (i != j)  {
      len=List.Length()-1;
      p1=(double)len/(double)(len+1);
      p2=(double)(len+1)/(double)(len+2);
      aa=(double)(i)/(double)num_strats;
      params.status.SetProgress(p1+aa*(p2-p1));
//      gout << "\n i = " << i;
      LHTableau<T> Bcopy(B);
//      Bcopy.NumPivots();
      Bcopy.LemkePath(i);
      All_Lemke(i,Bcopy,np, depth+1);
//      gout << "\nend of AllLemke: " << i;
//      delete Bcopy;

    }
  }
  return 1;
}

template <class T>
const gList<MixedSolution> &LemkeModule<T>::GetSolutions(void) const
{
  return solutions;
}

template <class T> void LemkeModule<T>::AddSolutions(void)
{
  int i,j;
  int n1=support.NumStrats(1);
  int n2=support.NumStrats(2);
  solutions.Flush();

  for (i = 1; i <= List.Length(); i++)    {
    MixedProfile<T> profile(support);
    T sum = (T) 0;

    for (j = 1; j <= n1; j++)
      if (List[i].IsDefined(j))   sum += List[i](j);

    if (sum == (T) 0)  continue;

    for (j = 1; j <= n1; j++) 
      if (List[i].IsDefined(j))   profile(1, j) = List[i](j) / sum;
      else  profile(1, j) = (T) 0;

    sum = (T) 0;

    for (j = 1; j <= n2; j++)
      if (List[i].IsDefined(n1 + j))  
	sum += List[i](n1 + j);

    if (sum == (T) 0)  continue;

    for (j = 1; j <= n2; j++)
      if (List[i].IsDefined(n1 + j))
	profile(2, j) = List[i](n1 + j) / sum;
      else
	profile(2, j) = (T) 0;

    int index = solutions.Append(MixedSolution(profile, algorithmNfg_LCP));
    solutions[index].SetEpsilon(epsilon);
    // let the MixedSolution code do this:
    //    if(solutions[index].IsNash())
    //      solutions[index].SetIsPerfect(triTRUE);
  }
}

template <class T> long LemkeModule<T>::NumPivots(void) const
{
  return npivots;
}

//-------------------------------------------------------------------------
//                    LemkeModule<T>: Member functions
//-------------------------------------------------------------------------

template <class T>
LemkeModule<T>::LemkeModule(const NFSupport &S, const LemkeParams &p)
  : NF(S.Game()), support(S), params(p), npivots(0), epsilon(0),
    num_strats(S.NumStrats(1) + S.NumStrats(2))
{ }

template <class T> LemkeModule<T>::~LemkeModule()
{ }

template <class T> double LemkeModule<T>::Time(void) const
{
  return time;
}




