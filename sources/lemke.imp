//
// FILE: lemke.imp -- Lemke-Howson module
//
// $Id$
//

#include "gwatch.h"
#include "gpvector.h"

#include "nfg.h"

#include "lemke.h"

template <class T> gMatrix<T> Make_A1(const Nfg &, const NFSupport &, const T &);
template <class T> gVector<T> Make_b1(const Nfg &, const NFSupport &, const T &);
template <class T> gMatrix<T> Make_A2(const Nfg &, const NFSupport &, const T &);
template <class T> gVector<T> Make_b2(const Nfg &, const NFSupport &, const T &);


//---------------------------------------------------------------------------
//                        LemkeModule: member functions
//---------------------------------------------------------------------------

//
// Lemke is the most important routine.
// It implements the Lemke-Howson algorithm, as refined by Eaves.
// It is assumed that the starting point is a complementary basic
// feasible solution.  If not it returns 0 without doing anything.
//


template <class T> int LemkeModule<T>::Lemke(int dup)
{
  BFS<T> cbfs((T) 0);
  int i;

  if (NF.NumPlayers() != 2 || !params.tracefile)   return 0;

  gWatch watch;

  List.Flush();

  gMatrix<T> A1 = Make_A1(NF, support, (T) 0);
  gVector<T> b1 = Make_b1(NF, support, (T) 0);
  gMatrix<T> A2 = Make_A2(NF, support, (T) 0);
  gVector<T> b2 = Make_b2(NF, support, (T) 0);
  LHTableau<T> B(A1,A2,b1,b2);
  epsilon = B.Epsilon();
  if ( params.stopAfter!=1 || dup==0)
    All_Lemke(0,B,npivots);
  else  {
    B.LemkePath(dup);
    Add_BFS(B);
  }
  if (params.trace >= 2)  {
    for (i = 1; i <= List.Length(); i++)   {
      List[i].Dump(*params.tracefile);
      (*params.tracefile) << "\n";
    }
    
  }
//  if(params.trace >= 1)
//    (*params.tracefile) << "\nN Pivots = " << npivots << "\n";

  if(params.status.Get()) params.status.Reset();
  AddSolutions();
  time = watch.Elapsed();
  return List.Length();
}

template <class T> int LemkeModule<T>::Add_BFS(LHTableau<T> &B)
{
  BFS<T> cbfs((T) 0);
  cbfs = B.GetBFS();
  if ( (params.stopAfter>0 && List.Length()>params.stopAfter) 
       || List.Contains(cbfs))  
    return 0;
  if(params.trace >=2) {
    (*params.tracefile) << "\nFound CBFS";
    (*params.tracefile)  << "\nB = ";
    B.Dump(*params.tracefile);
    (*params.tracefile)  << "\ncbfs = ";
    cbfs.Dump(*params.tracefile );
  }
  List.Append(cbfs);
  return 1;
}

//
// All_Lemke finds all accessible Nash equilibria by recursively 
// calling itself.  List maintains the list of basic variables 
// for the equilibria that have already been found.  
// From each new accessible equilibrium, it follows
// all possible paths, adding any new equilibria to the List.  
//
template <class T> int LemkeModule<T>::All_Lemke(int j, LHTableau<T> &B,long &np)
{
//  BFS<T> cbfs((T) 0);
  int i;
  int len;
  T p1,p2,aa;

  np+=B.NumPivots();
  if(!Add_BFS(B)) return 1;
  
  for (i = B.MinCol(); 
       i <= B.MaxCol()  && !params.status.Get() &&
       (params.stopAfter==0 || (List.Length()-1) < params.stopAfter);
       i++)
    if (i != j)  {
      len=List.Length()-1;
      p1=(double)len/(double)(len+1);
      p2=(double)(len+1)/(double)(len+2);
      aa=(double)(i)/(double)num_strats;
      params.status.SetProgress(p1+aa*(p2-p1));
//      gout << "\n i = " << i;
      LHTableau<T> Bcopy(B);
//      Bcopy.NumPivots();
      Bcopy.LemkePath(i);
      All_Lemke(i,Bcopy,np);
//      gout << "\nend of AllLemke: " << i;
//      delete Bcopy;

    }
  return 1;
}

template <class T>
const gList<MixedSolution<T> > &LemkeModule<T>::GetSolutions(void) const
{
  return solutions;
}

template <class T> void LemkeModule<T>::AddSolutions(void)
{
  int i,j;
  int n1=support.NumStrats(1);
  int n2=support.NumStrats(2);
  solutions.Flush();

  for (i = 1; i <= List.Length(); i++)    {
    MixedProfile<T> profile(NF,support);
    T sum = (T) 0;

    for (j = 1; j <= n1; j++)
      if (List[i].IsDefined(j))   sum += List[i](j);

    if (sum == (T) 0)  continue;

    for (j = 1; j <= n1; j++) 
      if (List[i].IsDefined(j))   profile(1, j) = List[i](j) / sum;
      else  profile(1, j) = (T) 0;

    sum = (T) 0;

    for (j = 1; j <= n2; j++)
      if (List[i].IsDefined(n1 + j))  
	sum += List[i](n1 + j);

    if (sum == (T) 0)  continue;

    for (j = 1; j <= n2; j++)
      if (List[i].IsDefined(n1 + j))
	profile(2, j) = List[i](n1 + j) / sum;
      else
	profile(2, j) = (T) 0;

    int index;
    bool add = false;
    if((params.status.Get() !=1) 
//       || (params.status.Get() ==1 && profile.IsNash())
     )
      add = true;
    if(add) {
      index = solutions.Append(MixedSolution<T>(profile, NfgAlg_LEMKE));
      if(params.status.Get() != 1) {
	solutions[index].SetIsNash(T_YES);
	solutions[index].SetIsPerfect(T_YES);
	solutions[index].SetEpsilon(epsilon);
      }
    }
  }
}

template <class T> long LemkeModule<T>::NumPivots(void) const
{
  return npivots;
}

//-------------------------------------------------------------------------
//                    LemkeModule<T>: Member functions
//-------------------------------------------------------------------------

template <class T>
LemkeModule<T>::LemkeModule(const Nfg &N, const LemkeParams &p,
			    const NFSupport &S)
  : NF(N), support(S), params(p), npivots(0), epsilon(0),
    num_strats(S.NumStrats(1) + S.NumStrats(2))
{ }

template <class T> LemkeModule<T>::~LemkeModule()
{ }

template <class T> double LemkeModule<T>::Time(void) const
{
  return time;
}




