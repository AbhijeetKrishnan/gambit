//#
//# File: gpoly.imp  -- Implementation of gPoly data type
//# @(#) gpoly.imp	1.3 8/2/95
//#

#include "gpoly.h"


//---------------------------------------------------------------
//                      gPoly
//---------------------------------------------------------------

//---------------------------
// Constructors / Destructors
//---------------------------


template <class T> gPoly<T>::gPoly(const gVariableList *p)
{
  List = p; 
  Root = NULL;
}

template <class T> gPoly<T>::gPoly(const gVariableList *p, const T &constant)
{
  List = p;

  if (constant == (T)0)
    Root = NULL;
  else
    {
      Root = new Power<T>;
      Root->next = NULL;
      Root->pow = 0;
      Root->down = new term<T>;
      
      Root->down->Coef = constant;
      Root->down->down = NULL;
      Root->down->Var = (*List)[1];  
    }
                      // Since pow == 0, variable shouldn't matter
}

template <class T> gPoly<T>::gPoly(const gVariableList *p, const gString &s)
{
  List = p;
  Root = NULL;
  *this=s;
}

template <class T> gPoly<T>::gPoly(const gVariableList *p, int var_no, int exp)
{
  List = p;

  Root = new Power<T>;
  Root->next = NULL;
  Root->pow = exp;             assert(exp >= 0);
  Root->down = new term<T>;

  Root->down->Coef = (T)1;
  Root->down->down = NULL;
  Root->down->Var = (*List)[var_no];  
}

template <class T> gPoly<T>::gPoly(const gVariableList *p, 
				   exp_vect exps, 
				   T coeff)
{
  List = p;

  Root = new Power<T>;
  Power<T>* q = Root;

  for (int i = 1; i <= List->NumVariables(); i++)
    {
      q->next = NULL;
      q->pow = exps[i];          assert(exps[i] >= 0);
      q->down = new term<T>;


      q->down->Var = (*List)[i];

      if (i == List->NumVariables()) q->down->Coef = coeff;
      else q->down->Coef = (T)1;

      if (i < List->NumVariables()) 
	{
	  q->down->down = new Power<T>;
	  q = q->down->down;
	}
      else q->down->down = NULL;
    }

  Collapsor(Root, NULL);
}

template <class T> gPoly<T>::gPoly(const gPoly<T> &p)
{
  List = p.List;
  Root = NULL;
  *this=p;  
}

template <class T> gPoly<T>::~gPoly()
{
  Remover(Root);
}

//----------------------------------
//        Operators
//----------------------------------


template<class T> gPoly<T> &gPoly<T>::operator=(const gPoly<T> &p)
{
  assert (List == p.List);
  
  if (this != &p) {
    Remover(Root);
    Root = CreatDupl(p.Root);
  }
  return (*this);
}

template<class T> gPoly<T> gPoly<T>::operator-()
{
  gPoly<T> neg(*this);
  Negate (neg.Root);
  return neg;
}

template<class T> gPoly<T> gPoly<T>::operator-(const gPoly<T> &p)
{
  gPoly<T> dif(*this);
  dif -= p;
  return dif;
}

template<class T> void gPoly<T>::operator-=(const gPoly<T> &p)
{
  assert(List == p.List);

  gPoly<T> neg = p;
  Negate(neg.Root);
  Power<T> *temp;
  temp = Adder(Root, neg.Root);
  Remover (Root);
  Root = temp;
  ZeroCoefRemover(Root, NULL);
  Collapsor(Root, NULL);
}

template<class T> gPoly<T> gPoly<T>::operator+(const gPoly<T> &p)
{ 

  gPoly<T> sum(*this);
  sum += p;
  return sum;
}

template<class T> void gPoly<T>::operator+=(const gPoly<T> &p)
{
  assert(List == p.List);

  Power<T> *temp;
  temp = Adder(Root, p.Root);
  Remover (Root);
  Root = temp;
  ZeroCoefRemover(Root, NULL);
  Collapsor(Root, NULL);
}

template<class T> gPoly<T> gPoly<T>::operator*(const gPoly<T> &p)
{
  gPoly<T> prod(*this);
  prod *= p;
  return prod;
}

template<class T> gPoly<T> gPoly<T>::operator/(const T val)
{
  gPoly<T> result(*this);
  result.DividebyConst(val,result.Root);
  return result;
}

template<class T> gPoly<T> gPoly<T>::operator/(const gPoly<T> & den)
{
  return DivideByPolynomial(den);
}

template<class T> int gPoly<T>::operator==(gPoly<T> &p) const
{
  int result;
  if (List != p.List) result = 0;
  else result = Equality(Root, p.Root);
  return result;
}

template<class T> int gPoly<T>::operator!=(gPoly<T> &p) const
{
  int result;
  if (List != p.List) result = 1;
  else result = !Equality(Root, p.Root);
  return result;
}

template<class T> void gPoly<T>::operator*=(const gPoly<T> &p)
{ 
  assert(List == p.List);

  Power<T> *temp;
  temp = Mult(Root, p.Root);
  Remover(Root);
  Root = temp;
  ZeroCoefRemover(Root, NULL);
  Collapsor(Root, NULL);
}

template <class T> gPoly<T> &gPoly<T>::operator=(const gString &Hold)
{
  charnum = 0;
  int contflag = 1;
  T nega = 1;
  gArray<int> PowArray(List->NumVariables());
  TheString = Hold + " +";
  Remover(Root);
  Root = NULL;

  GetChar();

  while (charnum <= TheString.length() && contflag){
    switch (charc) {
    case '+' :
    case ' ':
      charnum++;
      GetChar();
      break;
    case '-':
      charnum++;
      GetChar();
      nega = -nega;
      break;
    case 0:  //Null termination of string
      contflag = 0;
      break;
    default:
      String_Term(nega);
      nega = T (1);
      break;
    }
  }
  return (*this);
}


//----------------------------------
//        Member Functions
//----------------------------------

template <class T> void gPoly<T>::String_Term(T nega)
{
  gArray<int> PowArray(List->NumVariables());
  for (int a=1; a<= List->NumVariables(); a++) PowArray[a] = 0;
  T val;
  val = String_Coeff(nega);
  
  while (charc != '+' && charc != '-') {
    if (charc == ' ') { charnum ++; GetChar(); }
    else String_VarAndPow(PowArray);
  }
  SetCoef( PowArray, val);
}

//  **  Different String_Coeff procedure for Different Instantiations **
//  **  So that the parser will interpret the coefficients correctly  **

template <class T> int gPoly<T>::String_Coeff(int nega)
{
  gString Coeff = "";
  while (charc >= '0' && charc <= '9'){
    Coeff += charc;
    charnum++;
    GetChar();
  }
  if (Coeff == "") return (nega);
  else return (nega * atoi(Coeff.stradr()));  
}

template <class T> long gPoly<T>::String_Coeff(long nega)
{
  gString Coeff = "";
  while (charc >= '0' && charc <= '9'){
    Coeff += charc;
    charnum++;
    GetChar();
  }
  if (Coeff == "") return (nega);
  else return (nega * atol(Coeff.stradr()));  
}

template <class T> double gPoly<T>::String_Coeff(double nega)
{
  double doub;
  gString Coeff = "";
  while (charc >= '0' && charc <= '9' || charc == '.'){
    Coeff += charc;
    charnum++;
    GetChar();
  }
  if (Coeff == "") return (nega);
  else return (nega * FromString(Coeff,doub));  
}

template <class T> gRational gPoly<T>::String_Coeff(gRational nega)
{
  gRational rat;
  gString Coeff = "";
  while (charc >= '0' && charc <= '9' || charc == '/' || charc == '.'){
    Coeff += charc;
    charnum++;
    GetChar();
  }
  if (Coeff == "") return (nega);
  else return (nega * FromString(Coeff,rat));  
}

template <class T> int gPoly<T>::String_GetPow(void)
{

  gString Pow = "";
  while (charc == ' '){
    charnum++;
    GetChar();
  }

  while (charc >= '0' && charc <= '9'){
    Pow += charc;
    charnum++;
    GetChar();
  }
  return (atoi(Pow.stradr()));
}

template <class T> void gPoly<T>::String_VarAndPow(gArray<int> &PowArray)
{
  gString VarName = "";
  int pow, varname;
  while (charc != '^' && charc != ' '){
    VarName += charc;
    charnum++;
    GetChar();
  }
  if (charc == '^') { charnum++; GetChar(); pow = String_GetPow(); }
  else pow = 1;
  for(varname = 1;varname <= List->NumVariables() &&  
      VarName != (List->VariableWithNumber(varname))->Name;
      varname ++);
  if (varname <= List->NumVariables()) PowArray[varname] = pow;
}

template <class T> void gPoly<T>::GetChar(void)
{
  charc = TheString[charnum];
}
  
template <class T> gVariableList* gPoly<T>::GetList(void) const
{
  return (gVariableList *)List;
}

template <class T> int gPoly<T>::DegreeOfVar(int var_no) const
{
  return DegreeOfVar(var_no, Root);
}

template <class T> int gPoly<T>::TotalDegree() const
{
  return TotalDegree(Root);
}

template <class T> void gPoly<T>::SetCoef(const gArray<int> &Powers, 
				       const T &value)
{
  Power<T> *found;


  assert (Powers.First() == 1 && Powers.Last() == List->NumVariables());
  
  found = Locator(Powers,1,Root);

  if (found == NULL && value != T (0) ) {
    CreateTree(Powers,1,&Root,value); 
    Collapsor(Root, NULL);
  }
  else if (found != NULL){ 
    found->down->Coef = value;
    if (value == 0) {
      ZeroCoefRemover(Root,NULL);
      Collapsor(Root, NULL);
    }  
  }
}

template <class T> T gPoly<T>::GetCoef(const gArray<int> &Powers) const
{
  Power<T> *found;
  assert (Powers.First() == 1 && Powers.Last() == List->NumVariables());

  found = Locator(Powers,1,Root);
  if (found == NULL) return (T (0) );
  else return (found->down->Coef);
}

template <class T> T gPoly<T>::GetCoef(const exp_vect &Powers) const
{
  const Power<T>* found = Locator(Powers,Root);
  if (found == NULL) return (T)0;
  return found->down->Coef;
}

template <class T> T gPoly<T>::NumLeadCoeff() const
{
  assert (TotalDegree() == 0);

  if ( *this == gPoly<T>(List,(T)0) ) return (T)0;
  else return Root->down->Coef;
}

template <class T> T gPoly<T>::Evaluate(const gArray<T> &values) const
{
  T answer=0;
  evaluator (values, Root, 1, answer);
  return (answer);
}  
  

template <class T> void gPoly<T>::Print_Newt_Pltp(gOutput &f) const
{
  polyhedron np = NewtonPolytope();

  f << "\n\n" << np;
} 
  

template <class T> void gPoly<T>::Print(gOutput &f) const
{
  gString answer;
  printer (Root,"",answer,List);
  if (answer == "") answer = " 0";
  f << answer;
} 

template <class T> void gPoly<T>::Print(gString &s) const
{  
  s = "";
  printer(Root,"",s,List);
}


template <class T> void gPoly<T>::Remover(Power<T> *source) 
{
  Power<T> *i,*temp;
  for (i = source; i!=NULL; i=temp){
    if (i->down->down != NULL) Remover (i->down->down);
    delete i->down;
    temp = i->next;
    delete i;
  }
}


template <class T> Power<T> *gPoly<T>::CreatDupl(Power<T> *source)
{
  if (source != NULL){
    Power<T> *i, *j = new Power<T>, *dest;
    
    dest = j;
    for (i = source; i!=NULL; i=i->next){
      j->down = new term<T>;

      j->down->Coef = i->down->Coef;
      j->down->Var = i->down->Var;
      j->down->down = CreatDupl(i->down->down);
      j->pow = i->pow;                          assert(i->pow >= 0);

      if (i->next == NULL) j->next = NULL;
      else j->next = new Power<T>;
      j=j->next;
    }
    return dest;
  }
  else return NULL;
}
    
      
template <class T> const Power<T>*
gPoly<T>::Locator(const exp_vect &Powers, const Power<T> *p) const
{
  gArray<int> arrayexps(List->NumVariables());
  for (int i = 1; i <= List->NumVariables(); i++)
    arrayexps[i] = Powers[i];

  return Locator(arrayexps,1,(Power<T>*)p);
                   // Below is complicated, but debugged
}
      
template <class T> Power<T>*
gPoly<T>::Locator(const gArray<int> &Powers, int i, Power<T> *p) const
{
  Power<T> *j;
  Power<T> *result;

  
  if (( p != NULL && p->down->Var->number > (*List)[i]->number ||
      p == NULL) && Powers[i] == 0 && i < List->NumVariables()){
    result = Locator(Powers, i+1, p);
  }
  else if (( p != NULL && p->down->Var->number > (*List)[i]->number ||
      p == NULL) && Powers[i] == 0 && i == List->NumVariables()){
    result = p; 
  }
  else {
    for (j = p; j != NULL && j->pow < Powers[i] 
	 && j->down->Var->number == (*List)[i]->number; j = j->next) ;
    
    if (j == NULL || 
	(j->pow > Powers[i] &&
	 j->down->Var->number == (*List)[i]->number)){         
      result = NULL; 
    }
    else if (i == List->NumVariables() && j->down->down == NULL ) 
      result = j;
    else { 
      if (j->down->down != NULL)
	result = Locator(Powers, i+1, j->down->down);
      else if (ZeroCheck(Powers) <= i && 
	       j->down->Var->number == (*List)[i]->number){
	result = j;
      }
      else result = NULL; 
    }
  }  
  return result;	
}


template <class T> int gPoly<T>::ZeroCheck(const gArray<int> &Powers) const
{
  int j=0;
  for (int i = 1; i<= Powers.Last(); i++)
    if (Powers[i] != 0) j=i;
  return j;
}

template <class T> polyhedron gPoly<T>::NewtonPolytope() const
{
  polyhedron newt_pol(List->NumVariables(), No_Monomials());
  for (int i = 1; i <= No_Monomials(); i++)
    for (int j = 1; j <= List->NumVariables(); j++)
      newt_pol.set_coord(i,j-1,0);

  int count = 0;

  newton_polytope(Root, count, newt_pol); 

  return newt_pol;
}


template <class T> void gPoly<T>::newton_polytope(Power<T> *base, 
						  int &count, 
					          polyhedron &np) 
                                                const
{
  Power<T> *p;
  Power<T> *q;

  for (p = base; p!=NULL; p=p->next) {
    count++;
    int current_count = count;
    q = p;
    while ( q->down->down != NULL) {       
      np.set_coord(current_count, q->down->Var->number - 1, q->pow);
      q = q->down->down;
      newton_polytope(q->next, count, np);
    }
    np.set_coord(current_count, q->down->Var->number - 1, q->pow);
  }
}


template <class T> bool gPoly<T>::ExpVect(const Power<T>* here, 
					  const Power<T>* target, 
					  exp_vect& current) const
{
  if (here == target) {
    Power<T>* p = (Power<T>*)here;
    while (p != NULL) {
      current.SetExp(p->down->Var->number,p->pow);
      p = p->down->down;
    }
    return true;
  }

  exp_vect copy = current;
  Power<T>* p = (Power<T>*)here;
  while (p != NULL) {
    if (p->next != NULL && ExpVect(p->next,target,copy)) {
	current = copy;
	return true;
      }
    copy.SetExp(p->down->Var->number,p->pow);
    p = p->down->down;
  }

  return false;
}


template <class T> exp_vect gPoly<T>::ExpVect(const Power<T> *target) const
{
  exp_vect result(List);   // initializes to 0 vector
  bool success = ExpVect(Root,target,result);     assert(success);
  return result;
}


template <class T> void gPoly<T>::count_monomials(Power<T> *base, 
						  int &count) const
{
  Power<T> *p;
  Power<T> *q;

  for (p = base; p!=NULL; p=p->next) {
    count++;
    q = p;
    while ( q->down->down != NULL) {       
      q = q->down->down;
      count_monomials(q->next, count);
    }
  }
}


template <class T> int gPoly<T>::No_Monomials() const
{
  int count = 0;
  count_monomials(Root, count);
  return count;
}


template <class T> void gPoly<T>::printer(Power<T> *base, gString woCoef, 
					  gString &s, 
					  const gVariableList* List) const
{
  gString wCoef, nwoCoef;
  Power<T> *p;
  for (p = base; p!=NULL; p=p->next)
    {
      wCoef = "";
      if ( p->down->down != NULL) 
	{
	  nwoCoef = woCoef;
	  if (p->pow != 0){
	    nwoCoef += ' ';
	    nwoCoef += ((*List)[p->down->Var->number])->Name;
	    if (p->pow != 1){
	      nwoCoef += '^';
	      nwoCoef += ToString(p->pow);
	    }
	  }
	  printer(p->down->down, nwoCoef, s, List);
	}
      else
	{
	  wCoef = ' ';
	  wCoef += GetCoefToString(p->down->Coef);
	  wCoef += woCoef;
	  if (p->pow != 0) 
	    {
	      wCoef += ' ';
	      wCoef += ((*List)[p->down->Var->number])->Name;
	      if (p->pow != 1)
		{
		  wCoef += '^';
		  wCoef += ToString(p->pow);
		}
	    }      
	  if (s == "") s = wCoef;
	  else { s += " +"; s += wCoef;}
	}
    }
}

// ** different GetCoefToString for each instantiation **

template <class T> gString gPoly<T>::GetCoefToString( int val ) const
{
  gString Coeff = ToString(val);
  return (Coeff);
}

template <class T> gString gPoly<T>::GetCoefToString( long val ) const
{
  gString Coeff = ToString(val);
  return (Coeff);
}

template <class T> gString gPoly<T>::GetCoefToString( double val ) const
{
  gString Coeff = ToString(val);
  return (Coeff);
}

template <class T> gString gPoly<T>::GetCoefToString( gRational val ) const
{
  gString Coeff = ToString(val, false);
  return (Coeff);
}


template <class T> void gPoly<T>::evaluator( const gArray<T> &values, 
					    Power<T> *base,T woAns, T &t) const

{
  T wAns, nwoAns;
  Power<T> *p;
  
  for (p = base; p!=NULL; p=p->next){
    
    if (p->down->down == NULL) {
      wAns = p->down->Coef * woAns * 
	T (pow (values[p->down->Var->number], p->pow));
      t += wAns;
    }
    else {
      nwoAns = T (pow (values[p->down->Var->number], p->pow)) * woAns;
      evaluator( values, p->down->down, nwoAns, t);
    }
  }
}


template <class T> void gPoly<T>::Collapsor(Power<T> *base, Power<T> *caller)
{
  Power<T> *p, *temp, *k;
  for(p = base, k = caller; p != NULL; k = p, p = temp){
    temp = p->next;
    if (p->down->down != NULL) Collapsor(p->down->down, p);
    if (p->pow == 0 && p->next == NULL && caller == k){
      if (caller != NULL || p->down->down != NULL) {
	if (caller == NULL) Root = p->down->down;
	else caller->down->down = p->down->down;
	if (p->down->down == NULL) caller->down->Coef = p->down->Coef;
	delete (p->down);
	delete p;
	temp = NULL;
      }
    }
  }
}
    
template <class T> void gPoly<T>::ZeroCoefRemover(Power<T> *base, 
						  Power<T> *caller)
{
  Power<T> *p, *temp, *k;
  for (p = base, k = caller; p != NULL; k = p, p = temp){
    temp = p->next;
    if (p->down->down != NULL) ZeroCoefRemover(p->down->down, p);
    if  (p->down->Coef == (T) 0 && p->down->down == NULL){
      if (caller == NULL && k == caller)  
	Root = p->next; 
      else if (k == caller) { 
	k->down->down = p->next; 
	if (k!=NULL) k->down->Coef =(T)0;
      }
      else 
	k->next = p->next; 
      delete (p->down);
      delete (p);
      p = k;
    }
  }
}

template <class T> int gPoly<T>::DegreeOfVar(int var_no, 
					     Power<T> *start) const
{
  if (start == NULL) return 0;

  int cur_max = 0;
  Power<T>* Pp = start;
  do {
    if (Pp->down->Var->number == var_no && Pp->pow > cur_max)
      cur_max = Pp->pow;
    if (Pp->next != NULL) { 
      int tmp = DegreeOfVar(var_no, Pp->next);
      if (tmp > cur_max) cur_max = tmp;
    }	
    Pp = Pp->down->down;
  }
  while (Pp != NULL);

  return cur_max;
}

template <class T> int gPoly<T>::TotalDegree(Power<T> *start) const
{
  if (start == NULL) {  return 0; }

  int cur_max = 0;
  int total = 0;

  Power<T>* Pp = start;
  do {
    total += Pp->pow;

    if (Pp->next != NULL) { 
      int tmp = TotalDegree(Pp->next);
      if (tmp > cur_max) cur_max = tmp;
    }
    Pp = Pp->down->down;
  }
  while (Pp != NULL);

  if (total > cur_max)
    return total;
  else
    return cur_max;
}

template <class T> void gPoly<T>::CreateTree(const gArray<int> &Powers, int i,
					     Power<T> **p, T val)
     
{
  Power<T> *j, *k, *temp; 
  
  k=*p;
  
  if ( (*p != NULL && (*p)->down->Var->number > (*List)[i]->number ||
      *p == NULL) && Powers[i] == 0 && i < List->NumVariables()){
    CreateTree (Powers, i+1, p, val);
  }
  else {

    for (j = *p; j != NULL && j->pow < Powers[i] 
	 && j->down->Var->number == (*List)[i]->number; 
	 k = j, j = j->next) ;
 
    if (j == NULL || 
	(j->pow > Powers[i] && 
	 j->down->Var->number == (*List)[i]->number)){         
      
      temp = new Power<T>;
      if (*p==NULL || j==*p) { temp->next = *p; *p = temp; }
      else { temp->next = k->next; k->next = temp;}
      temp->down = new term<T>;
      temp->down->Var = (*List)[i];
      temp->down->down = NULL; 
      temp->pow = Powers[i];                 assert(Powers[i] >= 0);
      k = temp;
      for (i++; i <= List->NumVariables(); i++){
	if (Powers[i] != 0){
	  temp = new Power<T>;
	  k->down->down = temp;
	  temp->down = new term<T>;
	  temp->down->Var = (*List)[i];
	  temp->down->down = NULL;
	  temp->pow = Powers[i];            assert(Powers[i] >= 0);
	  temp->next = NULL;
	  k = temp;
	}
      }
     
      k->down->Coef = val;
      
      
    }  
    else if (j->down->Var->number > (*List)[i]->number){
      temp = new Power<T>;
      temp->down = new term<T>;
      temp->down->Var = (*List)[i];
      temp->down->down = j;
      temp->pow = 0;
      temp->next = NULL;
      if (j == *p ) *p = temp;
      else k->down->down = temp;
      CreateTree(Powers, i, p, val);
      
    }
    else if (j->down->down == NULL && i < List->NumVariables()){
      temp = new Power<T>;
      temp-> down = new term<T>;
      temp->down->Coef = j->down->Coef;
      temp->down->Var = (*List)[i+1];
      temp->down->down = NULL;
      temp->pow = 0;
      temp->next = NULL;
      j->down->down = temp;
      CreateTree(Powers, i+1, &(j->down->down), val);
    }
    else if (i < List->NumVariables()) 
      CreateTree(Powers, i+1, &(j->down->down), val);
  }    
}

template <class T> Power<T> *gPoly<T>::Adder( Power<T> *One, Power<T> *Two)
{
  Power<T> *i, *j, *k, *pk, *kRoot, *nexti, *nextj, *temp, *temp2, *one, *two;
  kRoot = NULL;
  
  one = One; two = Two;
  
  if (one != NULL && two != NULL &&
      two->down->Var->number != one->down->Var->number){
    kRoot = new Power<T>;
    kRoot->pow = 0;  
    kRoot->down = new term<T>;
    if (two->down->Var->number < one->down->Var->number){
      temp = one; one = two; two = temp;
    }
    if (two->down->Var->number > one->down->Var->number){
      temp = LowZero(two);
      if (one->pow == 0 && one->down->down == NULL && temp != NULL){
	if (temp->down->down == NULL){
	  k = CreatDupl(two);
	  LowZero(k)->down->Coef += one->down->Coef;
	  kRoot->next = CreatDupl(one->next);
	  kRoot->down->Var = one->down->Var;
	  kRoot->down->down = k;
	}
	else {
	  k = CreatDupl(two);
	  temp = LowZero(k);
	  temp2 = new Power<T>;
	  temp2->down = new term<T>;
	  temp2->pow = 0;
	  temp2->down->Var = temp->down->down->down->Var;
	  temp2->down->Coef = one->down->Coef;
	  temp2->down->down = NULL;
	  temp2->next = temp->down->down;
	  temp->down->down = temp2;
	  kRoot->next = CreatDupl(one->next);
	  kRoot->down->Var = one->down->Var;
	  kRoot->down->down = k;
	  
	}
      }
      else if (one->pow == 0 && one->down->down == NULL && temp == NULL){
	k = CreatDupl(two);
	temp2 = new Power<T>;
	temp2->down = new term<T>;
	temp2->pow = 0;
	temp2->down->Var = k->down->Var;
	temp2->down->Coef = one->down->Coef;
	temp2->down->down = NULL;
	temp2->next = k;
	k = temp2;
	kRoot->next = CreatDupl(one->next);
	kRoot->down->Var = one->down->Var;
	kRoot->down->down = k;
      }
      else {
	if (one->pow == 0) kRoot->next = CreatDupl(one->next);
	else kRoot->next = CreatDupl(one);
	kRoot->down->Var = one->down->Var;
	kRoot->down->down = Adder(one->down->down, two);
      }	
    }    
  }
  
  
  else {
    for (i = one, j = two, pk = NULL; i != NULL 
	 || j!=NULL; i = nexti, j = nextj, pk = k){
      if (i == NULL) {
	if (pk == NULL) kRoot = CreatDupl(j);
	else pk->next = CreatDupl(j);
	nexti = NULL; nextj = NULL;
      }
      else if (j == NULL) {
	if (pk == NULL) kRoot = CreatDupl(i);
	else pk->next = CreatDupl(i);
       	nexti = NULL; nextj = NULL;
      }
      else if (j->pow != i->pow){ 
	k = new Power<T>;
	k->next = NULL;
	k->down = new term<T>;
	if ( j->pow > i->pow) {
	  k->pow = i->pow;
	  k->down->Var = i->down->Var;
	  if (i->down->down == NULL) k->down->Coef = i->down->Coef;
	  k->down->down = CreatDupl(i->down->down);
	  nexti = i->next; nextj = j;
	}
	else {
	  k->pow = j->pow;
	  k->down->Var = j->down->Var;
	  if (j->down->down == NULL) k->down->Coef = j->down->Coef;
	  k->down->down = CreatDupl(j->down->down);
	  nexti = i; nextj = j->next;
	}	
	if (pk == NULL) kRoot = k;
	else pk->next = k;
      }

      else { 
	nexti = i->next; nextj = j->next; 
	if (i->down->down == NULL && j->down->down == NULL){
	  k = new Power<T>;
	  k->next = NULL;
	  k->down = new term<T>;
	  k->pow = i->pow;                               assert(i->pow >= 0);
	  k->down->Coef = j->down->Coef + i->down->Coef;
	  k->down->Var = i->down->Var;
	  k->down->down = NULL;

	}
	else if (i->down->down != NULL && j->down->down == NULL ||
	      i->down->down == NULL && j->down->down != NULL) {

	  k = new Power<T>;
	  k->down = new term<T>;
	  k->next = NULL;
	  k->pow = i->pow;                assert(i->pow >= 0);
	  k->down->Var = i->down->Var;

	  if (i->down->down != NULL) k->down->down = CreatDupl(i->down->down);
	  else k->down->down = CreatDupl(j->down->down);

	  temp = LowZero(k);

	  if (temp == NULL || temp->down->down != NULL) {
	    temp2 = new Power<T>;
	    temp2->down = new term<T>;
	    temp2->pow = 0;
	    if (i->down->down != NULL) {
	      temp2->down->Coef = j->down->Coef;
	    }
	    else {
	      temp2->down->Coef = i->down->Coef;
	    }
	    temp2->down->down = NULL;
	    if (temp == NULL) { 
	      if (j->down->down != NULL)
		temp2->down->Var = j->down->down->down->Var;
	      else temp2->down->Var = i->down->down->down->Var;
	      temp2->next = k->down->down;
	      k->down->down = temp2;
	    }
	    else {
	      temp2->down->Var = temp->down->down->down->Var;
	      temp2->next = temp->down->down;
	      temp->down->down = temp2;
	    }
	  }
	  else if (temp->down->down == NULL){ 
	    if (i->down->down != NULL)
	      temp->down->Coef += j->down->Coef;
	    else 
	      temp->down->Coef += i->down->Coef; 
	  } 
	  if (pk == NULL) kRoot = k;
	  else pk->next = k;
	}
	else {
	  k = new Power<T>;
	  k->next = NULL;
	  k->down = new term<T>;
	  k->pow = i->pow;              assert(i->pow >= 0);
	  k->down->Var = i->down->Var;
	  k->down->down = Adder (i->down->down, j->down->down);
	  if (pk == NULL) kRoot = k;
	  else pk->next = k;
	}
	if (pk == NULL) kRoot = k;
	else pk->next = k;
      }
    }       
  }
  return kRoot;
}

template <class T> Power<T> *gPoly<T>::LowZero(Power<T> *start)
{
  Power<T> *p;
  for (p = start; p->down->down != NULL &&
       p->down->down->pow == 0; p=p->down->down);
  if (p == start && start->pow != 0)
    return NULL;
  else return p;
}

template <class T> void gPoly<T>::Negate(Power<T> *start)
{
  MultbyConst( T (-1), start);
}


template <class T> void gPoly<T>::MultbyConst(T val, Power<T> *start)
{
  for (Power<T> *p = start; p!=NULL; p=p->next){
    if (p->down->down == NULL) p->down->Coef = val * (p->down->Coef);
    else MultbyConst(val,p->down->down);
  }
}

template <class T> void gPoly<T>::DividebyConst(T val, Power<T> *start)
{
  assert(val != (T) 0);
  for (Power<T> *p = start; p!=NULL; p=p->next)
    {
      if (p->down->down == NULL) 
	p->down->Coef = (p->down->Coef) / val;
      else DividebyConst(val, p->down->down);
    }
}


template <class T> gPoly<T> gPoly<T>::DivideByPolynomial(const gPoly<T> den)
{
  assert( den != gPoly<T>(List,(T)0) );
  assert(*this == gPoly<T>(List,(T)0) || den.TotalDegree() <= TotalDegree());

  // assumes exact divisibility!

  gPoly<T> result = gPoly<T>(List,(T)0);

  if ( *this == gPoly<T>(List,(T)0) ) return result;
  else if (den.TotalDegree() == 0)
    { result = *this/den.NumLeadCoeff(); return result; }
  else
    {
      int last = List->NumVariables();
      while (den.DegreeOfVar(last) == 0) last--;

      gPoly<T> remainder = *this;

      while ( remainder != gPoly<T>(List,(T)0) )
	{
	  gPoly<T> quot = remainder.LeadingCoefficient(last) /
	                     den.LeadingCoefficient(last);
	  gPoly<T> power_of_last(List,last,remainder.DegreeOfVar(last) - 
			                        den.DegreeOfVar(last));
	  result += quot * power_of_last;
	  remainder -= quot * power_of_last * den;
	}
    }
  return result;
}

template <class T> int gPoly<T>::Equality( Power<T> *one, Power<T> *two ) const
{
  Power<T> *k, *j;
  int result = 1;
  for (k = one, j = two; k != NULL && j != NULL && result; 
       j=j->next, k=k->next){
    if (j->pow != k->pow || (j->down->Var != k->down->Var && 
			     (j->pow != 0 || k->pow != 0))) 
      result = 0; 
    else if (j->down->down == NULL && k->down->down == NULL && 
	     j->down->Coef != k->down->Coef) result = 0;
    else if (j->pow == 0 && j->down->down == NULL && k->down->down == NULL && 
	     j->down->Coef == k->down->Coef) result = 1;
    else result *= Equality( j->down->down, k->down->down);
  } 
  if (j != NULL || k != NULL) result = 0;
  return result;
}
  

template <class T> Power<T> *gPoly<T>::Mult(Power<T> *One, Power<T> *Two)
{
  Power<T> *i, *j, *k, *pk, *kRoot, *temp, *temp2, *temp3, *ptemp;
  Power<T> *one, *two;
  kRoot = NULL;
  pk = NULL;
  one = One; two = Two;

  if (one == NULL || two == NULL)
    kRoot = NULL;

  else if (one != NULL && two != NULL &&
	   two->down->Var->number != one->down->Var->number) {
    if (two->down->Var->number < one->down->Var->number){
      temp = one; one = two; two = temp;
    }
    for (i = one; i != NULL; i = i->next, pk = k) {
      k = new Power<T>;
      k->down = new term<T>;
      k->next = NULL;
      k->pow = i->pow;	             assert(i->pow >= 0);
      k->down->Var = i->down->Var;
      if (i->down->down != NULL)
	k->down->down = Mult(i->down->down,two); // Recurse
      else {
	k->down->down = CreatDupl(two);
	MultbyConst(i->down->Coef, k->down->down);
      }
      if (pk == NULL) kRoot = k;
      else pk->next = k;
    }
  }

  else {
    pk = NULL;
    for (i = one; i != NULL; i = i->next, pk = k) {
      for (j = two; j != NULL; j = j->next, pk = k) {
	k = new Power<T>;
	k->down = new term<T>;
	k->next = NULL;
	k->pow = i->pow + j->pow;     assert(i->pow >= 0 && j->pow >= 0);
	k->down->Var = i->down->Var;

	if (i->down->down != NULL && j->down->down != NULL)
	  k->down->down = Mult(i->down->down, j->down->down);
	else if (i->down->down == NULL && j->down->down != NULL) {
	  k->down->down = CreatDupl(j->down->down);
	  MultbyConst(i->down->Coef, k->down->down);
	}	
	else if (i->down->down != NULL && j->down->down == NULL) {
	  k->down->down = CreatDupl(i->down->down);
	  MultbyConst(j->down->Coef, k->down->down);
	}
	else {
	  k->down->down = NULL; 
	  k->down->Coef = (i->down->Coef) * (j->down->Coef);
	}
	for (ptemp = NULL, temp = kRoot; temp!=NULL && temp->pow < k->pow; 
	     ptemp = temp, temp = temp->next);
	if (temp == NULL || temp->pow > k->pow ) {
	  if (pk == NULL) kRoot = k;
	  else pk->next = k;
	}
	else {
	  temp3 = temp->next;
	  temp->next = NULL;
	  temp2 = Adder(temp, k);
	  temp2->next = temp3;
	  if (ptemp == NULL) kRoot = temp2;
	  else ptemp->next = temp2;
	  if (temp == pk) pk = temp2;
	  Remover(k);
	  Remover(temp);
	  k = pk;
	}	
      }
    }
  }
  return kRoot;
}

template <class T> gPoly<T> gPoly<T>::EvaluateOneVar( int varnumber, T val)
{
  gPoly<T> newPoly(*this); 
  
  newPoly.Root = newPoly.EvalVar(varnumber, val, newPoly.Root);
  newPoly.ZeroCoefRemover(newPoly.Root,NULL);
  newPoly.Collapsor(newPoly.Root,NULL);
  return (newPoly);
}

template <class T> 
Power<T> *gPoly<T>::EvalVar( int num, T val, Power<T> *start)
{
  Power<T> *p, *temp, *temp2, *accumulator = NULL;
  
  if (start == NULL) accumulator = NULL;
  else if (start->down->Var->number < num){
    for (p = start; p!=NULL; p = p->next){
      if (p->down->down != NULL) 
	p->down->down = EvalVar(num, val, p->down->down);
      accumulator = start;
    }
  }
  else if(start->down->Var->number == num){
    for (p = start; p!=NULL; p = temp){
      temp = p->next;
      p->next = NULL;
      MultbyConst (T (pow(val, p->pow)), p);
      p->pow = 0;
      temp2 = accumulator;
      accumulator = Adder(p, accumulator);
      Remover(temp2);
      Remover(p);
    }
  }
  else if(start->down->Var->number > num){
    accumulator = start;
  }
  return accumulator;
}

template <class T>
exp_vect  gPoly<T>::LeadingPowProd(const term_order & order, 
				   const Power<T>* start) const
{
  exp_vect answer = ExpVect(start);
  for (Power<T>* p = (Power<T>*)start; p != NULL; p = p->down->down)
    if (p->next != NULL) 
      {
	exp_vect candidate = LeadingPowProd(order,p->next);

/*
//DEBUG
	if (order.Greater(candidate,answer))
	  gout << candidate << " Gr(reversedeglex) " << answer << "\n";
	else
	  gout << candidate << " LEq(reversedeglex) " << answer << "\n";
*/

	if (order.Greater(candidate,answer))
	  answer = candidate;
      }
  return answer;
}

template <class T>
Power<T>* gPoly<T>::OrderMaxMonomialDivisibleBy(const term_order& order,
						const Power<T>* start,
						const exp_vect& expv)
{
  Power<T>* answer;
  if (ExpVect(start) >= expv)
    answer = (Power<T>*)start;
  else
    answer = NULL;

  for (Power<T>* p = (Power<T>*)start; p != NULL; p = p->down->down)
    if (p->next != NULL) 
      {
	Power<T>* candidate = OrderMaxMonomialDivisibleBy(order,p->next,expv);
	if ( candidate != NULL &&
	     (answer == NULL || 
	      order.Greater(ExpVect(candidate),ExpVect(answer))) )
	  answer = candidate;
      }
  return answer;
}

template <class T>
Power<T>* gPoly<T>::OrderMaxMonomialDivisibleBy(const term_order& order,
						const exp_vect& expv)
{
  return OrderMaxMonomialDivisibleBy(order,Root,expv);
}

template <class T>
T gPoly<T>::LeadingCoeff(const term_order & order, 
				   const Power<T>* start) const
{
  T answer = (T)0;
  Power<T>* p;
  for (p = (Power<T>*)start; p != NULL; p = p->down->down)
    if (p->down->down == NULL)
      answer = p->down->Coef; 
  exp_vect expv = ExpVect(start);

  for (p = (Power<T>*)start; p != NULL; p = p->down->down)
    if (p->next != NULL) {
      exp_vect candidate = LeadingPowProd(order,p->next);
      if (order.Greater(candidate,expv)) { 
	answer = LeadingCoeff(order,p->next);
	expv = candidate;
      }
    }
  return answer;
}

template <class T> gPoly<T> gPoly<T>::PartialDerivative(int varnumber)
{
  gPoly<T> newPoly(*this); 

  int pow_of_var = 0;

  if (newPoly.Root != NULL)
    {
      newPoly.Root = newPoly.PrtlDrvtv(varnumber, newPoly.Root, pow_of_var);
      newPoly.ZeroCoefRemover(newPoly.Root,NULL);
      newPoly.Collapsor(newPoly.Root,NULL);
    }
  return (newPoly);
}

template <class T> Power<T> *gPoly<T>::PrtlDrvtv(int num, 
						 Power<T> *start,
						 int pow_of_var)
{
  Power<T> *q;
  Power<T> *temp;

  for (q = start; q != NULL; q = q->down->down)
    { 	
      if (q->down->Var->number == num)
	{
	  pow_of_var = q->pow;
	  if (q->pow > 0) (q->pow)--;      assert(q->pow >= 0);
	}
      if (q->down->down == NULL) temp = q;

      if (q->next != NULL) PrtlDrvtv(num, q->next, pow_of_var);     // Recurse
    }
  temp->down->Coef *= (T)pow_of_var;
  return start;
}

template <class T> gPoly<T> gPoly<T>::LeadingCoefficient(int varnumber)
{
  gPoly<T> newPoly(*this); 

  int degree = DegreeOfVar(varnumber);

  if (degree == 0)
    return newPoly;
  else
    {
      if (newPoly.Root != NULL)
	{
	  bool keep = false;
	  newPoly.Root = newPoly.LdngCffcnt(varnumber, degree, 
					    newPoly.Root, keep);
	  newPoly.ZeroCoefRemover(newPoly.Root,NULL);
	  newPoly.Collapsor(newPoly.Root,NULL);
	}
    }
  return (newPoly);
}

template <class T> Power<T> *gPoly<T>::LdngCffcnt(int num, int degree, 
						  Power<T> *start,
						  bool keep)
{
  Power<T> *q;
  Power<T> *temp;

  for (q = start; q != NULL; q = q->down->down)
    { 	
      if (q->down->Var->number == num && q->pow == degree)
	{ keep = true; q->pow = 0; }
      if (q->down->down == NULL) temp = q;

      if (q->next != NULL) LdngCffcnt(num, degree, q->next, keep);  // Recurse
    }
  if (degree != 0 && keep == false)
    temp->down->Coef = (T)0;

  return start;
}

//--------------------
// Term Order Concepts
//--------------------

template <class T> 
exp_vect gPoly<T>::LeadingPowerProduct(const term_order & order) const
{
  return LeadingPowProd(order,Root);
}

template <class T> 
T gPoly<T>::LeadingCoefficient(const term_order & order) const
{
  return LeadingCoeff(order,Root);
}

template <class T>
gPoly<T> gPoly<T>::LeadingTerm(const term_order & order) const
{
  return gPoly<T>(List,LeadingPowerProduct(order),LeadingCoefficient(order));
}

template <class T>
void gPoly<T>::ReduceByDivisionAtExpV(const term_order & order, 
				      const gPoly<T> & divisor, 
				      const exp_vect & expv)
{
  assert(expv >= divisor.LeadingPowerProduct(order));

  gPoly<T> factor(this->List, expv - divisor.LeadingPowerProduct(order), (T)1);

  *this -= (GetCoef(expv) / divisor.LeadingCoefficient(order)) * 
           factor * divisor;
}

template <class T>
void gPoly<T>::ReduceByRepeatedDivision(const term_order & order, 
					const gPoly<T> & divisor)
{
  Power<T>* exps = OrderMaxMonomialDivisibleBy(order,
			       divisor.LeadingPowerProduct(order));
  while (exps != NULL) {
    ReduceByDivisionAtExpV(order, divisor, ExpVect(exps));
    exps = OrderMaxMonomialDivisibleBy(order,
      		       divisor.LeadingPowerProduct(order));
  }
}

template <class T>
gPoly<T> gPoly<T>::S_Polynomial(const term_order & order, 
                                const gPoly<T> & arg2)
{
  exp_vect exp_lcm = 
        (LeadingPowerProduct(order)).LCM(arg2.LeadingPowerProduct(order));
  gPoly<T> lcm = gPoly<T>(List,exp_lcm,(T)1);
  gPoly<T> L1 = lcm/LeadingTerm(order);
  gPoly<T> L2 = lcm/arg2.LeadingTerm(order);

  return L1*(*this) - L2*arg2;
}


//---------------------------
//    Global Operators
//---------------------------

template<class T> gPoly<T> operator*(const T val, const gPoly<T> poly)
{
  gPoly<T> prod(poly);
  prod.MultbyConst(val, prod.Root);
  return prod;
}

template<class T> gPoly<T> operator*(const gPoly<T> poly, const T val)
{
  gPoly<T> prod(poly);
  prod.MultbyConst(val, prod.Root);
  return prod;
}

template <class T> gOutput& operator<<(gOutput &f, const gPoly<T> &p)
{
  p.Print(f);
  return f;
}


