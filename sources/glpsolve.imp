//
// FILE: glpsolve.imp -- Implementation of LP solver
//
// $Id$
//

#include "glpsolve.h"

template <class T>
gLPTableau<T>::gLPTableau(const gMatrix<T> &A, const gVector<T> &B,
			  const gVector<T> &C) 
  : gTableau<T>(1, B.Length() + 1, 0, 0, B.Length() + 1, B.Length()),
    phase(0), well_formed(1), feasible(1), bounded(1), optimum(1, C.Length())
{
// Check to make sure the sizes of the matrix and vectors match up properly
  if (A.NumRows() != B.Length() ||
      A.NumColumns() != C.Length())   {
    well_formed = 0;
    return;
  }

// Construct the auxiliary cost vector for phase I computation
  gVector<T> CX(C.Length() + 2 * B.Length());
  int i;
  for (i = 1; i <= C.Length(); CX[i++] = 0);
  for (i = 1; i <= B.Length(); i++)  {
    CX[C.Length() + 2 * i - 1] = 0;
	 if (B[i] < (T) 0)
      CX[C.Length() + 2 * i] = 1;
    else
      CX[C.Length() + 2 * i] = 0;
  }

// Initialize the tableau
  for (i = 1; i <= B.Length() + 1; i++)
    for (int j = 0; j <= B.Length() + 1; j++)
      Tableau(i, j) = 0;
  
  for (i = 1; i <= B.Length(); i++)  {
	 if (B[i] >= (T) 0)   {    // use slack variable
      Tableau(i, i + 1) = 1;
      Tableau(i, 1) = B[i];
      Col_Labels[i] = C.Length() + 2 * i - 1;
    }
    else  {               // use surplus variable
      Tableau(i, i + 1) = -1;
      Tableau(i, 1) = -B[i];
      Tableau(B.Length() + 1, 1) -= B[i];
      Tableau(B.Length() + 1, i + 1) = -1;
      Col_Labels[i] = C.Length() + 2 * i;
    }
  }

//  gout << "\nCost vector: ";
//  CX.Dump(gout);  gout << '\n';

//  gout << "Initial basis: ";
//  Col_Labels.Dump(gout);   gout << '\n';

//  Tableau.Dump(gout);
//  gout << "\n--- Phase I ---\n";

  while (ComputePivot(B.Length(), A, B, CX));

//  gout << "\n--- End Phase I ---\n";

  if (Tableau(B.Length() + 1, 1) > (T) 0)   {
    feasible = 0;
    return;
  }
  
  // install "real" cost vector
  for (i = 1; i <= C.Length(); i++)
    CX[i] = C[i];
  for (; i <= CX.Length(); CX[i++] = 0);

// Recompute criterion row components
  for (i = 1; i <= B.Length() + 1; i++)  {
    Tableau(B.Length() + 1, i) = 0;
    for (int j = 1; j <= Col_Labels.Length(); j++)
      Tableau(B.Length() + 1, i) += Tableau(j, i) * CX[Col_Labels[j]];
  }
    
// Do Phase II calculation
  while (ComputePivot(B.Length(), A, B, CX));
  
  for (i = 1; i <= optimum.Length(); i++) 
    if (Col_Labels.Contains(i))
      optimum[i] = Tableau(Col_Labels.Find(i), 1);
    else
      optimum[i] = 0;

  cost = Tableau(B.Length() + 1, 1);
}

template <class T> int gLPTableau<T>::ComputePivot(int Udim,
						   const gMatrix<T> &A,
						   const gVector<T> &B,
						   const gVector<T> &C)
{
  // Non-basic column selection
  int col = -1;
  T bestzed = 0;

  int i;
  for (i = 1; i <= C.Length(); i++)  {
    if (!Col_Labels.Contains(i))   {
      int constr_num = (i - A.NumColumns() - 1) / 2 + 1,
          col_num = (i - A.NumColumns() - 1) % 2;
	 
      // don't ever pivot surplus variables into basis 
      if (i > A.NumColumns() && col_num == 1)  continue;

      T zed = -C[i];
      for (int j = 1; j <= Udim; j++)
	if (i <= A.NumColumns())
	  zed += Tableau(Udim + 1, j + 1) * A(j, i);
        else if (j == constr_num)  {
	  if (col_num == 0)
	    zed += Tableau(Udim + 1, j + 1);
	  else if (B[j] < (T) 0)
	    zed -= Tableau(Udim + 1, j + 1);
	}
//    gout << "Column " << i << ": zed = " << zed << '\n';
      if (zed > bestzed || col == -1)  {
	col = i;
	bestzed = zed;
      }
    }
  }

  if (col == -1 || bestzed <= (T) 0)   return 0;

  // Compute pivot tableau column
  // This can be made more efficient by eliminating the U matrix entirely
  // and rewriting the multiplication explicitly off the tableau
  gMatrix<T> U(Udim, Udim);
  for (i = 1; i <= Udim; i++)
    for (int j = 1; j <= Udim; j++)
      U(i, j) = Tableau(i, j + 1);
  gVector<T> Acol(Udim);
  for (i = 1; i <= Udim; i++)
    if (col <= A.NumColumns())
      Acol[i] = A(i, col);
    else  {
      int constr_num = (col - A.NumColumns() - 1) / 2 + 1,
          col_num = (col - A.NumColumns() - 1) % 2;

      if (col_num == 0 && i == constr_num)            Acol[i] = 1;
		else if (B[constr_num] < (T) 0 && i == constr_num)  Acol[i] = -1;
      else                                            Acol[i] = 0;
    }
//  gout << "Reconstructed A: ";
//  Acol.Dump(gout);   gout << '\n';
  Acol = U * Acol;
  // now Acol is the pivot tableau column

  // Determine pivot row
  int row = -1;
  gVector<T> ratio(1, Udim + 1);
  for (i = 1; i <= ratio.Length(); ratio[i++] = 0);

  for (i = 1; i <= Udim; i++)  {
    if (Acol[i] > (T) 0)  {
      gVector<T> this_ratio(1, Udim + 1);
      int j;
      for (j = 1; j <= this_ratio.Length(); j++)
	this_ratio[j] = Tableau(i, j) / Acol[i];

//    gout << "Ratio for row " << i << ": ";
//    this_ratio.Dump(gout);  gout << '\n';

      // compute the lexicographically lesser of ratio and this_ratio
      for (j = 1; j <= this_ratio.Length(); j++)  {
	if (this_ratio[j] < ratio[j] || row == -1)  {
	  row = i;
	  ratio = this_ratio;
	  break;
	}
	else if (this_ratio[j] > ratio[j])  break;
      }
    }
  }
  
  if (row == -1)  {
    bounded = 0;
    return 0;
  }

  // Put Acol into the tableau, and pivot
  for (i = 1; i <= Udim; i++)
	 Tableau(i, 0) = Acol[i];
  if (phase)
	 Tableau(i, 0) = bestzed - C[col];
  else
	 Tableau(i, 0) = bestzed;

//  Tableau.Dump(gout);
//  Col_Labels.Dump(gout);
//  gout << '\n';

  Tableau.Pivot(row, 0);
  Col_Labels[row] = col;

//  Tableau.Dump(gout);
//  Col_Labels.Dump(gout);
//  gout << '\n';

  return 1;
}

template <class T> T gLPTableau<T>::OptimumCost(void) const
{
  return cost;
}

template <class T> const gVector<T> &gLPTableau<T>::OptimumVector(void) const
{
  return optimum;
}

template <class T> int gLPTableau<T>::IsFeasible(void) const
{
  return feasible;
}

template <class T> int gLPTableau<T>::IsBounded(void) const
{
  return bounded;
}

template <class T> int gLPTableau<T>::IsWellFormed(void) const
{
  return well_formed;
}

template <class T> gLPTableau<T>::~gLPTableau()
{ }
