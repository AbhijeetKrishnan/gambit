//#
//# FILE: normiter.imp -- Implementation of generic normal form iterator
//#
//# $Id$
//#

#include "nfgiter.h"
#include "nfg.h"
#include "nfstrat.h"
#include "nfplayer.h"

//#include "contiter.h"

//--------------------------------------------------------------------------
// NfgIter<T>:  Constructors, Destructors, Operators
//--------------------------------------------------------------------------

template <class T> NfgIter<T>::NfgIter(const NFSupport *s) 
  :  N((Nfg<T> *) s->sups[1]->nfp->N), current_strat((s->sups).Length()),
    profile(new StrategyProfile(s->sups.Length()))
{
  stratset = s;
  First();
}


template <class T> NfgIter<T>::NfgIter(const NfgIter<T> &it)
  : N(it.N), current_strat(it.current_strat), 
    profile(new StrategyProfile(*it.profile))
{ 
  stratset = it.stratset;
}

//template <class T> NfgIter<T>::NfgIter(const ContIter<T> &it)
//  : sset(it.sset), N(it.N), profile(new StrategyProfile(*it.profile))
//{ }

template <class T> NfgIter<T>::~NfgIter()
{
  delete profile;
}

template <class T>
NfgIter<T> &NfgIter<T>::operator=(const NfgIter<T> &it)
{
  if (this != &it)  {
    delete profile;

    N = it.N;
    profile = new StrategyProfile(*it.profile);
    current_strat = it.current_strat;
    stratset = it.stratset;
  }
  return *this;
}
//-----------------------------
// NfgIter: Member Functions
//-----------------------------

template <class T> void NfgIter<T>::First(void)
{
  for (int i = 1; i <= N->NumPlayers(); i++)  {
    Strategy *s = stratset->GetStrategy(i,1);
    profile->Set(i, s);
    current_strat[i] = 1;
  }
}

template <class T> int NfgIter<T>::Next(int p)
{
  Strategy *s;
  if (current_strat[p] < stratset->sups[p]->NumStrats())  {
    s = stratset->GetStrategy(p,++(current_strat[p]));
    profile->Set(p, s);
    return 1;
  }
  s = stratset->GetStrategy(p,1);
  profile->Set(p, s);
  current_strat[p] = 1;
  return 0;
}

template <class T> int NfgIter<T>::Set(int p, int s)
{
  if (p <= 0 || p > N->NumPlayers() ||
      s <= 0 || s > stratset->sups[p]->NumStrats())
    return 0;
  
  profile->Set(p, stratset->GetStrategy(p,s));
  return 1;
}

template <class T> void NfgIter<T>::Get(gArray<int> &t) const
{
  for (int i = 1; i <= N->NumPlayers(); i++)
    t[i] = (*profile)[i]->number;
}

template <class T> void NfgIter<T>::Set(const gArray<int> &t)
{
  for (int i = 1; i <= N->NumPlayers(); i++){
    profile->Set(i, stratset->GetStrategy(i,t[i]));
    current_strat[i] = t[i];
  } 
}

template <class T> long NfgIter<T>::GetIndex(void) const
{
  return profile->GetIndex();
}

template <class T> const T &NfgIter<T>::Payoff(int p) const
{
  return N->Payoff(p, current_strat);
}

template <class T> void NfgIter<T>::SetPayoff(int p, const T &value)
{
  N->SetPayoff(p, current_strat, value);
}

//template <class T> void NfgIter<T>::Payoff(gVector<T> &value) const
//{
//  N->Payoff(*profile, value);
//}

//template <class T> 
//const gArray<int> *const NfgIter<T>::GetActions(int i) const
//{
//  return (*profile)[i]->actions;
//}



