//
// FILE: normiter.imp -- Implementation of generic normal form iterator
//
// $Id$
//

#include "nfgiter.h"
#include "nfg.h"
#include "nfstrat.h"
#include "nfplayer.h"


//--------------------------------------------------------------------------
// NfgIter<T>:  Constructors, Destructors, Operators
//--------------------------------------------------------------------------

template <class T> NfgIter<T>::NfgIter(Nfg<T> &nfg)
  : support(nfg),
    N(&nfg), current_strat(nfg.NumPlayers()), profile(nfg)
{
  First();
}

template <class T> NfgIter<T>::NfgIter(const NFSupport &s) 
  : support(s), N((Nfg<T> *) &s.BelongsTo()),
    current_strat(N->NumPlayers()), profile(*N)
{
  First();
}

template <class T> NfgIter<T>::NfgIter(const NfgIter<T> &it)
  : support(it.support), N(it.N), current_strat(it.current_strat), 
    profile(it.profile)
{ }

template <class T> NfgIter<T>::NfgIter(const NfgContIter<T> &it)
  : support(it.support), N(it.N), current_strat(it.current_strat),
    profile(it.profile)
{ }

template <class T> NfgIter<T>::~NfgIter()
{ }

template <class T>
NfgIter<T> &NfgIter<T>::operator=(const NfgIter<T> &it)
{
  if (this != &it)  {
    N = it.N;
    profile = it.profile;
    current_strat = it.current_strat;
    support = it.support;
  }
  return *this;
}

//-----------------------------
// NfgIter: Member Functions
//-----------------------------

template <class T> void NfgIter<T>::First(void)
{
  for (int i = 1; i <= N->NumPlayers(); i++)  {
    Strategy *s = support.Strategies(i)[1];
    profile.Set(i, s);
    current_strat[i] = 1;
  }
}

template <class T> int NfgIter<T>::Next(int p)
{
  Strategy *s;
  if (current_strat[p] < support.NumStrats(p))  {
    s = support.Strategies(p)[++(current_strat[p])];
    profile.Set(p, s);
    return 1;
  }
  s = support.Strategies(p)[1];
  profile.Set(p, s);
  current_strat[p] = 1;
  return 0;
}

template <class T> int NfgIter<T>::Set(int p, int s)
{
  if (p <= 0 || p > N->NumPlayers() ||
      s <= 0 || s > support.NumStrats(p))
    return 0;
  
  profile.Set(p, support.Strategies(p)[s]);
  return 1;
}

template <class T> void NfgIter<T>::Get(gArray<int> &t) const
{
  for (int i = 1; i <= N->NumPlayers(); i++)
    t[i] = profile[i]->number;
}

template <class T> void NfgIter<T>::Set(const gArray<int> &t)
{
  for (int i = 1; i <= N->NumPlayers(); i++){
    profile.Set(i, support.Strategies(i)[t[i]]);
    current_strat[i] = t[i];
  } 
}

template <class T> long NfgIter<T>::GetIndex(void) const
{
  return profile.GetIndex();
}

template <class T> NFOutcome *NfgIter<T>::GetOutcome(void) const
{
  return N->GetOutcome(profile);
}

template <class T> void NfgIter<T>::SetOutcome(NFOutcome *outcome)
{
  N->SetOutcome(profile, outcome);
}



