//#
//# FILE: gsmatrix.imp -- Implementation of square matrices
//#
//# $Id$
//#

#include "gsmatrix.h"
#include <assert.h>

//-----------------------------------------------------------------------------
//     gSquareMatrix<T>: Constructors, destructor, constructive operators
//-----------------------------------------------------------------------------

template <class T> gSquareMatrix<T>::gSquareMatrix(void)   { }

template <class T> gSquareMatrix<T>::gSquareMatrix(int size)
  : gMatrix<T>(size, size)
{ }

template <class T> gSquareMatrix<T>::gSquareMatrix(const gSquareMatrix<T> &M)
  : gMatrix<T>(M)
{ }

template <class T> gSquareMatrix<T>::~gSquareMatrix()   { }

template <class T>
gSquareMatrix<T> &gSquareMatrix<T>::operator=(const gSquareMatrix<T> &M)
{
  gMatrix<T>::operator=(M);
  return *this;
}

//-----------------------------------------------------------------------------
//                gSquareMatrix<T>: Public member functions
//-----------------------------------------------------------------------------

template <class T> gSquareMatrix<T> gSquareMatrix<T>::Invert(void) const
{
  assert(mincol == minrow && maxcol == maxrow);
  gSquareMatrix<T> copy(*this);
  gSquareMatrix<T> inv(maxrow);

  // initialize inverse matrix and prescale row vectors
  for (int i = minrow; i <= maxrow; i++)   {
    T max= (T) 0;
    for (int j = mincol; j <= maxcol; j++)  {
      T abs = copy.data[i][j];
      if (abs < (T) 0)
	abs = -abs;
      if (abs > max)
	max = abs;
    }
    assert (max != (T) 0);
    T scale = (T) 1 / max;
    for (j = mincol; j <= maxcol; j++)  {
      copy.data[i][j] *= scale;
      if (i == j)
	inv.data[i][j] = scale;
      else
	inv.data[i][j] = (T) 0;
    }
  }
  
  for (i = mincol; i <= maxcol; i++)  {
    // find pivot row
    T max = copy.data[i][i];
    if (max < (T) 0)
      max = -max;
    int row = i;
    for (int j = i + 1; j <= maxrow; j++)  {
      T abs = copy.data[j][i];
      if (abs < (T) 0)
	abs = -abs;
      if (abs > max)  {
	max = abs;
	row = j;
      }
    }
    assert(max > (T) 0);
    copy.SwitchRows(i, row);
    inv.SwitchRows(i, row);
    // scale pivot row
    T factor = (T) 1 / copy.data[i][i];
    for (int k = mincol; k <= maxcol; k++)  {
      copy.data[i][k] *= factor;
      inv.data[i][k] *= factor;
    }

    // reduce other rows
    for (j = minrow; j <= maxrow; j++)  {
      if (j != i)  {
	T mult = copy.data[j][i];
	for (k = mincol; k <= maxcol; k++)  {
	  copy.data[j][k] -= copy.data[i][k] * mult;
	  inv.data[j][k] -= inv.data[i][k] * mult;
	}
      }
    }
  } 

  return inv;
}

template <class T> T gSquareMatrix<T>::Determinant(void) const
{
  T factor = (T) 1;
  gSquareMatrix<T> M(*this);
  
  for (int row = minrow; row <= maxrow; row++)  {
    for (int col = mincol; col < row; col++)   {
      T foo = M.data[row][col];
      if (foo == (T) 0)   continue;

      int i;
      T bar = M.data[col][col];
      
      for (i = mincol; i <= maxcol; i++)  {
	M.data[col][i] *= foo;
	M.data[row][i] *= bar;
	M.data[row][i] -= M.data[col][i];
      }
      factor *= foo * bar;
    }
    // now, we need to check that the value on the diagonal is nonzero
    if (M.data[row][row] == (T) 0)  {
      int i;
      for (i = row + 1; i <= maxrow; i++)
	if (M.data[i][row] != (T) 0)  {
	  M.SwitchRows(row, i);
	  factor = -factor;
	  row--;
	  break;
	}
      if (i > maxrow)    return (T) 0;   // matrix is singular
    }
  }

  T det = (T) 1;
  for (row = minrow; row <= maxrow; row++)    det *= M.data[row][row];

  return (det / factor);
}



