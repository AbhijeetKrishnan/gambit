//#
//# FILE: gsmatrix.imp -- Implementation of square matrices
//#
//# @(#)gsmatrix.imp	1.2 7/21/95 - Determinant fixed by AMM on 10/9/95
//#

#include "gsmatrix.h"
#include <assert.h>

//-----------------------------------------------------------------------------
//     gSquareMatrix<T>: Constructors, destructor, constructive operators
//-----------------------------------------------------------------------------

template <class T> gSquareMatrix<T>::gSquareMatrix(void)   { }

template <class T> gSquareMatrix<T>::gSquareMatrix(int size)
  : gMatrix<T>(size, size)
{ }

template <class T> gSquareMatrix<T>::gSquareMatrix(const gSquareMatrix<T> &M)
  : gMatrix<T>(M)
{ }

template <class T> gSquareMatrix<T>::~gSquareMatrix()   { }

template <class T>
gSquareMatrix<T> &gSquareMatrix<T>::operator=(const gSquareMatrix<T> &M)
{
  gMatrix<T>::operator=(M);
  return *this;
}

//-----------------------------------------------------------------------------
//                gSquareMatrix<T>: Public member functions
//-----------------------------------------------------------------------------

template <class T> gSquareMatrix<T> gSquareMatrix<T>::Invert(void) const
{
  assert(mincol == minrow && maxcol == maxrow);
  gSquareMatrix<T> copy(*this);
  gSquareMatrix<T> inv(maxrow);

  // initialize inverse matrix and prescale row vectors
  for (int i = minrow; i <= maxrow; i++)   {
    T max= (T) 0;
    for (int j = mincol; j <= maxcol; j++)  {
      T abs = copy.data[i][j];
      if (abs < (T) 0)
	abs = -abs;
      if (abs > max)
	max = abs;
    }
    assert (max != (T) 0);
    T scale = (T) 1 / max;
    for (int j = mincol; j <= maxcol; j++)  {
      copy.data[i][j] *= scale;
      if (i == j)
	inv.data[i][j] = scale;
      else
	inv.data[i][j] = (T) 0;
    }
  }
  
  for (int i = mincol; i <= maxcol; i++)  {
    // find pivot row
    T max = copy.data[i][i];
    if (max < (T) 0)
      max = -max;
    int row = i;
    for (int j = i + 1; j <= maxrow; j++)  {
      T abs = copy.data[j][i];
      if (abs < (T) 0)
	abs = -abs;
      if (abs > max)  {
	max = abs;
	row = j;
      }
    }
    assert(max > (T) 0);
    copy.SwitchRows(i, row);
    inv.SwitchRows(i, row);
    // scale pivot row
    T factor = (T) 1 / copy.data[i][i];
    for (int k = mincol; k <= maxcol; k++)  {
      copy.data[i][k] *= factor;
      inv.data[i][k] *= factor;
    }

    // reduce other rows
    for (int j = minrow; j <= maxrow; j++)  {
      if (j != i)  {
	T mult = copy.data[j][i];
	for (int k = mincol; k <= maxcol; k++)  {
	  copy.data[j][k] -= copy.data[i][k] * mult;
	  inv.data[j][k] -= inv.data[i][k] * mult;
	}
      }
    }
  } 

  return inv;
}

template <class T> T gSquareMatrix<T>::Determinant(void) const
{
  T factor = (T) 1;
  gSquareMatrix<T> M(*this);
  
  for (int row = minrow; row <= maxrow; row++)  {

    // first, we need to check that the value on the diagonal is nonzero
    // if not, we swap rows to bring this about

    if (M.data[row][row] == (T) 0)  {
      int swap_row = row + 1;
      while (M.data[swap_row][row] == (T) 0 && swap_row <= maxrow)
	swap_row++;

      if (swap_row > maxrow)  return (T) 0;   // matrix is singular

      M.SwitchRows(row, swap_row);
	  for (int j = mincol; j <= maxcol; j++)
	    M.data[row][j] *= (T) -1;
    }

    // now do row operations to clear the row'th column
    // below the diagonal
    for (int row1 = row+1; row1 <= maxrow; row1++)
      {
	T factor = -M.data[row1][row]/M.data[row][row];
	for (int i = mincol; i <= maxcol; i++)
	  M.data[row1][i] += M.data[row][i]*factor;
      }
  }

  // finally we multiply the diagonal elements
  T det = (T) 1;
  for (int row = minrow; row <= maxrow; row++)    det *= M.data[row][row];
  return det;
}

template <class T> gOutput &operator<<(gOutput &to, const gSquareMatrix<T> &M)
{
  to << (gMatrix<T>)M; return to;
}

