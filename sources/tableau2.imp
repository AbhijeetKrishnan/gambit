//
// FILE: tableau2.imp: implementation of tableau and Tableau classes
//
// $Id$
//

#include "tableau.h"
#include "gcdr.imp"

//
// Tableau method definitions 
//

// Constructors and Destructor


// Aligns the column indexes
int Tableau<gRational>::remap(int col_index) const
{
  int adjust(1-(*A).MinCol());
  if (col_index < 0){
    if (abs(col_index)>(*A).MaxCol()){
      return(abs(col_index)+adjust+1);
    }
    return((*A).MaxCol()+abs(col_index)+adjust+1);
  }
  return(col_index+adjust);
}
      

// function that actually turns the matrix into integers
double Integerize(gMatrix<gRational> &stuff)
{
  int i, j;
  int idex1,idex2,jdex;
  double real_lcm;
  int len(stuff.MaxRow()*stuff.MaxCol());
  gInteger darray[len];
  for(i=stuff.MinCol();i<=stuff.MaxCol();++i){
    for(j=stuff.MinRow();j<=stuff.MaxRow();++j){
      idex1=(i-stuff.MinCol());  
      idex2=(stuff.MaxRow()-stuff.MinRow()+1);  
      jdex=j-stuff.MinRow(); 
      darray[idex1*idex2+jdex]=gRational(stuff(j,i)).denominator();
    }
  }
  real_lcm = find_lcm(len,darray);
  for(i=stuff.MinRow(); i<=stuff.MaxRow();++i){
    for(j=stuff.MinCol(); j<=stuff.MaxCol();++j){
      stuff(i,j)=update(real_lcm,stuff(i,j));
    }
  }
  return(real_lcm);
}


void Tableau<gRational>::reintden() const
{
  int i,j;
  double div(denom*totdenom);

  for(i=Tabdat.MinRow();i<=Tabdat.MaxRow();++i)
    for(j=Tabdat.MinCol();j<=Tabdat.MaxCol();++j)
      Tabdat(i,j)/=div;
}

void Tableau<gRational>::unintden() const
{
  int i,j;
  double div(denom*totdenom);
  
  for(i=Tabdat.MinRow();i<=Tabdat.MaxRow();++i)
    for(j=Tabdat.MinCol();j<=Tabdat.MaxCol();++j)
      Tabdat(i,j)*=div;
}


Tableau<gRational>::Tableau(const gMatrix<gRational> &A, const gVector<gRational> &b)
  : npivots(0), tmpcol(A.MinRow(),A.MaxRow()), A(&A), b(&b), 
    basis(A),B(basis), solution(A.MinRow(), A.MaxRow()),
    Tabdat(A.MaxRow()-A.MinRow()+1,A.MaxRow()-A.MinRow()+A.MaxCol()-A.MinCol()+3), denom(1)
{
  gout << "\nMY CODE\n";

  int i;
  int j;  //loop control variables
    // These are the values recommended by Murtagh (1981) for 15 digit 
    // accuracy in LP problems 

  // Unnecessary for integers
  // gEpsilon(eps1,5);
  // gEpsilon(eps2);
  //  gout << "\nA = " << A << "\ndim A: " << A.MinRow() << " " << A.MaxRow();
  //  gout << " " << A.MinCol() << " " << A.MaxCol();
  //  gout << "\nbasis = ";
  //  basis.Dump(gout);

  // Not using LU decomposition
  // B.refactor(A, basis.label);

  // I believe the same applies here BF
  //  B.solve(b, solution);
  
  // Construct the contents of the Simplex Tableau

  // Initialize gMatrix with correct size
  gVector<gRational> TempVec(A.MaxRow()-A.MinRow()+1);

  for (i=A.MinRow();i<=A.MaxRow();++i){
    for (j=A.MinCol();j<=A.MaxCol();++j){
      Tabdat(i-A.MinRow()+1,j-A.MinCol()+1)=A(i,j);
    }
  }
  
  for (i=Tabdat.MinRow();i<=Tabdat.MaxRow();++i){
    Tabdat(i,A.MaxCol()-A.MinCol()+2)=b[i+b.First()-1];
  }

  solution = b;

  for (i=Tabdat.MinRow();i<=Tabdat.MaxRow();++i){
    for(j=Tabdat.MinRow();j<=Tabdat.MaxRow();++j){
      if(j==i)Tabdat(i,j+A.MaxCol()-A.MinCol()+2)=1;
      else Tabdat(i,j+A.MaxCol()-A.MinCol()+2)=0;
    }
  }
  totdenom = Integerize(Tabdat);
}

Tableau<gRational>::Tableau(const Tableau<gRational> &orig) 
  : npivots(0), tmpcol(orig.tmpcol), A(orig.A), b(orig.b), 
    basis(orig.basis), B(orig.B, basis), solution(orig.solution),
    Tabdat(orig.Tabdat), totdenom(orig.totdenom), denom(orig.denom)
{ }

Tableau<gRational>::~Tableau()
{ }


Tableau<gRational>& Tableau<gRational>::operator=(const Tableau<gRational> &orig)
{
//  assert( A==orig.A );
  if(this!= &orig) {
    tmpcol = orig.tmpcol;
    A = orig.A;
    b = orig.b;
    basis = orig.basis;
    Tabdat = orig.Tabdat;
    totdenom = orig.totdenom;
    denom = orig.denom;
    solution = orig.solution;

    npivots = orig.npivots;
  }
  return *this;
}


int Tableau<gRational>::MinRow() const { return A->MinRow(); }


int Tableau<gRational>::MaxRow() const { return A->MaxRow(); }


int Tableau<gRational>::MinCol() const { return A->MinCol(); }


int Tableau<gRational>::MaxCol() const { return A->MaxCol(); }


const gMatrix<gRational> & Tableau<gRational>::Get_A(void) const {return *A; }


const gVector<gRational> & Tableau<gRational>::Get_b(void) const {return *b;}


bool Tableau<gRational>::Member(int i) const
{ return basis.Member(i);}


int Tableau<gRational>::Label(int i) const
{ return basis.Label(i);}


int Tableau<gRational>::Find(int i) const
{ return basis.Find(i);}


//
// pivoting operations
//


int Tableau<gRational>::CanPivot(int outlabel, int col)
{
//  gVector<gRational> tmpcol(MinRow(),MaxRow());
//  gout << "\ndim tmpcol = " << tmpcol.First() << " " << tmpcol.Last();
//  gout << "\ntmpcol = " << tmpcol;

  SolveColumn(col,tmpcol);
  
  gRational val = tmpcol[basis.Find(outlabel)];
  if(val <=eps2 && val >= -eps2) return 0;
  return 1;  
}


void Tableau<gRational>::Pivot(int outrow,int in_col)
{
  assert( RowIndex(outrow) );
  assert( ValidIndex(in_col) );
  int outlabel = Label(outrow);

  gout << "\noutrow:" << outrow;
  gout << " outlabel: " << outlabel;
  gout << " inlabel: " << in_col;
  // BigDump(gout);

  // gout << "FIRST\n";
  // gout << Tabdat << '\n';
  int col;
  int row(outrow+Tabdat.MinRow()-(*A).MinRow());
  int i,j; // loop-control variables


  // gout << outrow << ":" << in_col << '\n';
  // gout << solution << '\n';

  col = remap(in_col);
  /*
  if (in_col<0){
    if(col!=(*A).MaxCol()+abs(in_col)+2){
      gout<<"\nALERT:\n" << in_col << ':' << col << '\n';
      assert(0);
    }
  }
  else{
    if (col!=in_col+1){
      gout<<"\nALERT:\n" << in_col << ':' << col << '\n';
      assert(0);
    }
  }
  */

  // Pivot Algorithm:
  // i* denotes Pivot Row
  // j* denotes Pivot Column
  // C is the Tableau
  // Cij is the (i,j)th component of C
  // X denotes multiplication
  // d is the denominator (initially 1)
  //
  // 1: Copy row i (don't need to implement this)
  // 2: Zero column j excepting the Pivot Element (done second)
  // 3: Cij=(Ci*j*XCij-Ci*jXCij*)/d for all other elements (done first)
  // 4: d=Ci*j* (done last)

  // Step 3


  for(i=Tabdat.MinRow();i<=Tabdat.MaxRow();++i){
    for(j=Tabdat.MinCol();j<=Tabdat.MaxCol();++j){
      // try{Tabdat(i,j);} catch(...){gout << "i,j\n"; assert(0);}
      // try{Tabdat(outrow,j);} catch(...){gout << "o,j\n"; assert(0);}
      // try{Tabdat(outrow,col);} catch(...){gout << "o,c\n"; assert(0);}
      // try{Tabdat(i,col);} catch(...){gout << "i,c\n"; assert(0);}

      if(i!=row){
	if(j!=col){
	  Tabdat(i,j)=((Tabdat(row,col)*Tabdat(i,j))-(Tabdat(row,j)*Tabdat(i,col)));
	  Tabdat(i,j)=Tabdat(i,j)/gRational(denom);
	}
      }
    }
  }
  // Step 2
  for(i=Tabdat.MinRow();i<=Tabdat.MaxRow();++i){
    if(i!=row){
      Tabdat(i,col)=0;
    }
  }
  // Step 4
  denom=Tabdat(row,col);
  // BigDump(gout);
  npivots++;
  basis.Pivot(outrow,in_col);

  for (i=solution.First();i<=solution.Last();++i){
    solution[i]=Tabdat(i+Tabdat.MinRow()-solution.First(),(*A).MaxCol()-(*A).MinCol()+2)*(gRational)sign(denom*totdenom);
  }

  // gout << "LAST\n";
  // gout << Tabdat << '\n';
  // gout << "\nEntering BigDump()";
  // BigDump(gout);

}

 long Tableau<gRational>::NumPivots() const
{ return npivots; }

 long &Tableau<gRational>::NumPivots()
{ return npivots; }

 void Tableau<gRational>::Mark(int label)
{basis.Mark(label);}

 void Tableau<gRational>::UnMark(int label)
{basis.UnMark(label);}

 bool Tableau<gRational>::IsBlocked(int label) const
{
  return basis.IsBlocked(label);
}

//
// raw Tableau functions
//

 void Tableau<gRational>::Refactor()
{
  // B.refactor(*A, basis.label);
  // B.solve(*b, solution);
}


    // solve A x = b 

void LPTableau<gRational>::Solve(const gVector<gRational> &b, gVector<gRational> &x) const
{
  B.solve(b,x);
}

    // solve y A = c 

void LPTableau<gRational>::SolveT(const gVector<gRational> &c, gVector<gRational> &y) const
{
  B.solveT(c,y);
}


void Tableau<gRational>::BasisVector(gVector<gRational> &out) const
{
  out = solution;
  /*
  int i; // loop control variable
  gVector<gRational> TempVector(out.First(),out.Last());
  reintden();
  // Basis Vector is the Solution Column
  for(i=out.First();i<=out.Last();++i){
    TempVector[i]=Tabdat(Tabdat.MinRow()+i-out.First(),(*A).MaxCol()-(*A).MinCol()+2);
  }
  out= TempVector; // Fill This;
  unintden();
  */
}

// bat's dos?


void Tableau<gRational>::SolveColumn(int in_col, gVector<gRational> &out)
{
  // gout << "\nTableau<gRational>::SolveColumn  " << MinRow() << " " << MaxRow(); 
  // gout << " col: " << in_col;
  int col,i;
  
  col = remap(in_col);
  // if (in_col<0){col=(*A).MaxCol()+abs(in_col)+2;}
  // else col=in_col+1;

    for (i=(*A).MinRow();i<=(*A).MaxRow();++i){
    out[i] =  Tabdat(i+Tabdat.MinRow()-(*A).MinRow(),col)*(gRational)sign(denom*totdenom);
  }
 
    //  basis.GetColumn(in_col,out);
    // gout << "\nout: " << out;
/*
  if( col<0 ) {
    tmpcol2= (gRational)0;
    tmpcol2[-col]=1;
  }
  else
    A->GetColumn(col,tmpcol2);
*/
}



void Tableau<gRational>::GetColumn(int col, gVector<gRational> &out) const
{
  reintden();
  basis.GetColumn(col,out);
  unintden();
}


// Get these too...

void Tableau<gRational>::SetConst(const gVector<gRational> &bnew)
{
  assert(bnew.First()==b->First() && bnew.Last()==b->Last());
  b=&bnew;
  // B.solve(*b, solution);
}



void Tableau<gRational>::SetBasis(const Basis<gRational> &in)
{
  basis= in;
  // B.refactor();
  // B.solve(*b, solution);
}



void Tableau<gRational>::GetBasis(Basis<gRational> &out) const
{
  reintden();
  out= basis;
  unintden();
}

// miscellaneous functions

 bool Tableau<gRational>::EqZero(gRational x) const
{ 
  return (LeZero(x) && GeZero(x));
}

 bool Tableau<gRational>::LtZero(gRational x) const
{ 
  return !GeZero(x);
}

 bool Tableau<gRational>::GtZero(gRational x) const
{ 
  return !LeZero(x);
}

 bool Tableau<gRational>::LeZero(gRational x) const
{ 
  if(x <=eps2) return 1;
  return 0;
}

 bool Tableau<gRational>::GeZero(gRational x) const
{ 
  if(x >= -eps2) return 1;
  return 0;
}

 gRational Tableau<gRational>::Epsilon(int i) const
{
  assert(i==1 || i==2);
  if(i==1) return eps1;
  return eps2;
}

 bool Tableau<gRational>::IsFeasible()
{
  B.solve(*b, solution);
  for(int i=solution.First();i<=solution.Last();i++)
    if(solution[i]>=eps2) return false;
  return true;
}

 bool Tableau<gRational>::IsLexMin()
{
  int i,j;
  for(i=MinRow();i<=MaxRow();i++)
    if(EqZero(solution[i]))
      for(j=-MaxRow();j<Label(i);j++) if(j!=0){
	SolveColumn(j,tmpcol);
	if(LtZero(tmpcol[i]))
	  return 0;
      }
  return 1;
}

 BFS<gRational> Tableau<gRational>::GetBFS() const
{
  BFS<gRational> cbfs((gRational) 0);
  reintden();
  for(int i=MinCol();i<=MaxCol();i++) {
    if(Member(i)) 
      cbfs.Define(i,solution[basis.Find(i)]);
  }
  unintden();
  return cbfs;
}

 BFS<gRational> Tableau<gRational>::GetBFS1() const
{
  BFS<gRational> cbfs((gRational) 0);
  reintden();
int i;
  for(i=-MaxRow();i<=-MinRow();i++) {
    if(Member(i)) 
      cbfs.Define(i,solution[basis.Find(i)]);
  }
  for(i=MinCol();i<=MaxCol();i++) {
    if(Member(i)) 
      cbfs.Define(i,solution[basis.Find(i)]);
  }
  unintden();
  return cbfs;
}

 gOutput &operator<<(gOutput &to, const Tableau<gRational> &v)
{
  v.Dump(to); return to;
}

void Tableau<gRational>::Dump(gOutput &to) const
{ 
basis.Dump(to);to << "\n";solution.Dump(to); 
}


//
// checking functions
//

// BaseTableau<gRational>::~BaseTableau()
// { }

bool BaseTableau<gRational>::ColIndex(int x) const
{ return MinCol()<=x && x<=MaxCol(); }

bool BaseTableau<gRational>::RowIndex(int x) const
{ return MinRow()<=x && x<=MaxRow(); }

bool BaseTableau<gRational>::ValidIndex(int x) const
{ return (ColIndex(x) || RowIndex(-x)); }

void BaseTableau<gRational>::CompPivot(int outlabel, int col)
{
  Pivot(Find(outlabel),col);
  Pivot(Find(-col),-outlabel);
}


//
// LP Tableau member definitions 
// 


//  LPTableau<gRational>::LPTableau(void)
// : Tableau() , 
// { }



LPTableau<gRational>::LPTableau(const gMatrix<gRational> &A, const gVector<gRational> &b)
  : Tableau<gRational>(A,b), dual(A.MinRow(),A.MaxRow()),
    unitcost(A.MinRow(),A.MaxRow()),
    cost(A.MinCol(),A.MaxCol())
{
//  B.refactor(A, basis.label);
  B.solve(b, solution);
};



LPTableau<gRational>::LPTableau(const LPTableau<gRational> &orig)
  : Tableau<gRational>(orig), dual(orig.dual),  unitcost(orig.unitcost),
    cost(orig.cost)
{ }

 LPTableau<gRational>::~LPTableau()
{ }



LPTableau<gRational>& LPTableau<gRational>::operator=(const LPTableau<gRational> &orig)
{
//  assert( A==orig.A );
  Tableau<gRational>::operator=(orig);
  if(this!= &orig) {
    dual=orig.dual;
    unitcost= orig.unitcost;
    cost= orig.cost;
  }
  return *this;
}

// cost-based functions


void LPTableau<gRational>::SetCost(const gVector<gRational>& c)
{
  int i;
  if(cost.Check(c)) {
    unitcost= (gRational)0;
    cost= c;
    SolveDual();
    return;
  }
  assert(c.First()==cost.First());
  assert(c.Last()==(cost.Last()+unitcost.Length()));
  for(i=c.First();i<=cost.Last();i++)
    cost[i]=c[i];
  for(i=unitcost.First();i<=unitcost.Last();i++)
    unitcost[i]=c[cost.Length()+i-unitcost.First()+1];

  SolveDual();
}


void LPTableau<gRational>::SetCost(const gVector<gRational> &uc, const gVector<gRational> &c)
{
  assert(unitcost.Check(uc) && cost.Check(c));
  unitcost= uc;
  cost= c;
  SolveDual();
}



gVector<gRational> LPTableau<gRational>::GetCost(void) const
{
  return cost; 
}


gVector<gRational> LPTableau<gRational>::GetUnitCost(void) const
{
  return unitcost; 
}


gRational LPTableau<gRational>::TotalCost()
{
//  gVector<gRational> tmpcol(MinRow(),MaxRow());
  basis.BasisSelect(unitcost,cost,tmpcol);
  return tmpcol*solution;
}


void LPTableau<gRational>::DualVector(gVector<gRational> &L) const
{
  L= dual;
}


gRational LPTableau<gRational>::RelativeCost(int col) const
{
  if( col<0 ) {
    return unitcost[-col] - dual[-col];
  }
  else {
//      gVector<gRational> tmpcol(MinRow(),MaxRow());
//    A->GetColumn(col, (gArray<gRational> &)tmpcol);
    basis.GetColumn(col, (gVector<gRational> &)tmpcol);
    return cost[col] - dual*tmpcol;
  }
}
/*

void LPTableau<gRational>::RelativeCostVector(gVector<gRational> &relunitcost,
				      gVector<gRational> &relcost) const
{
  assert(A->CheckColumn(relunitcost));
  assert(A->CheckRow(relcost));
  
  relunitcost= unitcost - dual;
  relcost= cost - dual*A;  // pre multiplication not defined?  
}
*/


void LPTableau<gRational>::SolveDual()
{
  gVector<gRational> tmpcol1(MinRow(),MaxRow());
  basis.BasisSelect(unitcost,cost,tmpcol1);
  // gout << "\nIn SolveDual() tab = \n";
  // Dump(gout);
  // gout << "\n tmpcol1: " << tmpcol1;
  B.solveT(tmpcol1,dual);
  // gout << "\n dual: " << dual;
}

    // Redefined functions
 void LPTableau<gRational>::Refactor()
{
  Tableau<gRational>::Refactor();
  SolveDual();
}


void LPTableau<gRational>::Pivot(int outrow,int col)
{
  Tableau<gRational>::Pivot(outrow,col);
  SolveDual();
}


void LPTableau<gRational>::ReversePivots(gList<gArray<int> > &PivotList)
{
  bool flag;
  int i,j,k,enter;
  gRational ratio,a_ij,a_ik,b_i,b_k,c_j,c_k,c_jo,x;
  gList<int> BestSet;
  gArray<int> pivot(2);
  gVector<gRational> tmpdual(MinRow(),MaxRow());

  for(j=-MaxRow();j<=MaxCol();j++) if(j && !Member(j)  && !IsBlocked(j)) {
    SolveColumn(j,tmpcol);
    // gout << "\nColumn " << j;
    // gout << "\nPivCol = " << tmpcol;
    // gout << "\ncurrentSolCol = " << solution;
    
    // find all i where prior tableau is primal feasible
    
    BestSet.Flush();
    for(i=MinRow();i<=MaxRow();i++)
      if(GtZero(tmpcol[i])) BestSet.Append(i);
    if(BestSet.Length()>0) {
      ratio = solution[BestSet[1]]/tmpcol[BestSet[1]];
      // find max ratio
      for(i=2;i<=BestSet.Length();i++) {
	x = solution[BestSet[i]]/tmpcol[BestSet[i]];
	if(GtZero(x-ratio)) ratio = x;
      }
      // eliminate nonmaximizers
      for(i=BestSet.Length();i>=1;i--) {
	x = solution[BestSet[i]]/tmpcol[BestSet[i]];
	if(LtZero(x-ratio)) BestSet.Remove(i);
      }	

      // check that j would be the row to exit in prior tableau

      // first check that prior pivot entry > 0 
      for(i=BestSet.Length();i>=1;i--) {
	a_ij = (gRational)1/tmpcol[BestSet[i]];
	if(LeZero(a_ij)) {
	  // gout << "\nj not row to exit in prior tableau: a_ij <= 0";
	  BestSet.Remove(i);
	}
	else {
	  // next check that prior pivot entry attains max ratio
	  b_i = solution[BestSet[i]]/tmpcol[BestSet[i]];
	  ratio = b_i/a_ij;
  
	  flag = 0;
	  for(k=tmpcol.First();k<=tmpcol.Last() && !flag;k++) 
	    if(k!=BestSet[i]) {
	      a_ik = - a_ij * tmpcol[k];
	      b_k = solution[k] - b_i*tmpcol[k];
	      if(GtZero(a_ik) && GtZero(b_k/a_ik -ratio)) {
		// gout << "\nj not row to exit in prior tableau: ";
		// gout << "higher ratio at row= " << k;
		BestSet.Remove(i);
		flag = 1;
	      }
	      else if(GtZero(a_ik) && EqZero(b_k/a_ik-ratio) && Label(k)<j) {
		// gout << "\nj not row to exit in prior tableau: ";
		// gout << "same ratio,lower lex at k= " << k;
		BestSet.Remove(i);
		flag = 1;
	      }
	    }
	}
      }
    }
    // gout << "\nafter checking rows, BestSet = ";
    // BestSet.Dump(gout);

    // check that i would be the column to enter in prior tableau

    for(i=BestSet.Length();i>=1;i--) {
      enter = Label(BestSet[i]);
      // gout << "\nenter = " << enter;
      
      tmpcol = (gRational)0;
      tmpcol[BestSet[i]]=(gRational)1;
      B.solveT(tmpcol,tmpdual);
      
/*      if( j<0 )
	{ tmpcol=(gRational)0; tmpcol[-j]=(gRational)1; }
      else
	A->GetColumn(j,tmpcol);
*/
      basis.GetColumn(j,tmpcol);      
      // gout << "\ncol j = " << tmpcol;
      a_ij = tmpdual*tmpcol;
      c_j = RelativeCost(j);
      if(EqZero(a_ij)) {
	// gout << "\ni not col to enter in prior tableau: ";
	// gout << "a_ij=0";
	BestSet.Remove(i);
      }
      else {
	ratio = c_j/a_ij;
	if(enter<0) 
	  a_ik = tmpdual[-enter];
	else {
	  basis.GetColumn(enter,tmpcol);
//	  A->GetColumn(enter,tmpcol);
	  a_ik = tmpdual*tmpcol;
	}
	c_k = RelativeCost(enter);
	c_jo = c_k - a_ik * ratio; 
	// gout << "\ntmpdual = " << tmpdual << "\n";
	// gout << " c_j:" << c_j; 
	// gout << " c_k:" << c_k; 
	// gout << " c_jo:" << c_jo; 
	// gout << " a_ij:" << a_ij; 
	// gout << " a_ik:" << a_ik; 
	if(GeZero(c_jo)) {
	  // gout << "\ni not col to enter in prior tableau: ";
	  // gout << "c_jo<0";
	  BestSet.Remove(i);
	}
	else {
	  flag=0;
	  for(k=-b->Last();k<enter && !flag;k++) if(k!=0) {
	    if(k<0) 
	      a_ik=tmpdual[-k];
	    else {
//	      A->GetColumn(k,tmpcol);
	      basis.GetColumn(k,tmpcol);
	      a_ik = tmpdual*tmpcol;
	    }
	    c_k = RelativeCost(k);
	    c_jo = c_k - a_ik * ratio; 
	    
	    if(LtZero(c_jo)) { 
	      // gout << "\ni not col to enter in prior tableau: ";
	      // gout << "c_jo < 0 for k = " << k;
	      BestSet.Remove(i);
	      flag=1;
	    }
	  }
	}
      }
    }
    // gout << "\nafter checking cols, BestSet = ";
    // BestSet.Dump(gout);

    if(BestSet.Length()>0) 
      for(i=1;i<=BestSet.Length();i++) {
	pivot[1] = BestSet[i];
	pivot[2] = j;
	PivotList.Append(pivot);
      }
  }
}


bool LPTableau<gRational>::IsReversePivot(int i, int j)
{
  // first check that pivot preserves primal feasibility
  
  // gout << "\nin IsReversePivot, i= " << i << " j = "<< j;
  SolveColumn(j,tmpcol);
  // gout << "\ncurrentPivCol = " << tmpcol;
  // gout << "\ncurrentSolCol = " << solution;
  if(LeZero(tmpcol[i])) { 
    // gout << "\nPrior tableau not primal feasible: currentPivCol[i] <= 0";
    return 0;
  }
  int k;
  gRational ratio = solution[i]/tmpcol[i];
  // gout << "\nratio = " << ratio;
  
  for(k=tmpcol.First();k<=tmpcol.Last();k++)
    if(GtZero(tmpcol[k]) && GtZero(solution[k]/tmpcol[k]-ratio)) {
      // gout << "\nPrior tableau not primal feasible: i not min ratio";
      return 0;
    }
  // check that j would be the row to exit in prior tableau
  
  gRational a_ij,a_ik,b_i,b_k,c_j,c_k,c_jo;

  a_ij = (gRational)1/tmpcol[i];
  if(LeZero(a_ij)) {
    // gout << "\nj not row to exit in prior tableau: a_ij <= 0";
    return 0;
  }
  b_i = solution[i]/tmpcol[i];
  ratio = b_i/a_ij;
  
  for(k=tmpcol.First();k<=tmpcol.Last();k++) 
    if(k!=i) {
      a_ik = - a_ij * tmpcol[k];
      b_k = solution[k] - b_i*tmpcol[k];
      if(GtZero(a_ik) && GtZero(b_k/a_ik -ratio)) {
	// gout << "\nj not row to exit in prior tableau: ";
	// gout << "higher ratio at row= " << k;
	return 0;
      }
      if(GtZero(a_ik) && EqZero(b_k/a_ik-ratio) && Label(k)<j) {
	// gout << "\nj not row to exit in prior tableau: ";
	// gout << "same ratio,lower lex at k= " << k;
	return 0;
      }
    }

  // check that i would be the column to enter in prior tableau
  
  int enter = Label(i);
  // gout << "\nenter = " << enter;
  
  gVector<gRational> tmpdual(MinRow(),MaxRow());
  tmpcol = (gRational)0;
  tmpcol[i]=(gRational)1;
  B.solveT(tmpcol,tmpdual);

/*
  if( j<0 )
    { tmpcol=(gRational)0; tmpcol[-j]=(gRational)1; }
  else
    A->GetColumn(j,tmpcol);
*/
    basis.GetColumn(j,tmpcol);
  
  // gout << "\ncol j = " << tmpcol;
  a_ij = tmpdual*tmpcol;
  c_j = RelativeCost(j);
  if(EqZero(a_ij)) {
    // gout << "\ni not col to enter in prior tableau: ";
    // gout << "a_ij=0";
    return 0;
  }
  ratio = c_j/a_ij;
  
  if(enter<0) 
    a_ik = tmpdual[-enter];
  else {
//    A->GetColumn(enter,tmpcol);
    basis.GetColumn(enter,tmpcol);
    a_ik = tmpdual*tmpcol;
  }
  c_k = RelativeCost(enter);
  c_jo = c_k - a_ik * ratio; 
  if(GeZero(c_jo)) {
    // gout << "\ni not col to enter in prior tableau: ";
    // gout << "c_jo<0";
    return 0;
  }

  for(k=-b->Last();k<enter;k++) if(k!=0) {
    if(k<0) 
      a_ik=tmpdual[-k];
    else {
//      A->GetColumn(k,tmpcol);
      basis.GetColumn(k,tmpcol);
      a_ik = tmpdual*tmpcol;
    }
    c_k = RelativeCost(k);
    c_jo = c_k - a_ik * ratio; 
    
    if(LtZero(c_jo)) { 
      // gout << "\ni not col to enter in prior tableau: ";
      // gout << "c_jo < 0 for k = " << k;
      return 0;
    }
  }
  // gout << "\nValid Reverse pivot at i = " << i << " j =  " << j;
  return 1;
}


void LPTableau<gRational>::DualReversePivots(gList<gArray<int> > &/*list*/)
{
}


bool LPTableau<gRational>::IsDualReversePivot(int i, int j)
{
  // first check that pivot preserves dual feasibility
  
  // gout << "\nin IsDualReversePivot, i= " << i << " j = "<< j;

  int k;
  gVector<gRational> tmpdual(MinRow(),MaxRow());
  tmpcol = (gRational)0;
  tmpcol[i]=(gRational)1;
  B.solveT(tmpcol,tmpdual);

  gRational a_ij,a_ik,c_j,c_k,ratio;

/*  if( j<0 )
    { tmpcol=(gRational)0; tmpcol[-j]=(gRational)1; }
  else
    A->GetColumn(j,tmpcol);
  */

    basis.GetColumn(j,tmpcol);
  
  a_ij = tmpdual*tmpcol;
  c_j = RelativeCost(j);
  if(GeZero(a_ij)) {
    // gout << "\nPrior tableau not dual feasible: ";
    // gout << "a_ij>=0";
    return 0;
  }
  ratio = c_j/a_ij;
  
  for(k=-b->Last();k<=cost.Last();k++) if(k!=0) {
    if(k<0) 
      a_ik=tmpdual[-k];
    else {
//      A->GetColumn(k,tmpcol);
      basis.GetColumn(k,tmpcol);
      a_ik = tmpdual*tmpcol;
    }
    c_k = RelativeCost(k);
    
    if(LtZero(a_ik) && GtZero(c_k/a_ik-ratio)) { 
      // gout << "\nPrior tableau not dual feasible: ";
      // gout << "\nhigher ratio for k = " << k;
      return 0;
    }
  }

  // check that i would be the column to enter in prior tableau

  int enter = Label(i);
  // gout << "\nenter = " << enter;

  if(enter<0) 
    a_ik = tmpdual[-enter];
  else {
//    A->GetColumn(enter,tmpcol);
    basis.GetColumn(enter,tmpcol);
    a_ik = tmpdual*tmpcol;
  }
  a_ik = a_ik/a_ij;
  c_k = RelativeCost(enter);
  c_k -= a_ik * c_j; 

  if(GeZero(a_ik)) {
    // gout << "\ni not col to enter in prior tableau: ";
    // gout << "a_ik>=0";
    return 0;
  }
  ratio = c_k/a_ik;

  for(k=-b->Last();k<=cost.Last();k++) if(k!=0) {
    if(k<0) 
      a_ik=tmpdual[-k];
    else {
//    A->GetColumn(k,tmpcol);
    basis.GetColumn(k,tmpcol);
    a_ik = tmpdual*tmpcol;
    }
    a_ik = a_ik/a_ij;
    c_k = RelativeCost(k);
    c_k -= a_ik * c_j; 
    
    if(LtZero(a_ik) && GtZero(c_k/a_ik- ratio)) { 
      // gout << "\ni not col to enter in prior tableau: ";
      // gout << "\nhigher ratio for k = " << k;
      return 0;
    }
    if(k<enter && LtZero(a_ik) && EqZero(c_k/a_ik - ratio)) { 
      // gout << "\ni not col to enter in prior tableau: ";
      // gout << "\nsame ratio and lower lex for k = " << k;
      return 0;
    }
  }

  // check that j would be the row to exit in prior tableau

  SolveColumn(j,tmpcol);
  // gout << "\ncurrentPivCol = " << tmpcol;
  // gout << "\ncurrentSolCol = " << solution;

  gRational b_k,b_i;
  b_i= solution[i]/tmpcol[i];
  if(LeZero(b_i)) {
    // gout << "\nj not row to exit in prior tableau: ";
    // gout << "b_i<=0";
    return 0;
    }

  
  for(k=b->First();k<=b->Last();k++) 
    if(k!=i) {
      b_k = solution[k] -  b_i * tmpcol[k];
      if(GtZero(b_k) && Label(k)<j) {
	// gout << "\nj not row to exit in prior tableau: ";
	// gout << "same ratio,lower lex at k= " << k;
	return 0;
      }
    }
  // gout << "\nValid Reverse pivot at i = " << i << " j =  " << j;
  return 1;
}


BFS<gRational> LPTableau<gRational>::DualBFS() const
{
  BFS<gRational> cbfs((gRational) 0);
  for(int i=MinRow();i<=MaxRow();i++) {
    if(!Member(-i)) 
      cbfs.Define(-i,dual[i]);
  }
  return cbfs;
}


void LPTableau<gRational>::InsertArtificial( int art, int col )
{
  basis.InsertArtificial( art, col );
}


int LPTableau<gRational>::AppendArtificial( int art )
{
  return basis.AppendArtificial( art );
}


void LPTableau<gRational>::RemoveArtificial( int col )
{
  basis.RemoveArtificial( col );
}


int LPTableau<gRational>::LastArtificial( void )
{
  return basis.LastArtificial();
}


void LPTableau<gRational>::FlushArtificial( void )
{
  basis.FlushArtificial();
}
  
