//
// FILE: tableau2.imp: implementation of Tableau classes for gRational
//
// $Id$
//

gInteger find_lcd(const gMatrix<gRational> &mat)
{
  gInteger lcd(1);
  for(int i=mat.MinRow();i<=mat.MaxRow();i++)
    for(int j=mat.MinCol();j<=mat.MaxCol();j++) 
      lcd = lcm(mat(i,j).denominator(),lcd);
  return lcd;
}

gInteger find_lcd(const gVector<gRational> &vec)
{
  gInteger lcd(1);
  for(int i=vec.First();i<=vec.Last();i++)
    lcd = lcm(vec[i].denominator(),lcd);
  return lcd;
}

// ---------------------------------------------------------------------------
//                    Tableau method definitions 
// ---------------------------------------------------------------------------

// Constructor

Tableau<gRational>::Tableau(const gMatrix<gRational> &A, const gVector<gRational> &b) 
  : TableauInterface(A,b), Tabdat(A.MinRow(),A.MaxRow(),A.MinCol(),A.MaxCol()),
    Coeff(b.First(),b.Last()), nonbasic(A.MinCol(),A.MaxCol()),denom(1) {
// gout << "\nMY CODE\n";

  int j;
  for(j=A.MinCol();j<=A.MaxCol();j++) 
    nonbasic[j] = j;

  totdenom = lcm(find_lcd(A),find_lcd(b));
  assert(totdenom>0);

  for (int i = b.First();i<=b.Last();i++) {
    gRational x = b[i]*(gRational)totdenom;
    assert(x.denominator() == 1);
    Coeff[i] = x.numerator();
  }
  for (int i = A.MinRow();i<=A.MaxRow();i++) 
    for (int j = A.MinCol();j<=A.MaxCol();j++) {
      gRational x = A(i,j)*(gRational)totdenom;
      assert(x.denominator() == 1);
      Tabdat(i,j) = x.numerator();
    }
  for (int i = b.First();i<=b.Last();i++) 
    solution[i] = (gRational)Coeff[i];
}


Tableau<gRational>::Tableau(const Tableau<gRational> &orig) 
  : TableauInterface(orig), Tabdat(orig.Tabdat), Coeff(orig.Coeff), 
    nonbasic(orig.nonbasic), totdenom(orig.totdenom), denom(orig.denom) 
{ }

Tableau<gRational>::~Tableau()
{ }

Tableau<gRational>& Tableau<gRational>::operator=(const Tableau<gRational> &orig)
{
  TableauInterface<gRational>::operator=(orig);
  if(this!= &orig) {
    Tabdat = orig.Tabdat;
    Coeff = orig.Coeff;
    nonbasic = orig.nonbasic;
    totdenom = orig.totdenom;
    denom = orig.denom;
  }
  return *this;
}

// Aligns the column indexes

int Tableau<gRational>::remap(int col_index) const
{
  int i = nonbasic.First(); 
  while(i <= nonbasic.Last() && nonbasic[i] !=col_index) { i++;}
  assert(i <= nonbasic.Last());
  return i;
}

// pivoting operations

void Tableau<gRational>::Pivot(int outrow,int in_col)
{
  assert( RowIndex(outrow) );
  assert( ValidIndex(in_col) );
  int outlabel = Label(outrow);

  // gout << "\noutrow:" << outrow;
  // gout << " outlabel: " << outlabel;
  // gout << " inlabel: " << in_col;

  // BigDump(gout);
  // gout << "\ndenom: " << denom << " totdenom: " << totdenom;
  // gout << " product: " << denom*totdenom;
  // gout << "\nTabdat: loc 1\n " << Tabdat;

  int col;
  int row(outrow);
  int i,j; // loop-control variables

  col = remap(in_col);

  // Pivot Algorithm:
  // i* denotes Pivot Row
  // j* denotes Pivot Column
  // C is the Tableau
  // Cij is the (i,j)th component of C
  // X denotes multiplication
  // d is the denominator (initially 1)
  //
  // 1: Copy row i (don't need to implement this)
  // 2: Zero column j excepting the Pivot Element (done second)
  // 3: Cij=(Ci*j*XCij-Ci*jXCij*)/d for all other elements (done first)
  // 4: d=Ci*j* (done last)

  // Step 3


  for(i=Tabdat.MinRow();i<=Tabdat.MaxRow();++i){
    if(i!=row){
      for(j=Tabdat.MinCol();j<=Tabdat.MaxCol();++j){
	if(j!=col){
	  Tabdat(i,j) = (Tabdat(row,col)*Tabdat(i,j)-Tabdat(row,j)*Tabdat(i,col))/denom;
	}
      }
      Coeff[i] = (Tabdat(row,col)*Coeff[i]-Coeff[row]*Tabdat(i,col))/denom;
    }
  }
  // Step 2
  // Note: here we are moving the old basis column into column 'col'
  for(i=Tabdat.MinRow();i<=Tabdat.MaxRow();++i){
    if(i!=row)
      Tabdat(i,col)=-Tabdat(i,col);
  }
  // Step 4
  gRational old_denom = denom;
  denom=Tabdat(row,col);
  Tabdat(row,col)=old_denom;

  // BigDump(gout);
  npivots++;

  basis.Pivot(outrow,in_col);
  nonbasic[col] = outlabel;
  
  for (i = solution.First();i<=solution.Last();i++) 
    solution[i] = (gRational)(Coeff[i]*sign(denom*totdenom));

  // BigDump(gout);
  // gout << "\ndenom: " << denom << " totdenom: " << totdenom;
  // gout << " product: " << denom*totdenom;
  // gout << "\nTabdat: loc 2\n" << Tabdat;

}

void Tableau<gRational>::SolveColumn(int in_col, gVector<gRational> &out)
{
  gVector<gInteger> tempcol(out.First(),out.Last());
  
  if(Member(in_col)) {
    out = (gRational)0;
    out[Find(in_col)] = denom*sign(denom*totdenom);
  }
  else {
    int col = remap(in_col);
    Tabdat.GetColumn(col,tempcol);
    for(int i=tempcol.First();i<=tempcol.Last();i++)
      out[i] = (gRational)(tempcol[i]) * (gRational)(sign(denom*totdenom));
  }
}

void Tableau<gRational>::Refactor()
{ }

void Tableau<gRational>::SetRefactor(int)
{ }

void Tableau<gRational>::SetConst(const gVector<gRational> &bnew)
{
  b=&bnew;
  //** this will have to be changed -- Need to start over and re-solve
  //** current basis with bnew.  Here is where vertenum probably screws up (RDM)
  // B.solve(*b, solution);
}


//** this function is not currently used.  Drop it?
void Tableau<gRational>::SetBasis(const Basis<gRational> &in)
{
  basis= in;
  //** this has to be changed -- Need to start over and pivot to new basis.  
  // B.refactor();
  // B.solve(*b, solution);
}

 // solve M x = b
void Tableau<gRational>::Solve(const gVector<gRational> &b, gVector<gRational> &x) const
{
  //** Note --- commenting this out breaks LP<gRational> for now
  //** need to add private GetInverse() function to get V = M^(-1) (M inverse)
  //** then do x = V * b
  // B.solve(b,x);
}

 // solve y M = c
void Tableau<gRational>::SolveT(const gVector<gRational> &c, gVector<gRational> &y) const
{
  //** Note --- commenting this out breaks LP<gRational> for now
  //** need to add private GetInverse() function to get V = M^(-1) (M inverse)
  //** then do y = b * V
  // B.solveT(c,y);
}

bool Tableau<gRational>::IsFeasible()
{
  // B.solve(*b, solution);
  for(int i=solution.First();i<=solution.Last();i++)
    if(solution[i]>=eps2) return false;
  return true;
}

bool Tableau<gRational>::IsLexMin()
{
  int i,j;
  for(i=MinRow();i<=MaxRow();i++)
    if(EqZero(solution[i]))
      for(j=-MaxRow();j<Label(i);j++) if(j!=0){
	SolveColumn(j,tmpcol);
	if(LtZero(tmpcol[i]))
	  return 0;
      }
  return 1;
}

gOutput &operator<<(gOutput &to, const Tableau<gRational> &v)
{
  v.Dump(to); return to;
}


