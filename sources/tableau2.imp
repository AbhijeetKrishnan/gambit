//
// FILE: tableau2.imp: implementation of Tableau classes for gRational
//
// $Id$
//

#include "tableau.h"
#include "gcdr.imp"

// function that turns the matrix and vector into integers
double Integerize(gMatrix<gRational> &stuff, gVector<gRational> &vec)
{
  int i, j;
  int jdex2,idex,jdex;
  double real_lcm;
  int len(stuff.NumRows()*stuff.NumColumns()+vec.Length());
  gInteger darray[len];
  
  jdex2=stuff.NumRows();  
  for(i=stuff.MinRow();i<=stuff.MaxRow();++i){
    idex=i-stuff.MinRow(); 
    for(j=stuff.MinCol();j<=stuff.MaxCol();++j){
      jdex=j-stuff.MinCol();  
      darray[jdex*jdex2+idex]=gRational(stuff(i,j)).denominator();
    }
    jdex=stuff.NumColumns();
    darray[jdex*jdex2+idex]=gRational(vec[i]).denominator();
  }

  real_lcm = find_lcm(len,darray);
  for(i=stuff.MinRow(); i<=stuff.MaxRow();++i){
    for(j=stuff.MinCol(); j<=stuff.MaxCol();++j){
      stuff(i,j)=update(real_lcm,stuff(i,j));
    }
    vec[i]=update(real_lcm,vec[i]);
  }
  return(real_lcm);
}


//
// Tableau method definitions 
//

// Constructor

Tableau<gRational>::Tableau(const gMatrix<gRational> &A, const gVector<gRational> &b)
  : npivots(0), tmpcol(A.MinRow(),A.MaxRow()), A(&A), b(&b), 
    basis(A),B(basis), solution(A.MinRow(), A.MaxRow()),
    Tabdat(A), Coeff(b), nonbasic(A.MinCol(),A.MaxCol()),denom(1)
{
  gout << "\nMY CODE\n";

  int j;
  for(j=A.MinCol();j<=A.MaxCol();j++) 
    nonbasic[j] = j;

  totdenom = Integerize(Tabdat,Coeff);
  solution = Coeff;
}


// Aligns the column indexes

int Tableau<gRational>::remap(int col_index) const
{
  int i = nonbasic.First(); 
  while(i <= nonbasic.Last() && nonbasic[i] !=col_index) { i++;}
  assert(i <= nonbasic.Last());
  return i;
}

// Are these two needed anymore?        

/*
void Tableau<gRational>::reintden() const
{
  gRational div(denom*totdenom);

  Tabdat /= div;
  Coeff  = Coeff/div;
}

void Tableau<gRational>::unintden() const
{
  gRational div(denom*totdenom);
  
  Tabdat *= div;
  Coeff *= div;
}
*/

//
// pivoting operations
//


void Tableau<gRational>::Pivot(int outrow,int in_col)
{
  assert( RowIndex(outrow) );
  assert( ValidIndex(in_col) );
  int outlabel = Label(outrow);

  gout << "\noutrow:" << outrow;
  gout << " outlabel: " << outlabel;
  gout << " inlabel: " << in_col;

  // BigDump(gout);
  // gout << "\ndenom: " << denom << " totdenom: " << totdenom;
  // gout << " product: " << denom*totdenom;
  // gout << "\nTabdat: loc 1\n " << Tabdat;

  int col;
  int row(outrow);
  int i,j; // loop-control variables

  col = remap(in_col);

  // Pivot Algorithm:
  // i* denotes Pivot Row
  // j* denotes Pivot Column
  // C is the Tableau
  // Cij is the (i,j)th component of C
  // X denotes multiplication
  // d is the denominator (initially 1)
  //
  // 1: Copy row i (don't need to implement this)
  // 2: Zero column j excepting the Pivot Element (done second)
  // 3: Cij=(Ci*j*XCij-Ci*jXCij*)/d for all other elements (done first)
  // 4: d=Ci*j* (done last)

  // Step 3


  for(i=Tabdat.MinRow();i<=Tabdat.MaxRow();++i){
    if(i!=row){
      for(j=Tabdat.MinCol();j<=Tabdat.MaxCol();++j){
	if(j!=col){
	  Tabdat(i,j) = (Tabdat(row,col)*Tabdat(i,j))-(Tabdat(row,j)*Tabdat(i,col));
	  Tabdat(i,j) /= gRational(denom);
	}
      }
      Coeff[i] = (Tabdat(row,col)*Coeff[i])-(Coeff[row]*Tabdat(i,col));
      Coeff[i] /= gRational(denom);
    }
  }
  // Step 2
  // Note: here we are moving the old basis column into column 'col'
  for(i=Tabdat.MinRow();i<=Tabdat.MaxRow();++i){
    if(i!=row)
      Tabdat(i,col)=-Tabdat(i,col);
  }
  // Step 4
  gRational old_denom = denom;
  denom=Tabdat(row,col);
  Tabdat(row,col)=old_denom;
  // BigDump(gout);
  npivots++;
  basis.Pivot(outrow,in_col);
  nonbasic[col] = outlabel;
  
  solution = Coeff*(gRational)sign(denom*totdenom);
  // BigDump(gout);
  // gout << "\ndenom: " << denom << " totdenom: " << totdenom;
  // gout << " product: " << denom*totdenom;
  // gout << "\nTabdat: loc 2\n" << Tabdat;

}


void Tableau<gRational>::SolveColumn(int in_col, gVector<gRational> &out)
{
  // gout << "\nTableau<gRational>::SolveColumn  " << MinRow() << " " << MaxRow(); 
  // gout << " col: " << in_col;
  int col;
  
  if(Member(in_col)) {
    out = (gRational)0;
    out[Find(in_col)] = denom*(gRational)sign(denom*totdenom);
  }
  else {
    col = remap(in_col);
    Tabdat.GetColumn(col,out);
    out *= (gRational)sign(denom*totdenom);
  }
}


