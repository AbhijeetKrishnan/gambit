//#
//# FILE: glist.imp -- Implementation of a generic array container class
//#
//# @(#)glist.imp	1.6 12/19/95
//#

#include "glist.h"
#include "glistit.h"

#include <assert.h>

//--------------------------------------------------------------------------
//                        gNode<T>: Class definition
//--------------------------------------------------------------------------

template <class T> class gNode   {
  friend class gList<T>;
  friend class gListIter<T>;
  private:
    T data;
    gNode<T> *prev, *next;

  public:
    // Constructors
    gNode(const T &_data, gNode<T> *_prev, gNode<T> *_next);
    gNode(const gNode<T> &n);
    ~gNode();
};

//--------------------------------------------------------------------------
//                 gNode<T>: Member function implementations
//--------------------------------------------------------------------------

template <class T>
gNode<T>::gNode(const T &_data, gNode<T> *_prev, gNode<T> *_next)
  : data(_data), prev(_prev), next(_next)
{ }

template <class T> gNode<T>::gNode(const gNode<T> &n)
  : data(n.data), prev(n.prev), next(n.next)
{ }

template <class T> gNode<T>::~gNode()
{ }

//--------------------------------------------------------------------------
//                 gList<T>: Member function implementations
//--------------------------------------------------------------------------

template <class T> gList<T>::gList(void) 
: length(0), head(0), tail(0), CurrIndex(0), CurrNode(0)
{ }

template <class T> gList<T>::gList(const gList<T> &b)
 : length(b.length)
{
  if (length)   
  {
    gNode<T> *n = b.head;
    head = new gNode<T>(n->data, 0, 0);
    n = n->next;
    tail = head;
    while (n)  
    {
      tail->next = new gNode<T>(n->data, tail, 0);
      n = n->next;
      tail = tail->next;
    }
    CurrIndex = 1;
    CurrNode = head;
  }
  else
  {
    head = tail = 0;
    CurrIndex = 0;
    CurrNode = 0;
  }
}

template <class T> gList<T>::~gList()
{
  Flush();
}

template <class T> int gList<T>::InsertAt(const T &t, int num)
{
  assert( num >= 1 && num <= length + 1 );

  if (!length)  
  {
    head = tail = new gNode<T>(t, 0, 0);
    length = 1;
    CurrIndex = 1;
    CurrNode = head;
    return length;
  }

  gNode<T> *n;
  int i;

  if( num <= 1 )
  {
    n = new gNode<T>(t, 0, head);
    head->prev = n;
    CurrNode = head = n;
    CurrIndex = 1;
  }
  else if( num >= length + 1)
  {
    n = new gNode<T>(t, tail, 0);
    tail->next = n;
    CurrNode = tail = n;
    CurrIndex = length + 1;
  }
  else
  {
    assert( CurrIndex >= 1 && CurrIndex <= length );
    if( num < CurrIndex )
      for (i = CurrIndex, n = CurrNode; i > num; i--, n = n->prev);
    else
      for (i = CurrIndex, n = CurrNode; i < num; i++, n = n->next);
    n = new gNode<T>(t, n->prev, n);
    CurrNode = n->prev->next = n->next->prev = n;
    CurrIndex = num;
  }

  length++;
  return num;
}

//--------------------- visible functions ------------------------

template <class T> gList<T> &gList<T>::operator=(const gList<T> &b)
{
  if (this != &b)   {
    Flush();
    length = b.length;
    CurrIndex = b.CurrIndex;
    if (length)   {
      gNode<T> *n = b.head;
      head = new gNode<T>(n->data, 0, 0);
      if (b.CurrNode == n) CurrNode = head;
      n = n->next;
      tail = head;
      while (n)  {
	tail->next = new gNode<T>(n->data, tail, 0);
	if (b.CurrNode == n) CurrNode = tail->next;
	n = n->next;
	tail = tail->next;
      }
    }
    else
      head = tail = 0;
  }
  return *this;
}

template <class T> int gList<T>::operator==(const gList<T> &b) const
{
  if (length != b.length) return 0;
  for (gNode<T> *m = head, *n = b.head; m; m = m->next, n = n->next)
    if (m->data != n->data)  return 0;
  return 1;
}

template <class T> int gList<T>::operator!=(const gList<T> &b) const
{
  return !(*this == b);
}

template <class T> const T &gList<T>::operator[](int num) const
{
  assert(num >= 1 && num <= length);
  assert(CurrIndex >= 1 && CurrIndex <= length);
  gNode<T> *n;
  int i;
  if( num < CurrIndex )
    for (i = CurrIndex, n = CurrNode; i > num; i--, n = n->prev);
  else
    for (i = CurrIndex, n = CurrNode; i < num; i++, n = n->next);
  // CurrIndex = i;
  // CurrNode = n;
  return n->data;
}

template <class T> T &gList<T>::operator[](int num)
{
  assert(num >= 1 && num <= length);
  assert(CurrIndex >= 1 && CurrIndex <= length);
  gNode<T> *n;
  int i;
  if( num < CurrIndex )
    for (i = CurrIndex, n = CurrNode; i > num; i--, n = n->prev);
  else
    for (i = CurrIndex, n = CurrNode; i < num; i++, n = n->next);
  CurrIndex = i;
  CurrNode = n;
  return n->data;
}

template <class T> gList<T> gList<T>::operator+(const T &e) const
{
  gList<T> result(*this);
  result.Append(e);
  return result;
}

template <class T> gList<T> &gList<T>::operator+=(const T &e)
{
  Append(e);
  return *this;
}

template <class T> gList<T> gList<T>::operator+(const gList<T> &b) const
{
  gList<T> result(*this);
  gNode<T> *n = b.head;
  while (n)  {
    result.Append(n->data);
    n = n->next;
  }
  return result;
}

template <class T> gList<T> &gList<T>::operator+=(const gList<T> &b)
{
  gNode<T> *n = b.head;
  
  while (n)  {
    Append(n->data);
    n = n->next;
  }
  return *this;
}

template <class T> gList<T> &gList<T>::Combine(gList<T> &b)
{
  if (this == &b)   return *this;

  if (!head)   {
    head = b.head;
    tail = b.tail;
    length = b.length;
    b.head = 0;
    b.tail = 0;
    b.length = 0;
    b.CurrIndex = 0;
    b.CurrNode = 0;
    return *this;
  }

  tail->next = b.head;
  if (b.head)  b.head->prev = tail;
  length += b.length;
  if (b.tail)  tail = b.tail;
  b.head = 0;
  b.tail = 0;
  b.length = 0;
  b.CurrIndex = 0;
  b.CurrNode = 0;
  return *this;
}

template <class T> int gList<T>::Append(const T &t)
{
  return InsertAt(t, length + 1);
}

template <class T> int gList<T>::Insert(const T &t, int n)
{
  return InsertAt(t, (n < 1) ? 1 : ((n > length + 1) ? length + 1 : n));
}

template <class T> T gList<T>::Remove(int num)
{
  assert(num >= 1 && num <= length);
  assert(CurrIndex >= 1 && CurrIndex <= length);
  gNode<T> *n;
  int i;

  if( num < CurrIndex )
    for (i = CurrIndex, n = CurrNode; i > num; i--, n = n->prev);
  else
    for (i = CurrIndex, n = CurrNode; i < num; i++, n = n->next);

  if (n->prev)
    n->prev->next = n->next;
  else
    head = n->next;
  if (n->next)
    n->next->prev = n->prev;
  else
    tail = n->prev;

  length--;
  CurrIndex = i;
  CurrNode = n->next;
  if( CurrIndex > length )
  {
    CurrIndex = length;
    CurrNode = tail;
  }
  T ret = n->data;
  delete n;
  return ret;
}

template <class T> int gList<T>::Find(const T &t) const
{
  if (length == 0)  return 0;
  gNode<T> *n = head;
  for (int i = 1; n; i++, n = n->next)
    if (n->data == t)   return i;
  return 0;
}

template <class T> int gList<T>::Contains(const T &t) const
{
  return Find(t);
}

template <class T> int gList<T>::Length(void) const
{
  return length;
}

template <class T> void gList<T>::Flush(void)
{
  length = 0;
  gNode<T> *n = head;
  while (n)  {
    gNode<T> *next = n->next;
    delete n;
    n = next;
  }
  head = tail = 0;
  CurrIndex = 0;
  CurrNode = 0;
}

template <class T> void gList<T>::Dump(gOutput &f) const
{
  if (length)   {
    gNode<T> *n = head;
    int i = 1;
    while (n)  {
      f << i << ": " << (n->data) << '\n';
      i++;
      n = n->next;
    }
  }
}

template <class T> gOutput &operator<<(gOutput &f, const gList<T> &b)
{
  b.Dump(f);   return f;
}



//--------------------------------------------------------------------------
//                      gListIter<T>: Member functions
//--------------------------------------------------------------------------

template <class T> gListIter<T>::gListIter(gList<T> *l)
  : list(l), position(l->head), location(1)
{ }

template <class T> gListIter<T>::gListIter(gList<T> &l)
  : list(&l), position(l.head), location(1)
{ }

template <class T> gListIter<T>::~gListIter()
{ }

template <class T> void gListIter<T>::operator++(void)
{
  if (position)    {
    position = position->next;
    location++;
  }
}

template <class T> void gListIter<T>::operator++(int)
{
  if (position)   {
    position = position->next;
    location++;
  }
}

template <class T> void gListIter<T>::operator--(void)
{
  if (position)   {
    position = position->prev;
    location--;
  }
}

template <class T> void gListIter<T>::operator--(int)
{
  if (position)  {
    position = position->prev;
    location--;
  }
}

template <class T> void gListIter<T>::GoFirst(void)
{
  position = list->head;
  location = 1;
}

template <class T> void gListIter<T>::GoLast(void)
{
  position = list->tail;
  location = list->length;
}

template <class T> int gListIter<T>::AtBeginning(void) const
{
  return (location == 1);
}

template <class T> int gListIter<T>::AtEnd(void) const
{
  return (location == list->length);
}

template <class T> int gListIter<T>::PastBeginning(void) const
{
  return (location < 1);
}

template <class T> int gListIter<T>::PastEnd(void) const
{
  return (location > list->length);
}

template <class T> const T &gListIter<T>::GetValue(void) const
{
  assert(position);
  return position->data;
}

template <class T> T &gListIter<T>::GetValue(void)
{
  assert(position);
  return position->data;
}

template <class T> T gListIter<T>::Remove(void)
{
  assert(position);
  return list->Remove(location);
}

template <class T> void gListIter<T>::Insert(const T &t)
{
  list->Insert(t, location);
}
