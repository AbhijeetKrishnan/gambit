//
// FILE: seqeq.imp -- implementation of Sequential Equilibrium solver 
//
// $Id$ 
//

#include "gwatch.h"
#include "efg.h"
#include "efgutils.h"

#include "seqeq.h"
#include "quiksolv.h"

template <class T> class SequentialEquilibModule  {
private:
  T eps;
  const Efg &EF;
  const EFBasis &basis;
  const EFSupport &support;
  SeqEquilibParams params;
  gSpace *Space;
  term_order *Lex;
  int num_vars,lastsig,lastmu,lastzeta;
  long count,nevals;
  double time;
  gList<BehavSolution> solutions;

  gDPVector<int> *sigIndex, *muIndex, *zetaIndex;
  const EFBasis bigbasis;

  gPoly<T> Equation(int i, int j) const;
  gPoly<T> Equation(int i, int j, int k) const;
  gPoly<T> Equation(int i, int j, int k, int kk) const;

  gPoly<T> RealizProb(int i, int j) const;
  gPoly<T> RealizProb(Node *) const;

  gPoly<T> sigma(int i,int j, int k) const;
  gPoly<T> mu(int i,int j, int k) const;
  gPoly<T> zeta(int i,int j, int k) const;

  gPoly<T> Payoff(Node *, EFPlayer *) const;
  gPoly<T> Payoff(const Action *) const;

  int SaveSolutions(const gList<gVector<gDouble> > &list);
public:
  SequentialEquilibModule(const EFBasis &,const EFSupport &, 
			  const SeqEquilibParams &p);
  SequentialEquilibModule(const BehavSolution &, const EFBasis &,const EFSupport &, 
			  const SeqEquilibParams &p);
  virtual ~SequentialEquilibModule();

  int SequentialEquilib(void);
  
  long NumEvals(void) const;
  double Time(void) const;

  SeqEquilibParams &Parameters(void);

  const gList<BehavSolution> &GetSolutions(void) const;
};

//-------------------------------------------------------------------------
//                    SequentialEquilibModule<T>: Member functions
//-------------------------------------------------------------------------

template <class T>SequentialEquilibModule<T>::
SequentialEquilibModule(const EFBasis &b, const EFSupport &B,
			const SeqEquilibParams &p)
  : EF(b.Game()), basis(b), support(B), params(p), bigbasis(B.Game())
{ 
  sigIndex = new gDPVector<int>(bigbasis.NumActions());
  muIndex = new gDPVector<int>(bigbasis.NumNodes());
  zetaIndex = new gDPVector<int>(bigbasis.NumActions());

  (*sigIndex) = 0;
  (*muIndex) = 0;
  (*zetaIndex) = 0;

  int i,j,k,kk;
  int var = 1;

  for(i=1;i<=EF.NumPlayers();i++)
    for(j=1;j<=EF.NumInfosets()[i];j++)
      for(k=1;k<=bigbasis.NumActions(i,j);k++)
	if((kk=basis.EFSupport::Find(bigbasis.Actions(i,j)[k]))) 
	  if(kk!=basis.NumActions(i,j))
	    (*sigIndex)(i,j,k) = var++;
  gout << "\nsigIndex: " << (*sigIndex);
  lastsig = var-1;

  for(i=1;i<=EF.NumPlayers();i++)
    for(j=1;j<=EF.NumInfosets()[i];j++)
      for(k=1;k<=bigbasis.NumNodes(i,j);k++)
	if((kk=basis.Find(bigbasis.Nodes(i,j)[k]))) 
	  if(kk!=basis.NumNodes(i,j))
	    (*muIndex)(i,j,k) = var++;
  gout << "\nmuIndex: " << (*muIndex);
  lastmu = var-1;

  for(i=1;i<=EF.NumPlayers();i++)
    for(j=1;j<=EF.NumInfosets()[i];j++)
      for(k=1;k<=bigbasis.NumActions(i,j);k++)
	if(support.Find(bigbasis.Actions(i,j)[k])) 
	  if(!basis.EFSupport::Find(bigbasis.Actions(i,j)[k]))
	    (*zetaIndex)(i,j,k) = var++;
  gout << "\nzetaIndex: " << (*zetaIndex);
  lastzeta = var-1;

  num_vars = var-1;
  Space = new gSpace(num_vars);
  for(i=1;i<=lastsig;i++)
    Space->SetVariableName(i,"s"+ToText(i));
  for(i=lastsig+1;i<=lastmu;i++)
    Space->SetVariableName(i,"m"+ToText(i));
  for(i=lastmu+1;i<=lastzeta;i++)
    Space->SetVariableName(i,"z"+ToText(i));


  Lex = new term_order(Space, &lex);

//  gEpsilon(eps,12);
}

template <class T>SequentialEquilibModule<T>::
SequentialEquilibModule(const BehavSolution &s,const EFBasis &b, const EFSupport &B,
			const SeqEquilibParams &p)
  : EF(b.Game()), basis(b), support(B), params(p), bigbasis(B.Game())
{ 
  gList<Node *> list;
  Nodes(s.Game(), list);

  sigIndex = new gDPVector<int>(bigbasis.NumActions());
  muIndex = new gDPVector<int>(bigbasis.NumNodes());
  zetaIndex = new gDPVector<int>(bigbasis.NumActions());

  (*sigIndex) = 0;
  (*muIndex) = 0;
  (*zetaIndex) = 0;

  int i,j,k,kk;
  int var = 1;

  for(i=1;i<=EF.NumPlayers();i++)
    for(j=1;j<=EF.NumInfosets()[i];j++)
      for(k=1;k<=bigbasis.NumActions(i,j);k++)
	if((kk=basis.EFSupport::Find(bigbasis.Actions(i,j)[k]))) 
	  if(kk!=basis.NumActions(i,j))
	    (*sigIndex)(i,j,k) = var++;
  gout << "\nsigIndex: " << (*sigIndex);
  lastsig = var-1;

  for(i=1;i<=EF.NumPlayers();i++)
    for(j=1;j<=EF.NumInfosets()[i];j++)
      for(k=1;k<=bigbasis.NumNodes(i,j);k++)
	if((kk=basis.Find(bigbasis.Nodes(i,j)[k]))) 
	  if(kk!=basis.NumNodes(i,j))
	    (*muIndex)(i,j,k) = var++;
  gout << "\nmuIndex: " << (*muIndex);
  lastmu = var-1;

  for(i=1;i<=EF.NumPlayers();i++)
    for(j=1;j<=EF.NumInfosets()[i];j++)
      for(k=1;k<=bigbasis.NumActions(i,j);k++)
	if(support.Find(bigbasis.Actions(i,j)[k])) 
	  if(!basis.EFSupport::Find(bigbasis.Actions(i,j)[k]))
	    (*zetaIndex)(i,j,k) = var++;
  gout << "\nzetaIndex: " << (*zetaIndex);
  lastzeta = var-1;

  num_vars = var-1;
  Space = new gSpace(num_vars);
  for(i=1;i<=lastsig;i++)
    Space->SetVariableName(i,"s"+ToText(i));
  for(i=lastsig+1;i<=lastmu;i++)
    Space->SetVariableName(i,"m"+ToText(i));
  for(i=lastmu+1;i<=lastzeta;i++)
    Space->SetVariableName(i,"z"+ToText(i));


  Lex = new term_order(Space, &lex);

//  gEpsilon(eps,12);
}

template <class T>SequentialEquilibModule<T>::
~SequentialEquilibModule()
{
  delete Lex;
  delete Space;
  delete sigIndex;
  delete muIndex;
  delete zetaIndex;
}
template <class T> int SequentialEquilibModule<T>::SequentialEquilib(void)
{
  gWatch watch;
  gPolyList<T> equations(Space,Lex);
  
  // equations for equality of strat i,j,k to strat i,j,kk
  
  gout << "\nSequentialEquilib(), loc 1";
  int i,j,k;
  for(i=1;i<=EF.NumPlayers();i++) 
    for(j=1;j<=EF.NumInfosets()[i];j++)
      for(k=1;k<basis.NumActions(i,j);k++) 
	equations+=Equation(i,j,k,k+1);

  /*
  gout << "\nSequentialEquilib(), loc 2";
  for(i=1;i<=EF.NumPlayers();i++) 
    for(j=1;j<=EF.NumInfosets()[i];j++)
      equations+=Equation(i,j);

  gout << "\nSequentialEquilib(), loc 3";

  */

  for(i=1;i<=EF.NumPlayers();i++) 
    for(j=1;j<=EF.NumInfosets()[i];j++)
      for(k=1;k<basis.NumNodes(i,j);k++) 
	equations+=Equation(i,j,k);

  gout << "\nSequentialEquilib(), loc 4";
  
// set up the rectangle of search
  gVector<T> bottoms(num_vars), tops(num_vars);
  bottoms = (T)0;
  tops = (T)1;
  
  gRectangle<T> Cube(bottoms, tops); 
  
  // start QuikSolv
  gWatch timer;
  timer.Start();

  gout << "\nLast sig, mu, zeta: " << lastsig << " " << lastmu << " " << lastzeta;
  QuikSolv<T> quickie(equations);
  if(params.trace>0) {
    (*params.tracefile) << "\nThe equilibrium equations are \n" 
      << quickie.UnderlyingEquations() ;
  }  

  // 2147483647 = 2^31-1 = MaxInt

  if(quickie.FindCertainNumberOfRoots(Cube,2147483647,params.stopAfter)) {
    if(params.trace>0) {
      (*params.tracefile) << "\nThe system has the following roots in [0,1]^"
	<< num_vars << " :\n" << quickie.RootList();
    }
  }
  else
    if(params.trace>0) {
      (*params.tracefile) << "The system\n" << quickie.UnderlyingEquations()
	<< " could not be resolved by FindRoots.\n";
    }
  timer.Stop();
  if(params.trace>0) {
    (*params.tracefile)  << "The QuikSolv computation of roots took " 
      << (int)timer.Elapsed() << " seconds.\n\n";
  }
/*
  int index = SaveSolutions(quickie.RootList());

  return index;
*/	 
  time = watch.Elapsed();
  return 1;
}

template <class T> int 
SequentialEquilibModule<T>::SaveSolutions(const gList<gVector<gDouble> > &list)
{
  return 1;
}

template <class T> long SequentialEquilibModule<T>::NumEvals(void) const
{
  return nevals;
}

template <class T> double SequentialEquilibModule<T>::Time(void) const
{
  return time;
}

template <class T> SeqEquilibParams &SequentialEquilibModule<T>::Parameters(void)
{
  return params;
}

template <class T>
const gList<BehavSolution> &SequentialEquilibModule<T>::GetSolutions(void) const
{
  return solutions;
}

template <class T> gPoly<T> 
SequentialEquilibModule<T>::Equation(int i, int j, int k, int kk) const
{
  return Payoff(basis.Actions(i,j)[k]) - Payoff(basis.Actions(i,j)[kk]);
}

template <class T> gPoly<T> 
SequentialEquilibModule<T>::Equation(int i, int j, int k) const
{
  gout << "\nInEquation(i,j,k)";
  gPoly<T> equation(Space,Lex);

  equation=RealizProb(i,j);
  equation*=mu(i,j,k);
  equation-=RealizProb(bigbasis.Nodes(i,j)[k]);
  return equation;
}

template <class T> gPoly<T> 
SequentialEquilibModule<T>::Equation(int i, int j) const
{
  gPoly<T> equation(Space,(T)1,Lex);

  for(int k=1;k<=bigbasis.NumActions(i,j);k++)
    if(basis.EFSupport::Find(bigbasis.Actions(i,j)[k]))
      equation-=zeta(i,j,k);
  return equation;
}

template <class T> gPoly<T> 
SequentialEquilibModule<T>::RealizProb(Node *node) const
{
  gPoly<T> equation(Space,(T)1,Lex);
  const Action *act;
  Infoset *iset;
  while(node!=EF.RootNode()) {
    act = LastAction(node);
    iset = act->BelongsTo();
    if(iset->IsChanceInfoset())
      equation*=(double)EF.GetChanceProb(act);
    else
      equation*=zeta(iset->GetPlayer()->GetNumber(),iset->GetNumber(),
		     bigbasis.EFSupport::Find(act));
    node = node->GetParent();
  }
  return equation;
}

template <class T> gPoly<T> 
SequentialEquilibModule<T>::RealizProb(int i, int j) const
{
  gPoly<T> equation(Space,Lex);
  for(int k=1;k<=bigbasis.NumNodes(i,j);k++)
    if(basis.Find(bigbasis.Nodes(i,j)[k]))
      equation+=RealizProb(bigbasis.Nodes(i,j)[k]);
  return equation;
}


template <class T> gPoly<T> 
SequentialEquilibModule<T>::sigma(int i, int j, int k) const
{
  gPoly<T> equation(Space,Lex);
  int nn = basis.EFSupport::Find(bigbasis.Actions(i,j)[k]); 
  if(nn)
    if(nn<basis.NumActions(i,j)) {
      gPoly<T> term(Space,(*sigIndex)(i,j,k),1,Lex);
      equation = term;
    }
    else {
      gPoly<T> term(Space,(T)1,Lex);
      equation+=term;
      for(int kk=1;kk<basis.NumActions(i,j);kk++)
	equation-=sigma(i,j,kk);
    }
  return equation;
}

template <class T> gPoly<T> 
SequentialEquilibModule<T>::mu(int i, int j, int k) const
{
  gPoly<T> equation(Space,Lex);
  int nn = basis.Find(bigbasis.Nodes(i,j)[k]);
  if(nn)
    if(nn<basis.NumNodes(i,j)) {
      gPoly<T> term(Space,(*muIndex)(i,j,k),1,Lex);
      equation = term;
    }
    else {
      gPoly<T> term(Space,(T)1,Lex);
      equation+=term;
      for(int kk=1;kk<basis.NumNodes(i,j);kk++)
	equation-=mu(i,j,kk);
    }
  return equation;
}

template <class T> gPoly<T> 
SequentialEquilibModule<T>::zeta(int i, int j, int k) const
{
  const Action * act;
  act = bigbasis.Actions(i,j)[k];
  if(basis.EFSupport::Find(act))
    return sigma(i,j,k);
  gPoly<T> equation(Space,(T)1,Lex);
  if(!support.Find(act))
    return equation;
  gPoly<T> term(Space,(*zetaIndex)(i,j,k),1,Lex);
  return term;
}

//----------------
// Payoff
//----------------

template <class T> gPoly<T> SequentialEquilibModule<T>::
Payoff(Node *n, EFPlayer *p) const
{
  int pl = (n->GetInfoset()) ? n->GetInfoset()->GetPlayer()->GetNumber() : -1;
  int iset = (n->GetInfoset()) ? n->GetInfoset()->GetNumber() : 0;
  gPoly<T> value(Space,Lex);
  
  if (n->GetOutcome()) {
    gPoly<T> term(Space,(double)EF.Payoff(n->GetOutcome(), p->GetNumber()),Lex);
    value+=term;
  }

  int nc = n->NumChildren();
  if(nc==0) return value;

  if (n->GetInfoset()->IsChanceInfoset())
    for (int i = 1; i <= nc; i++) {
      gPoly<T> term(Space,(double)EF.GetChanceProb(n->GetInfoset(),i),Lex);
      value += (term * Payoff(n->GetChild(i),p));
    }
  else  {    // player decision node
    const gArray<const Action *> &actions =
      support.Actions(pl, iset);
    
    for (int act = 1; act <= actions.Length(); act++)  {
      int childno = actions[act]->GetNumber();
      value+= sigma(pl,iset,childno)*Payoff(n->GetChild(childno), p);
    }
  }
  return value;
}

template <class T> gPoly<T> SequentialEquilibModule<T>::
Payoff(const Action *a) const
{
//  gout << "\nInPayoff(a)";
  int iset = a->BelongsTo()->GetNumber();
  int pl = a->BelongsTo()->GetPlayer()->GetNumber();
  int act = a->GetNumber();
  gPoly<T> value(Space,Lex);

  const gArray<Node *> &nodes = basis.Nodes(pl,iset);
  for(int i = 1;i<=nodes.Length();i++) {
    int memberno = bigbasis.Find(nodes[i]);
//    gout << "\npl,iset,memberno: " << pl << " " << iset << " " << memberno;
    value += mu(pl,iset,memberno) * Payoff(nodes[i]->GetChild(act),a->BelongsTo()->GetPlayer());
//    gout << "\nvalue: " << value;
  }
//  gout << "\nreturning: " << value;
  return value;
}
