//
// $Source$
// $Date$
// $Revision$
//
// DESCRIPTION:
// Implementation of base tableau classes
//
// This file is part of Gambit
// Copyright (c) 2002, The Gambit Project
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

// ---------------------------------------------------------------------------
//                gbtBaseTableau method definitions
// ---------------------------------------------------------------------------

#include "btableau.h"

template <class T>
bool gbtBaseTableau<T>::ColIndex(int x) const
{ return MinCol()<=x && x<=MaxCol(); }

template <class T>
bool gbtBaseTableau<T>::RowIndex(int x) const
{ return MinRow()<=x && x<=MaxRow(); }

template <class T>
bool gbtBaseTableau<T>::ValidIndex(int x) const
{ return (ColIndex(x) || RowIndex(-x)); }

template <class T>
void gbtBaseTableau<T>::CompPivot(int outlabel, int col)
{
  Pivot(Find(outlabel),col);
  Pivot(Find(-col),-outlabel);
}


// ---------------------------------------------------------------------------
//            gbtTableauInterface method definitions
// ---------------------------------------------------------------------------

// Constructors and Destructor
 
template <class T> 
gbtTableauInterface<T>::gbtTableauInterface(const gbtMatrix<T> &A, const gbtVector<T> &b)
  : A(&A), b(&b), basis(A.MinRow(),A.MaxRow(),A.MinCol(),A.MaxCol()), 
    solution(A.MinRow(),A.MaxRow()), npivots(0), 
    artificial(A.MaxCol()+1,A.MaxCol())

{ 
  // These are the values recommended by Murtagh (1981) for 15 digit 
  // accuracy in LP problems 
  // Note: for gbtRational, eps1 and eps2 resolve to 0
  gEpsilon(eps1,5);
  gEpsilon(eps2);
}

template <class T> 
gbtTableauInterface<T>::gbtTableauInterface(const gbtMatrix<T> &A, 
				      const gbtBlock<int> &art, const gbtVector<T> &b)
  : A(&A), b(&b), 
    basis(A.MinRow(),A.MaxRow(),A.MinCol(),A.MaxCol()+art.Length()), 
    solution(A.MinRow(),A.MaxRow()), npivots(0),
    artificial(A.MaxCol()+1,A.MaxCol()+art.Length())
{ 
  gEpsilon(eps1,5);
  gEpsilon(eps2);
  for(int i = 0;i<art.Length();i++)
    artificial[A.MaxCol()+1+i] = art[art.First()+i];
}

template <class T>
gbtTableauInterface<T>::gbtTableauInterface(const gbtTableauInterface<T> &orig) 
  : A(orig.A), b(orig.b), basis(orig.basis), solution(orig.solution),
    npivots(orig.npivots), eps1(orig.eps1), eps2(orig.eps2), 
    artificial(orig.artificial)
{ }

template <class T>
gbtTableauInterface<T>::~gbtTableauInterface()
{ }

template <class T>
gbtTableauInterface<T>& gbtTableauInterface<T>::operator=(const gbtTableauInterface<T> &orig)
{
  if(this!= &orig) {
    A = orig.A;
    b = orig.b;
    basis= orig.basis;
    solution= orig.solution;
    npivots = orig.npivots;
    artificial = orig.artificial;
  }
  return *this;
}

// getting information

template <class T>
int gbtTableauInterface<T>::MinRow() const { return A->MinRow(); }

template <class T>
int gbtTableauInterface<T>::MaxRow() const { return A->MaxRow(); }

template <class T>
int gbtTableauInterface<T>::MinCol() const { return basis.MinCol(); }

template <class T>
int gbtTableauInterface<T>::MaxCol() const { return basis.MaxCol(); }

template <class T>
gbtBasis & gbtTableauInterface<T>::GetBasis(void) {return basis; }

template <class T>
const gbtMatrix<T> & gbtTableauInterface<T>::Get_A(void) const {return *A; }

template <class T>
const gbtVector<T> & gbtTableauInterface<T>::Get_b(void) const {return *b;}

template <class T>
bool gbtTableauInterface<T>::Member(int i) const
{ return basis.Member(i);}

template <class T>
int gbtTableauInterface<T>::Label(int i) const
{ return basis.Label(i);}

template <class T>
int gbtTableauInterface<T>::Find(int i) const
{ return basis.Find(i);}

template <class T>
long gbtTableauInterface<T>::NumPivots() const
{ return npivots; }

template <class T>
long &gbtTableauInterface<T>::NumPivots()
{ return npivots; }

template <class T>
void gbtTableauInterface<T>::Mark(int label)
{basis.Mark(label);}

template <class T>
void gbtTableauInterface<T>::UnMark(int label)
{basis.UnMark(label);}

template <class T>
bool gbtTableauInterface<T>::IsBlocked(int label) const
{
  return basis.IsBlocked(label);
}

template <class T>
void gbtTableauInterface<T>::GetColumn(int col, gbtVector<T> &ret) const
{
  if(IsArtifColumn(col)) {
    ret = (T) 0;
    ret[artificial[col]] = (T)1;
  }
  else if(basis.IsRegColumn(col))
    A->GetColumn(col, ret);
  else if (basis.IsSlackColumn(col)) {
    ret = (T) 0;
    ret[-col] = (T) 1;
  }
}

template <class T>
void gbtTableauInterface<T>::GetBasis(gbtBasis &out) const
{
  out= basis;
}

template <class T>
gbtBasicFeasibleSolution<T> gbtTableauInterface<T>::GetBFS()
{
  gbtVector<T> sol(basis.First(),basis.Last());
  BasisVector(sol);

  gbtBasicFeasibleSolution<T> cbfs((T) 0);
  for(int i=MinCol();i<=MaxCol();i++) 
    if(Member(i)) 
      cbfs.Define(i,sol[basis.Find(i)]);
  return cbfs;
}

template <class T>
gbtBasicFeasibleSolution<T> gbtTableauInterface<T>::GetBFS1() const
{
  gbtVector<T> sol(basis.First(),basis.Last());
  BasisVector(sol);

  gbtBasicFeasibleSolution<T> cbfs((T) 0);
  int i;
  for(i=-MaxRow();i<=-MinRow();i++) 
    if(Member(i)) 
      cbfs.Define(i,sol[basis.Find(i)]);
  for(i=MinCol();i<=MaxCol();i++) 
    if(Member(i)) 
      cbfs.Define(i,sol[basis.Find(i)]);
  return cbfs;
}

template <class T>
void gbtTableauInterface<T>::Dump(gbtOutput &to) const
{ 
  gbtVector<T> bb(MinRow(), MaxRow());
  BasisVector(bb);
  to << "\nBasis:\n";  
  basis.Dump(to);
  to << "\n" << bb;
}

template <class T>
void gbtTableauInterface<T>::BigDump(gbtOutput &to)
{ 
  to << "\nBasis:";
  basis.Dump(to);
  gbtMatrix<T> AA(MinRow(),MaxRow(),MinCol(),MaxCol()+(*A).NumRows());
  gbtVector<T> bb(MinRow(), MaxRow());

  BasisVector(bb);
  to << "\nBasisVector:\n" << bb;

  for(int j=MinCol();j<=MaxCol();j++) {
    SolveColumn(j, bb);
    for(int i=AA.MinRow();i<=AA.MaxRow();i++) 
      AA(i,j) = bb[i];
  }
  for(int j=MinRow();j<=MaxRow();j++) {
    SolveColumn(-j, bb);
    for(int i=AA.MinRow();i<=AA.MaxRow();i++) 
      AA(i,MaxCol()+j) = bb[i];
  }
  to << "\nTableau:\n" << AA;
}

// miscellaneous functions

template <class T>
bool gbtTableauInterface<T>::EqZero(T x) const
{ 
  return (LeZero(x) && GeZero(x));
}

template <class T>
bool gbtTableauInterface<T>::LtZero(T x) const
{ 
  return !GeZero(x);
}

template <class T>
bool gbtTableauInterface<T>::GtZero(T x) const
{ 
  return !LeZero(x);
}

template <class T>
bool gbtTableauInterface<T>::LeZero(T x) const
{ 
  if(x <=eps2) return 1;
  return 0;
}

template <class T>
bool gbtTableauInterface<T>::GeZero(T x) const
{ 
  if(x >= -eps2) return 1;
  return 0;
}

template <class T>
T gbtTableauInterface<T>::Epsilon(int i) const
{
  if(i!=1 && i!=2) throw BadDim();
  if(i==1) return eps1;
  return eps2;
}

template <class T>
bool gbtTableauInterface<T>::IsArtifColumn(int col) const
{
  return col>=artificial.First() && col<=artificial.Last();
}

/*
template <class T> gbtBaseTableau<T>::BadPivot::~BadPivot()
{ }

template <class T> gbtText gbtBaseTableau<T>::BadPivot::Description(void) const
{
  return "Bad Pivot in gbtBaseTableau";
}
*/
template <class T> gbtBaseTableau<T>::BadDim::~BadDim()
{ }

template <class T> gbtText gbtBaseTableau<T>::BadDim::Description(void) const
{
  return "Bad Dimension in gbtBaseTableau";
}
