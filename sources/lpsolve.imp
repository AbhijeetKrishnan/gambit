//
//# FILE: lpsolve.imp -- Implementation of LP solver
//#
//# @(#)lpsolve.imp	2.1 3/24/97 
//#

#include "lpsolve.h"

template <class T>
LPSolve<T>::LPSolve(const gMatrix<T> &A, const gVector<T> &b,
		    const gVector<T> &c, int nequals, gStatus &s) 
  : well_formed(1), feasible(1), bounded(1), aborted(0), 
    nvars(c.Length()),neqns(b.Length()), total_cost(0),tmin(0),
     opt_bfs((T)0),  dual_bfs((T)0) ,A(A), b(b), c(c), AA(0),tab(0), 
     UB(0),LB(0),ub(0),lb(0),xx(0), cost(0),
     y(b.Length()),x(b.Length()),d(b.Length()), status(s)
{
    // These are the values recommended by Murtagh (1981) for 15 digit 
    // accuracy in LP problems 
  gEpsilon(eps1,5);
  gEpsilon(eps2,8);
  gEpsilon(eps3,6);
  
  // Check dimensions
  if (A.NumRows() != b.Length() || A.NumColumns() != c.Length()) {
    well_formed = 0;
    return;
  }
   // gout << "\n--- Begin LPSolve ---\n";
  
  // initialize data
  int i,j,num_inequals,xlab,num_artific,index;
  
  num_inequals = A.NumRows()-nequals;
   // gout << "\nnvars = " << nvars;
   // gout << " neqns = " << neqns;
   // gout << " Num inequalities = " << num_inequals;
   // gout << " Num equalities = " << nequals;
  
  num_artific=0;
  for(i=b.First();i<=b.Last();i++)
    if(b[i]<(T)0) num_artific++; 
  nvars+=num_artific;
  status.SetProgress(0.0);
  
   // gout << "\n--- Begin Phase I ---\n";
  
   // gout << "\n nartific = " << num_artific;
   // gout << " nvars = " << nvars << "\n";
  
  // OK, the following is real dumb -- making copies of all this stuff 
  // for phase I (especially of A). But this will get it working for now.  
  // A better  solution must wait untill the Tableau class allows explicit 
  // handling of the artificial variables. 
  
  UB = new gVector<int>(nvars+neqns);
  LB = new gVector<int>(nvars+neqns);
  ub = new gVector<T>(nvars+neqns);
  lb = new gVector<T>(nvars+neqns);
  xx = new gVector<T>(nvars+neqns);
  cost = new gVector<T>(nvars+neqns);
  AA = new gMatrix<T>(neqns,nvars);
  
  for(i=A.MinRow();i<=A.MaxRow();i++)  
    for(j=A.MinCol();j<=A.MaxCol();j++)
      (*AA)(i,j)=A(i,j);
  index=1;
  for(j=b.First();j<=b.Last();j++)  // insert artificial variables for b[j]<0
    if(b[j]<(T)0) {
      for(i=A.MinRow();i<=A.MaxRow();i++)
	if (i==j)
	  (*AA)(i,A.MaxCol()+index) = (T)1;
	else
	  (*AA)(i,A.MaxCol()+index) = (T)0;
      index++;
    }
  *UB = 0; *LB = 0;
  *ub = (T)0; *lb = (T)0;
  
  
  // Define Phase I upper and lower bounds
  for(i=1;i<=nvars;i++) {
    (*LB)[i]=1;
    (*lb)[i]=(T)0;
  }
  // for slack variables
  for(i = 1;i<= neqns;i++) {
    if(b[i] >= (T)0) (*LB)[nvars+i] = 1;
    else (*UB)[nvars+i] = 1;
  }
  // define Phase 1 unit cost vector
  (*cost) = (T)0;
  int num_less_zero = 0;
  for (i = 1; i <= neqns; i++)  {
    (*cost)[nvars+i] = (T)0;
    if ((*UB)[nvars+i]) {
      (*cost)[nvars+i] = (T)1;
      num_less_zero++;
    }
    else 
      if(i > num_inequals) (*cost)[nvars+i] = -(T)1;
  }
  
   // gout << "\nUB = " <<  *UB << " " << "\nLB = " << *LB;
   // gout << "\nub = " <<  *ub << " " << "\nlb = " << *lb;
   // gout << "\ncost = " <<  (*cost);
  
  
  // Initialize the tableau
  
   // gout << "\nA: ";
   // (*AA).Dump(gout);
   // gout << "b: ";
   // b.Dump(gout);
   // gout << "\ncost: ";
   // (*cost).Dump(gout);
  
  tab = new LPTableau<T>((*AA),b);
  tab->SetCost((*cost));
  
   // gout << "\nInitial Tableau = \n";
   // tab->Dump(gout);
  
  
  for(i=1;i<=(*xx).Length();i++) {
    if((*LB)[i]) (*xx)[i]=(*lb)[i];
    else if((*UB)[i]) (*xx)[i]=(*ub)[i];
    else (*xx)[i]=(T)0;
  }
  tab->BasisVector(x);
  for(i=1;i<=x.Length();i++) {
    xlab = tab->Label(i);
    if(xlab<0) xlab=nvars-xlab;
    (*xx)[xlab]=x[i];
  }
   // gout << "\nxx: " << (*xx);
  
  Solve(1);
  
  if(status.Get()) {
    aborted=1;
    status.Reset();
    return;
  }
    
   // gout << "\nFinal tableau: ";
   // tab->Dump(gout); 
  total_cost = tab->TotalCost();
   // gout << ", cost: " << total_cost;

   // gout << "\n--- End Phase I ---\n";
  
  if(!bounded) {
      // gout << "\nPhase 1 Unbounded\n";
  }
  assert(bounded);
  
  // which eps should be used here?  
  if(total_cost < -eps1) {   
    feasible = 0;
     // gout << "\nProblem Infeasible\n\n";
    return;
  }
  
   // gout << "\n--- Begin Phase II ---\n";

// Define Phase II upper and lower bounds for slack variables
  
   // gout << "\nxx: " << (*xx);

  for(i=num_inequals+1;i<=neqns;i++) 
    (*UB)[nvars+i] = 1;
  for(i=1;i<=neqns;i++) {
    if(b[i] < (T)0) (*LB)[nvars+i] = 1;
  }
  
// install Phase II unit cost vector
  
  for(i=c.First();i<=c.Last();i++)
    (*cost)[i] = c[i];
  for(i=c.Last()+1;i<=nvars+neqns;i++)
    (*cost)[i] = (T)0;
  
   // gout << "\nUB = " <<  *UB << " " << " LB = " << *LB;
   // gout << "\nub = " <<  *ub << " " << " lb = " << *lb;
   // gout << "\nc = " <<  (*cost);
  
  tab->SetCost((*cost));
  
   // gout << "\nInitial basis: ";
   // tab->Dump(gout);   gout << '\n';
  
  Solve(2);
  
  if(status.Get()) {
    aborted=1;
    status.Reset();
    return;
  }
    
   // gout << "\n--- End Phase II ---\n";

  if(!bounded) {
     // gout << "\nPhase II Unbounded\n";
  }
   // gout << "\nFinal basis: ";
   // tab->Dump(gout);   gout << '\n';
  total_cost = tab->TotalCost();
   // gout << "\ncost: " << total_cost;
  tab->DualVector(y);
//  gout << "DualVector = " << y << "\n";
  opt_bfs = tab->GetBFS();
//   gout << "\nopt_bfs:\n";
//  opt_bfs.Dump(gout);
//  gout << "\n";
  dual_bfs = tab->DualBFS();
//  dual_bfs.Dump(gout);
  for(i=1;i<=neqns;i++)
    if(dual_bfs.IsDefined(-i))
      opt_bfs.Define(-i,dual_bfs(-i));

   // gout << "\n--- End LPSolve ---\n";

     // Call GetAll for testing purposes
   // GetAll();

}

//template <class T> LPSolve<T>::
//LPSolve(const gMatrix<T> &A, const gVector<T> &/*B*/, 
//	const gVector<T> &/*C*/,  const gVector<int> &/*sense*/, 
//	const gVector<int> &/*LB*/,  const gVector<T> &/*lb*/, 
//	const gVector<int> &/*UB*/, const gVector<T> &/*ub*/)
// : well_formed(1), feasible(1), bounded(1),  
//    nvars(c.Length()),neqns(b.Length()), total_cost(0), 
//    opt_bfs((T)0),  dual_bfs((T)0),  A(A), b(b), c(c), tab(0), 
//    UB(c.Length()+b.Length()), LB(b.Length()+c.Length()), 
//    ub(c.Length()+b.Length()),lb(c.Length()+b.Length()),
//    xx(c.Length()+b.Length()),
//    y(b.Length()),x(b.Length()),d(b.Length()),
//    cost(c.Length()+b.Length())
//{ 
//  gout << "\n This constructor not implemented yet";
//  assert(0);
//}

template <class T> void LPSolve<T>::Solve(int phase)
{
  int i, in,xlab;
  int outlab = 0;
  int out = 0;
  gVector<T> a(neqns);
  double npiv;
  
  if(status.Get()) return;
  do { 
    tab->DualVector(y);         // step 1: Solve y B = c_B
    // gout << "\nstep 1, y: " << y;
    do {
      in = Enter();            // step 2: Choose entering variable 
      // gout << "\nstep 2, in: " << in;
      if(in) {
	if(in>0) 
	  (*AA).GetColumn(in,a);
	else {
	  a=(T)0;a[-in]=(T)1;
	}
	tab->Solve(a,d);    // step 3: Solve B d = a
	out = Exit(in);          // step 4: Choose leaving variable
	if(out==0) {
	  bounded=0;
	  return;
	}
	else if (out<0)
	  outlab = in;
	else {
	  // gout << "\nstep 4, in: " << in << " out: " << out;
	  outlab = tab->Label(out);
	}
                                // update xx
	for(i=1;i<=x.Length();i++) {   // step 5a:
	// gout << "\nstep 5a, i: " << i;
	  xlab=tab->Label(i);
	  if(xlab<0)xlab=nvars-xlab;
	  (*xx)[xlab]=(*xx)[xlab]+(T)flag*tmin*d[i];
	}
	if(in>0)
	  (*xx)[in] -= (T)flag*tmin;
	if(in<0)
	  (*xx)[nvars-in] -= (T)flag*tmin;
	// gout << "\nstep 5a, xx: " << (*xx);
      }
    }
    while(outlab==in && outlab !=0 && !status.Get()); 
    if(in) {
     // gout << "\nstep 5b, Pivot in: " << in << " out: " << out;
      tab->Pivot(out,in);       // step5b: Pivot new variable into basis
      
      npiv=(double)tab->NumPivots();
      status.SetProgress(npiv/(npiv+1));
      tab->BasisVector(x);
      // gout << "\n tab = ";
      // tab->Dump(gout);
      // gout << "\nxx: " << (*xx);
      // gout << ", Cost = " << tab->TotalCost() << "\n";
      if(phase ==1 && tab->TotalCost() > -eps1) return;
//      gout << "\nAfter pivot tab = \n";
    }
  }
  while(in);
  
}
  
template <class T> int LPSolve<T>::Enter()
{ 
  int i,in;
  T z;
  gVector<T> tmp(A.MinRow(), A.MaxRow());

  in = 0;

  T test = (T)0;
  for(i=1;i<=nvars+neqns;i++) {
    int lab = i;
    if(i>nvars)lab=nvars-i;
    if(!tab->Member(lab)) {
      if(i<=nvars) {
	(*AA).GetColumn(i,tmp);
	z = y * tmp;
      }
      else 
	z = y[i-nvars];
      // gout << "\n i = " << i << " cost: " << (*cost)[i] << " z: " << z << " test: " << test;
      if((*cost)[i]-z > test+eps1) 
	if((*UB)[i]==0 || ((*UB)[i]==1 && (*xx)[i] - (*ub)[i] < -eps1)) {
	  {test=(*cost)[i]-z;in = lab;flag = -1;}
	  // gout << "\nflag: -1  in: " << in << " test: " << test;
	}
      if(z - (*cost)[i] > test+eps1) 
	if((*LB)[i]==0 || ((*LB)[i]==1 && (*xx)[i] - (*lb)[i] > eps1)) {
	  {test=z-(*cost)[i];in=lab;flag = 1;}
	  // gout << "\nflag: +1  in: " << in << " test: " << test;
	}
    }
  }
  return in;
}

template <class T> int LPSolve<T>::Exit(int in)
{
  int j,out,lab,col;
  T t;

  // gout << "\nin Exit(), flag: " << flag;
  out=0;
  tmin = (T)100000000;
  for (j=1; j<=neqns; j++)  {
    lab=tab->Label(j);
    col=lab;
    if(lab<0)col=nvars-lab;
    if(flag == -1) {
      t = (T)1000000000;
      if (d[j] > eps2 && (*LB)[col]==1) {
	t = ((*xx)[col]-(*lb)[col])/d[j];
      }
      if (d[j] < -eps2 && (*UB)[col]==1) { 
	t = ((*xx)[col]-(*ub)[col])/d[j];
      }
      if(t>=-eps2 && t < tmin-eps2) {
	tmin = t;
	out = j;
      }
      // gout << "\nd[" << j << "]: " << d[j] << " col: " << col << " xx: " << (*xx)[col];
      // gout << " t: " << t << " tmin: " << tmin; 
    }
    if(flag == 1) {
      t = (T)1000000000;
      if (d[j] > eps2 && (*UB)[col]==1) { 
	t = ((*ub)[col]-(*xx)[col])/d[j];
      }
      if (d[j] < -eps2 && (*LB)[col]==1) { 
	t = ((*lb)[col]-(*xx)[col])/d[j];
      }
      if(t >= -eps2 && t < tmin-eps2) {
	tmin = t;
	out = j;
      }
      // gout << "\nd[" << j << "]: " << d[j] << " col: " << col << " xx: " << (*xx)[col]; 
      // gout << " t: " << t << " tmin: " << tmin; 
    }
  }
  col=in;
    if(in<0)col=nvars-in;
  t = (T)1000000000;
  if(flag == -1 && (*UB)[col]) 
    t = (*ub)[col]-(*xx)[col];
  if(flag == 1 && (*LB)[col]) 
    t = (*xx)[col]-(*lb)[col];
  if(t > eps2 && t < tmin-eps2) {
    tmin = t;
    out = -1;
  }

  return out;
}

template <class T> T LPSolve<T>::OptimumCost(void) const
{
  return total_cost;
}

template <class T> const gVector<T> &LPSolve<T>::OptimumVector(void) const
{
  return (*xx);
}

template <class T> const gList<BFS <T> > &LPSolve<T>::GetAll(void)
{

    // These will be the data sent to NewVertEnum
  // gMatrix<T> *E  = new gMatrix<T>(1 + A.NumRows() + 
  //                                     A.NumColumns(),A.NumColumns());
  // gVector<T> *f  = new gVector<T>(1 + A.NumRows() + A.NumColumns());

    // These will be the data sent to NewVertEnum
  gMatrix<T> *O  = new gMatrix<T>(1 + A.NumRows() + 
                                      A.NumColumns(),A.NumColumns());
  gVector<T> *p  = new gVector<T>(1 + A.NumRows() + A.NumColumns());

    // These keep track of where in E and f we are when constructing them
  //int i = E->MinRow();
  //int ii = f->First();

    // These keep track of where in O and p we are when constructing them
  //int q = O->MinRow();
  //int qq = p->First();

    // Get full_bfs, which will tell me which rows to put first.
  BFS<T> full_bfs;
  full_bfs = tab->GetBFS1();

  
    // blank is a row of 0's used to fillin -I rows.
  gArray<T> blank(A.NumColumns());
  for (int j=blank.First(); j<=blank.Last(); j++)
    blank[j] = (T)0;

    // Temporary variable
  gArray<T> temp(A.NumColumns());

    // Counting variables for filling O and p
  int filled = 1;
  int filled2 = A.NumColumns() + 1;

    // Fill first n of O with desirable elements.
    // Cycle through every row of A and -I, putting them where they go.
  for (int Row1 = -A.NumRows(); Row1<=A.NumColumns(); Row1++)
  {
    // Find desirable row of A or -I 
    if (Row1 == 0)  // Do nothing for row 0, which is never defined in BFS
    {}
    else  // Not 0
    {
      if (! full_bfs.IsDefined(Row1))  // If it is a desirable row
      {
          // Set row filled to be proper thing, increment  filled.
        //gout << "Row " << Row1 << " is not defined.\n";
        if (Row1 < 0)
        {
          // Set row filled to be -Row1 of A
	  //gout << "Set row " << filled << " to row " << -Row1 << " of A\n";
          A.GetRow(-Row1,temp);
          O->SetRow(filled,temp);
          (*p)[filled] = -b[-Row1];
        }
        else
        {
          // Set row filled to be Row1 of -I
	  //gout << "Set row " << filled << " to row " << Row1 << " of -I\n";
          O->SetRow(filled,blank);
	  (*O)(filled,Row1) = (T)-1;
          (*p)[filled] = (T)0;

        }
         
        //gout << "  filled: " << filled << "\n";
        filled++;
      }
      else  // It is defined (Row1 is undesirable)
      {
          // Set row filled2 to be proper thing, increment  filled2.
        //gout << "Row " << Row1 << " is not defined.\n";
        if (Row1 < 0)
        {
          // Set row filled2 to be -Row1 of A
	  //gout << "Set row " << filled2 << " to row " << -Row1 << " of A\n";
          A.GetRow(-Row1,temp);
          O->SetRow(filled2,temp);
          (*p)[filled2] = -b[-Row1];
        }
        else
        {
          // Set row filled2 to be Row1 of -I
	  //gout << "Set row " << filled2 << " to row " << Row1 << " of -I\n";
          O->SetRow(filled2,blank);
	  (*O)(filled2,Row1) = (T)-1;
          (*p)[filled2] = (T)0;
        }
         
        //gout << "  filled2: " << filled2 << "\n";
        filled2++;
      }

    }
  }


    // Set next row of O to be (-c)
  temp = c;
  for (int j = temp.First(); j<=temp.Last(); j++)
    temp[j] = -temp[j];
  O->SetRow(filled2,temp); 

    // Set next element of p
  gVector<T> temp2(c.Length());
  int k=xx->First();
  for (int j=temp2.First(); j<=temp2.Last(); j++, k++)
    temp2[j] = (*xx)[k];
  (*p)[filled2] = (c * temp2);

    // Spit out info
  //gout << "O: \n" << (*O) << "\n\n";
  //gout << "p: \n" << (*p) << "\n\n";

    // Fill first n of O with desirable elements.
  /*for (; filled <= A.NumColumns(); filled++)*/
  /*{*/
    // Find desirable row of A or -I 
      // While current row is not desirable and there are more rows left
    /*while (full_bfs.IsDefined(-Row1) && Row1 < A.NumRows())*/
      /*Row1++;*/

    /*if (! full_bfs.IsDefined(-Row1))*/
    /*{*/
      /*// Set row filled to be Row1 of A*/
    /*}*/
    /*else*/
      /*break;*/

    // and put it in O and p.
  /*}*/
//
//    // Set first block of E to be A
//  for (int j = A.MinRow(); j<=A.MaxRow(); i++,j++)
//  {    
//    /*gout << "i: " << i << "\n";*/
//    A.GetRow(j,temp);
//    E->SetRow(i,temp);
//  }
//
//    // Set first block of f to be b
//  for (int j = b.First(); j<=b.Last(); ii++,j++)
//  {
//    (*f)[ii] = -b[j];
//  }
//
//    // Set next row of E to be (-c)
//  temp = c;
//  for (int j = temp.First(); j<=temp.Last(); j++)
//    temp[j] = -temp[j];
//  /*gout << "i: " << i << "\n";*/
//  E->SetRow(i,temp); 
//
//    // Set next element of f
//  k=xx->First();
//  for (int j=temp2.First(); j<=temp2.Last(); j++, k++)
//    temp2[j] = (*xx)[k];
//  (*f)[ii] = (c * temp2);
//
//    // Increment counters for above row
//  i++;ii++;
//
//    // Create SquareMatrices Ident and NegIdent, n by n ident matrices.
//  gSquareMatrix<T> Ident(A.NumColumns());
//  Ident.MakeIdent();
//  gSquareMatrix<T> NegIdent(-Ident);
//
//
//    // Set last block of E to be Negident, last of f to be 0
//  for (int j = NegIdent.MinRow(); j<=NegIdent.MaxRow(); i++,j++,ii++)
//  {
//    /*gout << "i: " << i << "\n";*/
//    NegIdent.GetRow(j,temp);
//    E->SetRow(i,temp);
//    (*f)[ii] = 0;
//  }
//
//    // Because VertEnum must remain general for all given matrices, then VE 
//    // cannot access full_bfs to determine an appropriate basis.  Instead,
//    // E and f will be arranged such that the first n elements/rows form the
//    // independent basis, so that VE will pick them.
//
//    // Print out some useful stuff.
//  gout << "Full_BFS: \n" << full_bfs << "\n\n";
//  full_bfs.Dump(gout);
//  gout << "\n\n";
//  // gout << "E: \n"    << (*E)    << "\n\n";
//
//    // Temporary variable of type T.
//  T ttemp;
//
//    //   Rearrange rows: This goes in two parts, depending on how the row must
//    // be looked up.
//
//    // First replace basic elements in the first N rows with non-basic rows
//    // between the Nth and Kth rows.
//  int row1, row2;
//    // Set first counter to first row, second to n+1th row-first n will be good.
//  for (row1=1, row2=(A.NumColumns()+1);  
//                          row1<=A.NumColumns() && row2<=A.NumRows();     row1++)
//  {
//    //gout << "Row1: " << row1 << "\n";
//    if (full_bfs.IsDefined(-row1))  // If row1 is undesirable
//    {
//      while (full_bfs.IsDefined(-row2))  // While row2 is undesirable
//        row2++;
//
//      if(row2 > A.NumRows())  // if row2 is past the A component of E
//	break;
//
//        // Switch here
//      E->SwitchRows(row1, row2);
//      ttemp = ((*f)[row1]);
//      (*f)[row1] = (*f)[row2];
//      (*f)[row2] = ttemp;
//
//      //gout << "Switched row " << row1 << " for row " << row2 << "\n";
//
//      row2++;
//    }
//  }
//
//    // Now replace basic rows in the first N rows with non-basic rows in
//    // the interval [K+1,K+N+1].
//  for (row2=1; row1<=A.NumColumns(); row1++)
//  {
//    if (full_bfs.IsDefined(-row1))
//    {
//      while (full_bfs.IsDefined(row2))
//        row2++;
//
//        // Switch here
//      E->SwitchRows(row1, (row2 + A.NumRows() + 1) );
//      ttemp = ((*f)[row1]);
//      (*f)[row1] = (*f)[row2 + A.NumRows() + 1];
//      (*f)[row2 + A.NumRows() + 1] = ttemp;
//
//      //gout << "Switched row " << row1 << " for row ";
//      //gout << (row2 + A.NumRows() + 1) << "\n";
//
//      row2++;
//    }
//  }


    // Output useful information
  //gout << "A: \n"    << A       << "\n\n";
  //gout << "b: \n"    << b       << "\n\n";
  //gout << "c: \n"    << c       << "\n\n";
  //gout << "xx: \n"   << (*xx)   << "\n\n";
  //gout << "E: \n"    << (*E)    << "\n\n";
  //gout << "f: \n"    << (*f)    << "\n\n";

  NewVertEnum<T> AllSolutions((*O),(*p),temp2,status);

  gList<BFS<T> > *verts = new gList<BFS<T> >(AllSolutions.VertexList());

  // gout << "Here are the vertices: \n";
  // verts->Dump(gout);
  // gout << "\n\n";
  
  return (*verts);
}

template <class T> int LPSolve<T>::IsFeasible(void) const
{
  return feasible;
}

template <class T> int LPSolve<T>::IsBounded(void) const
{
  return bounded;
}

template <class T> int LPSolve<T>::IsWellFormed(void) const
{
  return well_formed;
}

template <class T> int LPSolve<T>::IsAborted(void) const
{
  return aborted;
}

template <class T> long LPSolve<T>::NumPivots(void) const
{
  return tab->NumPivots();
}

template <class T> void LPSolve<T>::OptBFS(BFS<T> &b) const
{
  b = opt_bfs;
}

template <class T> LPSolve<T>::~LPSolve()
{ 
  if(AA) delete AA; 
  if(tab) delete tab; 
  if(UB) delete UB; 
  if(LB) delete LB; 
  if(ub) delete ub; 
  if(lb) delete lb; 
  if(xx) delete xx; 
  if(cost) delete cost; 
}

