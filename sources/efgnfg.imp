//
// FILE: efgnfg.imp -- Type-dependent parts of efg<->nfg routines
//
// $Id$
//

#include "efg.h"
#include "nfg.h"
#include "nfplayer.h"
#include "nfstrat.h"
#include "nfgiter.h"
#include "nfgciter.h"
#include "mixed.h"
#include "lexicon.h"



// Sort of hackish...
#include "efg.imp"

template <class T>
void RealizationProbs(const Nfg &N, const MixedProfile<T> &mp,
		      const Efg &E, BehavProfile<T> &bp,
		      int pl, const gArray<int> *const actions,
		      BehavNode<T> *n)
{
  static const T tremble = (T) 0;
  T prob;

  Node *node = n->node;

  for (int i = 1; i <= n->children.Length(); i++)   {
    if (node->GetPlayer() && !node->GetPlayer()->IsChance())   {
      if (node->GetPlayer()->GetNumber() == pl)  {
	if ((*actions)[node->GetInfoset()->GetNumber()] == i)
	  prob = (T) 1 - tremble + tremble / (T) node->NumChildren();
	else
	  prob = tremble / (T) node->NumChildren();
      }
      else if (bp.Support().Find(node->GetInfoset()->Actions()[i]))
	prob = (T) 1 / (T) bp.Support().NumActions(node->GetPlayer()->GetNumber(),
							  node->GetInfoset()->GetNumber());
      else
	prob = (T) 0;
    }
    else  {   // n.GetPlayer() == 0
      prob = E.GetChanceProb(node->GetInfoset(), i);
    }

    BehavNode<T> *child = n->children[i];
    child->bval = prob * n->bval;
    child->nval += child->bval;    

    RealizationProbs(N, mp, E, bp, pl, actions, child);
  }    
	
}

template <class T>
void BehaviorStrat(const Efg &E, BehavProfile<T> &bp, int pl,
		   BehavNode<T> *n)
{
  for (int i = 1; i <= n->children.Length(); i++)   {
    BehavNode<T> *child = n->children[i];
    if (n->node->GetPlayer() && n->node->GetPlayer()->GetNumber() == pl)
      if (n->nval > (T) 0 && child->nval > (T) 0)  {
	bp(n->node->GetPlayer()->GetNumber(),
	   n->node->GetInfoset()->GetNumber(), 
	   bp.Support().Find(n->node->GetInfoset()->Actions()[i])) =
	  child->nval / n->nval;
      }
    BehaviorStrat(E, bp, pl, child);
  }
}

template <class T> void ClearNodeProbs(BehavNode<T> *n)
{
  n->nval = 0;
  for (int i = 1; i <= n->children.Length(); i++)
    ClearNodeProbs(n->children[i]);
}




template <class T>
void MixedToBehav(const Nfg &N, const MixedProfile<T> &mp,
		  const Efg &E, BehavProfile<T> &bp)
{
  if (AssociatedAfg((Efg *) &E) == &N)   {
    ((gVector<T> &) bp).operator=((gVector<T> &) mp);
    return;
  }

  if (AssociatedNfg((Efg *) &E) != &N)   return;

  ((gVector<T> &) bp).operator=((T)0); 

  BehavNode<T> *n = bp.m_root;
  const NFSupport &support = mp.Support();

  for (int pl = 1; pl <= N.NumPlayers(); pl++)   {
    ClearNodeProbs(n);

    for (int st = 1; st <= support.NumStrats(pl); st++)  {
      int snum = support.Strategies(pl)[st]->Number();
      if (mp(pl, st) > (T) 0)  {
	const gArray<int> *const actions = E.lexicon->strategies[pl][snum];

	n->bval = mp(pl, st);

	RealizationProbs(N, mp, E, bp, pl, actions, bp.m_root);
      }
    }
    
    bp.m_root->nval = (T) 1;
    BehaviorStrat(E, bp, pl, n);
  }
}

template <class T>
void BehavToMixed(const Efg &E, const BehavProfile<T> &bp,
		  const Nfg &N, MixedProfile<T> &mp)
{
  if (E.afg == &N)   {
    ((gVector<T> &) mp).operator=((gVector<T> &) bp);
    return;
  }

  if (!E.lexicon || E.lexicon->N != &N)  return;
  
  for (int pl = 1; pl <= N.NumPlayers(); pl++)  {
    for (int st = 1; st <= N.NumStrats(pl); st++)  {
      T prob = (T) 1;

      for (int iset = 1; iset <= E.Players()[pl]->NumInfosets(); iset++) {
	if ((*E.lexicon->strategies[pl][st])[iset] > 0)
	  prob *= bp(pl, iset, (*E.lexicon->strategies[pl][st])[iset]);
      }
      mp(pl, st) = prob;
    }
  }
}


