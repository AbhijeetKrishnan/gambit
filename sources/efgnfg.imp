//
// FILE: efgnfg.imp -- Type-dependent parts of efg<->nfg routines
//
// $Id$
//

#include "tnode.h"
#include "efg.h"
#include "nfg.h"
#include "nfplayer.h"
#include "nfstrat.h"
#include "nfgiter.h"
#include "nfgciter.h"
#include "mixed.h"
#include "lexicon.h"

void SetEfg(BaseNfg *, BaseEfg *);

template <class T> Nfg<T> *MakeReducedNfg(Efg<T> &E, const EFSupport &support)
{
  int i;

  Lexicon *L = new Lexicon(E);
  for (i = 1; i <= E.NumPlayers(); i++)  {
    L->MakeReducedStrats(support, E.PlayerList()[i], E.RootNode(), NULL);
  }
  gArray<int> dim(E.NumPlayers());
  for (i = 1; i <= E.NumPlayers(); i++)
    dim[i] = L->strategies[i].Length();

  L->MakeLink(&E, new Nfg<T>(dim));
  L->N->SetTitle(E.GetTitle());
  
  for (i = 1; i <= E.NumPlayers(); i++)   {
    L->N->PlayerList()[i]->SetName(E.PlayerList()[i]->GetName());
    for (int j = 1; j <= L->strategies[i].Length(); j++)   {
      gString name;
      for (int k = 1; k <= L->strategies[i][j]->Length(); k++)
	if ((*L->strategies[i][j])[k] > 0)
	  name += ToString((*L->strategies[i][j])[k]);
        else
	  name += "*";
      L->N->PlayerList()[i]->StrategyList()[j]->name = name;
    }
  }
  
  NFSupport S(*L->N);
  NfgContIter<T> iter(&S);
  gArray<gArray<int> *> corr(E.NumPlayers());
  gArray<int> corrs(E.NumPlayers());
  for (i = 1; i <= E.NumPlayers(); i++)  {
    corrs[i] = 1;
    corr[i] = L->strategies[i][1]; 
  }

  gVector<T> value(E.NumPlayers());

  int pl = E.NumPlayers();
  while (1)  {
    E.Payoff(corr, value);
    for (int j = 1; j <= E.NumPlayers(); j++)
      iter.SetPayoff(j, value[j]);
    
    iter.NextContingency();
    while (pl > 0)   {
      corrs[pl]++;
      if (corrs[pl] <= L->strategies[pl].Length())  { 
	corr[pl] = L->strategies[pl][corrs[pl]];
	break;
      }
      corrs[pl] = 1;
      corr[pl] = L->strategies[pl][1];
      pl--;
    }

    if (pl == 0)  break;
    pl = E.NumPlayers();
  }

  E.lexicon = L;
  SetEfg(E.lexicon->N, &E);
  return ((Nfg<T> *) E.lexicon->N);
}

template <class T>
void RealizationProbs(const Nfg<T> &N, const MixedProfile<T> &mp,
		      const Efg<T> &E, BehavProfile<T> &bp,
		      int pl, const gArray<int> *const actions, Node *n)
{
  static const T tremble = (T) 0.0;
  T prob;

  for (int i = 1; i <= n->NumChildren(); i++)   {
    if (n->GetPlayer() && !n->GetPlayer()->IsChance())   {
      if (n->GetPlayer()->GetNumber() == pl)  {
	if ((*actions)[n->GetInfoset()->GetNumber()] == i)
	  prob = (T) 1.0 - tremble + tremble / (T) n->NumChildren();
	else
	  prob = tremble / (T) n->NumChildren();
      }
      else
	prob = (T) 1.0 / (T) n->NumChildren();
    }
    else  {   // n.GetPlayer() == 0
      prob = (T) ((ChanceInfoset<T> *) n->GetInfoset())->GetActionProb(i);
    }

    Node *child = n->GetChild(i);
    ((TypedNode<T> *) child)->bval = prob * ((TypedNode<T> *) n)->bval;
    ((TypedNode<T> *) child)->nval += ((TypedNode<T> *) child)->bval;    

    RealizationProbs(N, mp, E, bp, pl, actions, child);
  }    
	
}

template <class T>
void BehaviorStrat(const Efg<T> &E, BehavProfile<T> &bp, int pl, Node *n)
{
  for (int i = 1; i <= n->NumChildren(); i++)   {
    Node *child = n->GetChild(i);
    if (n->GetPlayer() && n->GetPlayer()->GetNumber() == pl)
      if (((TypedNode<T> *) n)->nval > (T) 0.0)  {
	bp(n->GetPlayer()->GetNumber(), n->GetInfoset()->GetNumber(), i) =
	  ((TypedNode<T> *) child)->nval / ((TypedNode<T> *) n)->nval;
      }
    BehaviorStrat(E, bp, pl, child);
  }
}

template <class T> void ClearNodeProbs(TypedNode<T> *n)
{
  n->nval = 0.0;
  for (int i = 1; i <= n->NumChildren(); i++)
    ClearNodeProbs(((TypedNode<T> *) n->GetChild(i)));
}




template <class T>
void MixedToBehav(const Nfg<T> &N, const MixedProfile<T> &mp,
		  const Efg<T> &E, BehavProfile<T> &bp)
{
  if ((Nfg<T> *) E.afg == &N)   {
    ((gVector<T> &) bp).operator=((gVector<T> &) mp);
    return;
  }

  if (!E.lexicon || (const Nfg<T> *)E.lexicon->N != &N)   return;

  ((gVector<T> &) bp).operator=((T)0); 

  Node *n = E.RootNode();

  for (int pl = 1; pl <= N.NumPlayers(); pl++)   {
    ClearNodeProbs((TypedNode<T> *) n);

    NFStrategySet *S = mp.GetNFSupport().GetNFStrategySet(pl);

    for (int st = 1; st <= S->NumStrats(); st++)  {
      int snum = S->GetStrategy(st)->number;
      if (mp(pl, st) > (T) 0.0)  {
	const gArray<int> *const actions = E.lexicon->strategies[pl][snum];

	((TypedNode<T> *) n)->bval = mp(pl, st);

	RealizationProbs(N, mp, E, bp, pl, actions, E.RootNode());
      }
    }
    
    ((TypedNode<T> *) E.RootNode())->nval = (T) 1.0;
    BehaviorStrat(E, bp, pl, n);
  }
}

template <class T>
void BehavToMixed(const Efg<T> &E, const BehavProfile<T> &bp,
		  const Nfg<T> &N, MixedProfile<T> &mp)
{
  if ((Nfg<T> *) E.afg == &N)   {
    ((gVector<T> &) mp).operator=((gVector<T> &) bp);
    return;
  }

  if (!E.lexicon || (const Nfg<T> *) E.lexicon->N != &N)  return;
  
  for (int pl = 1; pl <= N.NumPlayers(); pl++)  {
    for (int st = 1; st <= N.PlayerList()[pl]->NumStrats(); st++)  {
      T prob = (T) 1.0;

      for (int iset = 1; iset <= E.PlayerList()[pl]->NumInfosets(); iset++) {
	if ((*E.lexicon->strategies[pl][st])[iset] > 0)
	  prob *= bp(pl, iset, (*E.lexicon->strategies[pl][st])[iset]);
      }
      mp(pl, st) = prob;
    }
  }
}


template <class T> Nfg<T> *MakeAfg(Efg<T> &E)
{
  Nfg<T> *afg = new Nfg<T>(gArray<int>(E.Dimensionality()));

  if (!afg)   return 0;

  E.afg = afg;
  afg->SetTitle(E.GetTitle() + " (Agent Form)");

  for (int epl = 1, npl = 1; epl <= E.NumPlayers(); epl++)   {
    for (int iset = 1; iset <= E.PlayerList()[epl]->NumInfosets(); iset++, npl++)  {
      Infoset *s = E.PlayerList()[epl]->InfosetList()[iset];
      for (int act = 1; act <= s->NumActions(); act++)  {
	Strategy *st = afg->GetStrategy(npl, act);
	st->name = ToString(act);
      }
    }
  }

  NfgIter<T> iter(*afg);
  int pl = afg->NumPlayers();

  gArray<int> dim(E.NumPlayers());
  for (int i = 1; i <= dim.Length(); i++)
    dim[i] = E.PlayerList()[i]->NumInfosets();
  gPVector<int> profile(dim);
  ((gVector<int> &) profile).operator=(1);

  gVector<T> payoff(E.NumPlayers());
  
  while (1)  {
    E.Payoff(profile, payoff);
    for (int epl = 1, npl = 1; epl <= E.NumPlayers(); epl++)
      for (int iset = 1; iset <= E.PlayerList()[epl]->NumInfosets(); iset++, npl++)
	iter.SetPayoff(npl, payoff[epl]);
    
    while (pl > 0)  {
      if (iter.Next(pl))  {
	profile[pl]++;
	break;
      }
      profile[pl] = 1;
      pl--;
    }

    if (pl == 0)  break;
    pl = afg->NumPlayers();
  }

  SetEfg(afg, &E); 

  return afg;
}

