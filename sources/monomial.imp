//
// FILE: monomial.imp -- Implementation of class gMono
//
// $Id$
//

#include "monomial.h"


//--------------------------------------------------------------------------
//                 gMono -- constructors and destructor
//--------------------------------------------------------------------------

template<class T> gMono<T>::gMono(const gSpace* p, const T& x) 
: coef(x), exps(p)
{ 
}

template<class T> gMono<T>::gMono(const T& x, const exp_vect& e) 
: coef(x), exps(e)
{ 
  if (x == (T)0) exps.ToZero();
}

template<class T> gMono<T>::gMono(const gMono<T>& y) 
: coef(y.coef), exps(y.exps)
{
}

template<class T> gMono<T>::~gMono() 
{
}

//--------------------------------------------------------------------------
//                             gMono -- operators
//--------------------------------------------------------------------------

template<class T> gMono<T>& gMono<T>::operator = (const gMono<T>& y)
{
  if (this != &y) { coef = y.coef; exps = y.exps; }
  return *this;
}

template<class T> bool gMono<T>::operator == (const gMono<T>& y) const
{
  return (coef == y.coef && exps == y.exps);
}

template<class T> bool gMono<T>::operator != (const gMono<T>& y) const
{
  return !(*this == y);
}

template<class T> gMono<T> gMono<T>::operator * (const gMono<T> & y) const
{
  return gMono<T>(coef * y.coef,exps + y.exps);
}

template<class T> gMono<T> gMono<T>::operator / (const gMono<T>& y) const
{
  assert ( y.coef != (T)0);
  return gMono<T>(coef / y.coef,exps - y.exps);
}

template<class T> gMono<T> gMono<T>::operator + (const gMono<T> & y) const
{
  assert (exps == y.exps);
  return gMono<T>(coef + y.coef,exps);
}

template<class T> gMono<T>& gMono<T>::operator += (const gMono<T> & y) 
{
  assert (exps == y.exps);
  coef += y.coef;
  return *this;
}

template<class T> gMono<T>& gMono<T>::operator *= (const T& val) 
{
  coef *= val;
  return *this;
}

template<class T> gMono<T> gMono<T>::operator - () const
{
  return gMono<T>(-coef,exps);
}

//--------------------------------------------------------------------------
//                             gMono -- information
//--------------------------------------------------------------------------

template<class T> const T &gMono<T>::Coef() const 
{ 
  return coef; 
}

template<class T> int gMono<T>::Dmnsn() const 
{ 
  return exps.Dmnsn(); 
}

template<class T> int gMono<T>::TotalDegree() const 
{ 
  return exps.TotalDegree(); 
}

template<class T> const exp_vect &gMono<T>::ExpV() const 
{ 
  return exps; 
}

template<class T> bool gMono<T>::IsConstant() const 
{ 
  return exps.IsConstant(); 
}

template<class T> T gMono<T>::Evaluate(const gArray<T>& vals) const 
{ 
  T answer = Coef();

  for (int i = 1; i <= Dmnsn(); i++)
    for (int j = 1; j <= exps[i]; j++)
      answer *= vals[i];

  return answer;
}

template<class T> T gMono<T>::Evaluate(const gVector<T>& vals) const 
{ 
  T answer = Coef();

  for (int i = 1; i <= Dmnsn(); i++)
    for (int j = 1; j <= exps[i]; j++)
      answer *= vals[i];

  return answer;
}

//--------------------------------------------------------------------------
//                             gMono -- printing
//--------------------------------------------------------------------------

template<class T> gOutput& operator << (gOutput& output, const gMono<T>& x)
{
    output << x.coef << x.exps;    return output;
}
